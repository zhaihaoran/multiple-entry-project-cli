var index =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("module.exports = vendor;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInZlbmRvclwiP2I5NDAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB2ZW5kb3I7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ2ZW5kb3JcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvX21hdGVyaWFsaXplLWNzc0AxLjAuMC1hbHBoYS4zQG1hdGVyaWFsaXplLWNzcy9kaXN0L2pzL21hdGVyaWFsaXplLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3I/YTg5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSgzKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvX21hdGVyaWFsaXplLWNzc0AxLjAuMC1hbHBoYS4zQG1hdGVyaWFsaXplLWNzcy9kaXN0L2pzL21hdGVyaWFsaXplLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvd2luZG93LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3I/ZTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDApKSg0KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvd2luZG93LmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3Jcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = (__webpack_require__(0))(0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvX3dlYnBhY2tAMy4xMC4wQHdlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcj9jNmNkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMCkpKDApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9fd2VicGFja0AzLjEwLjBAd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = isFunction;\n\nvar toString = Object.prototype.toString;\n\nfunction isFunction(fn) {\n  var string = toString.call(fn);\n  return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (\n  // IE8 and below\n  fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvX2lzLWZ1bmN0aW9uQDEuMC4xQGlzLWZ1bmN0aW9uL2luZGV4LmpzP2QyNTIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9faXMtZnVuY3Rpb25AMS4wLjFAaXMtZnVuY3Rpb24vaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // materialize\n\n//\n\n\nvar _materializeCss = __webpack_require__(1);\n\nvar _materializeCss2 = _interopRequireDefault(_materializeCss);\n\n__webpack_require__(12);\n\nvar _lodash = __webpack_require__(13);\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _video = __webpack_require__(15);\n\nvar _video2 = _interopRequireDefault(_video);\n\n__webpack_require__(29);\n\n__webpack_require__(30);\n\n__webpack_require__(31);\n\n__webpack_require__(32);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Index = function () {\n    function Index() {\n        _classCallCheck(this, Index);\n\n        this.initEvent();\n    }\n\n    _createClass(Index, [{\n        key: 'initEvent',\n        value: function initEvent() {\n            this.declareVar();\n            this.pluginsInit();\n            this.videoPlay();\n\n            var elem1 = document.querySelector('.fixed-action-btn');\n            $('.tooltip').tooltip();\n            _materializeCss2.default.FloatingActionButton.init(elem1);\n            this.windowListenEvents();\n        }\n    }, {\n        key: 'declareVar',\n        value: function declareVar() {\n            this.$animateNumber = $('.animateNumber');\n            this.$carousel = $('.carousel.carousel-slider');\n            this.$videoPlay = $('.in-mask');\n            this.$header = $('nav.tum-header');\n        }\n    }, {\n        key: 'videoPlay',\n        value: function videoPlay() {\n            var _this = this;\n\n            var me = this;\n            this.$videoPlay.on('click', function (e) {\n                _this.$videoPlay.addClass('hide').siblings('.index-mask').addClass('hide');\n                $('.video-player').removeClass('hide');\n                $('.video-player').find('#video').css('height', $('.index-video').height());\n                me.videoPlayer.play();\n            });\n            var box = 3;\n        }\n    }, {\n        key: 'windowListenEvents',\n        value: function windowListenEvents() {\n            var me = this;\n            me.isPhone = false;\n            $(window).on('resize', _lodash2.default.debounce(function (e) {\n                var width = document.body.clientWidth;\n                console.log(width);\n                if (width < 660 && !me.isPhone) {\n                    me.loadCarouselImage(270, 'smpic');\n                    me.isPhone = true;\n                } else if (width > 660 && me.isPhone) {\n                    me.loadCarouselImage(500, 'bgpic');\n                    me.isPhone = false;\n                }\n            }, 150));\n\n            $(document).ready(function (e) {\n                var width = document.body.clientWidth;\n                if (width < 660) {\n                    me.isPhone = true;\n                    me.loadCarouselImage(270, 'smpic');\n                } else {\n                    me.isPhone = false;\n                    me.loadCarouselImage(500, 'bgpic');\n                }\n            });\n\n            $(window).on('scroll', _lodash2.default.throttle(function (e) {\n                var height = $(window).scrollTop();\n                console.log(height);\n            }, 500));\n        }\n        /**\n         * loadCarouselImage\n         *\n         * @param {any} carouselHeight 轮播图 固定高度\n         * @param {any} imageAttr 图片data属性\n         * @memberof Index\n         */\n\n    }, {\n        key: 'loadCarouselImage',\n        value: function loadCarouselImage(carouselHeight, imageAttr) {\n            this.$carousel.css(\"height\", carouselHeight);\n            this.$carousel.children('a').each(function (i, el) {\n                $(el).css({\n                    \"background-image\": $(el).data(imageAttr)\n                });\n            });\n        }\n    }, {\n        key: 'pluginsInit',\n        value: function pluginsInit() {\n\n            this.$animateNumber.each(function (i, el) {\n                var aa = $(el).data('number');\n                $(el).prop('number', 0).animateNumber({\n                    number: aa,\n                    easing: 'easeOut'\n                }, 3000);\n            });\n\n            _materializeCss2.default.Carousel.init(this.$carousel, {\n                fullWidth: true,\n                indicators: true,\n                duration: 300\n            });\n            this.videoPlayer = (0, _video2.default)('video', {\n                controls: true,\n                autoplay: false,\n                preload: 'auto'\n            });\n        }\n    }]);\n\n    return Index;\n}();\n\nnew Index();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2VudHJ5L2luZGV4LmpzP2M0NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbWF0ZXJpYWxpemVcbmltcG9ydCBNIGZyb20gJ21hdGVyaWFsaXplLWNzcydcbmltcG9ydCAnbWF0ZXJpYWxpemUtY3NzL3Nhc3MvbWF0ZXJpYWxpemUuc2NzcydcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCdcbmltcG9ydCB2aWRlb2pzIGZyb20gJ3ZpZGVvLmpzJ1xuaW1wb3J0ICd2aWRlby5qcy9kaXN0L3ZpZGVvLWpzLmNzcydcbmltcG9ydCAnQHNjc3MvaW5kZXguc2Nzcyc7XG4vL1xuaW1wb3J0ICdAbGliL2pxdWVyeS5zY3JvbGxmaXJlJ1xuaW1wb3J0ICdAbGliL2FuaW1hdGVOdW1iZXInXG5cbmNsYXNzIEluZGV4IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluaXRFdmVudCgpO1xuICAgIH1cblxuICAgIGluaXRFdmVudCgpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlVmFyKClcbiAgICAgICAgdGhpcy5wbHVnaW5zSW5pdCgpXG4gICAgICAgIHRoaXMudmlkZW9QbGF5KClcblxuICAgICAgICB2YXIgZWxlbTEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZml4ZWQtYWN0aW9uLWJ0bicpO1xuICAgICAgICAkKCcudG9vbHRpcCcpLnRvb2x0aXAoKTtcbiAgICAgICAgTS5GbG9hdGluZ0FjdGlvbkJ1dHRvbi5pbml0KGVsZW0xKTtcbiAgICAgICAgdGhpcy53aW5kb3dMaXN0ZW5FdmVudHMoKTtcbiAgICB9XG5cbiAgICBkZWNsYXJlVmFyKCkge1xuICAgICAgICB0aGlzLiRhbmltYXRlTnVtYmVyID0gJCgnLmFuaW1hdGVOdW1iZXInKTtcbiAgICAgICAgdGhpcy4kY2Fyb3VzZWwgPSAkKCcuY2Fyb3VzZWwuY2Fyb3VzZWwtc2xpZGVyJyk7XG4gICAgICAgIHRoaXMuJHZpZGVvUGxheSA9ICQoJy5pbi1tYXNrJyk7XG4gICAgICAgIHRoaXMuJGhlYWRlciA9ICQoJ25hdi50dW0taGVhZGVyJyk7XG4gICAgfVxuXG4gICAgdmlkZW9QbGF5KCkge1xuICAgICAgICBsZXQgbWUgPSB0aGlzO1xuICAgICAgICB0aGlzLiR2aWRlb1BsYXkub24oJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLiR2aWRlb1BsYXkuYWRkQ2xhc3MoJ2hpZGUnKS5zaWJsaW5ncygnLmluZGV4LW1hc2snKS5hZGRDbGFzcygnaGlkZScpO1xuICAgICAgICAgICAgJCgnLnZpZGVvLXBsYXllcicpLnJlbW92ZUNsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICAkKCcudmlkZW8tcGxheWVyJykuZmluZCgnI3ZpZGVvJykuY3NzKCdoZWlnaHQnLCAkKCcuaW5kZXgtdmlkZW8nKS5oZWlnaHQoKSlcbiAgICAgICAgICAgIG1lLnZpZGVvUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgYm94ID0gMztcbiAgICB9XG5cbiAgICB3aW5kb3dMaXN0ZW5FdmVudHMoKSB7XG4gICAgICAgIGxldCBtZSA9IHRoaXM7XG4gICAgICAgIG1lLmlzUGhvbmUgPSBmYWxzZTtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGUgPT4ge1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDY2MCAmJiAhbWUuaXNQaG9uZSkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRDYXJvdXNlbEltYWdlKDI3MCwgJ3NtcGljJylcbiAgICAgICAgICAgICAgICBtZS5pc1Bob25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggPiA2NjAgJiYgbWUuaXNQaG9uZSkge1xuICAgICAgICAgICAgICAgIG1lLmxvYWRDYXJvdXNlbEltYWdlKDUwMCwgJ2JncGljJylcbiAgICAgICAgICAgICAgICBtZS5pc1Bob25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDE1MCkpXG5cbiAgICAgICAgJChkb2N1bWVudCkucmVhZHkoZSA9PiB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgNjYwKSB7XG4gICAgICAgICAgICAgICAgbWUuaXNQaG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWUubG9hZENhcm91c2VsSW1hZ2UoMjcwLCAnc21waWMnKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZS5pc1Bob25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWUubG9hZENhcm91c2VsSW1hZ2UoNTAwLCAnYmdwaWMnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgICQod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZShlID0+IHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhoZWlnaHQpO1xuICAgICAgICB9LCA1MDApKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBsb2FkQ2Fyb3VzZWxJbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGNhcm91c2VsSGVpZ2h0IOi9ruaSreWbviDlm7rlrprpq5jluqZcbiAgICAgKiBAcGFyYW0ge2FueX0gaW1hZ2VBdHRyIOWbvueJh2RhdGHlsZ7mgKdcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcbiAgICAgKi9cbiAgICBsb2FkQ2Fyb3VzZWxJbWFnZShjYXJvdXNlbEhlaWdodCwgaW1hZ2VBdHRyKSB7XG4gICAgICAgIHRoaXMuJGNhcm91c2VsLmNzcyhcImhlaWdodFwiLCBjYXJvdXNlbEhlaWdodClcbiAgICAgICAgdGhpcy4kY2Fyb3VzZWwuY2hpbGRyZW4oJ2EnKS5lYWNoKChpLCBlbCkgPT4ge1xuICAgICAgICAgICAgJChlbCkuY3NzKHtcbiAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtaW1hZ2VcIjogJChlbCkuZGF0YShpbWFnZUF0dHIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHBsdWdpbnNJbml0KCkge1xuXG4gICAgICAgIHRoaXMuJGFuaW1hdGVOdW1iZXIuZWFjaCgoaSwgZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFhID0gJChlbCkuZGF0YSgnbnVtYmVyJyk7XG4gICAgICAgICAgICAkKGVsKS5wcm9wKCdudW1iZXInLCAwKS5hbmltYXRlTnVtYmVyKHtcbiAgICAgICAgICAgICAgICBudW1iZXI6IGFhLFxuICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXQnXG4gICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICB9KVxuXG4gICAgICAgIE0uQ2Fyb3VzZWwuaW5pdCh0aGlzLiRjYXJvdXNlbCwge1xuICAgICAgICAgICAgZnVsbFdpZHRoOiB0cnVlLFxuICAgICAgICAgICAgaW5kaWNhdG9yczogdHJ1ZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDBcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy52aWRlb1BsYXllciA9IHZpZGVvanMoJ3ZpZGVvJywge1xuICAgICAgICAgICAgY29udHJvbHM6IHRydWUsXG4gICAgICAgICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgICAgICAgICBwcmVsb2FkOiAnYXV0bydcbiAgICAgICAgfSk7XG5cbiAgICB9XG59XG5cbm5ldyBJbmRleCgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9lbnRyeS9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBUkE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX21hdGVyaWFsaXplLWNzc0AxLjAuMC1hbHBoYS4zQG1hdGVyaWFsaXplLWNzcy9zYXNzL21hdGVyaWFsaXplLnNjc3M/NWI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL19tYXRlcmlhbGl6ZS1jc3NAMS4wLjAtYWxwaGEuM0BtYXRlcmlhbGl6ZS1jc3Mvc2Fzcy9tYXRlcmlhbGl6ZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.4';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\\b__p \\+= '';/g,reEmptyStringMiddle=/\\b(__p \\+=) '' \\+/g,reEmptyStringTrailing=/(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>\"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\\s\\S]+?)%>/g,reEvaluate=/<%([\\s\\S]+?)%>/g,reInterpolate=/<%=([\\s\\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,reIsPlainProp=/^\\w*$/,reLeadingDot=/^\\./,rePropName=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;/**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */var reRegExpChar=/[\\\\^$.*+?()[\\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\\s+|\\s+$/g,reTrimStart=/^\\s+/,reTrimEnd=/\\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,reWrapDetails=/\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\\\(\\\\)?/g;/**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */var reEsTemplate=/\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\\[object .+?Constructor\\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\\n\\r\\u2028\\u2029\\\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\\\ud800-\\\\udfff',rsComboMarksRange='\\\\u0300-\\\\u036f',reComboHalfMarksRange='\\\\ufe20-\\\\ufe2f',rsComboSymbolsRange='\\\\u20d0-\\\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\\\u2700-\\\\u27bf',rsLowerRange='a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',rsMathOpRange='\\\\xac\\\\xb1\\\\xd7\\\\xf7',rsNonCharRange='\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',rsPunctuationRange='\\\\u2000-\\\\u206f',rsSpaceRange=' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',rsUpperRange='A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',rsVarRange='\\\\ufe0e\\\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos='[\\'\\u2019]',rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\\\ud83c[\\\\udffb-\\\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',rsSurrPair='[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\\\d*(?:(?:1st|2nd|3rd|(?![123])\\\\dth)\\\\b)',rsOrdUpper='\\\\d*(?:(?:1ST|2ND|3RD|(?![123])\\\\dTH)\\\\b)',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.\n'\\xc0':'A','\\xc1':'A','\\xc2':'A','\\xc3':'A','\\xc4':'A','\\xc5':'A','\\xe0':'a','\\xe1':'a','\\xe2':'a','\\xe3':'a','\\xe4':'a','\\xe5':'a','\\xc7':'C','\\xe7':'c','\\xd0':'D','\\xf0':'d','\\xc8':'E','\\xc9':'E','\\xca':'E','\\xcb':'E','\\xe8':'e','\\xe9':'e','\\xea':'e','\\xeb':'e','\\xcc':'I','\\xcd':'I','\\xce':'I','\\xcf':'I','\\xec':'i','\\xed':'i','\\xee':'i','\\xef':'i','\\xd1':'N','\\xf1':'n','\\xd2':'O','\\xd3':'O','\\xd4':'O','\\xd5':'O','\\xd6':'O','\\xd8':'O','\\xf2':'o','\\xf3':'o','\\xf4':'o','\\xf5':'o','\\xf6':'o','\\xf8':'o','\\xd9':'U','\\xda':'U','\\xdb':'U','\\xdc':'U','\\xf9':'u','\\xfa':'u','\\xfb':'u','\\xfc':'u','\\xdd':'Y','\\xfd':'y','\\xff':'y','\\xc6':'Ae','\\xe6':'ae','\\xde':'Th','\\xfe':'th','\\xdf':'ss',// Latin Extended-A block.\n'\\u0100':'A','\\u0102':'A','\\u0104':'A','\\u0101':'a','\\u0103':'a','\\u0105':'a','\\u0106':'C','\\u0108':'C','\\u010A':'C','\\u010C':'C','\\u0107':'c','\\u0109':'c','\\u010B':'c','\\u010D':'c','\\u010E':'D','\\u0110':'D','\\u010F':'d','\\u0111':'d','\\u0112':'E','\\u0114':'E','\\u0116':'E','\\u0118':'E','\\u011A':'E','\\u0113':'e','\\u0115':'e','\\u0117':'e','\\u0119':'e','\\u011B':'e','\\u011C':'G','\\u011E':'G','\\u0120':'G','\\u0122':'G','\\u011D':'g','\\u011F':'g','\\u0121':'g','\\u0123':'g','\\u0124':'H','\\u0126':'H','\\u0125':'h','\\u0127':'h','\\u0128':'I','\\u012A':'I','\\u012C':'I','\\u012E':'I','\\u0130':'I','\\u0129':'i','\\u012B':'i','\\u012D':'i','\\u012F':'i','\\u0131':'i','\\u0134':'J','\\u0135':'j','\\u0136':'K','\\u0137':'k','\\u0138':'k','\\u0139':'L','\\u013B':'L','\\u013D':'L','\\u013F':'L','\\u0141':'L','\\u013A':'l','\\u013C':'l','\\u013E':'l','\\u0140':'l','\\u0142':'l','\\u0143':'N','\\u0145':'N','\\u0147':'N','\\u014A':'N','\\u0144':'n','\\u0146':'n','\\u0148':'n','\\u014B':'n','\\u014C':'O','\\u014E':'O','\\u0150':'O','\\u014D':'o','\\u014F':'o','\\u0151':'o','\\u0154':'R','\\u0156':'R','\\u0158':'R','\\u0155':'r','\\u0157':'r','\\u0159':'r','\\u015A':'S','\\u015C':'S','\\u015E':'S','\\u0160':'S','\\u015B':'s','\\u015D':'s','\\u015F':'s','\\u0161':'s','\\u0162':'T','\\u0164':'T','\\u0166':'T','\\u0163':'t','\\u0165':'t','\\u0167':'t','\\u0168':'U','\\u016A':'U','\\u016C':'U','\\u016E':'U','\\u0170':'U','\\u0172':'U','\\u0169':'u','\\u016B':'u','\\u016D':'u','\\u016F':'u','\\u0171':'u','\\u0173':'u','\\u0174':'W','\\u0175':'w','\\u0176':'Y','\\u0177':'y','\\u0178':'Y','\\u0179':'Z','\\u017B':'Z','\\u017D':'Z','\\u017A':'z','\\u017C':'z','\\u017E':'z','\\u0132':'IJ','\\u0133':'ij','\\u0152':'Oe','\\u0153':'oe','\\u0149':\"'n\",'\\u017F':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'\"','&#39;':\"'\"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\\\':'\\\\',\"'\":\"'\",'\\n':'n','\\r':'r','\\u2028':'u2028','\\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==='undefined'?'undefined':_typeof(global))=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==='undefined'?'undefined':_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=( false?'undefined':_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?'undefined':_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.\nmap.set(pair[0],pair[1]);return map;}/**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.\nset.add(value);return set;}/**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */var asciiSize=baseProperty('length');/**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */function asciiToArray(string){return string.split('');}/**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */function baseIsNaN(value){return value!==value;}/**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */function baseUnary(func){return function(value){return func(value);};}/**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */function cacheHas(cache,key){return cache.has(key);}/**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */var deburrLetter=basePropertyOf(deburredLetters);/**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */function escapeStringChar(chr){return'\\\\'+stringEscapes[chr];}/**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */function getValue(object,key){return object==null?undefined:object[key];}/**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */function hasUnicode(string){return reHasUnicode.test(string);}/**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined,symIterator=_Symbol?_Symbol.iterator:undefined,symToStringTag=_Symbol?_Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */function baseLodash(){}// No operation performed.\n/**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */lodash.templateSettings={/**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */'escape':reEscape,/**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */'evaluate':reEvaluate,/**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */'interpolate':reInterpolate,/**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */'variable':'',/**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */'imports':{/**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.\nlodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.\nLazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.\nHash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */function listCacheClear(){this.__data__=[];this.size=0;}/**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.\nListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.\nMapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.\nSetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */function stackGet(key){return this.__data__.get(key);}/**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */function stackHas(key){return this.__data__.has(key);}/**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.\nStack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.\nkey=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.\nisBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.\nisType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.\nisIndex(key,length)))){result.push(key);}}return result;}/**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.\nstack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).\nassignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */var baseEach=createBaseEach(baseForOwn);/**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).\nbaseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */var baseFor=createBaseFor();/**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */var baseForRight=createBaseFor(true);/**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */function baseGt(value,other){return value>other;}/**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\nif(typeof value=='function'){return value;}if(value==null){return identity;}if((typeof value==='undefined'?'undefined':_typeof(value))=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */function baseLt(value,other){return value<other;}/**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(object[key],srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=object[key],srcValue=source[key],stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||srcIndex&&isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).\nstack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.\n// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\ndo{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */function baseSample(collection){return arraySample(values(collection));}/**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.\nif(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).\nreturn arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */function castFunction(value){return typeof value=='function'?value:identity;}/**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */var castRest=baseRest;/**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**\n     * Creates a clone of `map`.\n     *\n     * @private\n     * @param {Object} map The map to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned map.\n     */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),CLONE_DEEP_FLAG):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**\n     * Creates a clone of `set`.\n     *\n     * @private\n     * @param {Object} set The set to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned set.\n     */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),CLONE_DEEP_FLAG):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n// that causes it, under certain circumstances, to provide the same value for\n// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n// for more details.\n//\n// This also ensures a stable sort in V8 and other engines.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\nreturn object.index-other.index;}/**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See\n// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n// for more details.\nvar args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.\n// See https://es5.github.io/#x13.2.2 for more details.\nreturn isObject(result)?result:thisBinding;};}/**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.\nstart=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.\n// See [MDN](https://mdn.io/round#Examples) for more details.\nvar pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).\nstack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.\nvar stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.\nwhile(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).\nif(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.\n// Invalid dates are coerced to `NaN`.\nreturn eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,\n// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n// for more details.\nreturn object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.\nvar stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).\nstack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.\nvar stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).\nif(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.\nif(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.\nif(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {Function} cloneFunc The function to clone values.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\\n/* [wrapped with '+details+'] */\\n');}/**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index==='undefined'?'undefined':_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value==='undefined'?'undefined':_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */function isKeyable(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */var isMaskable=coreJsData?isFunction:stubFalse;/**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */function isStrictComparable(value){return value===value&&!isObject(value);}/**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.\nif(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.\nif(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.\nnewBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.\nvar value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.\nvalue=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.\nvalue=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.\nif(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.\nif(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.\ndata[0]=source[0];data[1]=newBitmask;return data;}/**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */function objectToString(value){return nativeObjectToString.call(value);}/**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */var setData=shortOut(baseSetData);/**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */var setToString=shortOut(baseSetToString);/**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */var stringToPath=memoizeCapped(function(string){var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});/**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */function head(array){return array&&array.length?array[0]:undefined;}/**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */var pull=baseRest(pullAll);/**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */var zip=baseRest(unzip);/**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */function tap(value,interceptor){interceptor(value);return value;}/**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */function thru(value,interceptor){return interceptor(value);}/**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */function wrapperChain(){return chain(this);}/**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */function wrapperToIterator(){return this;}/**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */var find=createFind(findIndex);/**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */var findLast=createFind(findLastIndex);/**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.\nlastInvokeTime=time;// Start the timer for the trailing edge.\ntimerId=setTimeout(timerExpired,wait);// Invoke the leading edge.\nreturn leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the\n// trailing edge, the system time has gone backwards and we're treating\n// it as the trailing edge, or we've hit the `maxWait` limit.\nreturn lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.\ntimerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been\n// debounced at least once.\nif(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.\ntimerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.\nmemoize.Cache=MapCache;/**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */function once(func){return before(2,func);}/**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */function unary(func){return ary(func,1);}/**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*//**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */function eq(value,other){return value===other||value!==value&&other!==other;}/**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */var gt=createRelationalOperation(baseGt);/**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */var isArray=Array.isArray;/**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */var isBuffer=nativeIsBuffer||stubFalse;/**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */function isEqual(value,other){return baseIsEqual(value,other);}/**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator\n// in Safari 9 which returns 'object' for typed arrays and other constructors.\nvar tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */function isObject(value){var type=typeof value==='undefined'?'undefined':_typeof(value);return value!=null&&(type=='object'||type=='function');}/**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */function isObjectLike(value){return value!=null&&(typeof value==='undefined'?'undefined':_typeof(value))=='object';}/**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.\n// Perform the `toStringTag` check first to avoid errors with some\n// ActiveX objects in IE.\nreturn isNumber(value)&&value!=+value;}/**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */function isNull(value){return value===null;}/**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */function isNil(value){return value==null;}/**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */function isSymbol(value){return(typeof value==='undefined'?'undefined':_typeof(value))=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */function isUndefined(value){return value===undefined;}/**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */var lt=createRelationalOperation(baseLt);/**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */var at=flatRest(baseAt);/**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */var defaults=baseRest(function(args){args.push(undefined,customDefaultsAssignIn);return apply(assignInWith,undefined,args);});/**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */var invert=createInverter(function(result,value,key){result[value]=key;},constant(identity));/**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */var invertBy=createInverter(function(result,value,key){if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */var invoke=baseRest(baseInvoke);/**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.\nif(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */var toPairs=createToPairs(keys);/**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */var toPairsIn=createToPairs(keysIn);/**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\\\$&'):string;}/**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */var lowerFirst=createCaseFirst('toLowerCase');/**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation\n// (http://ejohn.org/blog/javascript-micro-templating/)\n// and Laura Doktorova's doT.js (https://github.com/olado/doT).\nvar settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source=\"__p += '\";// Compile the regexp to match each delimiter.\nvar reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.\nvar sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.\nsource+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.\nif(escapeValue){isEscaping=true;source+=\"' +\\n__e(\"+escapeValue+\") +\\n'\";}if(evaluateValue){isEvaluating=true;source+=\"';\\n\"+evaluateValue+\";\\n__p += '\";}if(interpolateValue){source+=\"' +\\n((__t = (\"+interpolateValue+\")) == null ? '' : __t) +\\n'\";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in\n// order to produce the correct `offset` value.\nreturn match;});source+=\"';\\n\";// If `variable` is not specified wrap a with-statement around the generated\n// code to add the data object to the top of the scope chain.\nvar variable=options.variable;if(!variable){source='with (obj) {\\n'+source+'\\n}\\n';}// Cleanup code by stripping empty strings.\nsource=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.\nsource='function('+(variable||'obj')+') {\\n'+(variable?'':'obj || (obj = {});\\n')+\"var __t, __p = ''\"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\\n'+\"function print() { __p += __j.call(arguments, '') }\\n\":';\\n')+source+'return __p\\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or\n// the `source` property as a convenience for inlining compiled templates.\nresult.source=source;if(isError(result)){throw result;}return result;}/**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */function toLower(value){return toString(value).toLowerCase();}/**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */function toUpper(value){return toString(value).toUpperCase();}/**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */var upperFirst=createCaseFirst('toUpperCase');/**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */function constant(value){return function(){return value;};}/**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */var flow=createFlow();/**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */var flowRight=createFlow(true);/**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */function identity(value){return value;}/**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */function noop(){}// No operation performed.\n/**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */var over=createOver(arrayMap);/**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */var overEvery=createOver(arrayEvery);/**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */var overSome=createOver(arraySome);/**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */var range=createRange();/**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */var rangeRight=createRange(true);/**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */function stubArray(){return[];}/**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */function stubFalse(){return false;}/**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */function stubObject(){return{};}/**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */function stubString(){return'';}/**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */function stubTrue(){return true;}/**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */var ceil=createRound('ceil');/**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */var floor=createRound('floor');/**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */function mean(array){return baseMean(array,identity);}/**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */var round=createRound('round');/**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.\nlodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.\nlodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.\nmixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.\nlodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.\nlodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */lodash.VERSION=VERSION;// Assign default placeholders.\narrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\narrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.\narrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.\narrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.\narrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.\nbaseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a \"length\" value other than `1`.\nisLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.\narrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.\nbaseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.\nLazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.\nlodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.\nlodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/// Export lodash.\nvar _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:\nif(\"function\"=='function'&&_typeof(__webpack_require__(4))=='object'&&__webpack_require__(4)){// Expose Lodash on the global object to prevent errors when Lodash is\n// loaded by a script tag in the presence of an AMD loader.\n// See http://requirejs.org/docs/errors.html#mismatch for more details.\n// Use `_.noConflict` to remove Lodash from the global object.\nroot._=_;// Define as an anonymous module so, through path mapping, it can be\n// referenced as the \"underscore\" module.\n!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.\nelse if(freeModule){// Export for Node.js.\n(freeModule.exports=_)._=_;// Export for CommonJS support.\nfreeExports._=_;}else{// Export to the global object.\nroot._=_;}}).call(undefined);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(14)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy40QGxvZGFzaC9sb2Rhc2guanM/ZWUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy40JztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nLFxuICAgICAgcmVUcmltU3RhcnQgPSAvXlxccysvLFxuICAgICAgcmVUcmltRW5kID0gL1xccyskLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/Oig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpXFxcXGIpJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86KD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSClcXFxcYiknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICAgIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICAgIHNldC5hZGQodmFsdWUpO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCAoc3JjSW5kZXggJiYgaXNGdW5jdGlvbihvYmpWYWx1ZSkpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCBDTE9ORV9ERUVQX0ZMQUcpIDogbWFwVG9BcnJheShtYXApO1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTZXQoc2V0LCBpc0RlZXAsIGNsb25lRnVuYykge1xuICAgICAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgQ0xPTkVfREVFUF9GTEFHKSA6IHNldFRvQXJyYXkoc2V0KTtcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG4gICAgICByZXR1cm4gYXBwbHkoYXNzaWduSW5XaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG4gICAgICAgICAgPyBvcHRpb25zLnNvdXJjZVVSTFxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSAobG9kYXNoRnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XG5cbiAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy40QGxvZGFzaC9sb2Rhc2guanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBUUE7OztBQWdKQTs7O0FBdUJBOzs7QUFtRkE7QUFzRUE7QUFrQkE7Ozs7Ozs7QUFtSEE7QUFFQTs7Ozs7OztBQVlBO0FBRUE7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7O0FBb0JBOzs7Ozs7OztBQXFCQTs7Ozs7Ozs7O0FBcUJBOzs7Ozs7OztBQXFCQTs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7O0FBY0E7Ozs7Ozs7O0FBcUJBOzs7Ozs7O0FBbUJBOzs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7OztBQXFCQTs7Ozs7O0FBbUJBOzs7Ozs7QUFTQTs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7OztBQWdCQTs7Ozs7O0FBbUJBOzs7Ozs7OztBQWFBOzs7Ozs7QUFZQTs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7O0FBbUJBOzs7Ozs7OztBQW1CQTs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7O0FBbUJBOzs7Ozs7QUFhQTs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7O0FBY0E7Ozs7Ozs7O0FBYUE7Ozs7Ozs7O0FBaUJBOzs7Ozs7O0FBZUE7Ozs7Ozs7QUFvQkE7Ozs7OztBQVNBOzs7Ozs7QUFTQTs7Ozs7OztBQVlBOzs7Ozs7QUFXQTs7Ozs7O0FBV0E7Ozs7OztBQVdBOzs7Ozs7QUFpQkE7Ozs7Ozs7QUFrQkE7Ozs7Ozs7O0FBZUE7Ozs7OztBQXVCQTs7Ozs7O0FBaUJBOzs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7OztBQXNCQTs7Ozs7O0FBaUJBOzs7Ozs7QUFhQTs7Ozs7O0FBYUE7Ozs7OztBQVNBOzs7Ozs7QUFlQTs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7QUEwQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd01BOzs7Ozs7O0FBb0JBOzs7O0FBcUJBO0FBSUE7Ozs7OztBQU9BOzs7Ozs7OztBQWlCQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTtBQUtBOzs7Ozs7QUFlQTs7Ozs7OztBQWtCQTs7Ozs7OztBQW1CQTs7Ozs7OztBQW9CQTtBQWtEQTs7Ozs7O0FBWUE7Ozs7OztBQWtCQTs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7QUFlQTtBQVFBOzs7Ozs7QUFlQTs7Ozs7O0FBa0JBOzs7Ozs7OztBQWNBOzs7Ozs7OztBQTBCQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7OztBQWNBO0FBY0E7Ozs7OztBQWVBOzs7Ozs7QUFrQkE7Ozs7Ozs7O0FBa0JBOzs7Ozs7OztBQWVBOzs7Ozs7OztBQWFBOzs7Ozs7Ozs7QUFjQTtBQVVBOzs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7O0FBY0E7QUFLQTs7Ozs7O0FBWUE7Ozs7OztBQVlBOzs7Ozs7OztBQWNBOzs7Ozs7OztBQWlCQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7O0FBY0E7QUFpQkE7Ozs7Ozs7QUFnQkE7QUFhQTtBQUVBO0FBRUE7QUFFQTs7Ozs7O0FBZUE7Ozs7Ozs7QUFhQTs7Ozs7O0FBV0E7Ozs7Ozs7O0FBYUE7Ozs7Ozs7OztBQWlCQTs7Ozs7OztBQWdCQTs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7QUFxQkE7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUEyQ0E7QUFrQkE7Ozs7OztBQVlBOzs7Ozs7O0FBZUE7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7OztBQWtCQTs7Ozs7OztBQXFEQTs7Ozs7OztBQVVBOzs7Ozs7OztBQVdBOzs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7OztBQTZCQTs7Ozs7OztBQTBCQTs7Ozs7Ozs7OztBQXFCQTtBQVlBOzs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7QUFZQTs7Ozs7OztBQVVBOzs7Ozs7O0FBWUE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7QUFjQTs7Ozs7Ozs7OztBQXVCQTs7Ozs7O0FBWUE7Ozs7Ozs7O0FBa0JBOzs7Ozs7O0FBWUE7Ozs7Ozs7QUFZQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFnRUE7Ozs7Ozs7OztBQWlCQTs7Ozs7O0FBY0E7Ozs7OztBQVdBOzs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7O0FBb0RBOzs7Ozs7Ozs7QUFjQTs7Ozs7OztBQW9EQTs7Ozs7O0FBZUE7Ozs7OztBQVdBOzs7Ozs7QUFXQTs7Ozs7O0FBWUE7QUFFQTtBQUNBOzs7Ozs7QUFxQkE7Ozs7OztBQW9CQTs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7QUFZQTs7Ozs7O0FBaUJBOzs7Ozs7O0FBa0JBOzs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7OztBQXFDQTtBQXVEQTs7Ozs7OztBQWVBOzs7Ozs7OztBQWtCQTs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7O0FBZUE7Ozs7OztBQXVCQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7QUFvQ0E7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7QUFvQkE7QUFNQTtBQUNBOzs7Ozs7O0FBcUJBOzs7Ozs7QUFXQTs7Ozs7OztBQVlBOzs7Ozs7Ozs7QUFlQTs7Ozs7OztBQXNDQTs7Ozs7OztBQWFBOzs7Ozs7QUFnQkE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7OztBQWlEQTs7Ozs7OztBQTBCQTs7Ozs7OztBQWtCQTtBQUVBO0FBS0E7Ozs7Ozs7O0FBa0JBOzs7Ozs7O0FBNERBOzs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7O0FBOEJBOzs7Ozs7QUFvQkE7Ozs7OztBQVdBOzs7Ozs7O0FBWUE7Ozs7Ozs7O0FBZ0JBOzs7Ozs7OztBQVdBOzs7OztBQVlBOzs7Ozs7O0FBWUE7Ozs7OztBQWtCQTs7Ozs7OztBQWNBOzs7Ozs7OztBQWNBOzs7Ozs7QUFZQTs7Ozs7Ozs7QUFlQTs7Ozs7O0FBWUE7Ozs7Ozs7QUFZQTs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7O0FBNENBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7OztBQXFCQTs7Ozs7OztBQWtDQTs7Ozs7OztBQVlBOzs7Ozs7O0FBWUE7Ozs7OztBQWdCQTs7Ozs7OztBQWtDQTs7Ozs7O0FBNEJBOzs7Ozs7Ozs7QUEyQkE7Ozs7OztBQWtCQTs7Ozs7O0FBMkJBOzs7Ozs7O0FBY0E7QUFHQTtBQUNBO0FBQ0E7QUFlQTtBQUNBOzs7Ozs7OztBQWFBOzs7Ozs7QUFtQ0E7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUVBOzs7Ozs7O0FBOERBOzs7Ozs7O0FBY0E7Ozs7OztBQWlDQTs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7QUE4QkE7QUFNQTs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7QUFpQ0E7QUFPQTtBQUNBOzs7Ozs7QUFpQkE7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7Ozs7Ozs7Ozs7O0FBbUVBOzs7Ozs7Ozs7Ozs7O0FBc0JBO0FBR0E7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7Ozs7QUFpQkE7QUFTQTtBQVlBO0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBO0FBcUJBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFhQTtBQU9BOzs7Ozs7Ozs7Ozs7QUEwQkE7QUFrQkE7QUFvQkE7QUFjQTs7Ozs7O0FBbUJBOzs7Ozs7QUFXQTs7Ozs7OztBQVlBOzs7Ozs7QUFXQTs7Ozs7O0FBV0E7Ozs7OztBQXNCQTs7Ozs7Ozs7OztBQWdCQTs7Ozs7OztBQWNBOzs7Ozs7QUFjQTs7Ozs7OztBQXFCQTs7Ozs7O0FBWUE7Ozs7OztBQTJCQTs7Ozs7O0FBaUJBOzs7Ozs7QUFnQkE7QUFHQTs7Ozs7Ozs7O0FBaUNBOzs7Ozs7QUF5QkE7Ozs7Ozs7O0FBY0E7Ozs7OztBQTZCQTtBQUtBOzs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7O0FBNENBOzs7Ozs7QUFrQkE7Ozs7Ozs7QUFhQTs7Ozs7Ozs7O0FBaUJBOzs7Ozs7O0FBc0JBOzs7Ozs7QUFvQkE7Ozs7Ozs7QUFlQTs7Ozs7O0FBcUJBOzs7Ozs7QUFXQTs7Ozs7O0FBU0E7Ozs7Ozs7QUFlQTs7Ozs7Ozs7QUFhQTs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBWUE7QUFJQTtBQUdBO0FBR0E7QUFPQTtBQU9BO0FBS0E7QUFJQTtBQUlBOzs7Ozs7OztBQWVBOzs7Ozs7QUFpQkE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7QUE2QkE7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7O0FBVUE7Ozs7Ozs7QUFZQTs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7O0FBY0E7Ozs7Ozs7QUE0QkE7Ozs7OztBQXdCQTs7Ozs7O0FBa0JBOzs7Ozs7QUFlQTs7Ozs7OztBQW9CQTs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBOzs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBOzs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENBOzs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBOzs7Ozs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUNBOzs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBOzs7Ozs7Ozs7Ozs7Ozs7QUErQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2REE7QUFtQ0E7QUFFQTtBQUVBO0FBZ0JBO0FBQ0E7QUFDQTtBQVVBO0FBT0E7QUFDQTtBQWlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnREE7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNERBOzs7Ozs7Ozs7Ozs7OztBQWlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBOzs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0E7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkRBOzs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0hBO0FBRUE7QUFDQTtBQUNBO0FBbUJBO0FBUUE7QUFVQTtBQUdBO0FBY0E7QUFDQTtBQU1BO0FBQ0E7QUFLQTtBQUtBO0FBd0JBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTs7Ozs7Ozs7Ozs7O0FBaURBOzs7Ozs7Ozs7OztBQW1CQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7QUFTQTtBQXVKQTtBQU1BO0FBS0E7QUF1SkE7Ozs7OztBQXVCQTtBQUdBO0FBS0E7QUF5QkE7QUFnQkE7QUFTQTtBQTZEQTtBQXVCQTtBQXNCQTtBQWtCQTtBQWdCQTtBQUtBO0FBU0E7QUFXQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFUQTtBQWdCQTtBQUVBO0FBSUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function () {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDMuMTAuMEB3ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzP2ZmN2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fd2VicGFja0AzLjEwLjBAd2VicGFjay9idWlsZGluL21vZHVsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var _typeof2=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};/**\n * @license\n * Video.js 6.6.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */function _interopDefault(ex){return ex&&(typeof ex==='undefined'?'undefined':_typeof2(ex))==='object'&&'default'in ex?ex['default']:ex;}var window=_interopDefault(__webpack_require__(2));var document=_interopDefault(__webpack_require__(16));var tsml=_interopDefault(__webpack_require__(18));var safeParseTuple=_interopDefault(__webpack_require__(19));var xhr=_interopDefault(__webpack_require__(20));var vtt=_interopDefault(__webpack_require__(25));var version=\"6.6.0\";/**\n * @file browser.js\n * @module browser\n */var USER_AGENT=window.navigator&&window.navigator.userAgent||'';var webkitVersionMap=/AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);var appleWebkitVersion=webkitVersionMap?parseFloat(webkitVersionMap.pop()):null;/*\n * Device is an iPhone\n *\n * @type {Boolean}\n * @constant\n * @private\n */var IS_IPAD=/iPad/i.test(USER_AGENT);// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\nvar IS_IPHONE=/iPhone/i.test(USER_AGENT)&&!IS_IPAD;var IS_IPOD=/iPod/i.test(USER_AGENT);var IS_IOS=IS_IPHONE||IS_IPAD||IS_IPOD;var IOS_VERSION=function(){var match=USER_AGENT.match(/OS (\\d+)_/i);if(match&&match[1]){return match[1];}return null;}();var IS_ANDROID=/Android/i.test(USER_AGENT);var ANDROID_VERSION=function(){// This matches Android Major.Minor.Patch versions\n// ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\nvar match=USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);if(!match){return null;}var major=match[1]&&parseFloat(match[1]);var minor=match[2]&&parseFloat(match[2]);if(major&&minor){return parseFloat(match[1]+'.'+match[2]);}else if(major){return major;}return null;}();// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\nvar IS_OLD_ANDROID=IS_ANDROID&&/webkit/i.test(USER_AGENT)&&ANDROID_VERSION<2.3;var IS_NATIVE_ANDROID=IS_ANDROID&&ANDROID_VERSION<5&&appleWebkitVersion<537;var IS_FIREFOX=/Firefox/i.test(USER_AGENT);var IS_EDGE=/Edge/i.test(USER_AGENT);var IS_CHROME=!IS_EDGE&&/Chrome/i.test(USER_AGENT);var CHROME_VERSION=function(){var match=USER_AGENT.match(/Chrome\\/(\\d+)/);if(match&&match[1]){return parseFloat(match[1]);}return null;}();var IS_IE8=/MSIE\\s8\\.0/.test(USER_AGENT);var IE_VERSION=function(){var result=/MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);var version=result&&parseFloat(result[1]);if(!version&&/Trident\\/7.0/i.test(USER_AGENT)&&/rv:11.0/.test(USER_AGENT)){// IE 11 has a different user agent string than other IE versions\nversion=11.0;}return version;}();var IS_SAFARI=/Safari/i.test(USER_AGENT)&&!IS_CHROME&&!IS_ANDROID&&!IS_EDGE;var IS_ANY_SAFARI=IS_SAFARI||IS_IOS;var TOUCH_ENABLED=isReal()&&('ontouchstart'in window||window.DocumentTouch&&window.document instanceof window.DocumentTouch);var BACKGROUND_SIZE_SUPPORTED=isReal()&&'backgroundSize'in window.document.createElement('video').style;var browser=(Object.freeze||Object)({IS_IPAD:IS_IPAD,IS_IPHONE:IS_IPHONE,IS_IPOD:IS_IPOD,IS_IOS:IS_IOS,IOS_VERSION:IOS_VERSION,IS_ANDROID:IS_ANDROID,ANDROID_VERSION:ANDROID_VERSION,IS_OLD_ANDROID:IS_OLD_ANDROID,IS_NATIVE_ANDROID:IS_NATIVE_ANDROID,IS_FIREFOX:IS_FIREFOX,IS_EDGE:IS_EDGE,IS_CHROME:IS_CHROME,CHROME_VERSION:CHROME_VERSION,IS_IE8:IS_IE8,IE_VERSION:IE_VERSION,IS_SAFARI:IS_SAFARI,IS_ANY_SAFARI:IS_ANY_SAFARI,TOUCH_ENABLED:TOUCH_ENABLED,BACKGROUND_SIZE_SUPPORTED:BACKGROUND_SIZE_SUPPORTED});var _typeof=typeof Symbol===\"function\"&&_typeof2(Symbol.iterator)===\"symbol\"?function(obj){return typeof obj==='undefined'?'undefined':_typeof2(obj);}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj==='undefined'?'undefined':_typeof2(obj);};var classCallCheck=function classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}};var inherits=function inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+(typeof superClass==='undefined'?'undefined':_typeof2(superClass)));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;};var possibleConstructorReturn=function possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&((typeof call==='undefined'?'undefined':_typeof2(call))===\"object\"||typeof call===\"function\")?call:self;};var taggedTemplateLiteralLoose=function taggedTemplateLiteralLoose(strings,raw){strings.raw=raw;return strings;};/**\n * @file obj.js\n * @module obj\n *//**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *//**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */var toString=Object.prototype.toString;/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */var keys=function keys(object){return isObject(object)?Object.keys(object):[];};/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */function each(object,fn){keys(object).forEach(function(key){return fn(object[key],key);});}/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */function reduce(object,fn){var initial=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;return keys(object).reduce(function(accum,key){return fn(accum,object[key],key);},initial);}/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */function assign(target){for(var _len=arguments.length,sources=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){sources[_key-1]=arguments[_key];}if(Object.assign){return Object.assign.apply(Object,[target].concat(sources));}sources.forEach(function(source){if(!source){return;}each(source,function(value,key){target[key]=value;});});return target;}/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */function isObject(value){return!!value&&(typeof value==='undefined'?'undefined':_typeof(value))==='object';}/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */function isPlain(value){return isObject(value)&&toString.call(value)==='[object Object]'&&value.constructor===Object;}/**\n * @file log.js\n * @module log\n */var log=void 0;// This is the private tracking variable for logging level.\nvar level='info';// This is the private tracking variable for the logging history.\nvar history=[];/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n *\n * @param  {boolean} [stringify]\n *         By default, only old IEs should get console argument stringification,\n *         but this is exposed as a parameter to facilitate testing.\n */var logByType=function logByType(type,args){var stringify=arguments.length>2&&arguments[2]!==undefined?arguments[2]:!!IE_VERSION&&IE_VERSION<11;var lvl=log.levels[level];var lvlRegExp=new RegExp('^('+lvl+')$');if(type!=='log'){// Add the type to the front of the message when it's not \"log\".\nargs.unshift(type.toUpperCase()+':');}// Add a clone of the args at this point to history.\nif(history){history.push([].concat(args));}// Add console prefix after adding to history.\nargs.unshift('VIDEOJS:');// If there's no console then don't try to output messages, but they will\n// still be stored in history.\nif(!window.console){return;}// Was setting these once outside of this function, but containing them\n// in the function makes it easier to test cases where console doesn't exist\n// when the module is executed.\nvar fn=window.console[type];if(!fn&&type==='debug'){// Certain browsers don't have support for console.debug. For those, we\n// should default to the closest comparable log.\nfn=window.console.info||window.console.log;}// Bail out if there's no console or if this type is not allowed by the\n// current logging level.\nif(!fn||!lvl||!lvlRegExp.test(type)){return;}// IEs previous to 11 log objects uselessly as \"[object Object]\"; so, JSONify\n// objects and arrays for those less-capable browsers.\nif(stringify){args=args.map(function(a){if(isObject(a)||Array.isArray(a)){try{return JSON.stringify(a);}catch(x){return String(a);}}// Cast to string before joining, so we get null and undefined explicitly\n// included in output (as we would in a modern console).\nreturn String(a);}).join(' ');}// Old IE versions do not allow .apply() for console methods (they are\n// reported as objects rather than functions).\nif(!fn.apply){fn(args);}else{fn[Array.isArray(args)?'apply':'call'](window.console,args);}};/**\n * Logs plain debug messages. Similar to `console.log`.\n *\n * @class\n * @param    {Mixed[]} args\n *           One or more messages or objects that should be logged.\n */log=function log(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}logByType('log',args);};/**\n * Enumeration of available logging levels, where the keys are the level names\n * and the values are `|`-separated strings containing logging methods allowed\n * in that logging level. These strings are used to create a regular expression\n * matching the function name being called.\n *\n * Levels provided by video.js are:\n *\n * - `off`: Matches no calls. Any value that can be cast to `false` will have\n *   this effect. The most restrictive.\n * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n *   `log.warn`, and `log.error`).\n * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n * - `warn`: Matches `log.warn` and `log.error` calls.\n * - `error`: Matches only `log.error` calls.\n *\n * @type {Object}\n */log.levels={all:'debug|log|warn|error',off:'',debug:'debug|log|warn|error',info:'log|warn|error',warn:'warn|error',error:'error',DEFAULT:level};/**\n * Get or set the current logging level. If a string matching a key from\n * {@link log.levels} is provided, acts as a setter. Regardless of argument,\n * returns the current logging level.\n *\n * @param  {string} [lvl]\n *         Pass to set a new logging level.\n *\n * @return {string}\n *         The current logging level.\n */log.level=function(lvl){if(typeof lvl==='string'){if(!log.levels.hasOwnProperty(lvl)){throw new Error('\"'+lvl+'\" in not a valid log level');}level=lvl;}return level;};/**\n * Returns an array containing everything that has been logged to the history.\n *\n * This array is a shallow clone of the internal history record. However, its\n * contents are _not_ cloned; so, mutating objects inside this array will\n * mutate them in history.\n *\n * @return {Array}\n */log.history=function(){return history?[].concat(history):[];};/**\n * Clears the internal history tracking, but does not prevent further history\n * tracking.\n */log.history.clear=function(){if(history){history.length=0;}};/**\n * Disable history tracking if it is currently enabled.\n */log.history.disable=function(){if(history!==null){history.length=0;history=null;}};/**\n * Enable history tracking if it is currently disabled.\n */log.history.enable=function(){if(history===null){history=[];}};/**\n * Logs error messages. Similar to `console.error`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as an error\n */log.error=function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return logByType('error',args);};/**\n * Logs warning messages. Similar to `console.warn`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as a warning.\n */log.warn=function(){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}return logByType('warn',args);};/**\n * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n * log if `console.debug` is not available\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as debug.\n */log.debug=function(){for(var _len4=arguments.length,args=Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}return logByType('debug',args);};var log$1=log;/**\n * @file computed-style.js\n * @module computed-style\n *//**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to\n * make sure  that the player doesn't break in these cases.\n *\n * @param {Element} el\n *        The element you want the computed style of\n *\n * @param {string} prop\n *        The property name you want\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n *\n * @static\n * @const\n */function computedStyle(el,prop){if(!el||!prop){return'';}if(typeof window.getComputedStyle==='function'){var cs=window.getComputedStyle(el);return cs?cs[prop]:'';}return el.currentStyle[prop]||'';}var _templateObject=taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ',' to ','.'],['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ',' to ','.']);/**\n * @file dom.js\n * @module dom\n *//**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */function isNonBlankString(str){return typeof str==='string'&&/\\S/.test(str);}/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */function throwIfWhitespace(str){if(/\\s/.test(str)){throw new Error('class has illegal whitespace characters');}}/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */function classRegExp(className){return new RegExp('(^|\\\\s)'+className+'($|\\\\s)');}/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */function isReal(){return(// Both document and window will never be undefined thanks to `global`.\ndocument===window.document&&// In IE < 9, DOM methods return \"object\" as their type, so all we can\n// confidently check is that it exists.\ntypeof document.createElement!=='undefined');}/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */function isEl(value){return isObject(value)&&value.nodeType===1;}/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *\n */function isInFrame(){// We need a try/catch here because Safari will throw errors when attempting\n// to get either `parent` or `self`\ntry{return window.parent!==window.self;}catch(x){return true;}}/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */function createQuerier(method){return function(selector,context){if(!isNonBlankString(selector)){return document[method](null);}if(isNonBlankString(context)){context=document.querySelector(context);}var ctx=isEl(context)?context:document;return ctx[method]&&ctx[method](selector);};}/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */function createEl(){var tagName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'div';var properties=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var content=arguments[3];var el=document.createElement(tagName);Object.getOwnPropertyNames(properties).forEach(function(propName){var val=properties[propName];// See #2176\n// We originally were accepting both properties and attributes in the\n// same object, but that doesn't work so well.\nif(propName.indexOf('aria-')!==-1||propName==='role'||propName==='type'){log$1.warn(tsml(_templateObject,propName,val));el.setAttribute(propName,val);// Handle textContent since it's not supported everywhere and we have a\n// method for it.\n}else if(propName==='textContent'){textContent(el,val);}else{el[propName]=val;}});Object.getOwnPropertyNames(attributes).forEach(function(attrName){el.setAttribute(attrName,attributes[attrName]);});if(content){appendContent(el,content);}return el;}/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */function textContent(el,text){if(typeof el.textContent==='undefined'){el.innerText=text;}else{el.textContent=text;}return el;}/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */function prependTo(child,parent){if(parent.firstChild){parent.insertBefore(child,parent.firstChild);}else{parent.appendChild(child);}}/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */function hasClass(element,classToCheck){throwIfWhitespace(classToCheck);if(element.classList){return element.classList.contains(classToCheck);}return classRegExp(classToCheck).test(element.className);}/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */function addClass(element,classToAdd){if(element.classList){element.classList.add(classToAdd);// Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n// in the case of classList not being supported.\n}else if(!hasClass(element,classToAdd)){element.className=(element.className+' '+classToAdd).trim();}return element;}/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */function removeClass(element,classToRemove){if(element.classList){element.classList.remove(classToRemove);}else{throwIfWhitespace(classToRemove);element.className=element.className.split(/\\s+/).filter(function(c){return c!==classToRemove;}).join(' ');}return element;}/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n *//**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */function toggleClass(element,classToToggle,predicate){// This CANNOT use `classList` internally because IE does not support the\n// second parameter to the `classList.toggle()` method! Which is fine because\n// `classList` will be used by the add/remove functions.\nvar has=hasClass(element,classToToggle);if(typeof predicate==='function'){predicate=predicate(element,classToToggle);}if(typeof predicate!=='boolean'){predicate=!has;}// If the necessary class operation matches the current state of the\n// element, no action is required.\nif(predicate===has){return;}if(predicate){addClass(element,classToToggle);}else{removeClass(element,classToToggle);}return element;}/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */function setAttributes(el,attributes){Object.getOwnPropertyNames(attributes).forEach(function(attrName){var attrValue=attributes[attrName];if(attrValue===null||typeof attrValue==='undefined'||attrValue===false){el.removeAttribute(attrName);}else{el.setAttribute(attrName,attrValue===true?'':attrValue);}});}/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */function getAttributes(tag){var obj={};// known boolean attributes\n// we can check for matching boolean properties, but older browsers\n// won't know about HTML5 boolean attributes that we still read from\nvar knownBooleans=','+'autoplay,controls,playsinline,loop,muted,default,defaultMuted'+',';if(tag&&tag.attributes&&tag.attributes.length>0){var attrs=tag.attributes;for(var i=attrs.length-1;i>=0;i--){var attrName=attrs[i].name;var attrVal=attrs[i].value;// check for known booleans\n// the matching element property will return a value for typeof\nif(typeof tag[attrName]==='boolean'||knownBooleans.indexOf(','+attrName+',')!==-1){// the value of an included boolean attribute is typically an empty\n// string ('') which would equal false if we just check for a false value.\n// we also don't want support bad code like autoplay='false'\nattrVal=attrVal!==null?true:false;}obj[attrName]=attrVal;}}return obj;}/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */function getAttribute(el,attribute){return el.getAttribute(attribute);}/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */function setAttribute(el,attribute,value){el.setAttribute(attribute,value);}/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */function removeAttribute(el,attribute){el.removeAttribute(attribute);}/**\n * Attempt to block the ability to select text while dragging controls\n */function blockTextSelection(){document.body.focus();document.onselectstart=function(){return false;};}/**\n * Turn off text selection blocking\n */function unblockTextSelection(){document.onselectstart=function(){return true;};}/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain\n */function getBoundingClientRect(el){if(el&&el.getBoundingClientRect&&el.parentNode){var rect=el.getBoundingClientRect();var result={};['bottom','height','left','right','top','width'].forEach(function(k){if(rect[k]!==undefined){result[k]=rect[k];}});if(!result.height){result.height=parseFloat(computedStyle(el,'height'));}if(!result.width){result.width=parseFloat(computedStyle(el,'width'));}return result;}}/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n *//**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */function findPosition(el){var box=void 0;if(el.getBoundingClientRect&&el.parentNode){box=el.getBoundingClientRect();}if(!box){return{left:0,top:0};}var docEl=document.documentElement;var body=document.body;var clientLeft=docEl.clientLeft||body.clientLeft||0;var scrollLeft=window.pageXOffset||body.scrollLeft;var left=box.left+scrollLeft-clientLeft;var clientTop=docEl.clientTop||body.clientTop||0;var scrollTop=window.pageYOffset||body.scrollTop;var top=box.top+scrollTop-clientTop;// Android sometimes returns slightly off decimal values, so need to round\nreturn{left:Math.round(left),top:Math.round(top)};}/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n *//**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */function getPointerPosition(el,event){var position={};var box=findPosition(el);var boxW=el.offsetWidth;var boxH=el.offsetHeight;var boxY=box.top;var boxX=box.left;var pageY=event.pageY;var pageX=event.pageX;if(event.changedTouches){pageX=event.changedTouches[0].pageX;pageY=event.changedTouches[0].pageY;}position.y=Math.max(0,Math.min(1,(boxY-pageY+boxH)/boxH));position.x=Math.max(0,Math.min(1,(pageX-boxX)/boxW));return position;}/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */function isTextNode(value){return isObject(value)&&value.nodeType===3;}/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */function emptyEl(el){while(el.firstChild){el.removeChild(el.firstChild);}return el;}/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */function normalizeContent(content){// First, invoke content if it is a function. If it produces an array,\n// that needs to happen before normalization.\nif(typeof content==='function'){content=content();}// Next up, normalize to an array, so one or many items can be normalized,\n// filtered, and returned.\nreturn(Array.isArray(content)?content:[content]).map(function(value){// First, invoke value if it is a function to produce a new value,\n// which will be subsequently normalized to a Node of some kind.\nif(typeof value==='function'){value=value();}if(isEl(value)||isTextNode(value)){return value;}if(typeof value==='string'&&/\\S/.test(value)){return document.createTextNode(value);}}).filter(function(value){return value;});}/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */function appendContent(el,content){normalizeContent(content).forEach(function(node){return el.appendChild(node);});return el;}/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */function insertContent(el,content){return appendContent(emptyEl(el),content);}/**\n * Check if event was a single left click\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {boolean}\n *         - True if a left click\n *         - False if not a left click\n */function isSingleLeftClick(event){// Note: if you create something draggable, be sure to\n// call it on both `mousedown` and `mousemove` event,\n// otherwise `mousedown` should be enough for a button\nif(event.button===undefined&&event.buttons===undefined){// Why do we need `butttons` ?\n// Because, middle mouse sometimes have this:\n// e.button === 0 and e.buttons === 4\n// Furthermore, we want to prevent combination click, something like\n// HOLD middlemouse then left click, that would be\n// e.button === 0, e.buttons === 5\n// just `button` is not gonna work\n// Alright, then what this block does ?\n// this is for chrome `simulate mobile devices`\n// I want to support this as well\nreturn true;}if(event.button===0&&event.buttons===undefined){// Touch screen, sometimes on some specific device, `buttons`\n// doesn't have anything (safari on ios, blackberry...)\nreturn true;}if(IE_VERSION===9){// Ignore IE9\nreturn true;}if(event.button!==0||event.buttons!==1){// This is the reason we have those if else block above\n// if any special case we can catch and let it slide\n// we do it above, when get to here, this definitely\n// is-not-left-click\nreturn false;}return true;}/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */var $=createQuerier('querySelector');/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */var $$=createQuerier('querySelectorAll');var Dom=(Object.freeze||Object)({isReal:isReal,isEl:isEl,isInFrame:isInFrame,createEl:createEl,textContent:textContent,prependTo:prependTo,hasClass:hasClass,addClass:addClass,removeClass:removeClass,toggleClass:toggleClass,setAttributes:setAttributes,getAttributes:getAttributes,getAttribute:getAttribute,setAttribute:setAttribute,removeAttribute:removeAttribute,blockTextSelection:blockTextSelection,unblockTextSelection:unblockTextSelection,getBoundingClientRect:getBoundingClientRect,findPosition:findPosition,getPointerPosition:getPointerPosition,isTextNode:isTextNode,emptyEl:emptyEl,normalizeContent:normalizeContent,appendContent:appendContent,insertContent:insertContent,isSingleLeftClick:isSingleLeftClick,$:$,$$:$$});/**\n * @file guid.js\n * @module guid\n *//**\n * Unique ID for an element or function\n * @type {Number}\n */var _guid=1;/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */function newGUID(){return _guid++;}/**\n * @file dom-data.js\n * @module dom-data\n *//**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */var elData={};/*\n * Unique attribute name to store an element's guid in\n *\n * @type {String}\n * @constant\n * @private\n */var elIdAttr='vdata'+new Date().getTime();/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */function getData(el){var id=el[elIdAttr];if(!id){id=el[elIdAttr]=newGUID();}if(!elData[id]){elData[id]={};}return elData[id];}/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */function hasData(el){var id=el[elIdAttr];if(!id){return false;}return!!Object.getOwnPropertyNames(elData[id]).length;}/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */function removeData(el){var id=el[elIdAttr];if(!id){return;}// Remove all stored data\ndelete elData[id];// Remove the elIdAttr property from the DOM node\ntry{delete el[elIdAttr];}catch(e){if(el.removeAttribute){el.removeAttribute(elIdAttr);}else{// IE doesn't appear to support removeAttribute on the document element\nel[elIdAttr]=null;}}}/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n *//**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */function _cleanUpEvents(elem,type){var data=getData(elem);// Remove the events of a particular type if there are none left\nif(data.handlers[type].length===0){delete data.handlers[type];// data.handlers[type] = null;\n// Setting to null was causing an error with data.handlers\n// Remove the meta-handler from the element\nif(elem.removeEventListener){elem.removeEventListener(type,data.dispatcher,false);}else if(elem.detachEvent){elem.detachEvent('on'+type,data.dispatcher);}}// Remove the events object if there are no types left\nif(Object.getOwnPropertyNames(data.handlers).length<=0){delete data.handlers;delete data.dispatcher;delete data.disabled;}// Finally remove the element data if there is no data left\nif(Object.getOwnPropertyNames(data).length===0){removeData(elem);}}/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */function _handleMultipleEvents(fn,elem,types,callback){types.forEach(function(type){// Call the event method for each one of the types\nfn(elem,type,callback);});}/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */function fixEvent(event){function returnTrue(){return true;}function returnFalse(){return false;}// Test if fixing up is needed\n// Used to check if !event.stopPropagation instead of isPropagationStopped\n// But native events return true for stopPropagation, but don't have\n// other expected methods like isPropagationStopped. Seems to be a problem\n// with the Javascript Ninja code. So we're just overriding all events now.\nif(!event||!event.isPropagationStopped){var old=event||window.event;event={};// Clone the old object so that we can modify the values event = {};\n// IE8 Doesn't like when you mess with native event properties\n// Firefox returns false for event.hasOwnProperty('type') and other props\n//  which makes copying more difficult.\n// TODO: Probably best to create a whitelist of event props\nfor(var key in old){// Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n// Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n// and webkitMovementX/Y\nif(key!=='layerX'&&key!=='layerY'&&key!=='keyLocation'&&key!=='webkitMovementX'&&key!=='webkitMovementY'){// Chrome 32+ warns if you try to copy deprecated returnValue, but\n// we still want to if preventDefault isn't supported (IE8).\nif(!(key==='returnValue'&&old.preventDefault)){event[key]=old[key];}}}// The event occurred on this element\nif(!event.target){event.target=event.srcElement||document;}// Handle which other element the event is related to\nif(!event.relatedTarget){event.relatedTarget=event.fromElement===event.target?event.toElement:event.fromElement;}// Stop the default browser action\nevent.preventDefault=function(){if(old.preventDefault){old.preventDefault();}event.returnValue=false;old.returnValue=false;event.defaultPrevented=true;};event.defaultPrevented=false;// Stop the event from bubbling\nevent.stopPropagation=function(){if(old.stopPropagation){old.stopPropagation();}event.cancelBubble=true;old.cancelBubble=true;event.isPropagationStopped=returnTrue;};event.isPropagationStopped=returnFalse;// Stop the event from bubbling and executing other handlers\nevent.stopImmediatePropagation=function(){if(old.stopImmediatePropagation){old.stopImmediatePropagation();}event.isImmediatePropagationStopped=returnTrue;event.stopPropagation();};event.isImmediatePropagationStopped=returnFalse;// Handle mouse position\nif(event.clientX!==null&&event.clientX!==undefined){var doc=document.documentElement;var body=document.body;event.pageX=event.clientX+(doc&&doc.scrollLeft||body&&body.scrollLeft||0)-(doc&&doc.clientLeft||body&&body.clientLeft||0);event.pageY=event.clientY+(doc&&doc.scrollTop||body&&body.scrollTop||0)-(doc&&doc.clientTop||body&&body.clientTop||0);}// Handle key presses\nevent.which=event.charCode||event.keyCode;// Fix button for mouse clicks:\n// 0 == left; 1 == middle; 2 == right\nif(event.button!==null&&event.button!==undefined){// The following is disabled because it does not pass videojs-standard\n// and... yikes.\n/* eslint-disable */event.button=event.button&1?0:event.button&4?1:event.button&2?2:0;/* eslint-enable */}}// Returns fixed-up instance\nreturn event;}/**\n * Whether passive event listeners are supported\n */var _supportsPassive=false;(function(){try{var opts=Object.defineProperty({},'passive',{get:function get(){_supportsPassive=true;}});window.addEventListener('test',null,opts);window.removeEventListener('test',null,opts);}catch(e){// disregard\n}})();/**\n * Touch events Chrome expects to be passive\n */var passiveEvents=['touchstart','touchmove'];/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */function on(elem,type,fn){if(Array.isArray(type)){return _handleMultipleEvents(on,elem,type,fn);}var data=getData(elem);// We need a place to store all our handler data\nif(!data.handlers){data.handlers={};}if(!data.handlers[type]){data.handlers[type]=[];}if(!fn.guid){fn.guid=newGUID();}data.handlers[type].push(fn);if(!data.dispatcher){data.disabled=false;data.dispatcher=function(event,hash){if(data.disabled){return;}event=fixEvent(event);var handlers=data.handlers[event.type];if(handlers){// Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\nvar handlersCopy=handlers.slice(0);for(var m=0,n=handlersCopy.length;m<n;m++){if(event.isImmediatePropagationStopped()){break;}else{try{handlersCopy[m].call(elem,event,hash);}catch(e){log$1.error(e);}}}}};}if(data.handlers[type].length===1){if(elem.addEventListener){var options=false;if(_supportsPassive&&passiveEvents.indexOf(type)>-1){options={passive:true};}elem.addEventListener(type,data.dispatcher,options);}else if(elem.attachEvent){elem.attachEvent('on'+type,data.dispatcher);}}}/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */function off(elem,type,fn){// Don't want to add a cache object through getElData if not needed\nif(!hasData(elem)){return;}var data=getData(elem);// If no events exist, nothing to unbind\nif(!data.handlers){return;}if(Array.isArray(type)){return _handleMultipleEvents(off,elem,type,fn);}// Utility function\nvar removeType=function removeType(el,t){data.handlers[t]=[];_cleanUpEvents(el,t);};// Are we removing all bound events?\nif(type===undefined){for(var t in data.handlers){if(Object.prototype.hasOwnProperty.call(data.handlers||{},t)){removeType(elem,t);}}return;}var handlers=data.handlers[type];// If no handlers exist, nothing to unbind\nif(!handlers){return;}// If no listener was provided, remove all listeners for type\nif(!fn){removeType(elem,type);return;}// We're only removing a single handler\nif(fn.guid){for(var n=0;n<handlers.length;n++){if(handlers[n].guid===fn.guid){handlers.splice(n--,1);}}}_cleanUpEvents(elem,type);}/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */function trigger(elem,event,hash){// Fetches element data and a reference to the parent (for bubbling).\n// Don't want to add a data object to cache for every parent,\n// so checking hasElData first.\nvar elemData=hasData(elem)?getData(elem):{};var parent=elem.parentNode||elem.ownerDocument;// type = event.type || event,\n// handler;\n// If an event name was passed as a string, creates an event out of it\nif(typeof event==='string'){event={type:event,target:elem};}// Normalizes the event properties.\nevent=fixEvent(event);// If the passed element has a dispatcher, executes the established handlers.\nif(elemData.dispatcher){elemData.dispatcher.call(elem,event,hash);}// Unless explicitly stopped or the event does not bubble (e.g. media events)\n// recursively calls this function to bubble the event up the DOM.\nif(parent&&!event.isPropagationStopped()&&event.bubbles===true){trigger.call(null,parent,event,hash);// If at the top of the DOM, triggers the default action unless disabled.\n}else if(!parent&&!event.defaultPrevented){var targetData=getData(event.target);// Checks if the target has a default action for this event.\nif(event.target[event.type]){// Temporarily disables event dispatching on the target as we have already executed the handler.\ntargetData.disabled=true;// Executes the default action.\nif(typeof event.target[event.type]==='function'){event.target[event.type]();}// Re-enables event dispatching.\ntargetData.disabled=false;}}// Inform the triggerer if the default was prevented by returning false\nreturn!event.defaultPrevented;}/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */function one(elem,type,fn){if(Array.isArray(type)){return _handleMultipleEvents(one,elem,type,fn);}var func=function func(){off(elem,type,func);fn.apply(this,arguments);};// copy the guid to the new function so it can removed using the original function's ID\nfunc.guid=fn.guid=fn.guid||newGUID();on(elem,type,func);}var Events=(Object.freeze||Object)({fixEvent:fixEvent,on:on,off:off,trigger:trigger,one:one});/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */var _windowLoaded=false;var videojs$2=void 0;/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */var autoSetup=function autoSetup(){// Protect against breakage in non-browser environments.\nif(!isReal()){return;}// One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n// var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n// var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n// var mediaEls = vids.concat(audios);\n// Because IE8 doesn't support calling slice on a node list, we need to loop\n// through each list of elements to build up a new, combined list of elements.\nvar vids=document.getElementsByTagName('video');var audios=document.getElementsByTagName('audio');var divs=document.getElementsByTagName('video-js');var mediaEls=[];if(vids&&vids.length>0){for(var i=0,e=vids.length;i<e;i++){mediaEls.push(vids[i]);}}if(audios&&audios.length>0){for(var _i=0,_e=audios.length;_i<_e;_i++){mediaEls.push(audios[_i]);}}if(divs&&divs.length>0){for(var _i2=0,_e2=divs.length;_i2<_e2;_i2++){mediaEls.push(divs[_i2]);}}// Check if any media elements exist\nif(mediaEls&&mediaEls.length>0){for(var _i3=0,_e3=mediaEls.length;_i3<_e3;_i3++){var mediaEl=mediaEls[_i3];// Check if element exists, has getAttribute func.\n// IE seems to consider typeof el.getAttribute == 'object' instead of\n// 'function' like expected, at least when loading the player immediately.\nif(mediaEl&&mediaEl.getAttribute){// Make sure this player hasn't already been set up.\nif(mediaEl.player===undefined){var options=mediaEl.getAttribute('data-setup');// Check if data-setup attr exists.\n// We only auto-setup if they've added the data-setup attr.\nif(options!==null){// Create new video.js instance.\nvideojs$2(mediaEl);}}// If getAttribute isn't defined, we need to wait for the DOM.\n}else{autoSetupTimeout(1);break;}}// No videos were found, so keep looping unless page is finished loading.\n}else if(!_windowLoaded){autoSetupTimeout(1);}};/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */function autoSetupTimeout(wait,vjs){if(vjs){videojs$2=vjs;}window.setTimeout(autoSetup,wait);}if(isReal()&&document.readyState==='complete'){_windowLoaded=true;}else{/**\n   * Listen for the load event on window, and set _windowLoaded to true.\n   *\n   * @listens load\n   */one(window,'load',function(){_windowLoaded=true;});}/**\n * @file stylesheet.js\n * @module stylesheet\n *//**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */var createStyleElement=function createStyleElement(className){var style=document.createElement('style');style.className=className;return style;};/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */var setTextContent=function setTextContent(el,content){if(el.styleSheet){el.styleSheet.cssText=content;}else{el.textContent=content;}};/**\n * @file fn.js\n * @module fn\n *//**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */var bind=function bind(context,fn,uid){// Make sure the function has a unique ID\nif(!fn.guid){fn.guid=newGUID();}// Create the new function that changes the context\nvar bound=function bound(){return fn.apply(context,arguments);};// Allow for the ability to individualize this function\n// Needed in the case where multiple objects might share the same prototype\n// IF both items add an event listener with the same function, then you try to remove just one\n// it will remove both because they both have the same guid.\n// when using this, you need to use the bind method when you remove the listener as well.\n// currently used in text tracks\nbound.guid=uid?uid+'_'+fn.guid:fn.guid;return bound;};/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */var throttle=function throttle(fn,wait){var last=Date.now();var throttled=function throttled(){var now=Date.now();if(now-last>=wait){fn.apply(undefined,arguments);last=now;}};return throttled;};/**\n * @file src/js/event-target.js\n *//**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */var EventTarget=function EventTarget(){};/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n *//**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n *//**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */EventTarget.prototype.allowedEvents_={};/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */EventTarget.prototype.on=function(type,fn){// Remove the addEventListener alias before calling Events.on\n// so we don't get into an infinite type loop\nvar ael=this.addEventListener;this.addEventListener=function(){};on(this,type,fn);this.addEventListener=ael;};/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */EventTarget.prototype.addEventListener=EventTarget.prototype.on;/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */EventTarget.prototype.off=function(type,fn){off(this,type,fn);};/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */EventTarget.prototype.removeEventListener=EventTarget.prototype.off;/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */EventTarget.prototype.one=function(type,fn){// Remove the addEventListener alialing Events.on\n// so we don't get into an infinite type loop\nvar ael=this.addEventListener;this.addEventListener=function(){};one(this,type,fn);this.addEventListener=ael;};/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */EventTarget.prototype.trigger=function(event){var type=event.type||event;if(typeof event==='string'){event={type:type};}event=fixEvent(event);if(this.allowedEvents_[type]&&this['on'+type]){this['on'+type](event);}trigger(this,event);};/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */EventTarget.prototype.dispatchEvent=EventTarget.prototype.trigger;/**\n * @file mixins/evented.js\n * @module evented\n *//**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */var isEvented=function isEvented(object){return object instanceof EventTarget||!!object.eventBusEl_&&['on','one','off','trigger'].every(function(k){return typeof object[k]==='function';});};/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */var isValidEventType=function isValidEventType(type){return(// The regex here verifies that the `type` contains at least one non-\n// whitespace character.\ntypeof type==='string'&&/\\S/.test(type)||Array.isArray(type)&&!!type.length);};/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */var validateTarget=function validateTarget(target){if(!target.nodeName&&!isEvented(target)){throw new Error('Invalid target; must be a DOM node or evented object.');}};/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */var validateEventType=function validateEventType(type){if(!isValidEventType(type)){throw new Error('Invalid event type; must be a non-empty string or array.');}};/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */var validateListener=function validateListener(listener){if(typeof listener!=='function'){throw new Error('Invalid listener; must be a function.');}};/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */var normalizeListenArgs=function normalizeListenArgs(self,args){// If the number of arguments is less than 3, the target is always the\n// evented object itself.\nvar isTargetingSelf=args.length<3||args[0]===self||args[0]===self.eventBusEl_;var target=void 0;var type=void 0;var listener=void 0;if(isTargetingSelf){target=self.eventBusEl_;// Deal with cases where we got 3 arguments, but we are still listening to\n// the evented object itself.\nif(args.length>=3){args.shift();}type=args[0];listener=args[1];}else{target=args[0];type=args[1];listener=args[2];}validateTarget(target);validateEventType(type);validateListener(listener);listener=bind(self,listener);return{isTargetingSelf:isTargetingSelf,target:target,type:type,listener:listener};};/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */var listen=function listen(target,method,type,listener){validateTarget(target);if(target.nodeName){Events[method](target,type,listener);}else{target[method](type,listener);}};/**\n * Contains methods that provide event capabilites to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */var EventedMixin={/**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */on:function on$$1(){var _this=this;for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _normalizeListenArgs=normalizeListenArgs(this,args),isTargetingSelf=_normalizeListenArgs.isTargetingSelf,target=_normalizeListenArgs.target,type=_normalizeListenArgs.type,listener=_normalizeListenArgs.listener;listen(target,'on',type,listener);// If this object is listening to another evented object.\nif(!isTargetingSelf){// If this object is disposed, remove the listener.\nvar removeListenerOnDispose=function removeListenerOnDispose(){return _this.off(target,type,listener);};// Use the same function ID as the listener so we can remove it later it\n// using the ID of the original listener.\nremoveListenerOnDispose.guid=listener.guid;// Add a listener to the target's dispose event as well. This ensures\n// that if the target is disposed BEFORE this object, we remove the\n// removal listener that was just added. Otherwise, we create a memory leak.\nvar removeRemoverOnTargetDispose=function removeRemoverOnTargetDispose(){return _this.off('dispose',removeListenerOnDispose);};// Use the same function ID as the listener so we can remove it later\n// it using the ID of the original listener.\nremoveRemoverOnTargetDispose.guid=listener.guid;listen(this,'on','dispose',removeListenerOnDispose);listen(target,'on','dispose',removeRemoverOnTargetDispose);}},/**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */one:function one$$1(){var _this2=this;for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}var _normalizeListenArgs2=normalizeListenArgs(this,args),isTargetingSelf=_normalizeListenArgs2.isTargetingSelf,target=_normalizeListenArgs2.target,type=_normalizeListenArgs2.type,listener=_normalizeListenArgs2.listener;// Targeting this evented object.\nif(isTargetingSelf){listen(target,'one',type,listener);// Targeting another evented object.\n}else{var wrapper=function wrapper(){for(var _len3=arguments.length,largs=Array(_len3),_key3=0;_key3<_len3;_key3++){largs[_key3]=arguments[_key3];}_this2.off(target,type,wrapper);listener.apply(null,largs);};// Use the same function ID as the listener so we can remove it later\n// it using the ID of the original listener.\nwrapper.guid=listener.guid;listen(target,'one',type,wrapper);}},/**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */off:function off$$1(targetOrType,typeOrListener,listener){// Targeting this evented object.\nif(!targetOrType||isValidEventType(targetOrType)){off(this.eventBusEl_,targetOrType,typeOrListener);// Targeting another evented object.\n}else{var target=targetOrType;var type=typeOrListener;// Fail fast and in a meaningful way!\nvalidateTarget(target);validateEventType(type);validateListener(listener);// Ensure there's at least a guid, even if the function hasn't been used\nlistener=bind(this,listener);// Remove the dispose listener on this evented object, which was given\n// the same guid as the event listener in on().\nthis.off('dispose',listener);if(target.nodeName){off(target,type,listener);off(target,'dispose',listener);}else if(isEvented(target)){target.off(type,listener);target.off('dispose',listener);}}},/**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @returns {boolean}\n   *          Whether or not the default behavior was prevented.\n   */trigger:function trigger$$1(event,hash){return trigger(this.eventBusEl_,event,hash);}};/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {String} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */function evented(target){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var eventBusKey=options.eventBusKey;// Set or create the eventBusEl_.\nif(eventBusKey){if(!target[eventBusKey].nodeName){throw new Error('The eventBusKey \"'+eventBusKey+'\" does not refer to an element.');}target.eventBusEl_=target[eventBusKey];}else{target.eventBusEl_=createEl('span',{className:'vjs-event-bus'});}assign(target,EventedMixin);// When any evented object is disposed, it removes all its listeners.\ntarget.on('dispose',function(){target.off();window.setTimeout(function(){target.eventBusEl_=null;},0);});return target;}/**\n * @file mixins/stateful.js\n * @module stateful\n *//**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */var StatefulMixin={/**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */state:{},/**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @returns {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */setState:function setState(stateUpdates){var _this=this;// Support providing the `stateUpdates` state as a function.\nif(typeof stateUpdates==='function'){stateUpdates=stateUpdates();}var changes=void 0;each(stateUpdates,function(value,key){// Record the change if the value is different from what's in the\n// current state.\nif(_this.state[key]!==value){changes=changes||{};changes[key]={from:_this.state[key],to:value};}_this.state[key]=value;});// Only trigger \"statechange\" if there were changes AND we have a trigger\n// function. This allows us to not require that the target object be an\n// evented object.\nif(changes&&isEvented(this)){/**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */this.trigger({changes:changes,type:'statechanged'});}return changes;}};/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @returns {Object}\n *          Returns the `target`.\n */function stateful(target,defaultState){assign(target,StatefulMixin);// This happens after the mixing-in because we need to replace the `state`\n// added in that step.\ntarget.state=assign({},target.state,defaultState);// Auto-bind the `handleStateChanged` method of the target object if it exists.\nif(typeof target.handleStateChanged==='function'&&isEvented(target)){target.on('statechanged',target.handleStateChanged);}return target;}/**\n * @file to-title-case.js\n * @module to-title-case\n *//**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */function toTitleCase(string){if(typeof string!=='string'){return string;}return string.charAt(0).toUpperCase()+string.slice(1);}/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */function titleCaseEquals(str1,str2){return toTitleCase(str1)===toTitleCase(str2);}/**\n * @file merge-options.js\n * @module merge-options\n *//**\n * Deep-merge one or more options objects, recursively merging **only** plain\n * object properties.\n *\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @returns {Object}\n *          A new object that is the merged result of all sources.\n */function mergeOptions(){var result={};for(var _len=arguments.length,sources=Array(_len),_key=0;_key<_len;_key++){sources[_key]=arguments[_key];}sources.forEach(function(source){if(!source){return;}each(source,function(value,key){if(!isPlain(value)){result[key]=value;return;}if(!isPlain(result[key])){result[key]={};}result[key]=mergeOptions(result[key],value);});});return result;}/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n *//**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */var Component=function(){/**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   *//**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */function Component(player,options,ready){classCallCheck(this,Component);// The component might be the player itself and we can't pass `this` to super\nif(!player&&this.play){this.player_=player=this;// eslint-disable-line\n}else{this.player_=player;}// Make a copy of prototype.options_ to protect against overriding defaults\nthis.options_=mergeOptions({},this.options_);// Updated options with supplied options\noptions=this.options_=mergeOptions(this.options_,options);// Get ID from options or options element if one is supplied\nthis.id_=options.id||options.el&&options.el.id;// If there was no ID from the options, generate one\nif(!this.id_){// Don't require the player ID function in the case of mock players\nvar id=player&&player.id&&player.id()||'no_player';this.id_=id+'_component_'+newGUID();}this.name_=options.name||null;// Create element if one wasn't provided in options\nif(options.el){this.el_=options.el;}else if(options.createEl!==false){this.el_=this.createEl();}// if evented is anything except false, we want to mixin in evented\nif(options.evented!==false){// Make this an evented object and use `el_`, if available, as its event bus\nevented(this,{eventBusKey:this.el_?'el_':null});}stateful(this,this.constructor.defaultState);this.children_=[];this.childIndex_={};this.childNameIndex_={};// Add any child components in options\nif(options.initChildren!==false){this.initChildren();}this.ready(ready);// Don't want to trigger ready here or it will before init is actually\n// finished for all children that run this constructor\nif(options.reportTouchActivity!==false){this.enableTouchActivity();}}/**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */Component.prototype.dispose=function dispose(){/**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up\n     */this.trigger({type:'dispose',bubbles:false});// Dispose all children.\nif(this.children_){for(var i=this.children_.length-1;i>=0;i--){if(this.children_[i].dispose){this.children_[i].dispose();}}}// Delete child references\nthis.children_=null;this.childIndex_=null;this.childNameIndex_=null;if(this.el_){// Remove element from DOM\nif(this.el_.parentNode){this.el_.parentNode.removeChild(this.el_);}removeData(this.el_);this.el_=null;}// remove reference to the player after disposing of the element\nthis.player_=null;};/**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */Component.prototype.player=function player(){return this.player_;};/**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   *\n   * @deprecated since version 5\n   */Component.prototype.options=function options(obj){log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');if(!obj){return this.options_;}this.options_=mergeOptions(this.options_,obj);return this.options_;};/**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */Component.prototype.el=function el(){return this.el_;};/**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Component.prototype.createEl=function createEl$$1(tagName,properties,attributes){return createEl(tagName,properties,attributes);};/**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */Component.prototype.localize=function localize(string,tokens){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:string;var code=this.player_.language&&this.player_.language();var languages=this.player_.languages&&this.player_.languages();var language=languages&&languages[code];var primaryCode=code&&code.split('-')[0];var primaryLang=languages&&languages[primaryCode];var localizedString=defaultValue;if(language&&language[string]){localizedString=language[string];}else if(primaryLang&&primaryLang[string]){localizedString=primaryLang[string];}if(tokens){localizedString=localizedString.replace(/\\{(\\d+)\\}/g,function(match,index){var value=tokens[index-1];var ret=value;if(typeof value==='undefined'){ret=match;}return ret;});}return localizedString;};/**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */Component.prototype.contentEl=function contentEl(){return this.contentEl_||this.el_;};/**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */Component.prototype.id=function id(){return this.id_;};/**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */Component.prototype.name=function name(){return this.name_;};/**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */Component.prototype.children=function children(){return this.children_;};/**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */Component.prototype.getChildById=function getChildById(id){return this.childIndex_[id];};/**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */Component.prototype.getChild=function getChild(name){if(!name){return;}name=toTitleCase(name);return this.childNameIndex_[name];};/**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */Component.prototype.addChild=function addChild(child){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var index=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.children_.length;var component=void 0;var componentName=void 0;// If child is a string, create component with options\nif(typeof child==='string'){componentName=toTitleCase(child);var componentClassName=options.componentClass||componentName;// Set name through options\noptions.name=componentName;// Create a new object & element for this controls set\n// If there's no .player_, this is a player\nvar ComponentClass=Component.getComponent(componentClassName);if(!ComponentClass){throw new Error('Component '+componentClassName+' does not exist');}// data stored directly on the videojs object may be\n// misidentified as a component to retain\n// backwards-compatibility with 4.x. check to make sure the\n// component class can be instantiated.\nif(typeof ComponentClass!=='function'){return null;}component=new ComponentClass(this.player_||this,options);// child is a component instance\n}else{component=child;}this.children_.splice(index,0,component);if(typeof component.id==='function'){this.childIndex_[component.id()]=component;}// If a name wasn't used to create the component, check if we can use the\n// name function of the component\ncomponentName=componentName||component.name&&toTitleCase(component.name());if(componentName){this.childNameIndex_[componentName]=component;}// Add the UI object's element to the container div (box)\n// Having an element is not required\nif(typeof component.el==='function'&&component.el()){var childNodes=this.contentEl().children;var refNode=childNodes[index]||null;this.contentEl().insertBefore(component.el(),refNode);}// Return so it can stored on parent object if desired.\nreturn component;};/**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */Component.prototype.removeChild=function removeChild(component){if(typeof component==='string'){component=this.getChild(component);}if(!component||!this.children_){return;}var childFound=false;for(var i=this.children_.length-1;i>=0;i--){if(this.children_[i]===component){childFound=true;this.children_.splice(i,1);break;}}if(!childFound){return;}this.childIndex_[component.id()]=null;this.childNameIndex_[component.name()]=null;var compEl=component.el();if(compEl&&compEl.parentNode===this.contentEl()){this.contentEl().removeChild(component.el());}};/**\n   * Add and initialize default child `Component`s based upon options.\n   */Component.prototype.initChildren=function initChildren(){var _this=this;var children=this.options_.children;if(children){// `this` is `parent`\nvar parentOptions=this.options_;var handleAdd=function handleAdd(child){var name=child.name;var opts=child.opts;// Allow options for children to be set at the parent options\n// e.g. videojs(id, { controlBar: false });\n// instead of videojs(id, { children: { controlBar: false });\nif(parentOptions[name]!==undefined){opts=parentOptions[name];}// Allow for disabling default components\n// e.g. options['children']['posterImage'] = false\nif(opts===false){return;}// Allow options to be passed as a simple boolean if no configuration\n// is necessary.\nif(opts===true){opts={};}// We also want to pass the original player options\n// to each component as well so they don't need to\n// reach back into the player for options later.\nopts.playerOptions=_this.options_.playerOptions;// Create and add the child component.\n// Add a direct reference to the child by name on the parent instance.\n// If two of the same component are used, different names should be supplied\n// for each\nvar newChild=_this.addChild(name,opts);if(newChild){_this[name]=newChild;}};// Allow for an array of children details to passed in the options\nvar workingChildren=void 0;var Tech=Component.getComponent('Tech');if(Array.isArray(children)){workingChildren=children;}else{workingChildren=Object.keys(children);}workingChildren// children that are in this.options_ but also in workingChildren  would\n// give us extra children we do not want. So, we want to filter them out.\n.concat(Object.keys(this.options_).filter(function(child){return!workingChildren.some(function(wchild){if(typeof wchild==='string'){return child===wchild;}return child===wchild.name;});})).map(function(child){var name=void 0;var opts=void 0;if(typeof child==='string'){name=child;opts=children[name]||_this.options_[name]||{};}else{name=child.name;opts=child;}return{name:name,opts:opts};}).filter(function(child){// we have to make sure that child.name isn't in the techOrder since\n// techs are registerd as Components but can't aren't compatible\n// See https://github.com/videojs/video.js/issues/2772\nvar c=Component.getComponent(child.opts.componentClass||toTitleCase(child.name));return c&&!Tech.isTech(c);}).forEach(handleAdd);}};/**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */Component.prototype.buildCSSClass=function buildCSSClass(){// Child classes can include a function that does:\n// return 'CLASS NAME' + this._super();\nreturn'';};/**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */Component.prototype.ready=function ready(fn){var sync=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!fn){return;}if(!this.isReady_){this.readyQueue_=this.readyQueue_||[];this.readyQueue_.push(fn);return;}if(sync){fn.call(this);}else{// Call the function asynchronously by default for consistency\nthis.setTimeout(fn,1);}};/**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */Component.prototype.triggerReady=function triggerReady(){this.isReady_=true;// Ensure ready is triggerd asynchronously\nthis.setTimeout(function(){var readyQueue=this.readyQueue_;// Reset Ready Queue\nthis.readyQueue_=[];if(readyQueue&&readyQueue.length>0){readyQueue.forEach(function(fn){fn.call(this);},this);}// Allow for using event listeners also\n/**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */this.trigger('ready');},1);};/**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */Component.prototype.$=function $$$1(selector,context){return $(selector,context||this.contentEl());};/**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */Component.prototype.$$=function $$$$1(selector,context){return $$(selector,context||this.contentEl());};/**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */Component.prototype.hasClass=function hasClass$$1(classToCheck){return hasClass(this.el_,classToCheck);};/**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */Component.prototype.addClass=function addClass$$1(classToAdd){addClass(this.el_,classToAdd);};/**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */Component.prototype.removeClass=function removeClass$$1(classToRemove){removeClass(this.el_,classToRemove);};/**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */Component.prototype.toggleClass=function toggleClass$$1(classToToggle,predicate){toggleClass(this.el_,classToToggle,predicate);};/**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */Component.prototype.show=function show(){this.removeClass('vjs-hidden');};/**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */Component.prototype.hide=function hide(){this.addClass('vjs-hidden');};/**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */Component.prototype.lockShowing=function lockShowing(){this.addClass('vjs-lock-showing');};/**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */Component.prototype.unlockShowing=function unlockShowing(){this.removeClass('vjs-lock-showing');};/**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */Component.prototype.getAttribute=function getAttribute$$1(attribute){return getAttribute(this.el_,attribute);};/**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */Component.prototype.setAttribute=function setAttribute$$1(attribute,value){setAttribute(this.el_,attribute,value);};/**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */Component.prototype.removeAttribute=function removeAttribute$$1(attribute){removeAttribute(this.el_,attribute);};/**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */Component.prototype.width=function width(num,skipListeners){return this.dimension('width',num,skipListeners);};/**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */Component.prototype.height=function height(num,skipListeners){return this.dimension('height',num,skipListeners);};/**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */Component.prototype.dimensions=function dimensions(width,height){// Skip componentresize listeners on width for optimization\nthis.width(width,true);this.height(height);};/**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */Component.prototype.dimension=function dimension(widthOrHeight,num,skipListeners){if(num!==undefined){// Set to zero if null or literally NaN (NaN !== NaN)\nif(num===null||num!==num){num=0;}// Check if using css width/height (% or px) and adjust\nif((''+num).indexOf('%')!==-1||(''+num).indexOf('px')!==-1){this.el_.style[widthOrHeight]=num;}else if(num==='auto'){this.el_.style[widthOrHeight]='';}else{this.el_.style[widthOrHeight]=num+'px';}// skipListeners allows us to avoid triggering the resize event when setting both width and height\nif(!skipListeners){/**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */this.trigger('componentresize');}return;}// Not setting a value, so getting it\n// Make sure element exists\nif(!this.el_){return 0;}// Get dimension value from style\nvar val=this.el_.style[widthOrHeight];var pxIndex=val.indexOf('px');if(pxIndex!==-1){// Return the pixel value with no 'px'\nreturn parseInt(val.slice(0,pxIndex),10);}// No px so using % or no style was set, so falling back to offsetWidth/height\n// If component has display:none, offset will return 0\n// TODO: handle display:none and no dimension style using px\nreturn parseInt(this.el_['offset'+toTitleCase(widthOrHeight)],10);};/**\n   * Get the width or the height of the `Component` elements computed style. Uses\n   * `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */Component.prototype.currentDimension=function currentDimension(widthOrHeight){var computedWidthOrHeight=0;if(widthOrHeight!=='width'&&widthOrHeight!=='height'){throw new Error('currentDimension only accepts width or height value');}if(typeof window.getComputedStyle==='function'){var computedStyle=window.getComputedStyle(this.el_);computedWidthOrHeight=computedStyle.getPropertyValue(widthOrHeight)||computedStyle[widthOrHeight];}// remove 'px' from variable and parse as integer\ncomputedWidthOrHeight=parseFloat(computedWidthOrHeight);// if the computed value is still 0, it's possible that the browser is lying\n// and we want to check the offset values.\n// This code also runs on IE8 and wherever getComputedStyle doesn't exist.\nif(computedWidthOrHeight===0){var rule='offset'+toTitleCase(widthOrHeight);computedWidthOrHeight=this.el_[rule];}return computedWidthOrHeight;};/**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   *//**\n   * Get an object that contains width and height values of the `Component`s\n   * computed style.\n   *\n   * @return {Component~DimensionObject}\n   *         The dimensions of the components element\n   */Component.prototype.currentDimensions=function currentDimensions(){return{width:this.currentDimension('width'),height:this.currentDimension('height')};};/**\n   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} width\n   *           The width of the `Component`s computed style.\n   */Component.prototype.currentWidth=function currentWidth(){return this.currentDimension('width');};/**\n   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} height\n   *           The height of the `Component`s computed style.\n   */Component.prototype.currentHeight=function currentHeight(){return this.currentDimension('height');};/**\n   * Set the focus to this component\n   */Component.prototype.focus=function focus(){this.el_.focus();};/**\n   * Remove the focus from this component\n   */Component.prototype.blur=function blur(){this.el_.blur();};/**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */Component.prototype.emitTapEvents=function emitTapEvents(){// Track the start time so we can determine how long the touch lasted\nvar touchStart=0;var firstTouch=null;// Maximum movement allowed during a touch event to still be considered a tap\n// Other popular libs use anywhere from 2 (hammer.js) to 15,\n// so 10 seems like a nice, round number.\nvar tapMovementThreshold=10;// The maximum length a touch can be while still being considered a tap\nvar touchTimeThreshold=200;var couldBeTap=void 0;this.on('touchstart',function(event){// If more than one finger, don't consider treating this as a click\nif(event.touches.length===1){// Copy pageX/pageY from the object\nfirstTouch={pageX:event.touches[0].pageX,pageY:event.touches[0].pageY};// Record start time so we can detect a tap vs. \"touch and hold\"\ntouchStart=new Date().getTime();// Reset couldBeTap tracking\ncouldBeTap=true;}});this.on('touchmove',function(event){// If more than one finger, don't consider treating this as a click\nif(event.touches.length>1){couldBeTap=false;}else if(firstTouch){// Some devices will throw touchmoves for all but the slightest of taps.\n// So, if we moved only a small distance, this could still be a tap\nvar xdiff=event.touches[0].pageX-firstTouch.pageX;var ydiff=event.touches[0].pageY-firstTouch.pageY;var touchDistance=Math.sqrt(xdiff*xdiff+ydiff*ydiff);if(touchDistance>tapMovementThreshold){couldBeTap=false;}}});var noTap=function noTap(){couldBeTap=false;};// TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\nthis.on('touchleave',noTap);this.on('touchcancel',noTap);// When the touch ends, measure how long it took and trigger the appropriate\n// event\nthis.on('touchend',function(event){firstTouch=null;// Proceed only if the touchmove/leave/cancel event didn't happen\nif(couldBeTap===true){// Measure how long the touch lasted\nvar touchTime=new Date().getTime()-touchStart;// Make sure the touch was less than the threshold to be considered a tap\nif(touchTime<touchTimeThreshold){// Don't let browser turn this into a click\nevent.preventDefault();/**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */this.trigger('tap');// It may be good to copy the touchend event object and change the\n// type to tap, if the other event properties aren't exact after\n// Events.fixEvent runs (e.g. event.target)\n}}});};/**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */Component.prototype.enableTouchActivity=function enableTouchActivity(){// Don't continue if the root player doesn't support reporting user activity\nif(!this.player()||!this.player().reportUserActivity){return;}// listener for reporting that the user is active\nvar report=bind(this.player(),this.player().reportUserActivity);var touchHolding=void 0;this.on('touchstart',function(){report();// For as long as the they are touching the device or have their mouse down,\n// we consider them active even if they're not moving their finger or mouse.\n// So we want to continue to update that they are active\nthis.clearInterval(touchHolding);// report at the same interval as activityCheck\ntouchHolding=this.setInterval(report,250);});var touchEnd=function touchEnd(event){report();// stop the interval that maintains activity if the touch is holding\nthis.clearInterval(touchHolding);};this.on('touchmove',report);this.on('touchend',touchEnd);this.on('touchcancel',touchEnd);};/**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   *//**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose}.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */Component.prototype.setTimeout=function setTimeout(fn,timeout){var _this2=this;fn=bind(this,fn);var timeoutId=window.setTimeout(fn,timeout);var disposeFn=function disposeFn(){return _this2.clearTimeout(timeoutId);};disposeFn.guid='vjs-timeout-'+timeoutId;this.on('dispose',disposeFn);return timeoutId;};/**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */Component.prototype.clearTimeout=function clearTimeout(timeoutId){window.clearTimeout(timeoutId);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-timeout-'+timeoutId;this.off('dispose',disposeFn);return timeoutId;};/**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */Component.prototype.setInterval=function setInterval(fn,interval){var _this3=this;fn=bind(this,fn);var intervalId=window.setInterval(fn,interval);var disposeFn=function disposeFn(){return _this3.clearInterval(intervalId);};disposeFn.guid='vjs-interval-'+intervalId;this.on('dispose',disposeFn);return intervalId;};/**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */Component.prototype.clearInterval=function clearInterval(intervalId){window.clearInterval(intervalId);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-interval-'+intervalId;this.off('dispose',disposeFn);return intervalId;};/**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */Component.prototype.requestAnimationFrame=function requestAnimationFrame(fn){var _this4=this;if(this.supportsRaf_){fn=bind(this,fn);var id=window.requestAnimationFrame(fn);var disposeFn=function disposeFn(){return _this4.cancelAnimationFrame(id);};disposeFn.guid='vjs-raf-'+id;this.on('dispose',disposeFn);return id;}// Fall back to using a timer.\nreturn this.setTimeout(fn,1000/60);};/**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */Component.prototype.cancelAnimationFrame=function cancelAnimationFrame(id){if(this.supportsRaf_){window.cancelAnimationFrame(id);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-raf-'+id;this.off('dispose',disposeFn);return id;}// Fall back to using a timer.\nreturn this.clearTimeout(id);};/**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */Component.registerComponent=function registerComponent(name,ComponentToRegister){if(typeof name!=='string'||!name){throw new Error('Illegal component name, \"'+name+'\"; must be a non-empty string.');}var Tech=Component.getComponent('Tech');// We need to make sure this check is only done if Tech has been registered.\nvar isTech=Tech&&Tech.isTech(ComponentToRegister);var isComp=Component===ComponentToRegister||Component.prototype.isPrototypeOf(ComponentToRegister.prototype);if(isTech||!isComp){var reason=void 0;if(isTech){reason='techs must be registered using Tech.registerTech()';}else{reason='must be a Component subclass';}throw new Error('Illegal component, \"'+name+'\"; '+reason+'.');}name=toTitleCase(name);if(!Component.components_){Component.components_={};}var Player=Component.getComponent('Player');if(name==='Player'&&Player&&Player.players){var players=Player.players;var playerNames=Object.keys(players);// If we have players that were disposed, then their name will still be\n// in Players.players. So, we must loop through and verify that the value\n// for each item is not null. This allows registration of the Player component\n// after all players have been disposed or before any were created.\nif(players&&playerNames.length>0&&playerNames.map(function(pname){return players[pname];}).every(Boolean)){throw new Error('Can not register Player component after player has been created.');}}Component.components_[name]=ComponentToRegister;return ComponentToRegister;};/**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */Component.getComponent=function getComponent(name){if(!name){return;}name=toTitleCase(name);if(Component.components_&&Component.components_[name]){return Component.components_[name];}};return Component;}();/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */Component.prototype.supportsRaf_=typeof window.requestAnimationFrame==='function'&&typeof window.cancelAnimationFrame==='function';Component.registerComponent('Component',Component);/**\n * @file time-ranges.js\n * @module time-ranges\n *//**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @function time-ranges:indexFunction\n *\n * @param {number} [index=0]\n *        The range number to return the time for.\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n * @depricated index must be set to a value, in the future this will throw an error.\n *//**\n * An object that contains ranges of time for various reasons.\n *\n * @typedef {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this Object\n *\n * @property {time-ranges:indexFunction} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {time-ranges:indexFunction} end\n *           Returns the time offset at which a specified time range begins.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n *//**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {number} index\n *        The index to check\n *\n * @param {number} maxIndex\n *        The maximum possible index\n *\n * @throws {Error} if the timeRanges provided are over the maxIndex\n */function rangeCheck(fnName,index,maxIndex){if(typeof index!=='number'||index<0||index>maxIndex){throw new Error('Failed to execute \\''+fnName+'\\' on \\'TimeRanges\\': The index provided ('+index+') is non-numeric or out of bounds (0-'+maxIndex+').');}}/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {string} valueIndex\n *        The proprety that should be used to get the time. should be 'start' or 'end'\n *\n * @param {Array} ranges\n *        An array of time ranges\n *\n * @param {Array} [rangeIndex=0]\n *        The index to start the search at\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n *\n * @depricated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws {Error} if rangeIndex is more than the length of ranges\n */function getRange(fnName,valueIndex,ranges,rangeIndex){rangeCheck(fnName,rangeIndex,ranges.length-1);return ranges[rangeIndex][valueIndex];}/**\n * Create a time range object givent ranges of time.\n *\n * @param {Array} [ranges]\n *        An array of time ranges.\n */function createTimeRangesObj(ranges){if(ranges===undefined||ranges.length===0){return{length:0,start:function start(){throw new Error('This TimeRanges object is empty');},end:function end(){throw new Error('This TimeRanges object is empty');}};}return{length:ranges.length,start:getRange.bind(null,'start',0,ranges),end:getRange.bind(null,'end',1,ranges)};}/**\n * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.\n *\n * @param {number|Array} start\n *        The start of a single range or an array of ranges\n *\n * @param {number} end\n *        The end of a single range.\n *\n * @private\n */function createTimeRanges(start,end){if(Array.isArray(start)){return createTimeRangesObj(start);}else if(start===undefined||end===undefined){return createTimeRangesObj();}return createTimeRangesObj([[start,end]]);}/**\n * @file buffer.js\n * @module buffer\n *//**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */function bufferedPercent(buffered,duration){var bufferedDuration=0;var start=void 0;var end=void 0;if(!duration){return 0;}if(!buffered||!buffered.length){buffered=createTimeRanges(0,0);}for(var i=0;i<buffered.length;i++){start=buffered.start(i);end=buffered.end(i);// buffered end can be bigger than duration by a very small fraction\nif(end>duration){end=duration;}bufferedDuration+=end-start;}return bufferedDuration/duration;}/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n *//**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */var FullscreenApi={};// browser API methods\nvar apiMap=[['requestFullscreen','exitFullscreen','fullscreenElement','fullscreenEnabled','fullscreenchange','fullscreenerror'],// WebKit\n['webkitRequestFullscreen','webkitExitFullscreen','webkitFullscreenElement','webkitFullscreenEnabled','webkitfullscreenchange','webkitfullscreenerror'],// Old WebKit (Safari 5.1)\n['webkitRequestFullScreen','webkitCancelFullScreen','webkitCurrentFullScreenElement','webkitCancelFullScreen','webkitfullscreenchange','webkitfullscreenerror'],// Mozilla\n['mozRequestFullScreen','mozCancelFullScreen','mozFullScreenElement','mozFullScreenEnabled','mozfullscreenchange','mozfullscreenerror'],// Microsoft\n['msRequestFullscreen','msExitFullscreen','msFullscreenElement','msFullscreenEnabled','MSFullscreenChange','MSFullscreenError']];var specApi=apiMap[0];var browserApi=void 0;// determine the supported set of functions\nfor(var i=0;i<apiMap.length;i++){// check for exitFullscreen function\nif(apiMap[i][1]in document){browserApi=apiMap[i];break;}}// map the browser API names to the spec API names\nif(browserApi){for(var _i=0;_i<browserApi.length;_i++){FullscreenApi[specApi[_i]]=browserApi[_i];}}/**\n * @file media-error.js\n *//**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */function MediaError(value){// Allow redundant calls to this constructor to avoid having `instanceof`\n// checks peppered around the code.\nif(value instanceof MediaError){return value;}if(typeof value==='number'){this.code=value;}else if(typeof value==='string'){// default code is zero, so this is a custom error\nthis.message=value;}else if(isObject(value)){// We assign the `code` property manually because native `MediaError` objects\n// do not expose it as an own/enumerable property of the object.\nif(typeof value.code==='number'){this.code=value.code;}assign(this,value);}if(!this.message){this.message=MediaError.defaultMessages[this.code]||'';}}/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */MediaError.prototype.code=0;/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */MediaError.prototype.message='';/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */MediaError.prototype.status=null;/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_CUSTOM\n * @property {string} 2 - MEDIA_ERR_ABORTED\n * @property {string} 3 - MEDIA_ERR_NETWORK\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */MediaError.errorTypes=['MEDIA_ERR_CUSTOM','MEDIA_ERR_ABORTED','MEDIA_ERR_NETWORK','MEDIA_ERR_DECODE','MEDIA_ERR_SRC_NOT_SUPPORTED','MEDIA_ERR_ENCRYPTED'];/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */MediaError.defaultMessages={1:'You aborted the media playback',2:'A network error caused the media download to fail part-way.',3:'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',4:'The media could not be loaded, either because the server or network failed or because the format is not supported.',5:'The media is encrypted and we do not have the keys to decrypt it.'};// Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\nfor(var errNum=0;errNum<MediaError.errorTypes.length;errNum++){MediaError[MediaError.errorTypes[errNum]]=errNum;// values should be accessible on both the class and instance\nMediaError.prototype[MediaError.errorTypes[errNum]]=errNum;}/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {Boolean}\n *         Whether or not the object is `Promise`-like.\n */function isPromise(value){return value!==undefined&&typeof value.then==='function';}/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */function silencePromise(value){if(isPromise(value)){value.then(null,function(e){});}}/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n *//**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */var trackToJson_=function trackToJson_(track){var ret=['kind','label','language','id','inBandMetadataTrackDispatchType','mode','src'].reduce(function(acc,prop,i){if(track[prop]){acc[prop]=track[prop];}return acc;},{cues:track.cues&&Array.prototype.map.call(track.cues,function(cue){return{startTime:cue.startTime,endTime:cue.endTime,text:cue.text,id:cue.id};})});return ret;};/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */var textTracksToJson=function textTracksToJson(tech){var trackEls=tech.$$('track');var trackObjs=Array.prototype.map.call(trackEls,function(t){return t.track;});var tracks=Array.prototype.map.call(trackEls,function(trackEl){var json=trackToJson_(trackEl.track);if(trackEl.src){json.src=trackEl.src;}return json;});return tracks.concat(Array.prototype.filter.call(tech.textTracks(),function(track){return trackObjs.indexOf(track)===-1;}).map(trackToJson_));};/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */var jsonToTextTracks=function jsonToTextTracks(json,tech){json.forEach(function(track){var addedTrack=tech.addRemoteTextTrack(track).track;if(!track.src&&track.cues){track.cues.forEach(function(cue){return addedTrack.addCue(cue);});}});return tech.textTracks();};var textTrackConverter={textTracksToJson:textTracksToJson,jsonToTextTracks:jsonToTextTracks,trackToJson_:trackToJson_};/**\n * @file modal-dialog.js\n */var MODAL_CLASS_NAME='vjs-modal-dialog';var ESC=27;/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */var ModalDialog=function(_Component){inherits(ModalDialog,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */function ModalDialog(player,options){classCallCheck(this,ModalDialog);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.opened_=_this.hasBeenOpened_=_this.hasBeenFilled_=false;_this.closeable(!_this.options_.uncloseable);_this.content(_this.options_.content);// Make sure the contentEl is defined AFTER any children are initialized\n// because we only want the contents of the modal in the contentEl\n// (not the UI elements like the close button).\n_this.contentEl_=createEl('div',{className:MODAL_CLASS_NAME+'-content'},{role:'document'});_this.descEl_=createEl('p',{className:MODAL_CLASS_NAME+'-description vjs-control-text',id:_this.el().getAttribute('aria-describedby')});textContent(_this.descEl_,_this.description());_this.el_.appendChild(_this.descEl_);_this.el_.appendChild(_this.contentEl_);return _this;}/**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */ModalDialog.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:this.buildCSSClass(),tabIndex:-1},{'aria-describedby':this.id()+'_description','aria-hidden':'true','aria-label':this.label(),'role':'dialog'});};ModalDialog.prototype.dispose=function dispose(){this.contentEl_=null;this.descEl_=null;this.previouslyActiveEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ModalDialog.prototype.buildCSSClass=function buildCSSClass(){return MODAL_CLASS_NAME+' vjs-hidden '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Handles `keydown` events on the document, looking for ESC, which closes\n   * the modal.\n   *\n   * @param {EventTarget~Event} e\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown\n   */ModalDialog.prototype.handleKeyPress=function handleKeyPress(e){if(e.which===ESC&&this.closeable()){this.close();}};/**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */ModalDialog.prototype.label=function label(){return this.localize(this.options_.label||'Modal Window');};/**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */ModalDialog.prototype.description=function description(){var desc=this.options_.description||this.localize('This is a modal window.');// Append a universal closeability message if the modal is closeable.\nif(this.closeable()){desc+=' '+this.localize('This modal can be closed by pressing the Escape key or activating the close button.');}return desc;};/**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */ModalDialog.prototype.open=function open(){if(!this.opened_){var player=this.player();/**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */this.trigger('beforemodalopen');this.opened_=true;// Fill content if the modal has never opened before and\n// never been filled.\nif(this.options_.fillAlways||!this.hasBeenOpened_&&!this.hasBeenFilled_){this.fill();}// If the player was playing, pause it and take note of its previously\n// playing state.\nthis.wasPlaying_=!player.paused();if(this.options_.pauseOnOpen&&this.wasPlaying_){player.pause();}if(this.closeable()){this.on(this.el_.ownerDocument,'keydown',bind(this,this.handleKeyPress));}// Hide controls and note if they were enabled.\nthis.hadControls_=player.controls();player.controls(false);this.show();this.conditionalFocus_();this.el().setAttribute('aria-hidden','false');/**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */this.trigger('modalopen');this.hasBeenOpened_=true;}};/**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */ModalDialog.prototype.opened=function opened(value){if(typeof value==='boolean'){this[value?'open':'close']();}return this.opened_;};/**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */ModalDialog.prototype.close=function close(){if(!this.opened_){return;}var player=this.player();/**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */this.trigger('beforemodalclose');this.opened_=false;if(this.wasPlaying_&&this.options_.pauseOnOpen){player.play();}if(this.closeable()){this.off(this.el_.ownerDocument,'keydown',bind(this,this.handleKeyPress));}if(this.hadControls_){player.controls(true);}this.hide();this.el().setAttribute('aria-hidden','true');/**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */this.trigger('modalclose');this.conditionalBlur_();if(this.options_.temporary){this.dispose();}};/**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */ModalDialog.prototype.closeable=function closeable(value){if(typeof value==='boolean'){var closeable=this.closeable_=!!value;var close=this.getChild('closeButton');// If this is being made closeable and has no close button, add one.\nif(closeable&&!close){// The close button should be a child of the modal - not its\n// content element, so temporarily change the content element.\nvar temp=this.contentEl_;this.contentEl_=this.el_;close=this.addChild('closeButton',{controlText:'Close Modal Dialog'});this.contentEl_=temp;this.on(close,'close',this.close);}// If this is being made uncloseable and has a close button, remove it.\nif(!closeable&&close){this.off(close,'close',this.close);this.removeChild(close);close.dispose();}}return this.closeable_;};/**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */ModalDialog.prototype.fill=function fill(){this.fillWith(this.content());};/**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */ModalDialog.prototype.fillWith=function fillWith(content){var contentEl=this.contentEl();var parentEl=contentEl.parentNode;var nextSiblingEl=contentEl.nextSibling;/**\n     * Fired just before a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#beforemodalfill\n     * @type {EventTarget~Event}\n     */this.trigger('beforemodalfill');this.hasBeenFilled_=true;// Detach the content element from the DOM before performing\n// manipulation to avoid modifying the live DOM multiple times.\nparentEl.removeChild(contentEl);this.empty();insertContent(contentEl,content);/**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */this.trigger('modalfill');// Re-inject the re-filled content element.\nif(nextSiblingEl){parentEl.insertBefore(contentEl,nextSiblingEl);}else{parentEl.appendChild(contentEl);}// make sure that the close button is last in the dialog DOM\nvar closeButton=this.getChild('closeButton');if(closeButton){parentEl.appendChild(closeButton.el_);}};/**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */ModalDialog.prototype.empty=function empty(){/**\n     * Fired just before a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#beforemodalempty\n     * @type {EventTarget~Event}\n     */this.trigger('beforemodalempty');emptyEl(this.contentEl());/**\n     * Fired just after a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#modalempty\n     * @type {EventTarget~Event}\n     */this.trigger('modalempty');};/**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */ModalDialog.prototype.content=function content(value){if(typeof value!=='undefined'){this.content_=value;}return this.content_;};/**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */ModalDialog.prototype.conditionalFocus_=function conditionalFocus_(){var activeEl=document.activeElement;var playerEl=this.player_.el_;this.previouslyActiveEl_=null;if(playerEl.contains(activeEl)||playerEl===activeEl){this.previouslyActiveEl_=activeEl;this.focus();this.on(document,'keydown',this.handleKeyDown);}};/**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */ModalDialog.prototype.conditionalBlur_=function conditionalBlur_(){if(this.previouslyActiveEl_){this.previouslyActiveEl_.focus();this.previouslyActiveEl_=null;}this.off(document,'keydown',this.handleKeyDown);};/**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */ModalDialog.prototype.handleKeyDown=function handleKeyDown(event){// exit early if it isn't a tab key\nif(event.which!==9){return;}var focusableEls=this.focusableEls_();var activeEl=this.el_.querySelector(':focus');var focusIndex=void 0;for(var i=0;i<focusableEls.length;i++){if(activeEl===focusableEls[i]){focusIndex=i;break;}}if(document.activeElement===this.el_){focusIndex=0;}if(event.shiftKey&&focusIndex===0){focusableEls[focusableEls.length-1].focus();event.preventDefault();}else if(!event.shiftKey&&focusIndex===focusableEls.length-1){focusableEls[0].focus();event.preventDefault();}};/**\n   * get all focusable elements\n   *\n   * @private\n   */ModalDialog.prototype.focusableEls_=function focusableEls_(){var allChildren=this.el_.querySelectorAll('*');return Array.prototype.filter.call(allChildren,function(child){return(child instanceof window.HTMLAnchorElement||child instanceof window.HTMLAreaElement)&&child.hasAttribute('href')||(child instanceof window.HTMLInputElement||child instanceof window.HTMLSelectElement||child instanceof window.HTMLTextAreaElement||child instanceof window.HTMLButtonElement)&&!child.hasAttribute('disabled')||child instanceof window.HTMLIFrameElement||child instanceof window.HTMLObjectElement||child instanceof window.HTMLEmbedElement||child.hasAttribute('tabindex')&&child.getAttribute('tabindex')!==-1||child.hasAttribute('contenteditable');});};return ModalDialog;}(Component);/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */ModalDialog.prototype.options_={pauseOnOpen:true,temporary:true};Component.registerComponent('ModalDialog',ModalDialog);/**\n * @file track-list.js\n *//**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */var TrackList=function(_EventTarget){inherits(TrackList,_EventTarget);/**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @param {Object} [list]\n   *        The child object with inheritance done manually for ie8.\n   *\n   * @abstract\n   */function TrackList(){var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var _ret;var list=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;classCallCheck(this,TrackList);var _this=possibleConstructorReturn(this,_EventTarget.call(this));if(!list){list=_this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}}}list.tracks_=[];/**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.tracks_.length;}});for(var i=0;i<tracks.length;i++){list.addTrack(tracks[i]);}// must return the object, as for ie8 it will not be this\n// but a reference to a document object\nreturn _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */TrackList.prototype.addTrack=function addTrack(track){var index=this.tracks_.length;if(!(''+index in this)){Object.defineProperty(this,index,{get:function get$$1(){return this.tracks_[index];}});}// Do not add duplicate tracks\nif(this.tracks_.indexOf(track)===-1){this.tracks_.push(track);/**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */this.trigger({track:track,type:'addtrack'});}};/**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */TrackList.prototype.removeTrack=function removeTrack(rtrack){var track=void 0;for(var i=0,l=this.length;i<l;i++){if(this[i]===rtrack){track=this[i];if(track.off){track.off();}this.tracks_.splice(i,1);break;}}if(!track){return;}/**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */this.trigger({track:track,type:'removetrack'});};/**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {String} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */TrackList.prototype.getTrackById=function getTrackById(id){var result=null;for(var i=0,l=this.length;i<l;i++){var track=this[i];if(track.id===id){result=track;break;}}return result;};return TrackList;}(EventTarget);/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n *//**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */TrackList.prototype.allowedEvents_={change:'change',addtrack:'addtrack',removetrack:'removetrack'};// emulate attribute EventHandler support to allow for feature detection\nfor(var event in TrackList.prototype.allowedEvents_){TrackList.prototype['on'+event]=null;}/**\n * @file audio-track-list.js\n *//**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */var disableOthers=function disableOthers(list,track){for(var i=0;i<list.length;i++){if(!Object.keys(list[i]).length||track.id===list[i].id){continue;}// another audio track is enabled, disable it\nlist[i].enabled=false;}};/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */var AudioTrackList=function(_TrackList){inherits(AudioTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */function AudioTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,AudioTrackList);var list=void 0;// make sure only 1 track is enabled\n// sorted from last index to first index\nfor(var i=tracks.length-1;i>=0;i--){if(tracks[i].enabled){disableOthers(tracks,tracks[i]);break;}}// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in AudioTrackList.prototype){if(_prop!=='constructor'){list[_prop]=AudioTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);list.changing_=false;return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */AudioTrackList.prototype.addTrack=function addTrack(track){var _this2=this;if(track.enabled){disableOthers(this,track);}_TrackList.prototype.addTrack.call(this,track);// native tracks don't have this\nif(!track.addEventListener){return;}/**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */track.addEventListener('enabledchange',function(){// when we are disabling other tracks (since we don't support\n// more than one track at a time) we will set changing_\n// to true so that we don't trigger additional change events\nif(_this2.changing_){return;}_this2.changing_=true;disableOthers(_this2,track);_this2.changing_=false;_this2.trigger('change');});};return AudioTrackList;}(TrackList);/**\n * @file video-track-list.js\n *//**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */var disableOthers$1=function disableOthers(list,track){for(var i=0;i<list.length;i++){if(!Object.keys(list[i]).length||track.id===list[i].id){continue;}// another video track is enabled, disable it\nlist[i].selected=false;}};/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */var VideoTrackList=function(_TrackList){inherits(VideoTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */function VideoTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,VideoTrackList);var list=void 0;// make sure only 1 track is enabled\n// sorted from last index to first index\nfor(var i=tracks.length-1;i>=0;i--){if(tracks[i].selected){disableOthers$1(tracks,tracks[i]);break;}}// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in VideoTrackList.prototype){if(_prop!=='constructor'){list[_prop]=VideoTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);list.changing_=false;/**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */Object.defineProperty(list,'selectedIndex',{get:function get$$1(){for(var _i=0;_i<this.length;_i++){if(this[_i].selected){return _i;}}return-1;},set:function set$$1(){}});return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */VideoTrackList.prototype.addTrack=function addTrack(track){var _this2=this;if(track.selected){disableOthers$1(this,track);}_TrackList.prototype.addTrack.call(this,track);// native tracks don't have this\nif(!track.addEventListener){return;}/**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */track.addEventListener('selectedchange',function(){if(_this2.changing_){return;}_this2.changing_=true;disableOthers$1(_this2,track);_this2.changing_=false;_this2.trigger('change');});};return VideoTrackList;}(TrackList);/**\n * @file text-track-list.js\n *//**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */var TextTrackList=function(_TrackList){inherits(TextTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {TextTrack[]} [tracks=[]]\n   *        A list of `TextTrack` to instantiate the list with.\n   */function TextTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,TextTrackList);var list=void 0;// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in TextTrackList.prototype){if(_prop!=='constructor'){list[_prop]=TextTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */TextTrackList.prototype.addTrack=function addTrack(track){_TrackList.prototype.addTrack.call(this,track);/**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */track.addEventListener('modechange',bind(this,function(){this.trigger('change');}));var nonLanguageTextTrackKind=['metadata','chapters'];if(nonLanguageTextTrackKind.indexOf(track.kind)===-1){track.addEventListener('modechange',bind(this,function(){this.trigger('selectedlanguagechange');}));}};return TextTrackList;}(TrackList);/**\n * @file html-track-element-list.js\n *//**\n * The current list of {@link HtmlTrackElement}s.\n */var HtmlTrackElementList=function(){/**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */function HtmlTrackElementList(){var trackElements=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,HtmlTrackElementList);var list=this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in HtmlTrackElementList.prototype){if(prop!=='constructor'){list[prop]=HtmlTrackElementList.prototype[prop];}}}list.trackElements_=[];/**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.trackElements_.length;}});for(var i=0,length=trackElements.length;i<length;i++){list.addTrackElement_(trackElements[i]);}if(IS_IE8){return list;}}/**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.addTrackElement_=function addTrackElement_(trackElement){var index=this.trackElements_.length;if(!(''+index in this)){Object.defineProperty(this,index,{get:function get$$1(){return this.trackElements_[index];}});}// Do not add duplicate elements\nif(this.trackElements_.indexOf(trackElement)===-1){this.trackElements_.push(trackElement);}};/**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.getTrackElementByTrack_=function getTrackElementByTrack_(track){var trackElement_=void 0;for(var i=0,length=this.trackElements_.length;i<length;i++){if(track===this.trackElements_[i].track){trackElement_=this.trackElements_[i];break;}}return trackElement_;};/**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.removeTrackElement_=function removeTrackElement_(trackElement){for(var i=0,length=this.trackElements_.length;i<length;i++){if(trackElement===this.trackElements_[i]){this.trackElements_.splice(i,1);break;}}};return HtmlTrackElementList;}();/**\n * @file text-track-cue-list.js\n *//**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n *//**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */var TextTrackCueList=function(){/**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */function TextTrackCueList(cues){classCallCheck(this,TextTrackCueList);var list=this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in TextTrackCueList.prototype){if(prop!=='constructor'){list[prop]=TextTrackCueList.prototype[prop];}}}TextTrackCueList.prototype.setCues_.call(list,cues);/**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.length_;}});if(IS_IE8){return list;}}/**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */TextTrackCueList.prototype.setCues_=function setCues_(cues){var oldLength=this.length||0;var i=0;var l=cues.length;this.cues_=cues;this.length_=cues.length;var defineProp=function defineProp(index){if(!(''+index in this)){Object.defineProperty(this,''+index,{get:function get$$1(){return this.cues_[index];}});}};if(oldLength<l){i=oldLength;for(;i<l;i++){defineProp.call(this,i);}}};/**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */TextTrackCueList.prototype.getCueById=function getCueById(id){var result=null;for(var i=0,l=this.length;i<l;i++){var cue=this[i];if(cue.id===id){result=cue;break;}}return result;};return TextTrackCueList;}();/**\n * @file track-kinds.js\n *//**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */var VideoTrackKind={alternative:'alternative',captions:'captions',main:'main',sign:'sign',subtitles:'subtitles',commentary:'commentary'};/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */var AudioTrackKind={'alternative':'alternative','descriptions':'descriptions','main':'main','main-desc':'main-desc','translation':'translation','commentary':'commentary'};/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */var TextTrackKind={subtitles:'subtitles',captions:'captions',descriptions:'descriptions',chapters:'chapters',metadata:'metadata'};/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */var TextTrackMode={disabled:'disabled',hidden:'hidden',showing:'showing'};/**\n * @file track.js\n *//**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */var Track=function(_EventTarget){inherits(Track,_EventTarget);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */function Track(){var _ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Track);var _this=possibleConstructorReturn(this,_EventTarget.call(this));var track=_this;// eslint-disable-line\nif(IS_IE8){track=document.createElement('custom');for(var prop in Track.prototype){if(prop!=='constructor'){track[prop]=Track.prototype[prop];}}}var trackProps={id:options.id||'vjs_track_'+newGUID(),kind:options.kind||'',label:options.label||'',language:options.language||''};/**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */var _loop=function _loop(key){Object.defineProperty(track,key,{get:function get$$1(){return trackProps[key];},set:function set$$1(){}});};for(var key in trackProps){_loop(key);}return _ret=track,possibleConstructorReturn(_this,_ret);}return Track;}(EventTarget);/**\n * @file url.js\n * @module url\n *//**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n *//**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */var parseUrl=function parseUrl(url){var props=['protocol','hostname','port','pathname','search','hash','host'];// add the url to an anchor and let the browser parse the URL\nvar a=document.createElement('a');a.href=url;// IE8 (and 9?) Fix\n// ie8 doesn't parse the URL correctly until the anchor is actually\n// added to the body, and an innerHTML is needed to trigger the parsing\nvar addToBody=a.host===''&&a.protocol!=='file:';var div=void 0;if(addToBody){div=document.createElement('div');div.innerHTML='<a href=\"'+url+'\"></a>';a=div.firstChild;// prevent the div from affecting layout\ndiv.setAttribute('style','display:none; position:absolute;');document.body.appendChild(div);}// Copy the specific URL properties to a new object\n// This is also needed for IE8 because the anchor loses its\n// properties when it's removed from the dom\nvar details={};for(var i=0;i<props.length;i++){details[props[i]]=a[props[i]];}// IE9 adds the port to the host property unlike everyone else. If\n// a port identifier is added for standard ports, strip it.\nif(details.protocol==='http:'){details.host=details.host.replace(/:80$/,'');}if(details.protocol==='https:'){details.host=details.host.replace(/:443$/,'');}if(!details.protocol){details.protocol=window.location.protocol;}if(addToBody){document.body.removeChild(div);}return details;};/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */var getAbsoluteURL=function getAbsoluteURL(url){// Check if absolute URL\nif(!url.match(/^https?:\\/\\//)){// Convert to absolute URL. Flash hosted off-site needs an absolute URL.\nvar div=document.createElement('div');div.innerHTML='<a href=\"'+url+'\">x</a>';url=div.firstChild.href;}return url;};/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */var getFileExtension=function getFileExtension(path){if(typeof path==='string'){var splitPathRe=/^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;var pathParts=splitPathRe.exec(path);if(pathParts){return pathParts.pop().toLowerCase();}}return'';};/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */var isCrossOrigin=function isCrossOrigin(url){var winLoc=window.location;var urlInfo=parseUrl(url);// IE8 protocol relative urls will return ':' for protocol\nvar srcProtocol=urlInfo.protocol===':'?winLoc.protocol:urlInfo.protocol;// Check if url is for another domain/origin\n// IE8 doesn't know location.origin, so we won't rely on it here\nvar crossOrigin=srcProtocol+urlInfo.host!==winLoc.protocol+winLoc.host;return crossOrigin;};var Url=(Object.freeze||Object)({parseUrl:parseUrl,getAbsoluteURL:getAbsoluteURL,getFileExtension:getFileExtension,isCrossOrigin:isCrossOrigin});/**\n * @file text-track.js\n *//**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */var parseCues=function parseCues(srcContent,track){var parser=new window.WebVTT.Parser(window,window.vttjs,window.WebVTT.StringDecoder());var errors=[];parser.oncue=function(cue){track.addCue(cue);};parser.onparsingerror=function(error){errors.push(error);};parser.onflush=function(){track.trigger({type:'loadeddata',target:track});};parser.parse(srcContent);if(errors.length>0){if(window.console&&window.console.groupCollapsed){window.console.groupCollapsed('Text Track parsing errors for '+track.src);}errors.forEach(function(error){return log$1.error(error);});if(window.console&&window.console.groupEnd){window.console.groupEnd();}}parser.flush();};/**\n * Load a `TextTrack` from a specifed url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */var loadTrack=function loadTrack(src,track){var opts={uri:src};var crossOrigin=isCrossOrigin(src);if(crossOrigin){opts.cors=crossOrigin;}xhr(opts,bind(this,function(err,response,responseBody){if(err){return log$1.error(err,response);}track.loaded_=true;// Make sure that vttjs has loaded, otherwise, wait till it finished loading\n// NOTE: this is only used for the alt/video.novtt.js build\nif(typeof window.WebVTT!=='function'){if(track.tech_){var loadHandler=function loadHandler(){return parseCues(responseBody,track);};track.tech_.on('vttjsloaded',loadHandler);track.tech_.on('vttjserror',function(){log$1.error('vttjs failed to load, stopping trying to process '+track.src);track.tech_.off('vttjsloaded',loadHandler);});}}else{parseCues(responseBody,track);}}));};/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */var TextTrack=function(_Track){inherits(TextTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */function TextTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,TextTrack);if(!options.tech){throw new Error('A tech was not provided.');}var settings=mergeOptions(options,{kind:TextTrackKind[options.kind]||'subtitles',language:options.language||options.srclang||''});var mode=TextTrackMode[settings.mode]||'disabled';var default_=settings['default'];if(settings.kind==='metadata'||settings.kind==='chapters'){mode='hidden';}// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar tt=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);tt.tech_=settings.tech;if(IS_IE8){for(var prop in TextTrack.prototype){if(prop!=='constructor'){tt[prop]=TextTrack.prototype[prop];}}}tt.cues_=[];tt.activeCues_=[];var cues=new TextTrackCueList(tt.cues_);var activeCues=new TextTrackCueList(tt.activeCues_);var changed=false;var timeupdateHandler=bind(tt,function(){// Accessing this.activeCues for the side-effects of updating itself\n// due to it's nature as a getter function. Do not remove or cues will\n// stop updating!\n/* eslint-disable no-unused-expressions */this.activeCues;/* eslint-enable no-unused-expressions */if(changed){this.trigger('cuechange');changed=false;}});if(mode!=='disabled'){tt.tech_.ready(function(){tt.tech_.on('timeupdate',timeupdateHandler);},true);}/**\n     * @memberof TextTrack\n     * @member {boolean} default\n     *         If this track was set to be on or off by default. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */Object.defineProperty(tt,'default',{get:function get$$1(){return default_;},set:function set$$1(){}});/**\n     * @memberof TextTrack\n     * @member {string} mode\n     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n     *         not be set if setting to an invalid mode.\n     * @instance\n     *\n     * @fires TextTrack#modechange\n     */Object.defineProperty(tt,'mode',{get:function get$$1(){return mode;},set:function set$$1(newMode){var _this2=this;if(!TextTrackMode[newMode]){return;}mode=newMode;if(mode==='showing'){this.tech_.ready(function(){_this2.tech_.on('timeupdate',timeupdateHandler);},true);}/**\n         * An event that fires when mode changes on this track. This allows\n         * the TextTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec!\n         *\n         * @event TextTrack#modechange\n         * @type {EventTarget~Event}\n         */this.trigger('modechange');}});/**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} cues\n     *         The text track cue list for this TextTrack.\n     * @instance\n     */Object.defineProperty(tt,'cues',{get:function get$$1(){if(!this.loaded_){return null;}return cues;},set:function set$$1(){}});/**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} activeCues\n     *         The list text track cues that are currently active for this TextTrack.\n     * @instance\n     */Object.defineProperty(tt,'activeCues',{get:function get$$1(){if(!this.loaded_){return null;}// nothing to do\nif(this.cues.length===0){return activeCues;}var ct=this.tech_.currentTime();var active=[];for(var i=0,l=this.cues.length;i<l;i++){var cue=this.cues[i];if(cue.startTime<=ct&&cue.endTime>=ct){active.push(cue);}else if(cue.startTime===cue.endTime&&cue.startTime<=ct&&cue.startTime+0.5>=ct){active.push(cue);}}changed=false;if(active.length!==this.activeCues_.length){changed=true;}else{for(var _i=0;_i<active.length;_i++){if(this.activeCues_.indexOf(active[_i])===-1){changed=true;}}}this.activeCues_=active;activeCues.setCues_(this.activeCues_);return activeCues;},set:function set$$1(){}});if(settings.src){tt.src=settings.src;loadTrack(settings.src,tt);}else{tt.loaded_=true;}return _ret=tt,possibleConstructorReturn(_this,_ret);}/**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */TextTrack.prototype.addCue=function addCue(originalCue){var cue=originalCue;if(window.vttjs&&!(originalCue instanceof window.vttjs.VTTCue)){cue=new window.vttjs.VTTCue(originalCue.startTime,originalCue.endTime,originalCue.text);for(var prop in originalCue){if(!(prop in cue)){cue[prop]=originalCue[prop];}}// make sure that `id` is copied over\ncue.id=originalCue.id;cue.originalCue_=originalCue;}var tracks=this.tech_.textTracks();for(var i=0;i<tracks.length;i++){if(tracks[i]!==this){tracks[i].removeCue(cue);}}this.cues_.push(cue);this.cues.setCues_(this.cues_);};/**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */TextTrack.prototype.removeCue=function removeCue(_removeCue){var i=this.cues_.length;while(i--){var cue=this.cues_[i];if(cue===_removeCue||cue.originalCue_&&cue.originalCue_===_removeCue){this.cues_.splice(i,1);this.cues.setCues_(this.cues_);break;}}};return TextTrack;}(Track);/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */TextTrack.prototype.allowedEvents_={cuechange:'cuechange'};/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */var AudioTrack=function(_Track){inherits(AudioTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */function AudioTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,AudioTrack);var settings=mergeOptions(options,{kind:AudioTrackKind[options.kind]||''});// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar track=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);var enabled=false;if(IS_IE8){for(var prop in AudioTrack.prototype){if(prop!=='constructor'){track[prop]=AudioTrack.prototype[prop];}}}/**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */Object.defineProperty(track,'enabled',{get:function get$$1(){return enabled;},set:function set$$1(newEnabled){// an invalid or unchanged value\nif(typeof newEnabled!=='boolean'||newEnabled===enabled){return;}enabled=newEnabled;/**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */this.trigger('enabledchange');}});// if the user sets this track to selected then\n// set selected to that true value otherwise\n// we keep it false\nif(settings.enabled){track.enabled=settings.enabled;}track.loaded_=true;return _ret=track,possibleConstructorReturn(_this,_ret);}return AudioTrack;}(Track);/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */var VideoTrack=function(_Track){inherits(VideoTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */function VideoTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,VideoTrack);var settings=mergeOptions(options,{kind:VideoTrackKind[options.kind]||''});// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar track=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);var selected=false;if(IS_IE8){for(var prop in VideoTrack.prototype){if(prop!=='constructor'){track[prop]=VideoTrack.prototype[prop];}}}/**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */Object.defineProperty(track,'selected',{get:function get$$1(){return selected;},set:function set$$1(newSelected){// an invalid or unchanged value\nif(typeof newSelected!=='boolean'||newSelected===selected){return;}selected=newSelected;/**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */this.trigger('selectedchange');}});// if the user sets this track to selected then\n// set selected to that true value otherwise\n// we keep it false\nif(settings.selected){track.selected=settings.selected;}return _ret=track,possibleConstructorReturn(_this,_ret);}return VideoTrack;}(Track);/**\n * @file html-track-element.js\n *//**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */var NONE=0;var LOADING=1;var LOADED=2;var ERROR=3;/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */var HTMLTrackElement=function(_EventTarget){inherits(HTMLTrackElement,_EventTarget);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */function HTMLTrackElement(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,HTMLTrackElement);var _this=possibleConstructorReturn(this,_EventTarget.call(this));var readyState=void 0;var trackElement=_this;// eslint-disable-line\nif(IS_IE8){trackElement=document.createElement('custom');for(var prop in HTMLTrackElement.prototype){if(prop!=='constructor'){trackElement[prop]=HTMLTrackElement.prototype[prop];}}}var track=new TextTrack(options);trackElement.kind=track.kind;trackElement.src=track.src;trackElement.srclang=track.language;trackElement.label=track.label;trackElement['default']=track['default'];/**\n     * @memberof HTMLTrackElement\n     * @member {HTMLTrackElement~ReadyState} readyState\n     *         The current ready state of the track element.\n     * @instance\n     */Object.defineProperty(trackElement,'readyState',{get:function get$$1(){return readyState;}});/**\n     * @memberof HTMLTrackElement\n     * @member {TextTrack} track\n     *         The underlying TextTrack object.\n     * @instance\n     *\n     */Object.defineProperty(trackElement,'track',{get:function get$$1(){return track;}});readyState=NONE;/**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */track.addEventListener('loadeddata',function(){readyState=LOADED;trackElement.trigger({type:'load',target:trackElement});});if(IS_IE8){var _ret;return _ret=trackElement,possibleConstructorReturn(_this,_ret);}return _this;}return HTMLTrackElement;}(EventTarget);HTMLTrackElement.prototype.allowedEvents_={load:'load'};HTMLTrackElement.NONE=NONE;HTMLTrackElement.LOADING=LOADING;HTMLTrackElement.LOADED=LOADED;HTMLTrackElement.ERROR=ERROR;/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */var NORMAL={audio:{ListClass:AudioTrackList,TrackClass:AudioTrack,capitalName:'Audio'},video:{ListClass:VideoTrackList,TrackClass:VideoTrack,capitalName:'Video'},text:{ListClass:TextTrackList,TrackClass:TextTrack,capitalName:'Text'}};Object.keys(NORMAL).forEach(function(type){NORMAL[type].getterName=type+'Tracks';NORMAL[type].privateName=type+'Tracks_';});var REMOTE={remoteText:{ListClass:TextTrackList,TrackClass:TextTrack,capitalName:'RemoteText',getterName:'remoteTextTracks',privateName:'remoteTextTracks_'},remoteTextEl:{ListClass:HtmlTrackElementList,TrackClass:HTMLTrackElement,capitalName:'RemoteTextTrackEls',getterName:'remoteTextTrackEls',privateName:'remoteTextTrackEls_'}};var ALL=mergeOptions(NORMAL,REMOTE);REMOTE.names=Object.keys(REMOTE);NORMAL.names=Object.keys(NORMAL);ALL.names=[].concat(REMOTE.names).concat(NORMAL.names);/**\n * @file tech.js\n *//**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n *//**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */function createTrackHelper(self,kind,label,language){var options=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};var tracks=self.textTracks();options.kind=kind;if(label){options.label=label;}if(language){options.language=language;}options.tech=self;var track=new ALL.text.TrackClass(options);tracks.addTrack(track);return track;}/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */var Tech=function(_Component){inherits(Tech,_Component);/**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */function Tech(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var ready=arguments.length>1&&arguments[1]!==undefined?arguments[1]:function(){};classCallCheck(this,Tech);// we don't want the tech to report user activity automatically.\n// This is done manually in addControlsListeners\noptions.reportTouchActivity=false;// keep track of whether the current source has played at all to\n// implement a very limited played()\nvar _this=possibleConstructorReturn(this,_Component.call(this,null,options,ready));_this.hasStarted_=false;_this.on('playing',function(){this.hasStarted_=true;});_this.on('loadstart',function(){this.hasStarted_=false;});ALL.names.forEach(function(name){var props=ALL[name];if(options&&options[props.getterName]){_this[props.privateName]=options[props.getterName];}});// Manually track progress in cases where the browser/flash player doesn't report it.\nif(!_this.featuresProgressEvents){_this.manualProgressOn();}// Manually track timeupdates in cases where the browser/flash player doesn't report it.\nif(!_this.featuresTimeupdateEvents){_this.manualTimeUpdatesOn();}['Text','Audio','Video'].forEach(function(track){if(options['native'+track+'Tracks']===false){_this['featuresNative'+track+'Tracks']=false;}});if(options.nativeCaptions===false||options.nativeTextTracks===false){_this.featuresNativeTextTracks=false;}else if(options.nativeCaptions===true||options.nativeTextTracks===true){_this.featuresNativeTextTracks=true;}if(!_this.featuresNativeTextTracks){_this.emulateTextTracks();}_this.autoRemoteTextTracks_=new ALL.text.ListClass();_this.initTrackListeners();// Turn on component tap events only if not using native controls\nif(!options.nativeControlsForTouch){_this.emitTapEvents();}if(_this.constructor){_this.name_=_this.constructor.name||'Unknown Tech';}return _this;}/* Fallbacks for unsupported event types\n  ================================================================================ *//**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */Tech.prototype.manualProgressOn=function manualProgressOn(){this.on('durationchange',this.onDurationChange);this.manualProgress=true;// Trigger progress watching when a source begins loading\nthis.one('ready',this.trackProgress);};/**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */Tech.prototype.manualProgressOff=function manualProgressOff(){this.manualProgress=false;this.stopTrackingProgress();this.off('durationchange',this.onDurationChange);};/**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */Tech.prototype.trackProgress=function trackProgress(event){this.stopTrackingProgress();this.progressInterval=this.setInterval(bind(this,function(){// Don't trigger unless buffered amount is greater than last time\nvar numBufferedPercent=this.bufferedPercent();if(this.bufferedPercent_!==numBufferedPercent){/**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */this.trigger('progress');}this.bufferedPercent_=numBufferedPercent;if(numBufferedPercent===1){this.stopTrackingProgress();}}),500);};/**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */Tech.prototype.onDurationChange=function onDurationChange(event){this.duration_=this.duration();};/**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */Tech.prototype.buffered=function buffered(){return createTimeRanges(0,0);};/**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */Tech.prototype.bufferedPercent=function bufferedPercent$$1(){return bufferedPercent(this.buffered(),this.duration_);};/**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */Tech.prototype.stopTrackingProgress=function stopTrackingProgress(){this.clearInterval(this.progressInterval);};/**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */Tech.prototype.manualTimeUpdatesOn=function manualTimeUpdatesOn(){this.manualTimeUpdates=true;this.on('play',this.trackCurrentTime);this.on('pause',this.stopTrackingCurrentTime);};/**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */Tech.prototype.manualTimeUpdatesOff=function manualTimeUpdatesOff(){this.manualTimeUpdates=false;this.stopTrackingCurrentTime();this.off('play',this.trackCurrentTime);this.off('pause',this.stopTrackingCurrentTime);};/**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */Tech.prototype.trackCurrentTime=function trackCurrentTime(){if(this.currentTimeInterval){this.stopTrackingCurrentTime();}this.currentTimeInterval=this.setInterval(function(){/**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */this.trigger({type:'timeupdate',target:this,manuallyTriggered:true});// 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n},250);};/**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */Tech.prototype.stopTrackingCurrentTime=function stopTrackingCurrentTime(){this.clearInterval(this.currentTimeInterval);// #1002 - if the video ends right before the next timeupdate would happen,\n// the progress bar won't make it all the way to the end\nthis.trigger({type:'timeupdate',target:this,manuallyTriggered:true});};/**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */Tech.prototype.dispose=function dispose(){// clear out all tracks because we can't reuse them between techs\nthis.clearTracks(NORMAL.names);// Turn off any manual progress or timeupdate tracking\nif(this.manualProgress){this.manualProgressOff();}if(this.manualTimeUpdates){this.manualTimeUpdatesOff();}_Component.prototype.dispose.call(this);};/**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */Tech.prototype.clearTracks=function clearTracks(types){var _this2=this;types=[].concat(types);// clear out all tracks because we can't reuse them between techs\ntypes.forEach(function(type){var list=_this2[type+'Tracks']()||[];var i=list.length;while(i--){var track=list[i];if(type==='text'){_this2.removeRemoteTextTrack(track);}list.removeTrack(track);}});};/**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */Tech.prototype.cleanupAutoTextTracks=function cleanupAutoTextTracks(){var list=this.autoRemoteTextTracks_||[];var i=list.length;while(i--){var track=list[i];this.removeRemoteTextTrack(track);}};/**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */Tech.prototype.reset=function reset(){};/**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */Tech.prototype.error=function error(err){if(err!==undefined){this.error_=new MediaError(err);this.trigger('error');}return this.error_;};/**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks wether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */Tech.prototype.played=function played(){if(this.hasStarted_){return createTimeRanges(0,0);}return createTimeRanges();};/**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */Tech.prototype.setCurrentTime=function setCurrentTime(){// improve the accuracy of manual timeupdates\nif(this.manualTimeUpdates){/**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */this.trigger({type:'timeupdate',target:this,manuallyTriggered:true});}};/**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */Tech.prototype.initTrackListeners=function initTrackListeners(){var _this3=this;/**\n     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n     *\n     * @event Tech#audiotrackchange\n     * @type {EventTarget~Event}\n     *//**\n     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n     *\n     * @event Tech#videotrackchange\n     * @type {EventTarget~Event}\n     *//**\n     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n     *\n     * @event Tech#texttrackchange\n     * @type {EventTarget~Event}\n     */NORMAL.names.forEach(function(name){var props=NORMAL[name];var trackListChanges=function trackListChanges(){_this3.trigger(name+'trackchange');};var tracks=_this3[props.getterName]();tracks.addEventListener('removetrack',trackListChanges);tracks.addEventListener('addtrack',trackListChanges);_this3.on('dispose',function(){tracks.removeEventListener('removetrack',trackListChanges);tracks.removeEventListener('addtrack',trackListChanges);});});};/**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */Tech.prototype.addWebVttScript_=function addWebVttScript_(){var _this4=this;if(window.WebVTT){return;}// Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n// signals that the Tech is ready at which point Tech.el_ is part of the DOM\n// before inserting the WebVTT script\nif(document.body.contains(this.el())){// load via require if available and vtt.js script location was not passed in\n// as an option. novtt builds will turn the above require call into an empty object\n// which will cause this if check to always fail.\nif(!this.options_['vtt.js']&&isPlain(vtt)&&Object.keys(vtt).length>0){this.trigger('vttjsloaded');return;}// load vtt.js via the script location option or the cdn of no location was\n// passed in\nvar script=document.createElement('script');script.src=this.options_['vtt.js']||'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';script.onload=function(){/**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */_this4.trigger('vttjsloaded');};script.onerror=function(){/**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */_this4.trigger('vttjserror');};this.on('dispose',function(){script.onload=null;script.onerror=null;});// but have not loaded yet and we set it to true before the inject so that\n// we don't overwrite the injected window.WebVTT if it loads right away\nwindow.WebVTT=true;this.el().parentNode.appendChild(script);}else{this.ready(this.addWebVttScript_);}};/**\n   * Emulate texttracks\n   *\n   */Tech.prototype.emulateTextTracks=function emulateTextTracks(){var _this5=this;var tracks=this.textTracks();var remoteTracks=this.remoteTextTracks();var handleAddTrack=function handleAddTrack(e){return tracks.addTrack(e.track);};var handleRemoveTrack=function handleRemoveTrack(e){return tracks.removeTrack(e.track);};remoteTracks.on('addtrack',handleAddTrack);remoteTracks.on('removetrack',handleRemoveTrack);this.addWebVttScript_();var updateDisplay=function updateDisplay(){return _this5.trigger('texttrackchange');};var textTracksChanges=function textTracksChanges(){updateDisplay();for(var i=0;i<tracks.length;i++){var track=tracks[i];track.removeEventListener('cuechange',updateDisplay);if(track.mode==='showing'){track.addEventListener('cuechange',updateDisplay);}}};textTracksChanges();tracks.addEventListener('change',textTracksChanges);tracks.addEventListener('addtrack',textTracksChanges);tracks.addEventListener('removetrack',textTracksChanges);this.on('dispose',function(){remoteTracks.off('addtrack',handleAddTrack);remoteTracks.off('removetrack',handleRemoveTrack);tracks.removeEventListener('change',textTracksChanges);tracks.removeEventListener('addtrack',textTracksChanges);tracks.removeEventListener('removetrack',textTracksChanges);for(var i=0;i<tracks.length;i++){var track=tracks[i];track.removeEventListener('cuechange',updateDisplay);}});};/**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */Tech.prototype.addTextTrack=function addTextTrack(kind,label,language){if(!kind){throw new Error('TextTrack kind is required but was not provided');}return createTrackHelper(this,kind,label,language);};/**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */Tech.prototype.createRemoteTextTrack=function createRemoteTextTrack(options){var track=mergeOptions(options,{tech:this});return new REMOTE.remoteTextEl.TrackClass(track);};/**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */Tech.prototype.addRemoteTextTrack=function addRemoteTextTrack(){var _this6=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var manualCleanup=arguments[1];var htmlTrackElement=this.createRemoteTextTrack(options);if(manualCleanup!==true&&manualCleanup!==false){// deprecation warning\nlog$1.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');manualCleanup=true;}// store HTMLTrackElement and TextTrack to remote list\nthis.remoteTextTrackEls().addTrackElement_(htmlTrackElement);this.remoteTextTracks().addTrack(htmlTrackElement.track);if(manualCleanup!==true){// create the TextTrackList if it doesn't exist\nthis.ready(function(){return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);});}return htmlTrackElement;};/**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */Tech.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(track){var trackElement=this.remoteTextTrackEls().getTrackElementByTrack_(track);// remove HTMLTrackElement and TextTrack from remote list\nthis.remoteTextTrackEls().removeTrackElement_(trackElement);this.remoteTextTracks().removeTrack(track);this.autoRemoteTextTracks_.removeTrack(track);};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */Tech.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){return{};};/**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */Tech.prototype.setPoster=function setPoster(){};/**\n   * A method to check for the presence of the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */Tech.prototype.playsinline=function playsinline(){};/**\n   * A method to set or unset the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */Tech.prototype.setPlaysinline=function setPlaysinline(){};/*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */Tech.prototype.canPlayType=function canPlayType(){return'';};/**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */Tech.canPlayType=function canPlayType(){return'';};/**\n   * Check if the tech can support the given source\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */Tech.canPlaySource=function canPlaySource(srcObj,options){return Tech.canPlayType(srcObj.type);};/*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */Tech.isTech=function isTech(component){return component.prototype instanceof Tech||component instanceof Tech||component===Tech;};/**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */Tech.registerTech=function registerTech(name,tech){if(!Tech.techs_){Tech.techs_={};}if(!Tech.isTech(tech)){throw new Error('Tech '+name+' must be a Tech');}if(!Tech.canPlayType){throw new Error('Techs must have a static canPlayType method on them');}if(!Tech.canPlaySource){throw new Error('Techs must have a static canPlaySource method on them');}name=toTitleCase(name);Tech.techs_[name]=tech;if(name!=='Tech'){// camel case the techName for use in techOrder\nTech.defaultTechOrder_.push(name);}return tech;};/**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requsted.\n   */Tech.getTech=function getTech(name){if(!name){return;}name=toTitleCase(name);if(Tech.techs_&&Tech.techs_[name]){return Tech.techs_[name];}if(window&&window.videojs&&window.videojs[name]){log$1.warn('The '+name+' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');return window.videojs[name];}};return Tech;}(Component);/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n *//**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n *//**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n *//**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n *//**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */ALL.names.forEach(function(name){var props=ALL[name];Tech.prototype[props.getterName]=function(){this[props.privateName]=this[props.privateName]||new props.ListClass();return this[props.privateName];};});/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n *//**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n *//**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n *//**\n * Boolean indicating wether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresVolumeControl=true;/**\n * Boolean indicating wether the `Tech` support fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresFullscreenResize=false;/**\n * Boolean indicating wether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresPlaybackRate=false;/**\n * Boolean indicating wether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresProgressEvents=false;/**\n * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresTimeupdateEvents=false;/**\n * Boolean indicating wether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresNativeTextTracks=false;/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */Tech.withSourceHandlers=function(_Tech){/**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */_Tech.registerSourceHandler=function(handler,index){var handlers=_Tech.sourceHandlers;if(!handlers){handlers=_Tech.sourceHandlers=[];}if(index===undefined){// add to the end of the list\nindex=handlers.length;}handlers.splice(index,0,handler);};/**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */_Tech.canPlayType=function(type){var handlers=_Tech.sourceHandlers||[];var can=void 0;for(var i=0;i<handlers.length;i++){can=handlers[i].canPlayType(type);if(can){return can;}}return'';};/**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */_Tech.selectSourceHandler=function(source,options){var handlers=_Tech.sourceHandlers||[];var can=void 0;for(var i=0;i<handlers.length;i++){can=handlers[i].canHandleSource(source,options);if(can){return handlers[i];}}return null;};/**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */_Tech.canPlaySource=function(srcObj,options){var sh=_Tech.selectSourceHandler(srcObj,options);if(sh){return sh.canHandleSource(srcObj,options);}return'';};/**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */var deferrable=['seekable','duration'];/**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   *//**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */deferrable.forEach(function(fnName){var originalFn=this[fnName];if(typeof originalFn!=='function'){return;}this[fnName]=function(){if(this.sourceHandler_&&this.sourceHandler_[fnName]){return this.sourceHandler_[fnName].apply(this.sourceHandler_,arguments);}return originalFn.apply(this,arguments);};},_Tech.prototype);/**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */_Tech.prototype.setSource=function(source){var sh=_Tech.selectSourceHandler(source,this.options_);if(!sh){// Fall back to a native source hander when unsupported sources are\n// deliberately set\nif(_Tech.nativeSourceHandler){sh=_Tech.nativeSourceHandler;}else{log$1.error('No source hander found for the current source.');}}// Dispose any existing source handler\nthis.disposeSourceHandler();this.off('dispose',this.disposeSourceHandler);if(sh!==_Tech.nativeSourceHandler){this.currentSource_=source;}this.sourceHandler_=sh.handleSource(source,this,this.options_);this.on('dispose',this.disposeSourceHandler);};/**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */_Tech.prototype.disposeSourceHandler=function(){// if we have a source and get another one\n// then we are loading something new\n// than clear all of our current tracks\nif(this.currentSource_){this.clearTracks(['audio','video']);this.currentSource_=null;}// always clean up auto-text tracks\nthis.cleanupAutoTextTracks();if(this.sourceHandler_){if(this.sourceHandler_.dispose){this.sourceHandler_.dispose();}this.sourceHandler_=null;}};};// The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\nComponent.registerComponent('Tech',Tech);Tech.registerTech('Tech',Tech);/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */Tech.defaultTechOrder_=[];var middlewares={};function use(type,middleware){middlewares[type]=middlewares[type]||[];middlewares[type].push(middleware);}function setSource(player,src,next){player.setTimeout(function(){return setSourceHelper(src,middlewares[src.type],next,player);},1);}function setTech(middleware,tech){middleware.forEach(function(mw){return mw.setTech&&mw.setTech(tech);});}function get$1(middleware,tech,method){return middleware.reduceRight(middlewareIterator(method),tech[method]());}function set$1(middleware,tech,method,arg){return tech[method](middleware.reduce(middlewareIterator(method),arg));}var allowedGetters={buffered:1,currentTime:1,duration:1,seekable:1,played:1};var allowedSetters={setCurrentTime:1};function middlewareIterator(method){return function(value,mw){if(mw[method]){return mw[method](value);}return value;};}function setSourceHelper(){var src=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var middleware=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var next=arguments[2];var player=arguments[3];var acc=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];var lastRun=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var mwFactory=middleware[0],mwrest=middleware.slice(1);// if mwFactory is a string, then we're at a fork in the road\nif(typeof mwFactory==='string'){setSourceHelper(src,middlewares[mwFactory],next,player,acc,lastRun);// if we have an mwFactory, call it with the player to get the mw,\n// then call the mw's setSource method\n}else if(mwFactory){var mw=mwFactory(player);mw.setSource(assign({},src),function(err,_src){// something happened, try the next middleware on the current level\n// make sure to use the old src\nif(err){return setSourceHelper(src,mwrest,next,player,acc,lastRun);}// we've succeeded, now we need to go deeper\nacc.push(mw);// if it's the same time, continue does the current chain\n// otherwise, we want to go down the new chain\nsetSourceHelper(_src,src.type===_src.type?mwrest:middlewares[_src.type],next,player,acc,lastRun);});}else if(mwrest.length){setSourceHelper(src,mwrest,next,player,acc,lastRun);}else if(lastRun){next(src,acc);}else{setSourceHelper(src,middlewares['*'],next,player,acc,true);}}/**\n * @module filter-source\n *//**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */var filterSource=function filterSource(src){// traverse array\nif(Array.isArray(src)){var newsrc=[];src.forEach(function(srcobj){srcobj=filterSource(srcobj);if(Array.isArray(srcobj)){newsrc=newsrc.concat(srcobj);}else if(isObject(srcobj)){newsrc.push(srcobj);}});src=newsrc;}else if(typeof src==='string'&&src.trim()){// convert string into object\nsrc=[{src:src}];}else if(isObject(src)&&typeof src.src==='string'&&src.src&&src.src.trim()){// src is already valid\nsrc=[src];}else{// invalid source, turn it into an empty array\nsrc=[];}return src;};/**\n * @file loader.js\n *//**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */var MediaLoader=function(_Component){inherits(MediaLoader,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value stroe of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */function MediaLoader(player,options,ready){classCallCheck(this,MediaLoader);// MediaLoader has no element\nvar options_=mergeOptions({createEl:false},options);// If there are no sources when the player is initialized,\n// load the first supported playback technology.\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options_,ready));if(!options.playerOptions.sources||options.playerOptions.sources.length===0){for(var i=0,j=options.playerOptions.techOrder;i<j.length;i++){var techName=toTitleCase(j[i]);var tech=Tech.getTech(techName);// Support old behavior of techs being registered as components.\n// Remove once that deprecated behavior is removed.\nif(!techName){tech=Component.getComponent(techName);}// Check if the browser supports this technology\nif(tech&&tech.isSupported()){player.loadTech_(techName);break;}}}else{// Loop through playback technologies (HTML5, Flash) and check for support.\n// Then load the best source.\n// A few assumptions here:\n//   All playback technologies respect preload false.\nplayer.src(options.playerOptions.sources);}return _this;}return MediaLoader;}(Component);Component.registerComponent('MediaLoader',MediaLoader);/**\n * @file button.js\n *//**\n * Clickable Component which is clickable or keyboard actionable,\n * but is not a native HTML button.\n *\n * @extends Component\n */var ClickableComponent=function(_Component){inherits(ClickableComponent,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function ClickableComponent(player,options){classCallCheck(this,ClickableComponent);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.emitTapEvents();_this.enable();return _this;}/**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */ClickableComponent.prototype.createEl=function createEl$$1(){var tag=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'div';var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};props=assign({innerHTML:'<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',className:this.buildCSSClass(),tabIndex:0},props);if(tag==='button'){log$1.error('Creating a ClickableComponent with an HTML element of '+tag+' is not supported; use a Button instead.');}// Add ARIA attributes for clickable element which is not a native HTML button\nattributes=assign({'role':'button',// let the screen reader user know that the text of the element may change\n'aria-live':'polite'},attributes);this.tabIndex_=props.tabIndex;var el=_Component.prototype.createEl.call(this,tag,props,attributes);this.createControlTextEl(el);return el;};ClickableComponent.prototype.dispose=function dispose(){// remove controlTextEl_ on dipose\nthis.controlTextEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Create a control text element on this `Component`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */ClickableComponent.prototype.createControlTextEl=function createControlTextEl(el){this.controlTextEl_=createEl('span',{className:'vjs-control-text'});if(el){el.appendChild(this.controlTextEl_);}this.controlText(this.controlText_,el);return this.controlTextEl_;};/**\n   * Get or set the localize text to use for the controls on the `Component`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */ClickableComponent.prototype.controlText=function controlText(text){var el=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.el();if(text===undefined){return this.controlText_||'Need Text';}var localizedText=this.localize(text);this.controlText_=text;textContent(this.controlTextEl_,localizedText);if(!this.nonIconControl){// Set title attribute if only an icon is shown\nel.setAttribute('title',localizedText);}};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ClickableComponent.prototype.buildCSSClass=function buildCSSClass(){return'vjs-control vjs-button '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Enable this `Component`s element.\n   */ClickableComponent.prototype.enable=function enable(){if(!this.enabled_){this.enabled_=true;this.removeClass('vjs-disabled');this.el_.setAttribute('aria-disabled','false');if(typeof this.tabIndex_!=='undefined'){this.el_.setAttribute('tabIndex',this.tabIndex_);}this.on(['tap','click'],this.handleClick);this.on('focus',this.handleFocus);this.on('blur',this.handleBlur);}};/**\n   * Disable this `Component`s element.\n   */ClickableComponent.prototype.disable=function disable(){this.enabled_=false;this.addClass('vjs-disabled');this.el_.setAttribute('aria-disabled','true');if(typeof this.tabIndex_!=='undefined'){this.el_.removeAttribute('tabIndex');}this.off(['tap','click'],this.handleClick);this.off('focus',this.handleFocus);this.off('blur',this.handleBlur);};/**\n   * This gets called when a `ClickableComponent` gets:\n   * - Clicked (via the `click` event, listening starts in the constructor)\n   * - Tapped (via the `tap` event, listening starts in the constructor)\n   * - The following things happen in order:\n   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the\n   *      `ClickableComponent`.\n   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using\n   *      {@link ClickableComponent#handleKeyPress}.\n   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses\n   *      the space or enter key.\n   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`\n   *      event as a parameter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */ClickableComponent.prototype.handleClick=function handleClick(event){};/**\n   * This gets called when a `ClickableComponent` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */ClickableComponent.prototype.handleFocus=function handleFocus(event){on(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Called when this ClickableComponent has focus and a key gets pressed down. By\n   * default it will call `this.handleClick` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */ClickableComponent.prototype.handleKeyPress=function handleKeyPress(event){// Support Space (32) or Enter (13) key operation to fire a click event\nif(event.which===32||event.which===13){event.preventDefault();this.trigger('click');}else if(_Component.prototype.handleKeyPress){// Pass keypress handling up for unsupported keys\n_Component.prototype.handleKeyPress.call(this,event);}};/**\n   * Called when a `ClickableComponent` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */ClickableComponent.prototype.handleBlur=function handleBlur(event){off(document,'keydown',bind(this,this.handleKeyPress));};return ClickableComponent;}(Component);Component.registerComponent('ClickableComponent',ClickableComponent);/**\n * @file poster-image.js\n *//**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */var PosterImage=function(_ClickableComponent){inherits(PosterImage,_ClickableComponent);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PosterImage(player,options){classCallCheck(this,PosterImage);var _this=possibleConstructorReturn(this,_ClickableComponent.call(this,player,options));_this.update();player.on('posterchange',bind(_this,_this.update));return _this;}/**\n   * Clean up and dispose of the `PosterImage`.\n   */PosterImage.prototype.dispose=function dispose(){this.player().off('posterchange',this.update);_ClickableComponent.prototype.dispose.call(this);};/**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */PosterImage.prototype.createEl=function createEl$$1(){var el=createEl('div',{className:'vjs-poster',// Don't want poster to be tabbable.\ntabIndex:-1});// To ensure the poster image resizes while maintaining its original aspect\n// ratio, use a div with `background-size` when available. For browsers that\n// do not support `background-size` (e.g. IE8), fall back on using a regular\n// img element.\nif(!BACKGROUND_SIZE_SUPPORTED){this.fallbackImg_=createEl('img');el.appendChild(this.fallbackImg_);}return el;};/**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */PosterImage.prototype.update=function update(event){var url=this.player().poster();this.setSrc(url);// If there's no poster source we should display:none on this component\n// so it's not still clickable or right-clickable\nif(url){this.show();}else{this.hide();}};/**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */PosterImage.prototype.setSrc=function setSrc(url){if(this.fallbackImg_){this.fallbackImg_.src=url;}else{var backgroundImage='';// Any falsey values should stay as an empty string, otherwise\n// this will throw an extra error\nif(url){backgroundImage='url(\"'+url+'\")';}this.el_.style.backgroundImage=backgroundImage;}};/**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */PosterImage.prototype.handleClick=function handleClick(event){// We don't want a click to trigger playback when controls are disabled\nif(!this.player_.controls()){return;}if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};return PosterImage;}(ClickableComponent);Component.registerComponent('PosterImage',PosterImage);/**\n * @file text-track-display.js\n */var darkGray='#222';var lightGray='#ccc';var fontMap={monospace:'monospace',sansSerif:'sans-serif',serif:'serif',monospaceSansSerif:'\"Andale Mono\", \"Lucida Console\", monospace',monospaceSerif:'\"Courier New\", monospace',proportionalSansSerif:'sans-serif',proportionalSerif:'serif',casual:'\"Comic Sans MS\", Impact, fantasy',script:'\"Monotype Corsiva\", cursive',smallcaps:'\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'};/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n *\n * @private\n */function constructColor(color,opacity){return'rgba('+// color looks like \"#f0e\"\nparseInt(color[1]+color[1],16)+','+parseInt(color[2]+color[2],16)+','+parseInt(color[3]+color[3],16)+','+opacity+')';}/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */function tryUpdateStyle(el,style,rule){try{el.style[style]=rule;}catch(e){// Satisfies linter.\nreturn;}}/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */var TextTrackDisplay=function(_Component){inherits(TextTrackDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */function TextTrackDisplay(player,options,ready){classCallCheck(this,TextTrackDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options,ready));player.on('loadstart',bind(_this,_this.toggleDisplay));player.on('texttrackchange',bind(_this,_this.updateDisplay));player.on('loadstart',bind(_this,_this.preselectTrack));// This used to be called during player init, but was causing an error\n// if a track should show by default and the display hadn't loaded yet.\n// Should probably be moved to an external track loader when we support\n// tracks that don't need a display.\nplayer.ready(bind(_this,function(){if(player.tech_&&player.tech_.featuresNativeTextTracks){this.hide();return;}player.on('fullscreenchange',bind(this,this.updateDisplay));var tracks=this.options_.playerOptions.tracks||[];for(var i=0;i<tracks.length;i++){this.player_.addRemoteTextTrack(tracks[i],true);}this.preselectTrack();}));return _this;}/**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */TextTrackDisplay.prototype.preselectTrack=function preselectTrack(){var modes={captions:1,subtitles:1};var trackList=this.player_.textTracks();var userPref=this.player_.cache_.selectedLanguage;var firstDesc=void 0;var firstCaptions=void 0;var preferredTrack=void 0;for(var i=0;i<trackList.length;i++){var track=trackList[i];if(userPref&&userPref.enabled&&userPref.language===track.language){// Always choose the track that matches both language and kind\nif(track.kind===userPref.kind){preferredTrack=track;// or choose the first track that matches language\n}else if(!preferredTrack){preferredTrack=track;}// clear everything if offTextTrackMenuItem was clicked\n}else if(userPref&&!userPref.enabled){preferredTrack=null;firstDesc=null;firstCaptions=null;}else if(track['default']){if(track.kind==='descriptions'&&!firstDesc){firstDesc=track;}else if(track.kind in modes&&!firstCaptions){firstCaptions=track;}}}// The preferredTrack matches the user preference and takes\n// precendence over all the other tracks.\n// So, display the preferredTrack before the first default track\n// and the subtitles/captions track before the descriptions track\nif(preferredTrack){preferredTrack.mode='showing';}else if(firstCaptions){firstCaptions.mode='showing';}else if(firstDesc){firstDesc.mode='showing';}};/**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */TextTrackDisplay.prototype.toggleDisplay=function toggleDisplay(){if(this.player_.tech_&&this.player_.tech_.featuresNativeTextTracks){this.hide();}else{this.show();}};/**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TextTrackDisplay.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-text-track-display'},{'aria-live':'off','aria-atomic':'true'});};/**\n   * Clear all displayed {@link TextTrack}s.\n   */TextTrackDisplay.prototype.clearDisplay=function clearDisplay(){if(typeof window.WebVTT==='function'){window.WebVTT.processCues(window,[],this.el_);}};/**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */TextTrackDisplay.prototype.updateDisplay=function updateDisplay(){var tracks=this.player_.textTracks();this.clearDisplay();// Track display prioritization model: if multiple tracks are 'showing',\n//  display the first 'subtitles' or 'captions' track which is 'showing',\n//  otherwise display the first 'descriptions' track which is 'showing'\nvar descriptionsTrack=null;var captionsSubtitlesTrack=null;var i=tracks.length;while(i--){var track=tracks[i];if(track.mode==='showing'){if(track.kind==='descriptions'){descriptionsTrack=track;}else{captionsSubtitlesTrack=track;}}}if(captionsSubtitlesTrack){if(this.getAttribute('aria-live')!=='off'){this.setAttribute('aria-live','off');}this.updateForTrack(captionsSubtitlesTrack);}else if(descriptionsTrack){if(this.getAttribute('aria-live')!=='assertive'){this.setAttribute('aria-live','assertive');}this.updateForTrack(descriptionsTrack);}};/**\n   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack} track\n   *        Text track object to be added to the list.\n   */TextTrackDisplay.prototype.updateForTrack=function updateForTrack(track){if(typeof window.WebVTT!=='function'||!track.activeCues){return;}var overrides=this.player_.textTrackSettings.getValues();var cues=[];for(var _i=0;_i<track.activeCues.length;_i++){cues.push(track.activeCues[_i]);}window.WebVTT.processCues(window,cues,this.el_);var i=cues.length;while(i--){var cue=cues[i];if(!cue){continue;}var cueDiv=cue.displayState;if(overrides.color){cueDiv.firstChild.style.color=overrides.color;}if(overrides.textOpacity){tryUpdateStyle(cueDiv.firstChild,'color',constructColor(overrides.color||'#fff',overrides.textOpacity));}if(overrides.backgroundColor){cueDiv.firstChild.style.backgroundColor=overrides.backgroundColor;}if(overrides.backgroundOpacity){tryUpdateStyle(cueDiv.firstChild,'backgroundColor',constructColor(overrides.backgroundColor||'#000',overrides.backgroundOpacity));}if(overrides.windowColor){if(overrides.windowOpacity){tryUpdateStyle(cueDiv,'backgroundColor',constructColor(overrides.windowColor,overrides.windowOpacity));}else{cueDiv.style.backgroundColor=overrides.windowColor;}}if(overrides.edgeStyle){if(overrides.edgeStyle==='dropshadow'){cueDiv.firstChild.style.textShadow='2px 2px 3px '+darkGray+', 2px 2px 4px '+darkGray+', 2px 2px 5px '+darkGray;}else if(overrides.edgeStyle==='raised'){cueDiv.firstChild.style.textShadow='1px 1px '+darkGray+', 2px 2px '+darkGray+', 3px 3px '+darkGray;}else if(overrides.edgeStyle==='depressed'){cueDiv.firstChild.style.textShadow='1px 1px '+lightGray+', 0 1px '+lightGray+', -1px -1px '+darkGray+', 0 -1px '+darkGray;}else if(overrides.edgeStyle==='uniform'){cueDiv.firstChild.style.textShadow='0 0 4px '+darkGray+', 0 0 4px '+darkGray+', 0 0 4px '+darkGray+', 0 0 4px '+darkGray;}}if(overrides.fontPercent&&overrides.fontPercent!==1){var fontSize=window.parseFloat(cueDiv.style.fontSize);cueDiv.style.fontSize=fontSize*overrides.fontPercent+'px';cueDiv.style.height='auto';cueDiv.style.top='auto';cueDiv.style.bottom='2px';}if(overrides.fontFamily&&overrides.fontFamily!=='default'){if(overrides.fontFamily==='small-caps'){cueDiv.firstChild.style.fontVariant='small-caps';}else{cueDiv.firstChild.style.fontFamily=fontMap[overrides.fontFamily];}}}};return TextTrackDisplay;}(Component);Component.registerComponent('TextTrackDisplay',TextTrackDisplay);/**\n * @file loading-spinner.js\n *//**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */var LoadingSpinner=function(_Component){inherits(LoadingSpinner,_Component);function LoadingSpinner(){classCallCheck(this,LoadingSpinner);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */LoadingSpinner.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-loading-spinner',dir:'ltr'});};return LoadingSpinner;}(Component);Component.registerComponent('LoadingSpinner',LoadingSpinner);/**\n * @file button.js\n *//**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */var Button=function(_ClickableComponent){inherits(Button,_ClickableComponent);function Button(){classCallCheck(this,Button);return possibleConstructorReturn(this,_ClickableComponent.apply(this,arguments));}/**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Button.prototype.createEl=function createEl(tag){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};tag='button';props=assign({innerHTML:'<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',className:this.buildCSSClass()},props);// Add attributes for button element\nattributes=assign({// Necessary since the default button type is \"submit\"\n'type':'button',// let the screen reader user know that the text of the button may change\n'aria-live':'polite'},attributes);var el=Component.prototype.createEl.call(this,tag,props,attributes);this.createControlTextEl(el);return el;};/**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */Button.prototype.addChild=function addChild(child){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var className=this.constructor.name;log$1.warn('Adding an actionable (user controllable) child to a Button ('+className+') is not supported; use a ClickableComponent instead.');// Avoid the error message generated by ClickableComponent's addChild method\nreturn Component.prototype.addChild.call(this,child,options);};/**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */Button.prototype.enable=function enable(){_ClickableComponent.prototype.enable.call(this);this.el_.removeAttribute('disabled');};/**\n   * Enable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */Button.prototype.disable=function disable(){_ClickableComponent.prototype.disable.call(this);this.el_.setAttribute('disabled','disabled');};/**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */Button.prototype.handleKeyPress=function handleKeyPress(event){// Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\nif(event.which===32||event.which===13){return;}// Pass keypress handling up for unsupported keys\n_ClickableComponent.prototype.handleKeyPress.call(this,event);};return Button;}(ClickableComponent);Component.registerComponent('Button',Button);/**\n * @file big-play-button.js\n *//**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */var BigPlayButton=function(_Button){inherits(BigPlayButton,_Button);function BigPlayButton(player,options){classCallCheck(this,BigPlayButton);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.mouseused_=false;_this.on('mousedown',_this.handleMouseDown);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */BigPlayButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-big-play-button';};/**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */BigPlayButton.prototype.handleClick=function handleClick(event){var playPromise=this.player_.play();// exit early if clicked via the mouse\nif(this.mouseused_&&event.clientX&&event.clientY){return;}var cb=this.player_.getChild('controlBar');var playToggle=cb&&cb.getChild('playToggle');if(!playToggle){this.player_.focus();return;}var playFocus=function playFocus(){return playToggle.focus();};if(isPromise(playPromise)){playPromise.then(playFocus,function(){});}else{this.setTimeout(playFocus,1);}};BigPlayButton.prototype.handleKeyPress=function handleKeyPress(event){this.mouseused_=false;_Button.prototype.handleKeyPress.call(this,event);};BigPlayButton.prototype.handleMouseDown=function handleMouseDown(event){this.mouseused_=true;};return BigPlayButton;}(Button);/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */BigPlayButton.prototype.controlText_='Play Video';Component.registerComponent('BigPlayButton',BigPlayButton);/**\n * @file close-button.js\n *//**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */var CloseButton=function(_Button){inherits(CloseButton,_Button);/**\n   * Creates an instance of the this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function CloseButton(player,options){classCallCheck(this,CloseButton);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.controlText(options&&options.controlText||_this.localize('Close'));return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CloseButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-close-button '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when this will be\n   * triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */CloseButton.prototype.handleClick=function handleClick(event){/**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */this.trigger({type:'close',bubbles:false});};return CloseButton;}(Button);Component.registerComponent('CloseButton',CloseButton);/**\n * @file play-toggle.js\n *//**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */var PlayToggle=function(_Button){inherits(PlayToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlayToggle(player,options){classCallCheck(this,PlayToggle);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.on(player,'play',_this.handlePlay);_this.on(player,'pause',_this.handlePause);_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */PlayToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-play-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlayToggle.prototype.handleClick=function handleClick(event){if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};/**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */PlayToggle.prototype.handleSeeked=function handleSeeked(event){this.removeClass('vjs-ended');if(this.player_.paused()){this.handlePause(event);}else{this.handlePlay(event);}};/**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */PlayToggle.prototype.handlePlay=function handlePlay(event){this.removeClass('vjs-ended');this.removeClass('vjs-paused');this.addClass('vjs-playing');// change the button text to \"Pause\"\nthis.controlText('Pause');};/**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */PlayToggle.prototype.handlePause=function handlePause(event){this.removeClass('vjs-playing');this.addClass('vjs-paused');// change the button text to \"Play\"\nthis.controlText('Play');};/**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */PlayToggle.prototype.handleEnded=function handleEnded(event){this.removeClass('vjs-playing');this.addClass('vjs-ended');// change the button text to \"Replay\"\nthis.controlText('Replay');// on the next seek remove the replay button\nthis.one(this.player_,'seeked',this.handleSeeked);};return PlayToggle;}(Button);/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlayToggle.prototype.controlText_='Play';Component.registerComponent('PlayToggle',PlayToggle);/**\n * @file format-time.js\n * @module Format-time\n *//**\n * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)\n * will force a number of leading zeros to cover the length of the guide.\n *\n * @param {number} seconds\n *        Number of seconds to be turned into a string\n *\n * @param {number} guide\n *        Number (in seconds) to model the string after\n *\n * @return {string}\n *         Time formatted as H:MM:SS or M:SS\n */function formatTime(seconds){var guide=arguments.length>1&&arguments[1]!==undefined?arguments[1]:seconds;seconds=seconds<0?0:seconds;var s=Math.floor(seconds%60);var m=Math.floor(seconds/60%60);var h=Math.floor(seconds/3600);var gm=Math.floor(guide/60%60);var gh=Math.floor(guide/3600);// handle invalid times\nif(isNaN(seconds)||seconds===Infinity){// '-' is false for all relational operators (e.g. <, >=) so this setting\n// will add the minimum number of fields specified by the guide\nh=m=s='-';}// Check if we need to show hours\nh=h>0||gh>0?h+':':'';// If hours are showing, we may need to add a leading zero.\n// Always show at least one digit of minutes.\nm=((h||gm>=10)&&m<10?'0'+m:m)+':';// Check if leading zero is need for seconds\ns=s<10?'0'+s:s;return h+m+s;}/**\n * @file time-display.js\n *//**\n * Displays the time left in the video\n *\n * @extends Component\n */var TimeDisplay=function(_Component){inherits(TimeDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TimeDisplay(player,options){classCallCheck(this,TimeDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.throttledUpdateContent=throttle(bind(_this,_this.updateContent),25);_this.on(player,'timeupdate',_this.throttledUpdateContent);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeDisplay.prototype.createEl=function createEl$$1(plainName){var className=this.buildCSSClass();var el=_Component.prototype.createEl.call(this,'div',{className:className+' vjs-time-control vjs-control'});this.contentEl_=createEl('div',{className:className+'-display'},{// tell screen readers not to automatically read the time as it changes\n'aria-live':'off'},createEl('span',{className:'vjs-control-text',textContent:this.localize(this.controlText_)}));this.updateTextNode_();el.appendChild(this.contentEl_);return el;};TimeDisplay.prototype.dispose=function dispose(){this.contentEl_=null;this.textNode_=null;_Component.prototype.dispose.call(this);};/**\n   * Updates the \"remaining time\" text node with new content using the\n   * contents of the `formattedTime_` property.\n   *\n   * @private\n   */TimeDisplay.prototype.updateTextNode_=function updateTextNode_(){if(!this.contentEl_){return;}while(this.contentEl_.firstChild){this.contentEl_.removeChild(this.contentEl_.firstChild);}this.textNode_=document.createTextNode(this.formattedTime_||'0:00');this.contentEl_.appendChild(this.textNode_);};/**\n   * Generates a formatted time for this component to use in display.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */TimeDisplay.prototype.formatTime_=function formatTime_(time){return formatTime(time);};/**\n   * Updates the time display text node if it has what was passed in changed\n   * the formatted time.\n   *\n   * @param {number} time\n   *        The time to update to\n   *\n   * @private\n   */TimeDisplay.prototype.updateFormattedTime_=function updateFormattedTime_(time){var formattedTime=this.formatTime_(time);if(formattedTime===this.formattedTime_){return;}this.formattedTime_=formattedTime;this.requestAnimationFrame(this.updateTextNode_);};/**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */TimeDisplay.prototype.updateContent=function updateContent(event){};return TimeDisplay;}(Component);/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */TimeDisplay.prototype.controlText_='Time';Component.registerComponent('TimeDisplay',TimeDisplay);/**\n * @file current-time-display.js\n *//**\n * Displays the current time\n *\n * @extends Component\n */var CurrentTimeDisplay=function(_TimeDisplay){inherits(CurrentTimeDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function CurrentTimeDisplay(player,options){classCallCheck(this,CurrentTimeDisplay);var _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CurrentTimeDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-current-time';};/**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */CurrentTimeDisplay.prototype.updateContent=function updateContent(event){// Allows for smooth scrubbing, when player can't keep up.\nvar time=this.player_.scrubbing()?this.player_.getCache().currentTime:this.player_.currentTime();this.updateFormattedTime_(time);};/**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */CurrentTimeDisplay.prototype.handleEnded=function handleEnded(event){if(!this.player_.duration()){return;}this.updateFormattedTime_(this.player_.duration());};return CurrentTimeDisplay;}(TimeDisplay);/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */CurrentTimeDisplay.prototype.controlText_='Current Time';Component.registerComponent('CurrentTimeDisplay',CurrentTimeDisplay);/**\n * @file duration-display.js\n *//**\n * Displays the duration\n *\n * @extends Component\n */var DurationDisplay=function(_TimeDisplay){inherits(DurationDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function DurationDisplay(player,options){classCallCheck(this,DurationDisplay);// we do not want to/need to throttle duration changes,\n// as they should always display the changed duration as\n// it has changed\nvar _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'durationchange',_this.updateContent);// Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n// listeners could have broken dependent applications/libraries. These\n// can likely be removed for 7.0.\n_this.on(player,'loadedmetadata',_this.throttledUpdateContent);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */DurationDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-duration';};/**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */DurationDisplay.prototype.updateContent=function updateContent(event){var duration=this.player_.duration();if(duration&&this.duration_!==duration){this.duration_=duration;this.updateFormattedTime_(duration);}};return DurationDisplay;}(TimeDisplay);/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */DurationDisplay.prototype.controlText_='Duration Time';Component.registerComponent('DurationDisplay',DurationDisplay);/**\n * @file time-divider.js\n *//**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */var TimeDivider=function(_Component){inherits(TimeDivider,_Component);function TimeDivider(){classCallCheck(this,TimeDivider);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeDivider.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-time-control vjs-time-divider',innerHTML:'<div><span>/</span></div>'});};return TimeDivider;}(Component);Component.registerComponent('TimeDivider',TimeDivider);/**\n * @file remaining-time-display.js\n *//**\n * Displays the time left in the video\n *\n * @extends Component\n */var RemainingTimeDisplay=function(_TimeDisplay){inherits(RemainingTimeDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function RemainingTimeDisplay(player,options){classCallCheck(this,RemainingTimeDisplay);var _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'durationchange',_this.throttledUpdateContent);_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */RemainingTimeDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-remaining-time';};/**\n   * The remaining time display prefixes numbers with a \"minus\" character.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */RemainingTimeDisplay.prototype.formatTime_=function formatTime_(time){return'-'+_TimeDisplay.prototype.formatTime_.call(this,time);};/**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */RemainingTimeDisplay.prototype.updateContent=function updateContent(event){if(!this.player_.duration()){return;}// @deprecated We should only use remainingTimeDisplay\n// as of video.js 7\nif(this.player_.remainingTimeDisplay){this.updateFormattedTime_(this.player_.remainingTimeDisplay());}else{this.updateFormattedTime_(this.player_.remainingTime());}};/**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */RemainingTimeDisplay.prototype.handleEnded=function handleEnded(event){if(!this.player_.duration()){return;}this.updateFormattedTime_(0);};return RemainingTimeDisplay;}(TimeDisplay);/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */RemainingTimeDisplay.prototype.controlText_='Remaining Time';Component.registerComponent('RemainingTimeDisplay',RemainingTimeDisplay);/**\n * @file live-display.js\n */// TODO - Future make it click to snap to live\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */var LiveDisplay=function(_Component){inherits(LiveDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function LiveDisplay(player,options){classCallCheck(this,LiveDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.updateShowing();_this.on(_this.player(),'durationchange',_this.updateShowing);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */LiveDisplay.prototype.createEl=function createEl$$1(){var el=_Component.prototype.createEl.call(this,'div',{className:'vjs-live-control vjs-control'});this.contentEl_=createEl('div',{className:'vjs-live-display',innerHTML:'<span class=\"vjs-control-text\">'+this.localize('Stream Type')+'</span>'+this.localize('LIVE')},{'aria-live':'off'});el.appendChild(this.contentEl_);return el;};LiveDisplay.prototype.dispose=function dispose(){this.contentEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */LiveDisplay.prototype.updateShowing=function updateShowing(event){if(this.player().duration()===Infinity){this.show();}else{this.hide();}};return LiveDisplay;}(Component);Component.registerComponent('LiveDisplay',LiveDisplay);/**\n * @file slider.js\n *//**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */var Slider=function(_Component){inherits(Slider,_Component);/**\n   * Create an instance of this class\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function Slider(player,options){classCallCheck(this,Slider);// Set property names to bar to match with the child Slider class is looking for\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.bar=_this.getChild(_this.options_.barName);// Set a horizontal or vertical class on the slider depending on the slider type\n_this.vertical(!!_this.options_.vertical);_this.enable();return _this;}/**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */Slider.prototype.enabled=function enabled(){return this.enabled_;};/**\n   * Enable controls for this slider if they are disabled\n   */Slider.prototype.enable=function enable(){if(this.enabled()){return;}this.on('mousedown',this.handleMouseDown);this.on('touchstart',this.handleMouseDown);this.on('focus',this.handleFocus);this.on('blur',this.handleBlur);this.on('click',this.handleClick);this.on(this.player_,'controlsvisible',this.update);if(this.playerEvent){this.on(this.player_,this.playerEvent,this.update);}this.removeClass('disabled');this.setAttribute('tabindex',0);this.enabled_=true;};/**\n   * Disable controls for this slider if they are enabled\n   */Slider.prototype.disable=function disable(){if(!this.enabled()){return;}var doc=this.bar.el_.ownerDocument;this.off('mousedown',this.handleMouseDown);this.off('touchstart',this.handleMouseDown);this.off('focus',this.handleFocus);this.off('blur',this.handleBlur);this.off('click',this.handleClick);this.off(this.player_,'controlsvisible',this.update);this.off(doc,'mousemove',this.handleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchmove',this.handleMouseMove);this.off(doc,'touchend',this.handleMouseUp);this.removeAttribute('tabindex');this.addClass('disabled');if(this.playerEvent){this.off(this.player_,this.playerEvent,this.update);}this.enabled_=false;};/**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Slider.prototype.createEl=function createEl$$1(type){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};// Add the slider element class to all sub classes\nprops.className=props.className+' vjs-slider';props=assign({tabIndex:0},props);attributes=assign({'role':'slider','aria-valuenow':0,'aria-valuemin':0,'aria-valuemax':100,'tabIndex':0},attributes);return _Component.prototype.createEl.call(this,type,props,attributes);};/**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */Slider.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.bar.el_.ownerDocument;event.preventDefault();blockTextSelection();this.addClass('vjs-sliding');/**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */this.trigger('slideractive');this.on(doc,'mousemove',this.handleMouseMove);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchmove',this.handleMouseMove);this.on(doc,'touchend',this.handleMouseUp);this.handleMouseMove(event);};/**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */Slider.prototype.handleMouseMove=function handleMouseMove(event){};/**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */Slider.prototype.handleMouseUp=function handleMouseUp(){var doc=this.bar.el_.ownerDocument;unblockTextSelection();this.removeClass('vjs-sliding');/**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */this.trigger('sliderinactive');this.off(doc,'mousemove',this.handleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchmove',this.handleMouseMove);this.off(doc,'touchend',this.handleMouseUp);this.update();};/**\n   * Update the progress bar of the `Slider`.\n   *\n   * @returns {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */Slider.prototype.update=function update(){// In VolumeBar init we have a setTimeout for update that pops and update\n// to the end of the execution stack. The player is destroyed before then\n// update will cause an error\nif(!this.el_){return;}// If scrubbing, we could use a cached value to make the handle keep up\n// with the user's mouse. On HTML5 browsers scrubbing is really smooth, but\n// some flash players are slow, so we might want to utilize this later.\n// var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\nvar progress=this.getPercent();var bar=this.bar;// If there's no bar...\nif(!bar){return;}// Protect against no duration and other division issues\nif(typeof progress!=='number'||progress!==progress||progress<0||progress===Infinity){progress=0;}// Convert to a percentage for setting\nvar percentage=(progress*100).toFixed(2)+'%';var style=bar.el().style;// Set the new bar width or height\nif(this.vertical()){style.height=percentage;}else{style.width=percentage;}return progress;};/**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - postition.x for vertical `Slider`s\n   *         - postition.y for horizontal `Slider`s\n   */Slider.prototype.calculateDistance=function calculateDistance(event){var position=getPointerPosition(this.el_,event);if(this.vertical()){return position.y;}return position.x;};/**\n   * Handle a `focus` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to run.\n   *\n   * @listens focus\n   */Slider.prototype.handleFocus=function handleFocus(){this.on(this.bar.el_.ownerDocument,'keydown',this.handleKeyPress);};/**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */Slider.prototype.handleKeyPress=function handleKeyPress(event){// Left and Down Arrows\nif(event.which===37||event.which===40){event.preventDefault();this.stepBack();// Up and Right Arrows\n}else if(event.which===38||event.which===39){event.preventDefault();this.stepForward();}};/**\n   * Handle a `blur` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to run.\n   *\n   * @listens blur\n   */Slider.prototype.handleBlur=function handleBlur(){this.off(this.bar.el_.ownerDocument,'keydown',this.handleKeyPress);};/**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */Slider.prototype.handleClick=function handleClick(event){event.stopImmediatePropagation();event.preventDefault();};/**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */Slider.prototype.vertical=function vertical(bool){if(bool===undefined){return this.vertical_||false;}this.vertical_=!!bool;if(this.vertical_){this.addClass('vjs-slider-vertical');}else{this.addClass('vjs-slider-horizontal');}};return Slider;}(Component);Component.registerComponent('Slider',Slider);/**\n * @file load-progress-bar.js\n *//**\n * Shows loading progress\n *\n * @extends Component\n */var LoadProgressBar=function(_Component){inherits(LoadProgressBar,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function LoadProgressBar(player,options){classCallCheck(this,LoadProgressBar);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.partEls_=[];_this.on(player,'progress',_this.update);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */LoadProgressBar.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-load-progress',innerHTML:'<span class=\"vjs-control-text\"><span>'+this.localize('Loaded')+'</span>: 0%</span>'});};LoadProgressBar.prototype.dispose=function dispose(){this.partEls_=null;_Component.prototype.dispose.call(this);};/**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */LoadProgressBar.prototype.update=function update(event){var buffered=this.player_.buffered();var duration=this.player_.duration();var bufferedEnd=this.player_.bufferedEnd();var children=this.partEls_;// get the percent width of a time compared to the total end\nvar percentify=function percentify(time,end){// no NaN\nvar percent=time/end||0;return(percent>=1?1:percent)*100+'%';};// update the width of the progress bar\nthis.el_.style.width=percentify(bufferedEnd,duration);// add child elements to represent the individual buffered time ranges\nfor(var i=0;i<buffered.length;i++){var start=buffered.start(i);var end=buffered.end(i);var part=children[i];if(!part){part=this.el_.appendChild(createEl());children[i]=part;}// set the percent based on the width of the progress bar (bufferedEnd)\npart.style.left=percentify(start,bufferedEnd);part.style.width=percentify(end-start,bufferedEnd);}// remove unused buffered range elements\nfor(var _i=children.length;_i>buffered.length;_i--){this.el_.removeChild(children[_i-1]);}children.length=buffered.length;};return LoadProgressBar;}(Component);Component.registerComponent('LoadProgressBar',LoadProgressBar);/**\n * @file time-tooltip.js\n *//**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */var TimeTooltip=function(_Component){inherits(TimeTooltip,_Component);function TimeTooltip(){classCallCheck(this,TimeTooltip);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeTooltip.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-time-tooltip'});};/**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */TimeTooltip.prototype.update=function update(seekBarRect,seekBarPoint,content){var tooltipRect=getBoundingClientRect(this.el_);var playerRect=getBoundingClientRect(this.player_.el());var seekBarPointPx=seekBarRect.width*seekBarPoint;// do nothing if either rect isn't available\n// for example, if the player isn't in the DOM for testing\nif(!playerRect||!tooltipRect){return;}// This is the space left of the `seekBarPoint` available within the bounds\n// of the player. We calculate any gap between the left edge of the player\n// and the left edge of the `SeekBar` and add the number of pixels in the\n// `SeekBar` before hitting the `seekBarPoint`\nvar spaceLeftOfPoint=seekBarRect.left-playerRect.left+seekBarPointPx;// This is the space right of the `seekBarPoint` available within the bounds\n// of the player. We calculate the number of pixels from the `seekBarPoint`\n// to the right edge of the `SeekBar` and add to that any gap between the\n// right edge of the `SeekBar` and the player.\nvar spaceRightOfPoint=seekBarRect.width-seekBarPointPx+(playerRect.right-seekBarRect.right);// This is the number of pixels by which the tooltip will need to be pulled\n// further to the right to center it over the `seekBarPoint`.\nvar pullTooltipBy=tooltipRect.width/2;// Adjust the `pullTooltipBy` distance to the left or right depending on\n// the results of the space calculations above.\nif(spaceLeftOfPoint<pullTooltipBy){pullTooltipBy+=pullTooltipBy-spaceLeftOfPoint;}else if(spaceRightOfPoint<pullTooltipBy){pullTooltipBy=spaceRightOfPoint;}// Due to the imprecision of decimal/ratio based calculations and varying\n// rounding behaviors, there are cases where the spacing adjustment is off\n// by a pixel or two. This adds insurance to these calculations.\nif(pullTooltipBy<0){pullTooltipBy=0;}else if(pullTooltipBy>tooltipRect.width){pullTooltipBy=tooltipRect.width;}this.el_.style.right='-'+pullTooltipBy+'px';textContent(this.el_,content);};return TimeTooltip;}(Component);Component.registerComponent('TimeTooltip',TimeTooltip);/**\n * @file play-progress-bar.js\n *//**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */var PlayProgressBar=function(_Component){inherits(PlayProgressBar,_Component);function PlayProgressBar(){classCallCheck(this,PlayProgressBar);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */PlayProgressBar.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-play-progress vjs-slider-bar',innerHTML:'<span class=\"vjs-control-text\"><span>'+this.localize('Progress')+'</span>: 0%</span>'});};/**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */PlayProgressBar.prototype.update=function update(seekBarRect,seekBarPoint){var _this2=this;// If there is an existing rAF ID, cancel it so we don't over-queue.\nif(this.rafId_){this.cancelAnimationFrame(this.rafId_);}this.rafId_=this.requestAnimationFrame(function(){var time=_this2.player_.scrubbing()?_this2.player_.getCache().currentTime:_this2.player_.currentTime();var content=formatTime(time,_this2.player_.duration());var timeTooltip=_this2.getChild('timeTooltip');if(timeTooltip){timeTooltip.update(seekBarRect,seekBarPoint,content);}});};return PlayProgressBar;}(Component);/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */PlayProgressBar.prototype.options_={children:[]};// Time tooltips should not be added to a player on mobile devices or IE8\nif((!IE_VERSION||IE_VERSION>8)&&!IS_IOS&&!IS_ANDROID){PlayProgressBar.prototype.options_.children.push('timeTooltip');}Component.registerComponent('PlayProgressBar',PlayProgressBar);/**\n * @file mouse-time-display.js\n *//**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */var MouseTimeDisplay=function(_Component){inherits(MouseTimeDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function MouseTimeDisplay(player,options){classCallCheck(this,MouseTimeDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.update=throttle(bind(_this,_this.update),25);return _this;}/**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */MouseTimeDisplay.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-mouse-display'});};/**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */MouseTimeDisplay.prototype.update=function update(seekBarRect,seekBarPoint){var _this2=this;// If there is an existing rAF ID, cancel it so we don't over-queue.\nif(this.rafId_){this.cancelAnimationFrame(this.rafId_);}this.rafId_=this.requestAnimationFrame(function(){var duration=_this2.player_.duration();var content=formatTime(seekBarPoint*duration,duration);_this2.el_.style.left=seekBarRect.width*seekBarPoint+'px';_this2.getChild('timeTooltip').update(seekBarRect,seekBarPoint,content);});};return MouseTimeDisplay;}(Component);/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */MouseTimeDisplay.prototype.options_={children:['timeTooltip']};Component.registerComponent('MouseTimeDisplay',MouseTimeDisplay);/**\n * @file seek-bar.js\n */// The number of seconds the `step*` functions move the timeline.\nvar STEP_SECONDS=5;// The interval at which the bar should update as it progresses.\nvar UPDATE_REFRESH_INTERVAL=30;/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */var SeekBar=function(_Slider){inherits(SeekBar,_Slider);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function SeekBar(player,options){classCallCheck(this,SeekBar);var _this=possibleConstructorReturn(this,_Slider.call(this,player,options));_this.update=throttle(bind(_this,_this.update),UPDATE_REFRESH_INTERVAL);_this.on(player,'timeupdate',_this.update);_this.on(player,'ended',_this.handleEnded);// when playing, let's ensure we smoothly update the play progress bar\n// via an interval\n_this.updateInterval=null;_this.on(player,['playing'],function(){_this.clearInterval(_this.updateInterval);_this.updateInterval=_this.setInterval(function(){_this.requestAnimationFrame(function(){_this.update();});},UPDATE_REFRESH_INTERVAL);});_this.on(player,['ended','pause','waiting'],function(){_this.clearInterval(_this.updateInterval);});_this.on(player,['timeupdate','ended'],_this.update);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */SeekBar.prototype.createEl=function createEl$$1(){return _Slider.prototype.createEl.call(this,'div',{className:'vjs-progress-holder'},{'aria-label':this.localize('Progress Bar')});};/**\n   * This function updates the play progress bar and accessiblity\n   * attributes to whatever is passed in.\n   *\n   * @param {number} currentTime\n   *        The currentTime value that should be used for accessiblity\n   *\n   * @param {number} percent\n   *        The percentage as a decimal that the bar should be filled from 0-1.\n   *\n   * @private\n   */SeekBar.prototype.update_=function update_(currentTime,percent){var duration=this.player_.duration();// machine readable value of progress bar (percentage complete)\nthis.el_.setAttribute('aria-valuenow',(percent*100).toFixed(2));// human readable value of progress bar (time complete)\nthis.el_.setAttribute('aria-valuetext',this.localize('progress bar timing: currentTime={1} duration={2}',[formatTime(currentTime,duration),formatTime(duration,duration)],'{1} of {2}'));// Update the `PlayProgressBar`.\nthis.bar.update(getBoundingClientRect(this.el_),percent);};/**\n   * Update the seek bar's UI.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @returns {number}\n   *          The current percent at a number from 0-1\n   */SeekBar.prototype.update=function update(event){var percent=_Slider.prototype.update.call(this);this.update_(this.getCurrentTime_(),percent);return percent;};/**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */SeekBar.prototype.getCurrentTime_=function getCurrentTime_(){return this.player_.scrubbing()?this.player_.getCache().currentTime:this.player_.currentTime();};/**\n   * We want the seek bar to be full on ended\n   * no matter what the actual internal values are. so we force it.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */SeekBar.prototype.handleEnded=function handleEnded(event){this.update_(this.player_.duration(),1);};/**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */SeekBar.prototype.getPercent=function getPercent(){var percent=this.getCurrentTime_()/this.player_.duration();return percent>=1?1:percent;};/**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */SeekBar.prototype.handleMouseDown=function handleMouseDown(event){if(!isSingleLeftClick(event)){return;}this.player_.scrubbing(true);this.videoWasPlaying=!this.player_.paused();this.player_.pause();_Slider.prototype.handleMouseDown.call(this,event);};/**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */SeekBar.prototype.handleMouseMove=function handleMouseMove(event){if(!isSingleLeftClick(event)){return;}var newTime=this.calculateDistance(event)*this.player_.duration();// Don't let video end while scrubbing.\nif(newTime===this.player_.duration()){newTime=newTime-0.1;}// Set new time (tell player to seek to new time)\nthis.player_.currentTime(newTime);};SeekBar.prototype.enable=function enable(){_Slider.prototype.enable.call(this);var mouseTimeDisplay=this.getChild('mouseTimeDisplay');if(!mouseTimeDisplay){return;}mouseTimeDisplay.show();};SeekBar.prototype.disable=function disable(){_Slider.prototype.disable.call(this);var mouseTimeDisplay=this.getChild('mouseTimeDisplay');if(!mouseTimeDisplay){return;}mouseTimeDisplay.hide();};/**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */SeekBar.prototype.handleMouseUp=function handleMouseUp(event){_Slider.prototype.handleMouseUp.call(this,event);this.player_.scrubbing(false);/**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */this.player_.trigger({type:'timeupdate',target:this,manuallyTriggered:true});if(this.videoWasPlaying){this.player_.play();}};/**\n   * Move more quickly fast forward for keyboard-only users\n   */SeekBar.prototype.stepForward=function stepForward(){this.player_.currentTime(this.player_.currentTime()+STEP_SECONDS);};/**\n   * Move more quickly rewind for keyboard-only users\n   */SeekBar.prototype.stepBack=function stepBack(){this.player_.currentTime(this.player_.currentTime()-STEP_SECONDS);};/**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */SeekBar.prototype.handleAction=function handleAction(event){if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};/**\n   * Called when this SeekBar has focus and a key gets pressed down. By\n   * default it will call `this.handleAction` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */SeekBar.prototype.handleKeyPress=function handleKeyPress(event){// Support Space (32) or Enter (13) key operation to fire a click event\nif(event.which===32||event.which===13){event.preventDefault();this.handleAction(event);}else if(_Slider.prototype.handleKeyPress){// Pass keypress handling up for unsupported keys\n_Slider.prototype.handleKeyPress.call(this,event);}};return SeekBar;}(Slider);/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */SeekBar.prototype.options_={children:['loadProgressBar','playProgressBar'],barName:'playProgressBar'};// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8\nif((!IE_VERSION||IE_VERSION>8)&&!IS_IOS&&!IS_ANDROID){SeekBar.prototype.options_.children.splice(1,0,'mouseTimeDisplay');}/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */SeekBar.prototype.playerEvent='timeupdate';Component.registerComponent('SeekBar',SeekBar);/**\n * @file progress-control.js\n *//**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */var ProgressControl=function(_Component){inherits(ProgressControl,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function ProgressControl(player,options){classCallCheck(this,ProgressControl);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.handleMouseMove=throttle(bind(_this,_this.handleMouseMove),25);_this.throttledHandleMouseSeek=throttle(bind(_this,_this.handleMouseSeek),25);_this.enable();return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */ProgressControl.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-progress-control vjs-control'});};/**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */ProgressControl.prototype.handleMouseMove=function handleMouseMove(event){var seekBar=this.getChild('seekBar');var mouseTimeDisplay=seekBar.getChild('mouseTimeDisplay');var seekBarEl=seekBar.el();var seekBarRect=getBoundingClientRect(seekBarEl);var seekBarPoint=getPointerPosition(seekBarEl,event).x;// The default skin has a gap on either side of the `SeekBar`. This means\n// that it's possible to trigger this behavior outside the boundaries of\n// the `SeekBar`. This ensures we stay within it at all times.\nif(seekBarPoint>1){seekBarPoint=1;}else if(seekBarPoint<0){seekBarPoint=0;}if(mouseTimeDisplay){mouseTimeDisplay.update(seekBarRect,seekBarPoint);}};/**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   *//**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */ProgressControl.prototype.handleMouseSeek=function handleMouseSeek(event){var seekBar=this.getChild('seekBar');seekBar.handleMouseMove(event);};/**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */ProgressControl.prototype.enabled=function enabled(){return this.enabled_;};/**\n   * Disable all controls on the progress control and its children\n   */ProgressControl.prototype.disable=function disable(){this.children().forEach(function(child){return child.disable&&child.disable();});if(!this.enabled()){return;}this.off(['mousedown','touchstart'],this.handleMouseDown);this.off(this.el_,'mousemove',this.handleMouseMove);this.handleMouseUp();this.addClass('disabled');this.enabled_=false;};/**\n   * Enable all controls on the progress control and its children\n   */ProgressControl.prototype.enable=function enable(){this.children().forEach(function(child){return child.enable&&child.enable();});if(this.enabled()){return;}this.on(['mousedown','touchstart'],this.handleMouseDown);this.on(this.el_,'mousemove',this.handleMouseMove);this.removeClass('disabled');this.enabled_=true;};/**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */ProgressControl.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.el_.ownerDocument;this.on(doc,'mousemove',this.throttledHandleMouseSeek);this.on(doc,'touchmove',this.throttledHandleMouseSeek);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */ProgressControl.prototype.handleMouseUp=function handleMouseUp(event){var doc=this.el_.ownerDocument;this.off(doc,'mousemove',this.throttledHandleMouseSeek);this.off(doc,'touchmove',this.throttledHandleMouseSeek);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchend',this.handleMouseUp);};return ProgressControl;}(Component);/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */ProgressControl.prototype.options_={children:['seekBar']};Component.registerComponent('ProgressControl',ProgressControl);/**\n * @file fullscreen-toggle.js\n *//**\n * Toggle fullscreen video\n *\n * @extends Button\n */var FullscreenToggle=function(_Button){inherits(FullscreenToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function FullscreenToggle(player,options){classCallCheck(this,FullscreenToggle);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.on(player,'fullscreenchange',_this.handleFullscreenChange);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */FullscreenToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-fullscreen-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */FullscreenToggle.prototype.handleFullscreenChange=function handleFullscreenChange(event){if(this.player_.isFullscreen()){this.controlText('Non-Fullscreen');}else{this.controlText('Fullscreen');}};/**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */FullscreenToggle.prototype.handleClick=function handleClick(event){if(!this.player_.isFullscreen()){this.player_.requestFullscreen();}else{this.player_.exitFullscreen();}};return FullscreenToggle;}(Button);/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */FullscreenToggle.prototype.controlText_='Fullscreen';Component.registerComponent('FullscreenToggle',FullscreenToggle);/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */var checkVolumeSupport=function checkVolumeSupport(self,player){// hide volume controls when they're not supported by the current tech\nif(player.tech_&&!player.tech_.featuresVolumeControl){self.addClass('vjs-hidden');}self.on(player,'loadstart',function(){if(!player.tech_.featuresVolumeControl){self.addClass('vjs-hidden');}else{self.removeClass('vjs-hidden');}});};/**\n * @file volume-level.js\n *//**\n * Shows volume level\n *\n * @extends Component\n */var VolumeLevel=function(_Component){inherits(VolumeLevel,_Component);function VolumeLevel(){classCallCheck(this,VolumeLevel);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeLevel.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-level',innerHTML:'<span class=\"vjs-control-text\"></span>'});};return VolumeLevel;}(Component);Component.registerComponent('VolumeLevel',VolumeLevel);/**\n * @file volume-bar.js\n */// Required children\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */var VolumeBar=function(_Slider){inherits(VolumeBar,_Slider);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function VolumeBar(player,options){classCallCheck(this,VolumeBar);var _this=possibleConstructorReturn(this,_Slider.call(this,player,options));_this.on('slideractive',_this.updateLastVolume_);_this.on(player,'volumechange',_this.updateARIAAttributes);player.ready(function(){return _this.updateARIAAttributes();});return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeBar.prototype.createEl=function createEl$$1(){return _Slider.prototype.createEl.call(this,'div',{className:'vjs-volume-bar vjs-slider-bar'},{'aria-label':this.localize('Volume Level'),'aria-live':'polite'});};/**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */VolumeBar.prototype.handleMouseDown=function handleMouseDown(event){if(!isSingleLeftClick(event)){return;}_Slider.prototype.handleMouseDown.call(this,event);};/**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */VolumeBar.prototype.handleMouseMove=function handleMouseMove(event){if(!isSingleLeftClick(event)){return;}this.checkMuted();this.player_.volume(this.calculateDistance(event));};/**\n   * If the player is muted unmute it.\n   */VolumeBar.prototype.checkMuted=function checkMuted(){if(this.player_.muted()){this.player_.muted(false);}};/**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */VolumeBar.prototype.getPercent=function getPercent(){if(this.player_.muted()){return 0;}return this.player_.volume();};/**\n   * Increase volume level for keyboard users\n   */VolumeBar.prototype.stepForward=function stepForward(){this.checkMuted();this.player_.volume(this.player_.volume()+0.1);};/**\n   * Decrease volume level for keyboard users\n   */VolumeBar.prototype.stepBack=function stepBack(){this.checkMuted();this.player_.volume(this.player_.volume()-0.1);};/**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */VolumeBar.prototype.updateARIAAttributes=function updateARIAAttributes(event){var ariaValue=this.player_.muted()?0:this.volumeAsPercentage_();this.el_.setAttribute('aria-valuenow',ariaValue);this.el_.setAttribute('aria-valuetext',ariaValue+'%');};/**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */VolumeBar.prototype.volumeAsPercentage_=function volumeAsPercentage_(){return Math.round(this.player_.volume()*100);};/**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */VolumeBar.prototype.updateLastVolume_=function updateLastVolume_(){var _this2=this;var volumeBeforeDrag=this.player_.volume();this.one('sliderinactive',function(){if(_this2.player_.volume()===0){_this2.player_.lastVolume_(volumeBeforeDrag);}});};return VolumeBar;}(Slider);/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */VolumeBar.prototype.options_={children:['volumeLevel'],barName:'volumeLevel'};/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */VolumeBar.prototype.playerEvent='volumechange';Component.registerComponent('VolumeBar',VolumeBar);/**\n * @file volume-control.js\n */// Required children\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */var VolumeControl=function(_Component){inherits(VolumeControl,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function VolumeControl(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,VolumeControl);options.vertical=options.vertical||false;// Pass the vertical option down to the VolumeBar if\n// the VolumeBar is turned on.\nif(typeof options.volumeBar==='undefined'||isPlain(options.volumeBar)){options.volumeBar=options.volumeBar||{};options.volumeBar.vertical=options.vertical;}// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));checkVolumeSupport(_this,player);_this.throttledHandleMouseMove=throttle(bind(_this,_this.handleMouseMove),25);_this.on('mousedown',_this.handleMouseDown);_this.on('touchstart',_this.handleMouseDown);// while the slider is active (the mouse has been pressed down and\n// is dragging) or in focus we do not want to hide the VolumeBar\n_this.on(_this.volumeBar,['focus','slideractive'],function(){_this.volumeBar.addClass('vjs-slider-active');_this.addClass('vjs-slider-active');_this.trigger('slideractive');});_this.on(_this.volumeBar,['blur','sliderinactive'],function(){_this.volumeBar.removeClass('vjs-slider-active');_this.removeClass('vjs-slider-active');_this.trigger('sliderinactive');});return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeControl.prototype.createEl=function createEl(){var orientationClass='vjs-volume-horizontal';if(this.options_.vertical){orientationClass='vjs-volume-vertical';}return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-control vjs-control '+orientationClass});};/**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */VolumeControl.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.el_.ownerDocument;this.on(doc,'mousemove',this.throttledHandleMouseMove);this.on(doc,'touchmove',this.throttledHandleMouseMove);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */VolumeControl.prototype.handleMouseUp=function handleMouseUp(event){var doc=this.el_.ownerDocument;this.off(doc,'mousemove',this.throttledHandleMouseMove);this.off(doc,'touchmove',this.throttledHandleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */VolumeControl.prototype.handleMouseMove=function handleMouseMove(event){this.volumeBar.handleMouseMove(event);};return VolumeControl;}(Component);/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */VolumeControl.prototype.options_={children:['volumeBar']};Component.registerComponent('VolumeControl',VolumeControl);/**\n * @file mute-toggle.js\n *//**\n * A button component for muting the audio.\n *\n * @extends Button\n */var MuteToggle=function(_Button){inherits(MuteToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function MuteToggle(player,options){classCallCheck(this,MuteToggle);// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Button.call(this,player,options));checkVolumeSupport(_this,player);_this.on(player,['loadstart','volumechange'],_this.update);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */MuteToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-mute-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MuteToggle.prototype.handleClick=function handleClick(event){var vol=this.player_.volume();var lastVolume=this.player_.lastVolume_();if(vol===0){var volumeToSet=lastVolume<0.1?0.1:lastVolume;this.player_.volume(volumeToSet);this.player_.muted(false);}else{this.player_.muted(this.player_.muted()?false:true);}};/**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */MuteToggle.prototype.update=function update(event){this.updateIcon_();this.updateControlText_();};/**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */MuteToggle.prototype.updateIcon_=function updateIcon_(){var vol=this.player_.volume();var level=3;if(vol===0||this.player_.muted()){level=0;}else if(vol<0.33){level=1;}else if(vol<0.67){level=2;}// TODO improve muted icon classes\nfor(var i=0;i<4;i++){removeClass(this.el_,'vjs-vol-'+i);}addClass(this.el_,'vjs-vol-'+level);};/**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */MuteToggle.prototype.updateControlText_=function updateControlText_(){var soundOff=this.player_.muted()||this.player_.volume()===0;var text=soundOff?'Unmute':'Mute';if(this.controlText()!==text){this.controlText(text);}};return MuteToggle;}(Button);/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */MuteToggle.prototype.controlText_='Mute';Component.registerComponent('MuteToggle',MuteToggle);/**\n * @file volume-control.js\n */// Required children\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */var VolumePanel=function(_Component){inherits(VolumePanel,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function VolumePanel(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,VolumePanel);if(typeof options.inline!=='undefined'){options.inline=options.inline;}else{options.inline=true;}// pass the inline option down to the VolumeControl as vertical if\n// the VolumeControl is on.\nif(typeof options.volumeControl==='undefined'||isPlain(options.volumeControl)){options.volumeControl=options.volumeControl||{};options.volumeControl.vertical=!options.inline;}// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));checkVolumeSupport(_this,player);// while the slider is active (the mouse has been pressed down and\n// is dragging) or in focus we do not want to hide the VolumeBar\n_this.on(_this.volumeControl,['slideractive'],_this.sliderActive_);_this.on(_this.muteToggle,'focus',_this.sliderActive_);_this.on(_this.volumeControl,['sliderinactive'],_this.sliderInactive_);_this.on(_this.muteToggle,'blur',_this.sliderInactive_);return _this;}/**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */VolumePanel.prototype.sliderActive_=function sliderActive_(){this.addClass('vjs-slider-active');};/**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */VolumePanel.prototype.sliderInactive_=function sliderInactive_(){this.removeClass('vjs-slider-active');};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumePanel.prototype.createEl=function createEl(){var orientationClass='vjs-volume-panel-horizontal';if(!this.options_.inline){orientationClass='vjs-volume-panel-vertical';}return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-panel vjs-control '+orientationClass});};return VolumePanel;}(Component);/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */VolumePanel.prototype.options_={children:['muteToggle','volumeControl']};Component.registerComponent('VolumePanel',VolumePanel);/**\n * @file menu.js\n *//**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */var Menu=function(_Component){inherits(Menu,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */function Menu(player,options){classCallCheck(this,Menu);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));if(options){_this.menuButton_=options.menuButton;}_this.focusedChild_=-1;_this.on('keydown',_this.handleKeyPress);return _this;}/**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */Menu.prototype.addItem=function addItem(component){this.addChild(component);component.on('click',bind(this,function(event){// Unpress the associated MenuButton, and move focus back to it\nif(this.menuButton_){this.menuButton_.unpressButton();// don't focus menu button if item is a caption settings item\n// because focus will move elsewhere and it logs an error on IE8\nif(component.name()!=='CaptionSettingsMenuItem'){this.menuButton_.focus();}}}));};/**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */Menu.prototype.createEl=function createEl$$1(){var contentElType=this.options_.contentElType||'ul';this.contentEl_=createEl(contentElType,{className:'vjs-menu-content'});this.contentEl_.setAttribute('role','menu');var el=_Component.prototype.createEl.call(this,'div',{append:this.contentEl_,className:'vjs-menu'});el.appendChild(this.contentEl_);// Prevent clicks from bubbling up. Needed for Menu Buttons,\n// where a click on the parent is significant\non(el,'click',function(event){event.preventDefault();event.stopImmediatePropagation();});return el;};Menu.prototype.dispose=function dispose(){this.contentEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */Menu.prototype.handleKeyPress=function handleKeyPress(event){// Left and Down Arrows\nif(event.which===37||event.which===40){event.preventDefault();this.stepForward();// Up and Right Arrows\n}else if(event.which===38||event.which===39){event.preventDefault();this.stepBack();}};/**\n   * Move to next (lower) menu item for keyboard users.\n   */Menu.prototype.stepForward=function stepForward(){var stepChild=0;if(this.focusedChild_!==undefined){stepChild=this.focusedChild_+1;}this.focus(stepChild);};/**\n   * Move to previous (higher) menu item for keyboard users.\n   */Menu.prototype.stepBack=function stepBack(){var stepChild=0;if(this.focusedChild_!==undefined){stepChild=this.focusedChild_-1;}this.focus(stepChild);};/**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */Menu.prototype.focus=function focus(){var item=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var children=this.children().slice();var haveTitle=children.length&&children[0].className&&/vjs-menu-title/.test(children[0].className);if(haveTitle){children.shift();}if(children.length>0){if(item<0){item=0;}else if(item>=children.length){item=children.length-1;}this.focusedChild_=item;children[item].el_.focus();}};return Menu;}(Component);Component.registerComponent('Menu',Menu);/**\n * @file menu-button.js\n *//**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */var MenuButton=function(_Component){inherits(MenuButton,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function MenuButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,MenuButton);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.menuButton_=new Button(player,options);_this.menuButton_.controlText(_this.controlText_);_this.menuButton_.el_.setAttribute('aria-haspopup','true');// Add buildCSSClass values to the button, not the wrapper\nvar buttonClass=Button.prototype.buildCSSClass();_this.menuButton_.el_.className=_this.buildCSSClass()+' '+buttonClass;_this.menuButton_.removeClass('vjs-control');_this.addChild(_this.menuButton_);_this.update();_this.enabled_=true;_this.on(_this.menuButton_,'tap',_this.handleClick);_this.on(_this.menuButton_,'click',_this.handleClick);_this.on(_this.menuButton_,'focus',_this.handleFocus);_this.on(_this.menuButton_,'blur',_this.handleBlur);_this.on('keydown',_this.handleSubmenuKeyPress);return _this;}/**\n   * Update the menu based on the current state of its items.\n   */MenuButton.prototype.update=function update(){var menu=this.createMenu();if(this.menu){this.menu.dispose();this.removeChild(this.menu);}this.menu=menu;this.addChild(menu);/**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */this.buttonPressed_=false;this.menuButton_.el_.setAttribute('aria-expanded','false');if(this.items&&this.items.length<=this.hideThreshold_){this.hide();}else{this.show();}};/**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */MenuButton.prototype.createMenu=function createMenu(){var menu=new Menu(this.player_,{menuButton:this});/**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */this.hideThreshold_=0;// Add a title list item to the top\nif(this.options_.title){var title=createEl('li',{className:'vjs-menu-title',innerHTML:toTitleCase(this.options_.title),tabIndex:-1});this.hideThreshold_+=1;menu.children_.unshift(title);prependTo(title,menu.contentEl());}this.items=this.createItems();if(this.items){// Add menu items to the menu\nfor(var i=0;i<this.items.length;i++){menu.addItem(this.items[i]);}}return menu;};/**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */MenuButton.prototype.createItems=function createItems(){};/**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */MenuButton.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:this.buildWrapperCSSClass()},{});};/**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */MenuButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){var menuButtonClass='vjs-menu-button';// If the inline option is passed, we want to use different styles altogether.\nif(this.options_.inline===true){menuButtonClass+='-inline';}else{menuButtonClass+='-popup';}// TODO: Fix the CSS so that this isn't necessary\nvar buttonClass=Button.prototype.buildCSSClass();return'vjs-menu-button '+menuButtonClass+' '+buttonClass+' '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */MenuButton.prototype.buildCSSClass=function buildCSSClass(){var menuButtonClass='vjs-menu-button';// If the inline option is passed, we want to use different styles altogether.\nif(this.options_.inline===true){menuButtonClass+='-inline';}else{menuButtonClass+='-popup';}return'vjs-menu-button '+menuButtonClass+' '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */MenuButton.prototype.controlText=function controlText(text){var el=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.menuButton_.el();return this.menuButton_.controlText(text,el);};/**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MenuButton.prototype.handleClick=function handleClick(event){// When you click the button it adds focus, which will show the menu.\n// So we'll remove focus when the mouse leaves the button. Focus is needed\n// for tab navigation.\nthis.one(this.menu.contentEl(),'mouseleave',bind(this,function(e){this.unpressButton();this.el_.blur();}));if(this.buttonPressed_){this.unpressButton();}else{this.pressButton();}};/**\n   * Set the focus to the actual button, not to this element\n   */MenuButton.prototype.focus=function focus(){this.menuButton_.focus();};/**\n   * Remove the focus from the actual button, not this element\n   */MenuButton.prototype.blur=function blur(){this.menuButton_.blur();};/**\n   * This gets called when a `MenuButton` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */MenuButton.prototype.handleFocus=function handleFocus(){on(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Called when a `MenuButton` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */MenuButton.prototype.handleBlur=function handleBlur(){off(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyPress} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */MenuButton.prototype.handleKeyPress=function handleKeyPress(event){// Escape (27) key or Tab (9) key unpress the 'button'\nif(event.which===27||event.which===9){if(this.buttonPressed_){this.unpressButton();}// Don't preventDefault for Tab key - we still want to lose focus\nif(event.which!==9){event.preventDefault();// Set focus back to the menu button's button\nthis.menuButton_.el_.focus();}// Up (38) key or Down (40) key press the 'button'\n}else if(event.which===38||event.which===40){if(!this.buttonPressed_){this.pressButton();event.preventDefault();}}};/**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */MenuButton.prototype.handleSubmenuKeyPress=function handleSubmenuKeyPress(event){// Escape (27) key or Tab (9) key unpress the 'button'\nif(event.which===27||event.which===9){if(this.buttonPressed_){this.unpressButton();}// Don't preventDefault for Tab key - we still want to lose focus\nif(event.which!==9){event.preventDefault();// Set focus back to the menu button's button\nthis.menuButton_.el_.focus();}}};/**\n   * Put the current `MenuButton` into a pressed state.\n   */MenuButton.prototype.pressButton=function pressButton(){if(this.enabled_){this.buttonPressed_=true;this.menu.lockShowing();this.menuButton_.el_.setAttribute('aria-expanded','true');// set the focus into the submenu, except on iOS where it is resulting in\n// undesired scrolling behavior when the player is in an iframe\nif(IS_IOS&&isInFrame()){// Return early so that the menu isn't focused\nreturn;}this.menu.focus();}};/**\n   * Take the current `MenuButton` out of a pressed state.\n   */MenuButton.prototype.unpressButton=function unpressButton(){if(this.enabled_){this.buttonPressed_=false;this.menu.unlockShowing();this.menuButton_.el_.setAttribute('aria-expanded','false');}};/**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */MenuButton.prototype.disable=function disable(){this.unpressButton();this.enabled_=false;this.addClass('vjs-disabled');this.menuButton_.disable();};/**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */MenuButton.prototype.enable=function enable(){this.enabled_=true;this.removeClass('vjs-disabled');this.menuButton_.enable();};return MenuButton;}(Component);Component.registerComponent('MenuButton',MenuButton);/**\n * @file track-button.js\n *//**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */var TrackButton=function(_MenuButton){inherits(TrackButton,_MenuButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TrackButton(player,options){classCallCheck(this,TrackButton);var tracks=options.tracks;var _this=possibleConstructorReturn(this,_MenuButton.call(this,player,options));if(_this.items.length<=1){_this.hide();}if(!tracks){return possibleConstructorReturn(_this);}var updateHandler=bind(_this,_this.update);tracks.addEventListener('removetrack',updateHandler);tracks.addEventListener('addtrack',updateHandler);_this.player_.on('ready',updateHandler);_this.player_.on('dispose',function(){tracks.removeEventListener('removetrack',updateHandler);tracks.removeEventListener('addtrack',updateHandler);});return _this;}return TrackButton;}(MenuButton);Component.registerComponent('TrackButton',TrackButton);/**\n * @file menu-item.js\n *//**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */var MenuItem=function(_ClickableComponent){inherits(MenuItem,_ClickableComponent);/**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */function MenuItem(player,options){classCallCheck(this,MenuItem);var _this=possibleConstructorReturn(this,_ClickableComponent.call(this,player,options));_this.selectable=options.selectable;_this.selected(options.selected);if(_this.selectable){// TODO: May need to be either menuitemcheckbox or menuitemradio,\n//       and may need logical grouping of menu items.\n_this.el_.setAttribute('role','menuitemcheckbox');}else{_this.el_.setAttribute('role','menuitem');}return _this;}/**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */MenuItem.prototype.createEl=function createEl(type,props,attrs){// The control is textual, not just an icon\nthis.nonIconControl=true;return _ClickableComponent.prototype.createEl.call(this,'li',assign({className:'vjs-menu-item',innerHTML:'<span class=\"vjs-menu-item-text\">'+this.localize(this.options_.label)+'</span>',tabIndex:-1},props),attrs);};/**\n   * Any click on a `MenuItem` puts int into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MenuItem.prototype.handleClick=function handleClick(event){this.selected(true);};/**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */MenuItem.prototype.selected=function selected(_selected){if(this.selectable){if(_selected){this.addClass('vjs-selected');this.el_.setAttribute('aria-checked','true');// aria-checked isn't fully supported by browsers/screen readers,\n// so indicate selected state to screen reader in the control text.\nthis.controlText(', selected');}else{this.removeClass('vjs-selected');this.el_.setAttribute('aria-checked','false');// Indicate un-selected state to screen reader\nthis.controlText('');}}};return MenuItem;}(ClickableComponent);Component.registerComponent('MenuItem',MenuItem);/**\n * @file text-track-menu-item.js\n *//**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */var TextTrackMenuItem=function(_MenuItem){inherits(TextTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TextTrackMenuItem(player,options){classCallCheck(this,TextTrackMenuItem);var track=options.track;var tracks=player.textTracks();// Modify options for parent MenuItem class's init.\noptions.label=track.label||track.language||'Unknown';options.selected=track.mode==='showing';var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;var changeHandler=function changeHandler(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this.handleTracksChange.apply(_this,args);};var selectedLanguageChangeHandler=function selectedLanguageChangeHandler(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}_this.handleSelectedLanguageChange.apply(_this,args);};player.on(['loadstart','texttrackchange'],changeHandler);tracks.addEventListener('change',changeHandler);tracks.addEventListener('selectedlanguagechange',selectedLanguageChangeHandler);_this.on('dispose',function(){player.off(['loadstart','texttrackchange'],changeHandler);tracks.removeEventListener('change',changeHandler);tracks.removeEventListener('selectedlanguagechange',selectedLanguageChangeHandler);});// iOS7 doesn't dispatch change events to TextTrackLists when an\n// associated track's mode changes. Without something like\n// Object.observe() (also not present on iOS7), it's not\n// possible to detect changes to the mode attribute and polyfill\n// the change event. As a poor substitute, we manually dispatch\n// change events whenever the controls modify the mode.\nif(tracks.onchange===undefined){var event=void 0;_this.on(['tap','click'],function(){if(_typeof(window.Event)!=='object'){// Android 2.3 throws an Illegal Constructor error for window.Event\ntry{event=new window.Event('change');}catch(err){// continue regardless of error\n}}if(!event){event=document.createEvent('Event');event.initEvent('change',true,true);}tracks.dispatchEvent(event);});}// set the default state based on current tracks\n_this.handleTracksChange();return _this;}/**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */TextTrackMenuItem.prototype.handleClick=function handleClick(event){var kind=this.track.kind;var kinds=this.track.kinds;var tracks=this.player_.textTracks();if(!kinds){kinds=[kind];}_MenuItem.prototype.handleClick.call(this,event);if(!tracks){return;}for(var i=0;i<tracks.length;i++){var track=tracks[i];if(track===this.track&&kinds.indexOf(track.kind)>-1){if(track.mode!=='showing'){track.mode='showing';}}else if(track.mode!=='disabled'){track.mode='disabled';}}};/**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */TextTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){this.selected(this.track.mode==='showing');};TextTrackMenuItem.prototype.handleSelectedLanguageChange=function handleSelectedLanguageChange(event){if(this.track.mode==='showing'){var selectedLanguage=this.player_.cache_.selectedLanguage;// Don't replace the kind of track across the same language\nif(selectedLanguage&&selectedLanguage.enabled&&selectedLanguage.language===this.track.language&&selectedLanguage.kind!==this.track.kind){return;}this.player_.cache_.selectedLanguage={enabled:true,language:this.track.language,kind:this.track.kind};}};TextTrackMenuItem.prototype.dispose=function dispose(){// remove reference to track object on dispose\nthis.track=null;_MenuItem.prototype.dispose.call(this);};return TextTrackMenuItem;}(MenuItem);Component.registerComponent('TextTrackMenuItem',TextTrackMenuItem);/**\n * @file off-text-track-menu-item.js\n *//**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */var OffTextTrackMenuItem=function(_TextTrackMenuItem){inherits(OffTextTrackMenuItem,_TextTrackMenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function OffTextTrackMenuItem(player,options){classCallCheck(this,OffTextTrackMenuItem);// Create pseudo track info\n// Requires options['kind']\noptions.track={player:player,kind:options.kind,kinds:options.kinds,'default':false,mode:'disabled'};if(!options.kinds){options.kinds=[options.kind];}if(options.label){options.track.label=options.label;}else{options.track.label=options.kinds.join(' and ')+' off';}// MenuItem is selectable\noptions.selectable=true;return possibleConstructorReturn(this,_TextTrackMenuItem.call(this,player,options));}/**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */OffTextTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){var tracks=this.player().textTracks();var selected=true;for(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(this.options_.kinds.indexOf(track.kind)>-1&&track.mode==='showing'){selected=false;break;}}this.selected(selected);};OffTextTrackMenuItem.prototype.handleSelectedLanguageChange=function handleSelectedLanguageChange(event){var tracks=this.player().textTracks();var allHidden=true;for(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(['captions','descriptions','subtitles'].indexOf(track.kind)>-1&&track.mode==='showing'){allHidden=false;break;}}if(allHidden){this.player_.cache_.selectedLanguage={enabled:false};}};return OffTextTrackMenuItem;}(TextTrackMenuItem);Component.registerComponent('OffTextTrackMenuItem',OffTextTrackMenuItem);/**\n * @file text-track-button.js\n *//**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */var TextTrackButton=function(_TrackButton){inherits(TextTrackButton,_TrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function TextTrackButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,TextTrackButton);options.tracks=player.textTracks();return possibleConstructorReturn(this,_TrackButton.call(this,player,options));}/**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */TextTrackButton.prototype.createItems=function createItems(){var items=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var TrackMenuItem=arguments.length>1&&arguments[1]!==undefined?arguments[1]:TextTrackMenuItem;// Label is an overide for the [track] off label\n// USed to localise captions/subtitles\nvar label=void 0;if(this.label_){label=this.label_+' off';}// Add an OFF menu item to turn all tracks off\nitems.push(new OffTextTrackMenuItem(this.player_,{kinds:this.kinds_,kind:this.kind_,label:label}));this.hideThreshold_+=1;var tracks=this.player_.textTracks();if(!Array.isArray(this.kinds_)){this.kinds_=[this.kind_];}for(var i=0;i<tracks.length;i++){var track=tracks[i];// only add tracks that are of an appropriate kind and have a label\nif(this.kinds_.indexOf(track.kind)>-1){var item=new TrackMenuItem(this.player_,{track:track,// MenuItem is selectable\nselectable:true});item.addClass('vjs-'+track.kind+'-menu-item');items.push(item);}}return items;};return TextTrackButton;}(TrackButton);Component.registerComponent('TextTrackButton',TextTrackButton);/**\n * @file chapters-track-menu-item.js\n *//**\n * The chapter track menu item\n *\n * @extends MenuItem\n */var ChaptersTrackMenuItem=function(_MenuItem){inherits(ChaptersTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function ChaptersTrackMenuItem(player,options){classCallCheck(this,ChaptersTrackMenuItem);var track=options.track;var cue=options.cue;var currentTime=player.currentTime();// Modify options for parent MenuItem class's init.\noptions.selectable=true;options.label=cue.text;options.selected=cue.startTime<=currentTime&&currentTime<cue.endTime;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;_this.cue=cue;track.addEventListener('cuechange',bind(_this,_this.update));return _this;}/**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */ChaptersTrackMenuItem.prototype.handleClick=function handleClick(event){_MenuItem.prototype.handleClick.call(this);this.player_.currentTime(this.cue.startTime);this.update(this.cue.startTime);};/**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */ChaptersTrackMenuItem.prototype.update=function update(event){var cue=this.cue;var currentTime=this.player_.currentTime();// vjs.log(currentTime, cue.startTime);\nthis.selected(cue.startTime<=currentTime&&currentTime<cue.endTime);};return ChaptersTrackMenuItem;}(MenuItem);Component.registerComponent('ChaptersTrackMenuItem',ChaptersTrackMenuItem);/**\n * @file chapters-button.js\n *//**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */var ChaptersButton=function(_TextTrackButton){inherits(ChaptersButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */function ChaptersButton(player,options,ready){classCallCheck(this,ChaptersButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ChaptersButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-chapters-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};ChaptersButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-chapters-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */ChaptersButton.prototype.update=function update(event){if(!this.track_||event&&(event.type==='addtrack'||event.type==='removetrack')){this.setTrack(this.findChaptersTrack());}_TextTrackButton.prototype.update.call(this);};/**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */ChaptersButton.prototype.setTrack=function setTrack(track){if(this.track_===track){return;}if(!this.updateHandler_){this.updateHandler_=this.update.bind(this);}// here this.track_ refers to the old track instance\nif(this.track_){var remoteTextTrackEl=this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);if(remoteTextTrackEl){remoteTextTrackEl.removeEventListener('load',this.updateHandler_);}this.track_=null;}this.track_=track;// here this.track_ refers to the new track instance\nif(this.track_){this.track_.mode='hidden';var _remoteTextTrackEl=this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);if(_remoteTextTrackEl){_remoteTextTrackEl.addEventListener('load',this.updateHandler_);}}};/**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */ChaptersButton.prototype.findChaptersTrack=function findChaptersTrack(){var tracks=this.player_.textTracks()||[];for(var i=tracks.length-1;i>=0;i--){// We will always choose the last track as our chaptersTrack\nvar track=tracks[i];if(track.kind===this.kind_){return track;}}};/**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */ChaptersButton.prototype.getMenuCaption=function getMenuCaption(){if(this.track_&&this.track_.label){return this.track_.label;}return this.localize(toTitleCase(this.kind_));};/**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */ChaptersButton.prototype.createMenu=function createMenu(){this.options_.title=this.getMenuCaption();return _TextTrackButton.prototype.createMenu.call(this);};/**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */ChaptersButton.prototype.createItems=function createItems(){var items=[];if(!this.track_){return items;}var cues=this.track_.cues;if(!cues){return items;}for(var i=0,l=cues.length;i<l;i++){var cue=cues[i];var mi=new ChaptersTrackMenuItem(this.player_,{track:this.track_,cue:cue});items.push(mi);}return items;};return ChaptersButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */ChaptersButton.prototype.kind_='chapters';/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */ChaptersButton.prototype.controlText_='Chapters';Component.registerComponent('ChaptersButton',ChaptersButton);/**\n * @file descriptions-button.js\n *//**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */var DescriptionsButton=function(_TextTrackButton){inherits(DescriptionsButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function DescriptionsButton(player,options,ready){classCallCheck(this,DescriptionsButton);var _this=possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));var tracks=player.textTracks();var changeHandler=bind(_this,_this.handleTracksChange);tracks.addEventListener('change',changeHandler);_this.on('dispose',function(){tracks.removeEventListener('change',changeHandler);});return _this;}/**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */DescriptionsButton.prototype.handleTracksChange=function handleTracksChange(event){var tracks=this.player().textTracks();var disabled=false;// Check whether a track of a different kind is showing\nfor(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(track.kind!==this.kind_&&track.mode==='showing'){disabled=true;break;}}// If another track is showing, disable this menu button\nif(disabled){this.disable();}else{this.enable();}};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */DescriptionsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-descriptions-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};DescriptionsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-descriptions-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};return DescriptionsButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */DescriptionsButton.prototype.kind_='descriptions';/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */DescriptionsButton.prototype.controlText_='Descriptions';Component.registerComponent('DescriptionsButton',DescriptionsButton);/**\n * @file subtitles-button.js\n *//**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */var SubtitlesButton=function(_TextTrackButton){inherits(SubtitlesButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function SubtitlesButton(player,options,ready){classCallCheck(this,SubtitlesButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */SubtitlesButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-subtitles-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};SubtitlesButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-subtitles-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};return SubtitlesButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */SubtitlesButton.prototype.kind_='subtitles';/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */SubtitlesButton.prototype.controlText_='Subtitles';Component.registerComponent('SubtitlesButton',SubtitlesButton);/**\n * @file caption-settings-menu-item.js\n *//**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */var CaptionSettingsMenuItem=function(_TextTrackMenuItem){inherits(CaptionSettingsMenuItem,_TextTrackMenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function CaptionSettingsMenuItem(player,options){classCallCheck(this,CaptionSettingsMenuItem);options.track={player:player,kind:options.kind,label:options.kind+' settings',selectable:false,'default':false,mode:'disabled'};// CaptionSettingsMenuItem has no concept of 'selected'\noptions.selectable=false;options.name='CaptionSettingsMenuItem';var _this=possibleConstructorReturn(this,_TextTrackMenuItem.call(this,player,options));_this.addClass('vjs-texttrack-settings');_this.controlText(', opens '+options.kind+' settings dialog');return _this;}/**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */CaptionSettingsMenuItem.prototype.handleClick=function handleClick(event){this.player().getChild('textTrackSettings').open();};return CaptionSettingsMenuItem;}(TextTrackMenuItem);Component.registerComponent('CaptionSettingsMenuItem',CaptionSettingsMenuItem);/**\n * @file captions-button.js\n *//**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */var CaptionsButton=function(_TextTrackButton){inherits(CaptionsButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function CaptionsButton(player,options,ready){classCallCheck(this,CaptionsButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CaptionsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-captions-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};CaptionsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-captions-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */CaptionsButton.prototype.createItems=function createItems(){var items=[];if(!(this.player().tech_&&this.player().tech_.featuresNativeTextTracks)){items.push(new CaptionSettingsMenuItem(this.player_,{kind:this.kind_}));this.hideThreshold_+=1;}return _TextTrackButton.prototype.createItems.call(this,items);};return CaptionsButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */CaptionsButton.prototype.kind_='captions';/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */CaptionsButton.prototype.controlText_='Captions';Component.registerComponent('CaptionsButton',CaptionsButton);/**\n * @file subs-caps-menu-item.js\n *//**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */var SubsCapsMenuItem=function(_TextTrackMenuItem){inherits(SubsCapsMenuItem,_TextTrackMenuItem);function SubsCapsMenuItem(){classCallCheck(this,SubsCapsMenuItem);return possibleConstructorReturn(this,_TextTrackMenuItem.apply(this,arguments));}SubsCapsMenuItem.prototype.createEl=function createEl(type,props,attrs){var innerHTML='<span class=\"vjs-menu-item-text\">'+this.localize(this.options_.label);if(this.options_.track.kind==='captions'){innerHTML+='\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> '+this.localize('Captions')+'</span>\\n      ';}innerHTML+='</span>';var el=_TextTrackMenuItem.prototype.createEl.call(this,type,assign({innerHTML:innerHTML},props),attrs);return el;};return SubsCapsMenuItem;}(TextTrackMenuItem);Component.registerComponent('SubsCapsMenuItem',SubsCapsMenuItem);/**\n * @file sub-caps-button.js\n *//**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */var SubsCapsButton=function(_TextTrackButton){inherits(SubsCapsButton,_TextTrackButton);function SubsCapsButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,SubsCapsButton);// Although North America uses \"captions\" in most cases for\n// \"captions and subtitles\" other locales use \"subtitles\"\nvar _this=possibleConstructorReturn(this,_TextTrackButton.call(this,player,options));_this.label_='subtitles';if(['en','en-us','en-ca','fr-ca'].indexOf(_this.player_.language_)>-1){_this.label_='captions';}_this.menuButton_.controlText(toTitleCase(_this.label_));return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */SubsCapsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-subs-caps-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};SubsCapsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-subs-caps-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */SubsCapsButton.prototype.createItems=function createItems(){var items=[];if(!(this.player().tech_&&this.player().tech_.featuresNativeTextTracks)){items.push(new CaptionSettingsMenuItem(this.player_,{kind:this.label_}));this.hideThreshold_+=1;}items=_TextTrackButton.prototype.createItems.call(this,items,SubsCapsMenuItem);return items;};return SubsCapsButton;}(TextTrackButton);/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */SubsCapsButton.prototype.kinds_=['captions','subtitles'];/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */SubsCapsButton.prototype.controlText_='Subtitles';Component.registerComponent('SubsCapsButton',SubsCapsButton);/**\n * @file audio-track-menu-item.js\n *//**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */var AudioTrackMenuItem=function(_MenuItem){inherits(AudioTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function AudioTrackMenuItem(player,options){classCallCheck(this,AudioTrackMenuItem);var track=options.track;var tracks=player.audioTracks();// Modify options for parent MenuItem class's init.\noptions.label=track.label||track.language||'Unknown';options.selected=track.enabled;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;var changeHandler=bind(_this,_this.handleTracksChange);tracks.addEventListener('change',changeHandler);_this.on('dispose',function(){tracks.removeEventListener('change',changeHandler);});return _this;}/**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */AudioTrackMenuItem.prototype.handleClick=function handleClick(event){var tracks=this.player_.audioTracks();_MenuItem.prototype.handleClick.call(this,event);for(var i=0;i<tracks.length;i++){var track=tracks[i];track.enabled=track===this.track;}};/**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */AudioTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){this.selected(this.track.enabled);};return AudioTrackMenuItem;}(MenuItem);Component.registerComponent('AudioTrackMenuItem',AudioTrackMenuItem);/**\n * @file audio-track-button.js\n *//**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */var AudioTrackButton=function(_TrackButton){inherits(AudioTrackButton,_TrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function AudioTrackButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,AudioTrackButton);options.tracks=player.audioTracks();return possibleConstructorReturn(this,_TrackButton.call(this,player,options));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */AudioTrackButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-audio-button '+_TrackButton.prototype.buildCSSClass.call(this);};AudioTrackButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-audio-button '+_TrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */AudioTrackButton.prototype.createItems=function createItems(){var items=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];// if there's only one audio track, there no point in showing it\nthis.hideThreshold_=1;var tracks=this.player_.audioTracks();for(var i=0;i<tracks.length;i++){var track=tracks[i];items.push(new AudioTrackMenuItem(this.player_,{track:track,// MenuItem is selectable\nselectable:true}));}return items;};return AudioTrackButton;}(TrackButton);/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */AudioTrackButton.prototype.controlText_='Audio Track';Component.registerComponent('AudioTrackButton',AudioTrackButton);/**\n * @file playback-rate-menu-item.js\n *//**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */var PlaybackRateMenuItem=function(_MenuItem){inherits(PlaybackRateMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlaybackRateMenuItem(player,options){classCallCheck(this,PlaybackRateMenuItem);var label=options.rate;var rate=parseFloat(label,10);// Modify options for parent MenuItem class's init.\noptions.label=label;options.selected=rate===1;options.selectable=true;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.label=label;_this.rate=rate;_this.on(player,'ratechange',_this.update);return _this;}/**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlaybackRateMenuItem.prototype.handleClick=function handleClick(event){_MenuItem.prototype.handleClick.call(this);this.player().playbackRate(this.rate);};/**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */PlaybackRateMenuItem.prototype.update=function update(event){this.selected(this.player().playbackRate()===this.rate);};return PlaybackRateMenuItem;}(MenuItem);/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlaybackRateMenuItem.prototype.contentElType='button';Component.registerComponent('PlaybackRateMenuItem',PlaybackRateMenuItem);/**\n * @file playback-rate-menu-button.js\n *//**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */var PlaybackRateMenuButton=function(_MenuButton){inherits(PlaybackRateMenuButton,_MenuButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlaybackRateMenuButton(player,options){classCallCheck(this,PlaybackRateMenuButton);var _this=possibleConstructorReturn(this,_MenuButton.call(this,player,options));_this.updateVisibility();_this.updateLabel();_this.on(player,'loadstart',_this.updateVisibility);_this.on(player,'ratechange',_this.updateLabel);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */PlaybackRateMenuButton.prototype.createEl=function createEl$$1(){var el=_MenuButton.prototype.createEl.call(this);this.labelEl_=createEl('div',{className:'vjs-playback-rate-value',innerHTML:'1x'});el.appendChild(this.labelEl_);return el;};PlaybackRateMenuButton.prototype.dispose=function dispose(){this.labelEl_=null;_MenuButton.prototype.dispose.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */PlaybackRateMenuButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-playback-rate '+_MenuButton.prototype.buildCSSClass.call(this);};PlaybackRateMenuButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-playback-rate '+_MenuButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */PlaybackRateMenuButton.prototype.createMenu=function createMenu(){var menu=new Menu(this.player());var rates=this.playbackRates();if(rates){for(var i=rates.length-1;i>=0;i--){menu.addChild(new PlaybackRateMenuItem(this.player(),{rate:rates[i]+'x'}));}}return menu;};/**\n   * Updates ARIA accessibility attributes\n   */PlaybackRateMenuButton.prototype.updateARIAAttributes=function updateARIAAttributes(){// Current playback rate\nthis.el().setAttribute('aria-valuenow',this.player().playbackRate());};/**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlaybackRateMenuButton.prototype.handleClick=function handleClick(event){// select next rate option\nvar currentRate=this.player().playbackRate();var rates=this.playbackRates();// this will select first one if the last one currently selected\nvar newRate=rates[0];for(var i=0;i<rates.length;i++){if(rates[i]>currentRate){newRate=rates[i];break;}}this.player().playbackRate(newRate);};/**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */PlaybackRateMenuButton.prototype.playbackRates=function playbackRates(){return this.options_.playbackRates||this.options_.playerOptions&&this.options_.playerOptions.playbackRates;};/**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */PlaybackRateMenuButton.prototype.playbackRateSupported=function playbackRateSupported(){return this.player().tech_&&this.player().tech_.featuresPlaybackRate&&this.playbackRates()&&this.playbackRates().length>0;};/**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */PlaybackRateMenuButton.prototype.updateVisibility=function updateVisibility(event){if(this.playbackRateSupported()){this.removeClass('vjs-hidden');}else{this.addClass('vjs-hidden');}};/**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */PlaybackRateMenuButton.prototype.updateLabel=function updateLabel(event){if(this.playbackRateSupported()){this.labelEl_.innerHTML=this.player().playbackRate()+'x';}};return PlaybackRateMenuButton;}(MenuButton);/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlaybackRateMenuButton.prototype.controlText_='Playback Rate';Component.registerComponent('PlaybackRateMenuButton',PlaybackRateMenuButton);/**\n * @file spacer.js\n *//**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */var Spacer=function(_Component){inherits(Spacer,_Component);function Spacer(){classCallCheck(this,Spacer);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */Spacer.prototype.buildCSSClass=function buildCSSClass(){return'vjs-spacer '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */Spacer.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:this.buildCSSClass()});};return Spacer;}(Component);Component.registerComponent('Spacer',Spacer);/**\n * @file custom-control-spacer.js\n *//**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */var CustomControlSpacer=function(_Spacer){inherits(CustomControlSpacer,_Spacer);function CustomControlSpacer(){classCallCheck(this,CustomControlSpacer);return possibleConstructorReturn(this,_Spacer.apply(this,arguments));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CustomControlSpacer.prototype.buildCSSClass=function buildCSSClass(){return'vjs-custom-control-spacer '+_Spacer.prototype.buildCSSClass.call(this);};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */CustomControlSpacer.prototype.createEl=function createEl(){var el=_Spacer.prototype.createEl.call(this,{className:this.buildCSSClass()});// No-flex/table-cell mode requires there be some content\n// in the cell to fill the remaining space of the table.\nel.innerHTML='&nbsp;';return el;};return CustomControlSpacer;}(Spacer);Component.registerComponent('CustomControlSpacer',CustomControlSpacer);/**\n * @file control-bar.js\n */// Required children\n/**\n * Container of main controls.\n *\n * @extends Component\n */var ControlBar=function(_Component){inherits(ControlBar,_Component);function ControlBar(){classCallCheck(this,ControlBar);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */ControlBar.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-control-bar',dir:'ltr'},{// The control bar is a group, but we don't aria-label it to avoid\n//  over-announcing by JAWS\nrole:'group'});};return ControlBar;}(Component);/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */ControlBar.prototype.options_={children:['playToggle','volumePanel','currentTimeDisplay','timeDivider','durationDisplay','progressControl','liveDisplay','remainingTimeDisplay','customControlSpacer','playbackRateMenuButton','chaptersButton','descriptionsButton','subsCapsButton','audioTrackButton','fullscreenToggle']};Component.registerComponent('ControlBar',ControlBar);/**\n * @file error-display.js\n *//**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */var ErrorDisplay=function(_ModalDialog){inherits(ErrorDisplay,_ModalDialog);/**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function ErrorDisplay(player,options){classCallCheck(this,ErrorDisplay);var _this=possibleConstructorReturn(this,_ModalDialog.call(this,player,options));_this.on(player,'error',_this.open);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */ErrorDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-error-display '+_ModalDialog.prototype.buildCSSClass.call(this);};/**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */ErrorDisplay.prototype.content=function content(){var error=this.player().error();return error?this.localize(error.message):'';};return ErrorDisplay;}(ModalDialog);/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */ErrorDisplay.prototype.options_=mergeOptions(ModalDialog.prototype.options_,{pauseOnOpen:false,fillAlways:true,temporary:false,uncloseable:true});Component.registerComponent('ErrorDisplay',ErrorDisplay);/**\n * @file text-track-settings.js\n */var LOCAL_STORAGE_KEY='vjs-text-track-settings';var COLOR_BLACK=['#000','Black'];var COLOR_BLUE=['#00F','Blue'];var COLOR_CYAN=['#0FF','Cyan'];var COLOR_GREEN=['#0F0','Green'];var COLOR_MAGENTA=['#F0F','Magenta'];var COLOR_RED=['#F00','Red'];var COLOR_WHITE=['#FFF','White'];var COLOR_YELLOW=['#FF0','Yellow'];var OPACITY_OPAQUE=['1','Opaque'];var OPACITY_SEMI=['0.5','Semi-Transparent'];var OPACITY_TRANS=['0','Transparent'];// Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\nvar selectConfigs={backgroundColor:{selector:'.vjs-bg-color > select',id:'captions-background-color-%s',label:'Color',options:[COLOR_BLACK,COLOR_WHITE,COLOR_RED,COLOR_GREEN,COLOR_BLUE,COLOR_YELLOW,COLOR_MAGENTA,COLOR_CYAN]},backgroundOpacity:{selector:'.vjs-bg-opacity > select',id:'captions-background-opacity-%s',label:'Transparency',options:[OPACITY_OPAQUE,OPACITY_SEMI,OPACITY_TRANS]},color:{selector:'.vjs-fg-color > select',id:'captions-foreground-color-%s',label:'Color',options:[COLOR_WHITE,COLOR_BLACK,COLOR_RED,COLOR_GREEN,COLOR_BLUE,COLOR_YELLOW,COLOR_MAGENTA,COLOR_CYAN]},edgeStyle:{selector:'.vjs-edge-style > select',id:'%s',label:'Text Edge Style',options:[['none','None'],['raised','Raised'],['depressed','Depressed'],['uniform','Uniform'],['dropshadow','Dropshadow']]},fontFamily:{selector:'.vjs-font-family > select',id:'captions-font-family-%s',label:'Font Family',options:[['proportionalSansSerif','Proportional Sans-Serif'],['monospaceSansSerif','Monospace Sans-Serif'],['proportionalSerif','Proportional Serif'],['monospaceSerif','Monospace Serif'],['casual','Casual'],['script','Script'],['small-caps','Small Caps']]},fontPercent:{selector:'.vjs-font-percent > select',id:'captions-font-size-%s',label:'Font Size',options:[['0.50','50%'],['0.75','75%'],['1.00','100%'],['1.25','125%'],['1.50','150%'],['1.75','175%'],['2.00','200%'],['3.00','300%'],['4.00','400%']],'default':2,parser:function parser(v){return v==='1.00'?null:Number(v);}},textOpacity:{selector:'.vjs-text-opacity > select',id:'captions-foreground-opacity-%s',label:'Transparency',options:[OPACITY_OPAQUE,OPACITY_SEMI]},// Options for this object are defined below.\nwindowColor:{selector:'.vjs-window-color > select',id:'captions-window-color-%s',label:'Color'},// Options for this object are defined below.\nwindowOpacity:{selector:'.vjs-window-opacity > select',id:'captions-window-opacity-%s',label:'Transparency',options:[OPACITY_TRANS,OPACITY_SEMI,OPACITY_OPAQUE]}};selectConfigs.windowColor.options=selectConfigs.backgroundColor.options;/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */function parseOptionValue(value,parser){if(parser){value=parser(value);}if(value&&value!=='none'){return value;}}/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */function getSelectedOptionValue(el,parser){var value=el.options[el.options.selectedIndex].value;return parseOptionValue(value,parser);}/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */function setSelectedOption(el,value,parser){if(!value){return;}for(var i=0;i<el.options.length;i++){if(parseOptionValue(el.options[i].value,parser)===value){el.selectedIndex=i;break;}}}/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */var TextTrackSettings=function(_ModalDialog){inherits(TextTrackSettings,_ModalDialog);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */function TextTrackSettings(player,options){classCallCheck(this,TextTrackSettings);options.temporary=false;var _this=possibleConstructorReturn(this,_ModalDialog.call(this,player,options));_this.updateDisplay=bind(_this,_this.updateDisplay);// fill the modal and pretend we have opened it\n_this.fill();_this.hasBeenOpened_=_this.hasBeenFilled_=true;_this.endDialog=createEl('p',{className:'vjs-control-text',textContent:_this.localize('End of dialog window.')});_this.el().appendChild(_this.endDialog);_this.setDefaults();// Grab `persistTextTrackSettings` from the player options if not passed in child options\nif(options.persistTextTrackSettings===undefined){_this.options_.persistTextTrackSettings=_this.options_.playerOptions.persistTextTrackSettings;}_this.on(_this.$('.vjs-done-button'),'click',function(){_this.saveSettings();_this.close();});_this.on(_this.$('.vjs-default-button'),'click',function(){_this.setDefaults();_this.updateDisplay();});each(selectConfigs,function(config){_this.on(_this.$(config.selector),'change',_this.updateDisplay);});if(_this.options_.persistTextTrackSettings){_this.restoreSettings();}return _this;}TextTrackSettings.prototype.dispose=function dispose(){this.endDialog=null;_ModalDialog.prototype.dispose.call(this);};/**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElSelect_=function createElSelect_(key){var _this2=this;var legendId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'label';var config=selectConfigs[key];var id=config.id.replace('%s',this.id_);return['<'+type+' id=\"'+id+'\" class=\"'+(type==='label'?'vjs-label':'')+'\">',this.localize(config.label),'</'+type+'>','<select aria-labelledby=\"'+(legendId!==''?legendId+' ':'')+id+'\">'].concat(config.options.map(function(o){var optionId=id+'-'+o[1];return['<option id=\"'+optionId+'\" value=\"'+o[0]+'\" ','aria-labelledby=\"'+(legendId!==''?legendId+' ':'')+id+' '+optionId+'\">',_this2.localize(o[1]),'</option>'].join('');})).concat('</select>').join('');};/**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElFgColor_=function createElFgColor_(){var legendId='captions-text-legend-'+this.id_;return['<fieldset class=\"vjs-fg-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Text'),'</legend>',this.createElSelect_('color',legendId),'<span class=\"vjs-text-opacity vjs-opacity\">',this.createElSelect_('textOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElBgColor_=function createElBgColor_(){var legendId='captions-background-'+this.id_;return['<fieldset class=\"vjs-bg-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Background'),'</legend>',this.createElSelect_('backgroundColor',legendId),'<span class=\"vjs-bg-opacity vjs-opacity\">',this.createElSelect_('backgroundOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElWinColor_=function createElWinColor_(){var legendId='captions-window-'+this.id_;return['<fieldset class=\"vjs-window-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Window'),'</legend>',this.createElSelect_('windowColor',legendId),'<span class=\"vjs-window-opacity vjs-opacity\">',this.createElSelect_('windowOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */TextTrackSettings.prototype.createElColors_=function createElColors_(){return createEl('div',{className:'vjs-track-settings-colors',innerHTML:[this.createElFgColor_(),this.createElBgColor_(),this.createElWinColor_()].join('')});};/**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElFont_=function createElFont_(){return createEl('div',{className:'vjs-track-settings-font\">',innerHTML:['<fieldset class=\"vjs-font-percent vjs-track-setting\">',this.createElSelect_('fontPercent','','legend'),'</fieldset>','<fieldset class=\"vjs-edge-style vjs-track-setting\">',this.createElSelect_('edgeStyle','','legend'),'</fieldset>','<fieldset class=\"vjs-font-family vjs-track-setting\">',this.createElSelect_('fontFamily','','legend'),'</fieldset>'].join('')});};/**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElControls_=function createElControls_(){var defaultsDescription=this.localize('restore all settings to the default values');return createEl('div',{className:'vjs-track-settings-controls',innerHTML:['<button class=\"vjs-default-button\" title=\"'+defaultsDescription+'\">',this.localize('Reset'),'<span class=\"vjs-control-text\"> '+defaultsDescription+'</span>','</button>','<button class=\"vjs-done-button\">'+this.localize('Done')+'</button>'].join('')});};TextTrackSettings.prototype.content=function content(){return[this.createElColors_(),this.createElFont_(),this.createElControls_()];};TextTrackSettings.prototype.label=function label(){return this.localize('Caption Settings Dialog');};TextTrackSettings.prototype.description=function description(){return this.localize('Beginning of dialog window. Escape will cancel and close the window.');};TextTrackSettings.prototype.buildCSSClass=function buildCSSClass(){return _ModalDialog.prototype.buildCSSClass.call(this)+' vjs-text-track-settings';};/**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */TextTrackSettings.prototype.getValues=function getValues(){var _this3=this;return reduce(selectConfigs,function(accum,config,key){var value=getSelectedOptionValue(_this3.$(config.selector),config.parser);if(value!==undefined){accum[key]=value;}return accum;},{});};/**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */TextTrackSettings.prototype.setValues=function setValues(values){var _this4=this;each(selectConfigs,function(config,key){setSelectedOption(_this4.$(config.selector),values[key],config.parser);});};/**\n   * Sets all `<select>` elements to their default values.\n   */TextTrackSettings.prototype.setDefaults=function setDefaults(){var _this5=this;each(selectConfigs,function(config){var index=config.hasOwnProperty('default')?config['default']:0;_this5.$(config.selector).selectedIndex=index;});};/**\n   * Restore texttrack settings from localStorage\n   */TextTrackSettings.prototype.restoreSettings=function restoreSettings(){var values=void 0;try{values=JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));}catch(err){log$1.warn(err);}if(values){this.setValues(values);}};/**\n   * Save text track settings to localStorage\n   */TextTrackSettings.prototype.saveSettings=function saveSettings(){if(!this.options_.persistTextTrackSettings){return;}var values=this.getValues();try{if(Object.keys(values).length){window.localStorage.setItem(LOCAL_STORAGE_KEY,JSON.stringify(values));}else{window.localStorage.removeItem(LOCAL_STORAGE_KEY);}}catch(err){log$1.warn(err);}};/**\n   * Update display of text track settings\n   */TextTrackSettings.prototype.updateDisplay=function updateDisplay(){var ttDisplay=this.player_.getChild('textTrackDisplay');if(ttDisplay){ttDisplay.updateDisplay();}};/**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */TextTrackSettings.prototype.conditionalBlur_=function conditionalBlur_(){this.previouslyActiveEl_=null;this.off(document,'keydown',this.handleKeyDown);var cb=this.player_.controlBar;var subsCapsBtn=cb&&cb.subsCapsButton;var ccBtn=cb&&cb.captionsButton;if(subsCapsBtn){subsCapsBtn.focus();}else if(ccBtn){ccBtn.focus();}};return TextTrackSettings;}(ModalDialog);Component.registerComponent('TextTrackSettings',TextTrackSettings);var _templateObject$2=taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.'],['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.']);/**\n * @file html5.js\n *//**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */var Html5=function(_Tech){inherits(Html5,_Tech);/**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */function Html5(options,ready){classCallCheck(this,Html5);var _this=possibleConstructorReturn(this,_Tech.call(this,options,ready));var source=options.source;var crossoriginTracks=false;// Set the source if one is provided\n// 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n// 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n// anyway so the error gets fired.\nif(source&&(_this.el_.currentSrc!==source.src||options.tag&&options.tag.initNetworkState_===3)){_this.setSource(source);}else{_this.handleLateInit_(_this.el_);}if(_this.el_.hasChildNodes()){var nodes=_this.el_.childNodes;var nodesLength=nodes.length;var removeNodes=[];while(nodesLength--){var node=nodes[nodesLength];var nodeName=node.nodeName.toLowerCase();if(nodeName==='track'){if(!_this.featuresNativeTextTracks){// Empty video tag tracks so the built-in player doesn't use them also.\n// This may not be fast enough to stop HTML5 browsers from reading the tags\n// so we'll need to turn off any default tracks if we're manually doing\n// captions and subtitles. videoElement.textTracks\nremoveNodes.push(node);}else{// store HTMLTrackElement and TextTrack to remote list\n_this.remoteTextTrackEls().addTrackElement_(node);_this.remoteTextTracks().addTrack(node.track);_this.textTracks().addTrack(node.track);if(!crossoriginTracks&&!_this.el_.hasAttribute('crossorigin')&&isCrossOrigin(node.src)){crossoriginTracks=true;}}}}for(var i=0;i<removeNodes.length;i++){_this.el_.removeChild(removeNodes[i]);}}_this.proxyNativeTracks_();if(_this.featuresNativeTextTracks&&crossoriginTracks){log$1.warn(tsml(_templateObject$2));}// prevent iOS Safari from disabling metadata text tracks during native playback\n_this.restoreMetadataTracksInIOSNativePlayer_();// Determine if native controls should be used\n// Our goal should be to get the custom controls on mobile solid everywhere\n// so we can remove this all together. Right now this will block custom\n// controls on touch enabled laptops like the Chrome Pixel\nif((TOUCH_ENABLED||IS_IPHONE||IS_NATIVE_ANDROID)&&options.nativeControlsForTouch===true){_this.setControls(true);}// on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n// into a `fullscreenchange` event\n_this.proxyWebkitFullscreen_();_this.triggerReady();return _this;}/**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */Html5.prototype.dispose=function dispose(){Html5.disposeMediaElement(this.el_);this.options_=null;// tech will handle clearing of the emulated track list\n_Tech.prototype.dispose.call(this);};/**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */Html5.prototype.restoreMetadataTracksInIOSNativePlayer_=function restoreMetadataTracksInIOSNativePlayer_(){var textTracks=this.textTracks();var metadataTracksPreFullscreenState=void 0;// captures a snapshot of every metadata track's current state\nvar takeMetadataTrackSnapshot=function takeMetadataTrackSnapshot(){metadataTracksPreFullscreenState=[];for(var i=0;i<textTracks.length;i++){var track=textTracks[i];if(track.kind==='metadata'){metadataTracksPreFullscreenState.push({track:track,storedMode:track.mode});}}};// snapshot each metadata track's initial state, and update the snapshot\n// each time there is a track 'change' event\ntakeMetadataTrackSnapshot();textTracks.addEventListener('change',takeMetadataTrackSnapshot);this.on('dispose',function(){return textTracks.removeEventListener('change',takeMetadataTrackSnapshot);});var restoreTrackMode=function restoreTrackMode(){for(var i=0;i<metadataTracksPreFullscreenState.length;i++){var storedTrack=metadataTracksPreFullscreenState[i];if(storedTrack.track.mode==='disabled'&&storedTrack.track.mode!==storedTrack.storedMode){storedTrack.track.mode=storedTrack.storedMode;}}// we only want this handler to be executed on the first 'change' event\ntextTracks.removeEventListener('change',restoreTrackMode);};// when we enter fullscreen playback, stop updating the snapshot and\n// restore all track modes to their pre-fullscreen state\nthis.on('webkitbeginfullscreen',function(){textTracks.removeEventListener('change',takeMetadataTrackSnapshot);// remove the listener before adding it just in case it wasn't previously removed\ntextTracks.removeEventListener('change',restoreTrackMode);textTracks.addEventListener('change',restoreTrackMode);});// start updating the snapshot again after leaving fullscreen\nthis.on('webkitendfullscreen',function(){// remove the listener before adding it just in case it wasn't previously removed\ntextTracks.removeEventListener('change',takeMetadataTrackSnapshot);textTracks.addEventListener('change',takeMetadataTrackSnapshot);// remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\ntextTracks.removeEventListener('change',restoreTrackMode);});};/**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */Html5.prototype.proxyNativeTracks_=function proxyNativeTracks_(){var _this2=this;NORMAL.names.forEach(function(name){var props=NORMAL[name];var elTracks=_this2.el()[props.getterName];var techTracks=_this2[props.getterName]();if(!_this2['featuresNative'+props.capitalName+'Tracks']||!elTracks||!elTracks.addEventListener){return;}var listeners={change:function change(e){techTracks.trigger({type:'change',target:techTracks,currentTarget:techTracks,srcElement:techTracks});},addtrack:function addtrack(e){techTracks.addTrack(e.track);},removetrack:function removetrack(e){techTracks.removeTrack(e.track);}};var removeOldTracks=function removeOldTracks(){var removeTracks=[];for(var i=0;i<techTracks.length;i++){var found=false;for(var j=0;j<elTracks.length;j++){if(elTracks[j]===techTracks[i]){found=true;break;}}if(!found){removeTracks.push(techTracks[i]);}}while(removeTracks.length){techTracks.removeTrack(removeTracks.shift());}};Object.keys(listeners).forEach(function(eventName){var listener=listeners[eventName];elTracks.addEventListener(eventName,listener);_this2.on('dispose',function(e){return elTracks.removeEventListener(eventName,listener);});});// Remove (native) tracks that are not used anymore\n_this2.on('loadstart',removeOldTracks);_this2.on('dispose',function(e){return _this2.off('loadstart',removeOldTracks);});});};/**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Html5.prototype.createEl=function createEl$$1(){var el=this.options_.tag;// Check if this browser supports moving the element into the box.\n// On the iPhone video will break if you move the element,\n// So we have to create a brand new element.\n// If we ingested the player div, we do not need to move the media element.\nif(!el||!(this.options_.playerElIngest||this.movingMediaElementInDOM)){// If the original tag is still there, clone and remove it.\nif(el){var clone=el.cloneNode(true);if(el.parentNode){el.parentNode.insertBefore(clone,el);}Html5.disposeMediaElement(el);el=clone;}else{el=document.createElement('video');// determine if native controls should be used\nvar tagAttributes=this.options_.tag&&getAttributes(this.options_.tag);var attributes=mergeOptions({},tagAttributes);if(!TOUCH_ENABLED||this.options_.nativeControlsForTouch!==true){delete attributes.controls;}setAttributes(el,assign(attributes,{id:this.options_.techId,'class':'vjs-tech'}));}el.playerId=this.options_.playerId;}if(typeof this.options_.preload!=='undefined'){setAttribute(el,'preload',this.options_.preload);}// Update specific tag settings, in case they were overridden\n// `autoplay` has to be *last* so that `muted` and `playsinline` are present\n// when iOS/Safari or other browsers attempt to autoplay.\nvar settingsAttrs=['loop','muted','playsinline','autoplay'];for(var i=0;i<settingsAttrs.length;i++){var attr=settingsAttrs[i];var value=this.options_[attr];if(typeof value!=='undefined'){if(value){setAttribute(el,attr,attr);}else{removeAttribute(el,attr);}el[attr]=value;}}return el;};/**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */Html5.prototype.handleLateInit_=function handleLateInit_(el){if(el.networkState===0||el.networkState===3){// The video element hasn't started loading the source yet\n// or didn't find a source\nreturn;}if(el.readyState===0){// NetworkState is set synchronously BUT loadstart is fired at the\n// end of the current stack, usually before setInterval(fn, 0).\n// So at this point we know loadstart may have already fired or is\n// about to fire, and either way the player hasn't seen it yet.\n// We don't want to fire loadstart prematurely here and cause a\n// double loadstart so we'll wait and see if it happens between now\n// and the next loop, and fire it if not.\n// HOWEVER, we also want to make sure it fires before loadedmetadata\n// which could also happen between now and the next loop, so we'll\n// watch for that also.\nvar loadstartFired=false;var setLoadstartFired=function setLoadstartFired(){loadstartFired=true;};this.on('loadstart',setLoadstartFired);var triggerLoadstart=function triggerLoadstart(){// We did miss the original loadstart. Make sure the player\n// sees loadstart before loadedmetadata\nif(!loadstartFired){this.trigger('loadstart');}};this.on('loadedmetadata',triggerLoadstart);this.ready(function(){this.off('loadstart',setLoadstartFired);this.off('loadedmetadata',triggerLoadstart);if(!loadstartFired){// We did miss the original native loadstart. Fire it now.\nthis.trigger('loadstart');}});return;}// From here on we know that loadstart already fired and we missed it.\n// The other readyState events aren't as much of a problem if we double\n// them, so not going to go to as much trouble as loadstart to prevent\n// that unless we find reason to.\nvar eventsToTrigger=['loadstart'];// loadedmetadata: newly equal to HAVE_METADATA (1) or greater\neventsToTrigger.push('loadedmetadata');// loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\nif(el.readyState>=2){eventsToTrigger.push('loadeddata');}// canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\nif(el.readyState>=3){eventsToTrigger.push('canplay');}// canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\nif(el.readyState>=4){eventsToTrigger.push('canplaythrough');}// We still need to give the player time to add event listeners\nthis.ready(function(){eventsToTrigger.forEach(function(type){this.trigger(type);},this);});};/**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */Html5.prototype.setCurrentTime=function setCurrentTime(seconds){try{this.el_.currentTime=seconds;}catch(e){log$1(e,'Video is not ready. (Video.js)');// this.warning(VideoJS.warnings.videoNotReady);\n}};/**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */Html5.prototype.duration=function duration(){var _this3=this;// Android Chrome will report duration as Infinity for VOD HLS until after\n// playback has started, which triggers the live display erroneously.\n// Return NaN if playback has not started and trigger a durationupdate once\n// the duration can be reliably known.\nif(this.el_.duration===Infinity&&IS_ANDROID&&IS_CHROME&&this.el_.currentTime===0){// Wait for the first `timeupdate` with currentTime > 0 - there may be\n// several with 0\nvar checkProgress=function checkProgress(){if(_this3.el_.currentTime>0){// Trigger durationchange for genuinely live video\nif(_this3.el_.duration===Infinity){_this3.trigger('durationchange');}_this3.off('timeupdate',checkProgress);}};this.on('timeupdate',checkProgress);return NaN;}return this.el_.duration||NaN;};/**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */Html5.prototype.width=function width(){return this.el_.offsetWidth;};/**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The heigth of the HTML5 media element.\n   */Html5.prototype.height=function height(){return this.el_.offsetHeight;};/**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */Html5.prototype.proxyWebkitFullscreen_=function proxyWebkitFullscreen_(){var _this4=this;if(!('webkitDisplayingFullscreen'in this.el_)){return;}var endFn=function endFn(){this.trigger('fullscreenchange',{isFullscreen:false});};var beginFn=function beginFn(){if('webkitPresentationMode'in this.el_&&this.el_.webkitPresentationMode!=='picture-in-picture'){this.one('webkitendfullscreen',endFn);this.trigger('fullscreenchange',{isFullscreen:true});}};this.on('webkitbeginfullscreen',beginFn);this.on('dispose',function(){_this4.off('webkitbeginfullscreen',beginFn);_this4.off('webkitendfullscreen',endFn);});};/**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */Html5.prototype.supportsFullScreen=function supportsFullScreen(){if(typeof this.el_.webkitEnterFullScreen==='function'){var userAgent=window.navigator&&window.navigator.userAgent||'';// Seems to be broken in Chromium/Chrome && Safari in Leopard\nif(/Android/.test(userAgent)||!/Chrome|Mac OS X 10.5/.test(userAgent)){return true;}}return false;};/**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */Html5.prototype.enterFullScreen=function enterFullScreen(){var video=this.el_;if(video.paused&&video.networkState<=video.HAVE_METADATA){// attempt to prime the video element for programmatic access\n// this isn't necessary on the desktop but shouldn't hurt\nthis.el_.play();// playing and pausing synchronously during the transition to fullscreen\n// can get iOS ~6.1 devices into a play/pause loop\nthis.setTimeout(function(){video.pause();video.webkitEnterFullScreen();},0);}else{video.webkitEnterFullScreen();}};/**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */Html5.prototype.exitFullScreen=function exitFullScreen(){this.el_.webkitExitFullScreen();};/**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */Html5.prototype.src=function src(_src){if(_src===undefined){return this.el_.src;}// Setting src through `src` instead of `setSrc` will be deprecated\nthis.setSrc(_src);};/**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */Html5.prototype.reset=function reset(){Html5.resetMediaElement(this.el_);};/**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */Html5.prototype.currentSrc=function currentSrc(){if(this.currentSource_){return this.currentSource_.src;}return this.el_.currentSrc;};/**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */Html5.prototype.setControls=function setControls(val){this.el_.controls=!!val;};/**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */Html5.prototype.addTextTrack=function addTextTrack(kind,label,language){if(!this.featuresNativeTextTracks){return _Tech.prototype.addTextTrack.call(this,kind,label,language);}return this.el_.addTextTrack(kind,label,language);};/**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to intialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */Html5.prototype.createRemoteTextTrack=function createRemoteTextTrack(options){if(!this.featuresNativeTextTracks){return _Tech.prototype.createRemoteTextTrack.call(this,options);}var htmlTrackElement=document.createElement('track');if(options.kind){htmlTrackElement.kind=options.kind;}if(options.label){htmlTrackElement.label=options.label;}if(options.language||options.srclang){htmlTrackElement.srclang=options.language||options.srclang;}if(options['default']){htmlTrackElement['default']=options['default'];}if(options.id){htmlTrackElement.id=options.id;}if(options.src){htmlTrackElement.src=options.src;}return htmlTrackElement;};/**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */Html5.prototype.addRemoteTextTrack=function addRemoteTextTrack(options,manualCleanup){var htmlTrackElement=_Tech.prototype.addRemoteTextTrack.call(this,options,manualCleanup);if(this.featuresNativeTextTracks){this.el().appendChild(htmlTrackElement);}return htmlTrackElement;};/**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */Html5.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(track){_Tech.prototype.removeRemoteTextTrack.call(this,track);if(this.featuresNativeTextTracks){var tracks=this.$$('track');var i=tracks.length;while(i--){if(track===tracks[i]||track===tracks[i].track){this.el().removeChild(tracks[i]);}}}};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */Html5.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){if(typeof this.el().getVideoPlaybackQuality==='function'){return this.el().getVideoPlaybackQuality();}var videoPlaybackQuality={};if(typeof this.el().webkitDroppedFrameCount!=='undefined'&&typeof this.el().webkitDecodedFrameCount!=='undefined'){videoPlaybackQuality.droppedVideoFrames=this.el().webkitDroppedFrameCount;videoPlaybackQuality.totalVideoFrames=this.el().webkitDecodedFrameCount;}if(window.performance&&typeof window.performance.now==='function'){videoPlaybackQuality.creationTime=window.performance.now();}else if(window.performance&&window.performance.timing&&typeof window.performance.timing.navigationStart==='number'){videoPlaybackQuality.creationTime=window.Date.now()-window.performance.timing.navigationStart;}return videoPlaybackQuality;};return Html5;}(Tech);/* HTML5 Support Testing ---------------------------------------------------- */if(isReal()){/**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */Html5.TEST_VID=document.createElement('video');var track=document.createElement('track');track.kind='captions';track.srclang='en';track.label='English';Html5.TEST_VID.appendChild(track);}/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */Html5.isSupported=function(){// IE9 with no Media Player is a LIAR! (#984)\ntry{Html5.TEST_VID.volume=0.5;}catch(e){return false;}return!!(Html5.TEST_VID&&Html5.TEST_VID.canPlayType);};/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */Html5.canPlayType=function(type){return Html5.TEST_VID.canPlayType(type);};/**\n * Check if the tech can support the given source\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */Html5.canPlaySource=function(srcObj,options){return Html5.canPlayType(srcObj.type);};/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */Html5.canControlVolume=function(){// IE will error if Windows Media Player not installed #3315\ntry{var volume=Html5.TEST_VID.volume;Html5.TEST_VID.volume=volume/2+0.1;return volume!==Html5.TEST_VID.volume;}catch(e){return false;}};/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */Html5.canControlPlaybackRate=function(){// Playback rate API is implemented in Android Chrome, but doesn't do anything\n// https://github.com/videojs/video.js/issues/3180\nif(IS_ANDROID&&IS_CHROME&&CHROME_VERSION<58){return false;}// IE will error if Windows Media Player not installed #3315\ntry{var playbackRate=Html5.TEST_VID.playbackRate;Html5.TEST_VID.playbackRate=playbackRate/2+0.1;return playbackRate!==Html5.TEST_VID.playbackRate;}catch(e){return false;}};/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */Html5.supportsNativeTextTracks=function(){return IS_ANY_SAFARI;};/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */Html5.supportsNativeVideoTracks=function(){return!!(Html5.TEST_VID&&Html5.TEST_VID.videoTracks);};/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */Html5.supportsNativeAudioTracks=function(){return!!(Html5.TEST_VID&&Html5.TEST_VID.audioTracks);};/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */Html5.Events=['loadstart','suspend','abort','error','emptied','stalled','loadedmetadata','loadeddata','canplay','canplaythrough','playing','waiting','seeking','seeked','ended','durationchange','timeupdate','progress','play','pause','ratechange','resize','volumechange'];/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */Html5.prototype.featuresVolumeControl=Html5.canControlVolume();/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */Html5.prototype.featuresPlaybackRate=Html5.canControlPlaybackRate();/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.movingMediaElementInDOM=!IS_IOS;// TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.featuresFullscreenResize=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggred instead.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.featuresProgressEvents=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggred instead.\n *\n * @default\n */Html5.prototype.featuresTimeupdateEvents=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */Html5.prototype.featuresNativeTextTracks=Html5.supportsNativeTextTracks();/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */Html5.prototype.featuresNativeVideoTracks=Html5.supportsNativeVideoTracks();/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */Html5.prototype.featuresNativeAudioTracks=Html5.supportsNativeAudioTracks();// HTML5 Feature detection and Device Fixes --------------------------------- //\nvar canPlayType=Html5.TEST_VID&&Html5.TEST_VID.constructor.prototype.canPlayType;var mpegurlRE=/^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;var mp4RE=/^video\\/mp4/i;Html5.patchCanPlayType=function(){// Android 4.0 and above can play HLS to some extent but it reports being unable to do so\nif(ANDROID_VERSION>=4.0&&!IS_FIREFOX){Html5.TEST_VID.constructor.prototype.canPlayType=function(type){if(type&&mpegurlRE.test(type)){return'maybe';}return canPlayType.call(this,type);};// Override Android 2.2 and less canPlayType method which is broken\n}else if(IS_OLD_ANDROID){Html5.TEST_VID.constructor.prototype.canPlayType=function(type){if(type&&mp4RE.test(type)){return'maybe';}return canPlayType.call(this,type);};}};Html5.unpatchCanPlayType=function(){var r=Html5.TEST_VID.constructor.prototype.canPlayType;Html5.TEST_VID.constructor.prototype.canPlayType=canPlayType;return r;};// by default, patch the media element\nHtml5.patchCanPlayType();Html5.disposeMediaElement=function(el){if(!el){return;}if(el.parentNode){el.parentNode.removeChild(el);}// remove any child track or source nodes to prevent their loading\nwhile(el.hasChildNodes()){el.removeChild(el.firstChild);}// remove any src reference. not setting `src=''` because that causes a warning\n// in firefox\nel.removeAttribute('src');// force the media element to update its loading state by calling load()\n// however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\nif(typeof el.load==='function'){// wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n(function(){try{el.load();}catch(e){// not supported\n}})();}};Html5.resetMediaElement=function(el){if(!el){return;}var sources=el.querySelectorAll('source');var i=sources.length;while(i--){el.removeChild(sources[i]);}// remove any src reference.\n// not setting `src=''` because that throws an error\nel.removeAttribute('src');if(typeof el.load==='function'){// wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n(function(){try{el.load();}catch(e){// satisfy linter\n}})();}};/* Native HTML5 element property wrapping ----------------------------------- */// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n[/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */'muted',/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */'defaultMuted',/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */'autoplay',/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */'controls',/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */'loop',/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */'playsinline'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop]||this.el_.hasAttribute(prop);};});// Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n[/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */'muted',/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on intial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */'defaultMuted',/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */'autoplay',/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */'loop',/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */'playsinline'].forEach(function(prop){Html5.prototype['set'+toTitleCase(prop)]=function(v){this.el_[prop]=v;if(v){this.el_.setAttribute(prop,prop);}else{this.el_.removeAttribute(prop);}};});// Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState\n// readyState, videoWidth, videoHeight\n[/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */'paused',/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */'currentTime',/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */'buffered',/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */'volume',/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */'poster',/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */'preload',/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occured during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */'error',/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - Flase indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */'seeking',/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */'seekable',/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */'ended',/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'playbackRate',/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'defaultPlaybackRate',/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */'played',/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */'networkState',/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */'readyState',/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */'videoWidth',/**\n * Get the value of `videoHeight` from the video element. `videoHeigth` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */'videoHeight'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop];};});// Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate\n[/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */'volume',/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */'src',/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */'poster',/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */'preload',/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'playbackRate',/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */'defaultPlaybackRate'].forEach(function(prop){Html5.prototype['set'+toTitleCase(prop)]=function(v){this.el_[prop]=v;};});// wrap native functions with a function\n// The list is as follows:\n// pause, load play\n[/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */'pause',/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */'load',/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */'play'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop]();};});Tech.withSourceHandlers(Html5);/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @proprety {Tech~SourceObject} source\n *        The source object\n *\n * @proprety {Html5} tech\n *        The instance of the HTML5 tech.\n */Html5.nativeSourceHandler={};/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */Html5.nativeSourceHandler.canPlayType=function(type){// IE9 on Windows 7 without MediaPlayer throws an error here\n// https://github.com/videojs/video.js/issues/519\ntry{return Html5.TEST_VID.canPlayType(type);}catch(e){return'';}};/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */Html5.nativeSourceHandler.canHandleSource=function(source,options){// If a type was provided we should rely on that\nif(source.type){return Html5.nativeSourceHandler.canPlayType(source.type);// If no type, fall back to checking 'video/[EXTENSION]'\n}else if(source.src){var ext=getFileExtension(source.src);return Html5.nativeSourceHandler.canPlayType('video/'+ext);}return'';};/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */Html5.nativeSourceHandler.handleSource=function(source,tech,options){tech.setSrc(source.src);};/**\n * A noop for the native dispose function, as cleanup is not needed.\n */Html5.nativeSourceHandler.dispose=function(){};// Register the native source handler\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);Tech.registerTech('Html5',Html5);var _templateObject$1=taggedTemplateLiteralLoose(['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      '],['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      ']);/**\n * @file player.js\n */// Subclasses Component\n// The following imports are used only to ensure that the corresponding modules\n// are always included in the video.js package. Importing the modules will\n// execute them and they will register themselves with video.js.\n// Import Html5 tech, at least for disposing the original video tag.\n// The following tech events are simply re-triggered\n// on the player when they happen\nvar TECH_EVENTS_RETRIGGER=[/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */'progress',/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */'abort',/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */'suspend',/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */'emptied',/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */'stalled',/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */'loadedmetadata',/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n *//**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */'loadeddata',/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n *//**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */'timeupdate',/**\n * Fires when the playing speed of the audio/video is changed\n *\n * @event Player#ratechange\n * @type {event}\n *//**\n * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechRatechange_\n * @fires Player#ratechange\n * @listens Tech#ratechange\n */'ratechange',/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n *//**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */'resize',/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n *//**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */'volumechange',/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n *//**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */'texttrackchange'];/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */var Player=function(_Component){inherits(Player,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */function Player(tag,options,ready){classCallCheck(this,Player);// Make sure tag ID exists\ntag.id=tag.id||'vjs_video_'+newGUID();// Set Options\n// The options argument overrides options set in the video tag\n// which overrides globally set options.\n// This latter part coincides with the load order\n// (tag must exist before Player)\noptions=assign(Player.getTagSettings(tag),options);// Delay the initialization of children because we need to set up\n// player properties first, and can't use `this` before `super()`\noptions.initChildren=false;// Same with creating the element\noptions.createEl=false;// don't auto mixin the evented mixin\noptions.evented=false;// we don't want the player to report touch activity on itself\n// see enableTouchActivity in Component\noptions.reportTouchActivity=false;// If language is not set, get the closest lang attribute\nif(!options.language){if(typeof tag.closest==='function'){var closest=tag.closest('[lang]');if(closest&&closest.getAttribute){options.language=closest.getAttribute('lang');}}else{var element=tag;while(element&&element.nodeType===1){if(getAttributes(element).hasOwnProperty('lang')){options.language=element.getAttribute('lang');break;}element=element.parentNode;}}}// Run base component initializing with new options\n// Turn off API access because we're loading a new tech that might load asynchronously\nvar _this=possibleConstructorReturn(this,_Component.call(this,null,options,ready));_this.isReady_=false;// Init state hasStarted_\n_this.hasStarted_=false;// Init state userActive_\n_this.userActive_=false;// if the global option object was accidentally blown away by\n// someone, bail early with an informative error\nif(!_this.options_||!_this.options_.techOrder||!_this.options_.techOrder.length){throw new Error('No techOrder specified. Did you overwrite '+'videojs.options instead of just changing the '+'properties you want to override?');}// Store the original tag used to set options\n_this.tag=tag;// Store the tag attributes used to restore html5 element\n_this.tagAttributes=tag&&getAttributes(tag);// Update current language\n_this.language(_this.options_.language);// Update Supported Languages\nif(options.languages){// Normalise player option languages to lowercase\nvar languagesToLower={};Object.getOwnPropertyNames(options.languages).forEach(function(name$$1){languagesToLower[name$$1.toLowerCase()]=options.languages[name$$1];});_this.languages_=languagesToLower;}else{_this.languages_=Player.prototype.options_.languages;}// Cache for video property values.\n_this.cache_={};// Set poster\n_this.poster_=options.poster||'';// Set controls\n_this.controls_=!!options.controls;// Set default values for lastVolume\n_this.cache_.lastVolume=1;// Original tag settings stored in options\n// now remove immediately so native controls don't flash.\n// May be turned back on by HTML5 tech if nativeControlsForTouch is true\ntag.controls=false;tag.removeAttribute('controls');/*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */_this.scrubbing_=false;_this.el_=_this.createEl();// Make this an evented object and use `el_` as its event bus.\nevented(_this,{eventBusKey:'el_'});// We also want to pass the original player options to each component and plugin\n// as well so they don't need to reach back into the player for options later.\n// We also need to do another copy of this.options_ so we don't end up with\n// an infinite loop.\nvar playerOptionsCopy=mergeOptions(_this.options_);// Load plugins\nif(options.plugins){var plugins=options.plugins;Object.keys(plugins).forEach(function(name$$1){if(typeof this[name$$1]==='function'){this[name$$1](plugins[name$$1]);}else{throw new Error('plugin \"'+name$$1+'\" does not exist');}},_this);}_this.options_.playerOptions=playerOptionsCopy;_this.middleware_=[];_this.initChildren();// Set isAudio based on whether or not an audio tag was used\n_this.isAudio(tag.nodeName.toLowerCase()==='audio');// Update controls className. Can't do this when the controls are initially\n// set because the element doesn't exist yet.\nif(_this.controls()){_this.addClass('vjs-controls-enabled');}else{_this.addClass('vjs-controls-disabled');}// Set ARIA label and region role depending on player type\n_this.el_.setAttribute('role','region');if(_this.isAudio()){_this.el_.setAttribute('aria-label',_this.localize('Audio Player'));}else{_this.el_.setAttribute('aria-label',_this.localize('Video Player'));}if(_this.isAudio()){_this.addClass('vjs-audio');}if(_this.flexNotSupported_()){_this.addClass('vjs-no-flex');}// TODO: Make this smarter. Toggle user state between touching/mousing\n// using events, since devices can have both touch and mouse events.\n// if (browser.TOUCH_ENABLED) {\n//   this.addClass('vjs-touch-enabled');\n// }\n// iOS Safari has broken hover handling\nif(!IS_IOS){_this.addClass('vjs-workinghover');}// Make player easily findable by ID\nPlayer.players[_this.id_]=_this;// Add a major version class to aid css in plugins\nvar majorVersion=version.split('.')[0];_this.addClass('vjs-v'+majorVersion);// When the player is first initialized, trigger activity so components\n// like the control bar show themselves if needed\n_this.userActive(true);_this.reportUserActivity();_this.listenForUserActivity_();_this.on('fullscreenchange',_this.handleFullscreenChange_);_this.on('stageclick',_this.handleStageClick_);_this.changingSrc_=false;_this.playWaitingForReady_=false;_this.playOnLoadstart_=null;_this.forceAutoplayInChrome_();return _this;}/**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */Player.prototype.dispose=function dispose(){/**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */this.trigger('dispose');// prevent dispose from being called twice\nthis.off('dispose');if(this.styleEl_&&this.styleEl_.parentNode){this.styleEl_.parentNode.removeChild(this.styleEl_);this.styleEl_=null;}// Kill reference to this player\nPlayer.players[this.id_]=null;if(this.tag&&this.tag.player){this.tag.player=null;}if(this.el_&&this.el_.player){this.el_.player=null;}if(this.tech_){this.tech_.dispose();}if(this.playerElIngest_){this.playerElIngest_=null;}if(this.tag){this.tag=null;}// the actual .el_ is removed here\n_Component.prototype.dispose.call(this);};/**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */Player.prototype.createEl=function createEl$$1(){var tag=this.tag;var el=void 0;var playerElIngest=this.playerElIngest_=tag.parentNode&&tag.parentNode.hasAttribute&&tag.parentNode.hasAttribute('data-vjs-player');var divEmbed=this.tag.tagName.toLowerCase()==='video-js';if(playerElIngest){el=this.el_=tag.parentNode;}else if(!divEmbed){el=this.el_=_Component.prototype.createEl.call(this,'div');}// Copy over all the attributes from the tag, including ID and class\n// ID will now reference player box, not the video tag\nvar attrs=getAttributes(tag);if(divEmbed){el=this.el_=tag;tag=this.tag=document.createElement('video');while(el.children.length){tag.appendChild(el.firstChild);}if(!hasClass(el,'video-js')){addClass(el,'video-js');}el.appendChild(tag);playerElIngest=this.playerElIngest_=el;}// set tabindex to -1 so we could focus on the player element\ntag.setAttribute('tabindex','-1');// Remove width/height attrs from tag so CSS can make it 100% width/height\ntag.removeAttribute('width');tag.removeAttribute('height');Object.getOwnPropertyNames(attrs).forEach(function(attr){// workaround so we don't totally break IE7\n// http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\nif(attr==='class'){el.className+=' '+attrs[attr];if(divEmbed){tag.className+=' '+attrs[attr];}}else{el.setAttribute(attr,attrs[attr]);if(divEmbed){tag.setAttribute(attr,attrs[attr]);}}});// Update tag id/class for use as HTML5 playback tech\n// Might think we should do this after embedding in container so .vjs-tech class\n// doesn't flash 100% width/height, but class only applies with .video-js parent\ntag.playerId=tag.id;tag.id+='_html5_api';tag.className='vjs-tech';// Make player findable on elements\ntag.player=el.player=this;// Default state of video is paused\nthis.addClass('vjs-paused');// Add a style element in the player that we'll use to set the width/height\n// of the player in a way that's still overrideable by CSS, just like the\n// video element\nif(window.VIDEOJS_NO_DYNAMIC_STYLE!==true){this.styleEl_=createStyleElement('vjs-styles-dimensions');var defaultsStyleEl=$('.vjs-styles-defaults');var head=$('head');head.insertBefore(this.styleEl_,defaultsStyleEl?defaultsStyleEl.nextSibling:head.firstChild);}// Pass in the width/height/aspectRatio options which will update the style el\nthis.width(this.options_.width);this.height(this.options_.height);this.fluid(this.options_.fluid);this.aspectRatio(this.options_.aspectRatio);// Hide any links within the video/audio tag, because IE doesn't hide them completely.\nvar links=tag.getElementsByTagName('a');for(var i=0;i<links.length;i++){var linkEl=links.item(i);addClass(linkEl,'vjs-hidden');linkEl.setAttribute('hidden','hidden');}// insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n// keep track of the original for later so we can know if the source originally failed\ntag.initNetworkState_=tag.networkState;// Wrap video tag in div (el/box) container\nif(tag.parentNode&&!playerElIngest){tag.parentNode.insertBefore(el,tag);}// insert the tag as the first child of the player element\n// then manually add it to the children array so that this.addChild\n// will work properly for other components\n//\n// Breaks iPhone, fixed in HTML5 setup.\nprependTo(tag,el);this.children_.unshift(tag);// Set lang attr on player to ensure CSS :lang() in consistent with player\n// if it's been set to something different to the doc\nthis.el_.setAttribute('lang',this.language_);this.el_=el;return el;};/**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */Player.prototype.width=function width(value,skipListeners){return this.dimension('width',value,skipListeners);};/**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */Player.prototype.height=function height(value,skipListeners){return this.dimension('height',value,skipListeners);};/**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @fires Player#playerresize\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */Player.prototype.dimension=function dimension(_dimension,value,skipListeners){var privDimension=_dimension+'_';if(value===undefined){return this[privDimension]||0;}if(value===''){// If an empty string is given, reset the dimension to be automatic\nthis[privDimension]=undefined;this.updateStyleEl_();return;}var parsedVal=parseFloat(value);if(isNaN(parsedVal)){log$1.error('Improper value \"'+value+'\" supplied for for '+_dimension);return;}this[privDimension]=parsedVal;this.updateStyleEl_();// skipListeners allows us to avoid triggering the resize event when setting both width and height\nif(this.isReady_&&!skipListeners){/**\n       * Triggered when the player is resized.\n       *\n       * @event Player#playerresize\n       * @type {EventTarget~Event}\n       */this.trigger('playerresize');}};/**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will toggle the fluid class.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */Player.prototype.fluid=function fluid(bool){if(bool===undefined){return!!this.fluid_;}this.fluid_=!!bool;if(bool){this.addClass('vjs-fluid');}else{this.removeClass('vjs-fluid');}this.updateStyleEl_();};/**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   *//**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player's aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */Player.prototype.aspectRatio=function aspectRatio(ratio){if(ratio===undefined){return this.aspectRatio_;}// Check for width:height format\nif(!/^\\d+\\:\\d+$/.test(ratio)){throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');}this.aspectRatio_=ratio;// We're assuming if you set an aspect ratio you want fluid mode,\n// because in fixed mode you could calculate width and height yourself.\nthis.fluid(true);this.updateStyleEl_();};/**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */Player.prototype.updateStyleEl_=function updateStyleEl_(){if(window.VIDEOJS_NO_DYNAMIC_STYLE===true){var _width=typeof this.width_==='number'?this.width_:this.options_.width;var _height=typeof this.height_==='number'?this.height_:this.options_.height;var techEl=this.tech_&&this.tech_.el();if(techEl){if(_width>=0){techEl.width=_width;}if(_height>=0){techEl.height=_height;}}return;}var width=void 0;var height=void 0;var aspectRatio=void 0;var idClass=void 0;// The aspect ratio is either used directly or to calculate width and height.\nif(this.aspectRatio_!==undefined&&this.aspectRatio_!=='auto'){// Use any aspectRatio that's been specifically set\naspectRatio=this.aspectRatio_;}else if(this.videoWidth()>0){// Otherwise try to get the aspect ratio from the video metadata\naspectRatio=this.videoWidth()+':'+this.videoHeight();}else{// Or use a default. The video element's is 2:1, but 16:9 is more common.\naspectRatio='16:9';}// Get the ratio as a decimal we can use to calculate dimensions\nvar ratioParts=aspectRatio.split(':');var ratioMultiplier=ratioParts[1]/ratioParts[0];if(this.width_!==undefined){// Use any width that's been specifically set\nwidth=this.width_;}else if(this.height_!==undefined){// Or calulate the width from the aspect ratio if a height has been set\nwidth=this.height_/ratioMultiplier;}else{// Or use the video's metadata, or use the video el's default of 300\nwidth=this.videoWidth()||300;}if(this.height_!==undefined){// Use any height that's been specifically set\nheight=this.height_;}else{// Otherwise calculate the height from the ratio and the width\nheight=width*ratioMultiplier;}// Ensure the CSS class is valid by starting with an alpha character\nif(/^[^a-zA-Z]/.test(this.id())){idClass='dimensions-'+this.id();}else{idClass=this.id()+'-dimensions';}// Ensure the right class is still on the player for the style element\nthis.addClass(idClass);setTextContent(this.styleEl_,'\\n      .'+idClass+' {\\n        width: '+width+'px;\\n        height: '+height+'px;\\n      }\\n\\n      .'+idClass+'.vjs-fluid {\\n        padding-top: '+ratioMultiplier*100+'%;\\n      }\\n    ');};/**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */Player.prototype.loadTech_=function loadTech_(techName,source){var _this2=this;// Pause and remove current playback technology\nif(this.tech_){this.unloadTech_();}var titleTechName=toTitleCase(techName);var camelTechName=techName.charAt(0).toLowerCase()+techName.slice(1);// get rid of the HTML5 video tag as soon as we are using another tech\nif(titleTechName!=='Html5'&&this.tag){Tech.getTech('Html5').disposeMediaElement(this.tag);this.tag.player=null;this.tag=null;}this.techName_=titleTechName;// Turn off API access because we're loading a new tech that might load asynchronously\nthis.isReady_=false;// Grab tech-specific options from player options and add source and parent element to use.\nvar techOptions={source:source,'nativeControlsForTouch':this.options_.nativeControlsForTouch,'playerId':this.id(),'techId':this.id()+'_'+titleTechName+'_api','autoplay':this.options_.autoplay,'playsinline':this.options_.playsinline,'preload':this.options_.preload,'loop':this.options_.loop,'muted':this.options_.muted,'poster':this.poster(),'language':this.language(),'playerElIngest':this.playerElIngest_||false,'vtt.js':this.options_['vtt.js']};ALL.names.forEach(function(name$$1){var props=ALL[name$$1];techOptions[props.getterName]=_this2[props.privateName];});assign(techOptions,this.options_[titleTechName]);assign(techOptions,this.options_[camelTechName]);assign(techOptions,this.options_[techName.toLowerCase()]);if(this.tag){techOptions.tag=this.tag;}if(source&&source.src===this.cache_.src&&this.cache_.currentTime>0){techOptions.startTime=this.cache_.currentTime;}// Initialize tech instance\nvar TechClass=Tech.getTech(techName);if(!TechClass){throw new Error('No Tech named \\''+titleTechName+'\\' exists! \\''+titleTechName+'\\' should be registered using videojs.registerTech()\\'');}this.tech_=new TechClass(techOptions);// player.triggerReady is always async, so don't need this to be async\nthis.tech_.ready(bind(this,this.handleTechReady_),true);textTrackConverter.jsonToTextTracks(this.textTracksJson_||[],this.tech_);// Listen to all HTML5-defined events and trigger them on the player\nTECH_EVENTS_RETRIGGER.forEach(function(event){_this2.on(_this2.tech_,event,_this2['handleTech'+toTitleCase(event)+'_']);});this.on(this.tech_,'loadstart',this.handleTechLoadStart_);this.on(this.tech_,'waiting',this.handleTechWaiting_);this.on(this.tech_,'canplay',this.handleTechCanPlay_);this.on(this.tech_,'canplaythrough',this.handleTechCanPlayThrough_);this.on(this.tech_,'playing',this.handleTechPlaying_);this.on(this.tech_,'ended',this.handleTechEnded_);this.on(this.tech_,'seeking',this.handleTechSeeking_);this.on(this.tech_,'seeked',this.handleTechSeeked_);this.on(this.tech_,'play',this.handleTechPlay_);this.on(this.tech_,'firstplay',this.handleTechFirstPlay_);this.on(this.tech_,'pause',this.handleTechPause_);this.on(this.tech_,'durationchange',this.handleTechDurationChange_);this.on(this.tech_,'fullscreenchange',this.handleTechFullscreenChange_);this.on(this.tech_,'error',this.handleTechError_);this.on(this.tech_,'loadedmetadata',this.updateStyleEl_);this.on(this.tech_,'posterchange',this.handleTechPosterChange_);this.on(this.tech_,'textdata',this.handleTechTextData_);this.usingNativeControls(this.techGet_('controls'));if(this.controls()&&!this.usingNativeControls()){this.addTechControlsListeners_();}// Add the tech element in the DOM if it was not already there\n// Make sure to not insert the original video element if using Html5\nif(this.tech_.el().parentNode!==this.el()&&(titleTechName!=='Html5'||!this.tag)){prependTo(this.tech_.el(),this.el());}// Get rid of the original video tag reference after the first tech is loaded\nif(this.tag){this.tag.player=null;this.tag=null;}};/**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */Player.prototype.unloadTech_=function unloadTech_(){var _this3=this;// Save the current text tracks so that we can reuse the same text tracks with the next tech\nALL.names.forEach(function(name$$1){var props=ALL[name$$1];_this3[props.privateName]=_this3[props.getterName]();});this.textTracksJson_=textTrackConverter.textTracksToJson(this.tech_);this.isReady_=false;this.tech_.dispose();this.tech_=false;};/**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */Player.prototype.tech=function tech(safety){if(safety===undefined){log$1.warn(tsml(_templateObject$1));}return this.tech_;};/**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */Player.prototype.addTechControlsListeners_=function addTechControlsListeners_(){// Make sure to remove all the previous listeners in case we are called multiple times.\nthis.removeTechControlsListeners_();// Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n// trigger mousedown/up.\n// http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n// Any touch events are set to block the mousedown event from happening\nthis.on(this.tech_,'mousedown',this.handleTechClick_);// If the controls were hidden we don't want that to change without a tap event\n// so we'll check if the controls were already showing before reporting user\n// activity\nthis.on(this.tech_,'touchstart',this.handleTechTouchStart_);this.on(this.tech_,'touchmove',this.handleTechTouchMove_);this.on(this.tech_,'touchend',this.handleTechTouchEnd_);// The tap listener needs to come after the touchend listener because the tap\n// listener cancels out any reportedUserActivity when setting userActive(false)\nthis.on(this.tech_,'tap',this.handleTechTap_);};/**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */Player.prototype.removeTechControlsListeners_=function removeTechControlsListeners_(){// We don't want to just use `this.off()` because there might be other needed\n// listeners added by techs that extend this.\nthis.off(this.tech_,'tap',this.handleTechTap_);this.off(this.tech_,'touchstart',this.handleTechTouchStart_);this.off(this.tech_,'touchmove',this.handleTechTouchMove_);this.off(this.tech_,'touchend',this.handleTechTouchEnd_);this.off(this.tech_,'mousedown',this.handleTechClick_);};/**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */Player.prototype.handleTechReady_=function handleTechReady_(){this.triggerReady();// Keep the same volume as before\nif(this.cache_.volume){this.techCall_('setVolume',this.cache_.volume);}// Look if the tech found a higher resolution poster while loading\nthis.handleTechPosterChange_();// Update the duration if available\nthis.handleTechDurationChange_();// Chrome and Safari both have issues with autoplay.\n// In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\n// In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\n// This fixes both issues. Need to wait for API, so it updates displays correctly\nif((this.src()||this.currentSrc())&&this.tag&&this.options_.autoplay&&this.paused()){try{// Chrome Fix. Fixed in Chrome v16.\ndelete this.tag.poster;}catch(e){log$1('deleting tag.poster throws in some browsers',e);}}};/**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */Player.prototype.handleTechLoadStart_=function handleTechLoadStart_(){// TODO: Update to use `emptied` event instead. See #1277.\nthis.removeClass('vjs-ended');this.removeClass('vjs-seeking');// reset the error state\nthis.error(null);// If it's already playing we want to trigger a firstplay event now.\n// The firstplay event relies on both the play and loadstart events\n// which can happen in any order for a new source\nif(!this.paused()){/**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */this.trigger('loadstart');this.trigger('firstplay');}else{// reset the hasStarted state\nthis.hasStarted(false);this.trigger('loadstart');}};/**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */Player.prototype.hasStarted=function hasStarted(request){if(request===undefined){// act as getter, if we have no request to change\nreturn this.hasStarted_;}if(request===this.hasStarted_){return;}this.hasStarted_=request;if(this.hasStarted_){this.addClass('vjs-has-started');this.trigger('firstplay');}else{this.removeClass('vjs-has-started');}};/**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */Player.prototype.handleTechPlay_=function handleTechPlay_(){this.removeClass('vjs-ended');this.removeClass('vjs-paused');this.addClass('vjs-playing');// hide the poster when the user hits play\nthis.hasStarted(true);/**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */this.trigger('play');};/**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */Player.prototype.handleTechWaiting_=function handleTechWaiting_(){var _this4=this;this.addClass('vjs-waiting');/**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */this.trigger('waiting');this.one('timeupdate',function(){return _this4.removeClass('vjs-waiting');});};/**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */Player.prototype.handleTechCanPlay_=function handleTechCanPlay_(){this.removeClass('vjs-waiting');/**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */this.trigger('canplay');};/**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */Player.prototype.handleTechCanPlayThrough_=function handleTechCanPlayThrough_(){this.removeClass('vjs-waiting');/**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */this.trigger('canplaythrough');};/**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */Player.prototype.handleTechPlaying_=function handleTechPlaying_(){this.removeClass('vjs-waiting');/**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */this.trigger('playing');};/**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */Player.prototype.handleTechSeeking_=function handleTechSeeking_(){this.addClass('vjs-seeking');/**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */this.trigger('seeking');};/**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */Player.prototype.handleTechSeeked_=function handleTechSeeked_(){this.removeClass('vjs-seeking');/**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */this.trigger('seeked');};/**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */Player.prototype.handleTechFirstPlay_=function handleTechFirstPlay_(){// If the first starttime attribute is specified\n// then we will start at the given offset in seconds\nif(this.options_.starttime){log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');this.currentTime(this.options_.starttime);}this.addClass('vjs-has-started');/**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */this.trigger('firstplay');};/**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */Player.prototype.handleTechPause_=function handleTechPause_(){this.removeClass('vjs-playing');this.addClass('vjs-paused');/**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */this.trigger('pause');};/**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */Player.prototype.handleTechEnded_=function handleTechEnded_(){this.addClass('vjs-ended');if(this.options_.loop){this.currentTime(0);this.play();}else if(!this.paused()){this.pause();}/**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */this.trigger('ended');};/**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */Player.prototype.handleTechDurationChange_=function handleTechDurationChange_(){this.duration(this.techGet_('duration'));};/**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mousedown\n   * @private\n   */Player.prototype.handleTechClick_=function handleTechClick_(event){if(!isSingleLeftClick(event)){return;}// When controls are disabled a click should not toggle playback because\n// the click is considered a control\nif(!this.controls_){return;}if(this.paused()){this.play();}else{this.pause();}};/**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */Player.prototype.handleTechTap_=function handleTechTap_(){this.userActive(!this.userActive());};/**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */Player.prototype.handleTechTouchStart_=function handleTechTouchStart_(){this.userWasActive=this.userActive();};/**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */Player.prototype.handleTechTouchMove_=function handleTechTouchMove_(){if(this.userWasActive){this.reportUserActivity();}};/**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */Player.prototype.handleTechTouchEnd_=function handleTechTouchEnd_(event){// Stop the mouse events from also happening\nevent.preventDefault();};/**\n   * Fired when the player switches in or out of fullscreen mode\n   *\n   * @private\n   * @listens Player#fullscreenchange\n   */Player.prototype.handleFullscreenChange_=function handleFullscreenChange_(){if(this.isFullscreen()){this.addClass('vjs-fullscreen');}else{this.removeClass('vjs-fullscreen');}};/**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */Player.prototype.handleStageClick_=function handleStageClick_(){this.reportUserActivity();};/**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */Player.prototype.handleTechFullscreenChange_=function handleTechFullscreenChange_(event,data){if(data){this.isFullscreen(data.isFullscreen);}/**\n     * Fired when going in and out of fullscreen.\n     *\n     * @event Player#fullscreenchange\n     * @type {EventTarget~Event}\n     */this.trigger('fullscreenchange');};/**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */Player.prototype.handleTechError_=function handleTechError_(){var error=this.tech_.error();this.error(error);};/**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */Player.prototype.handleTechTextData_=function handleTechTextData_(){var data=null;if(arguments.length>1){data=arguments[1];}/**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */this.trigger('textdata',data);};/**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */Player.prototype.getCache=function getCache(){return this.cache_;};/**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */Player.prototype.techCall_=function techCall_(method,arg){// If it's not ready yet, call method when it is\nthis.ready(function(){if(method in allowedSetters){return set$1(this.middleware_,this.tech_,method,arg);}try{if(this.tech_){this.tech_[method](arg);}}catch(e){log$1(e);throw e;}},true);};/**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */Player.prototype.techGet_=function techGet_(method){if(!this.tech_||!this.tech_.isReady_){return;}if(method in allowedGetters){return get$1(this.middleware_,this.tech_,method);}// Flash likes to die and reload when you hide or reposition it.\n// In these cases the object methods go away and we get errors.\n// When that happens we'll catch the errors and inform tech that it's not ready any more.\ntry{return this.tech_[method]();}catch(e){// When building additional tech libs, an expected method may not be defined yet\nif(this.tech_[method]===undefined){log$1('Video.js: '+method+' method not defined for '+this.techName_+' playback technology.',e);throw e;}// When a method isn't available on the object it throws a TypeError\nif(e.name==='TypeError'){log$1('Video.js: '+method+' unavailable on '+this.techName_+' playback technology element.',e);this.tech_.isReady_=false;throw e;}// If error unknown, just log and throw\nlog$1(e);throw e;}};/**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a `Promise` only if the browser returns one and the player\n   *         is ready to begin playback. For some browsers and all non-ready\n   *         situations, this will return `undefined`.\n   */Player.prototype.play=function play(){var _this5=this;// If this is called while we have a play queued up on a loadstart, remove\n// that listener to avoid getting in a potentially bad state.\nif(this.playOnLoadstart_){this.off('loadstart',this.playOnLoadstart_);}// If the player/tech is not ready, queue up another call to `play()` for\n// when it is. This will loop back into this method for another attempt at\n// playback when the tech is ready.\nif(!this.isReady_){// Bail out if we're already waiting for `ready`!\nif(this.playWaitingForReady_){return;}this.playWaitingForReady_=true;this.ready(function(){_this5.playWaitingForReady_=false;silencePromise(_this5.play());});// If the player/tech is ready and we have a source, we can attempt playback.\n}else if(!this.changingSrc_&&(this.src()||this.currentSrc())){return this.techGet_('play');// If the tech is ready, but we do not have a source, we'll need to wait\n// for both the `ready` and a `loadstart` when the source is finally\n// resolved by middleware and set on the player.\n//\n// This can happen if `play()` is called while changing sources or before\n// one has been set on the player.\n}else{this.playOnLoadstart_=function(){_this5.playOnLoadstart_=null;silencePromise(_this5.play());};this.one('loadstart',this.playOnLoadstart_);}};/**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */Player.prototype.pause=function pause(){this.techCall_('pause');};/**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */Player.prototype.paused=function paused(){// The initial state of paused should be true (in Safari it's actually false)\nreturn this.techGet_('paused')===false?false:true;};/**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */Player.prototype.played=function played(){return this.techGet_('played')||createTimeRanges(0,0);};/**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        wether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */Player.prototype.scrubbing=function scrubbing(isScrubbing){if(typeof isScrubbing==='undefined'){return this.scrubbing_;}this.scrubbing_=!!isScrubbing;if(isScrubbing){this.addClass('vjs-scrubbing');}else{this.removeClass('vjs-scrubbing');}};/**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */Player.prototype.currentTime=function currentTime(seconds){if(typeof seconds!=='undefined'){if(seconds<0){seconds=0;}this.techCall_('setCurrentTime',seconds);return;}// cache last currentTime and return. default to 0 seconds\n//\n// Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n// currentTime when scrubbing, but may not provide much performance benefit afterall.\n// Should be tested. Also something has to read the actual current time or the cache will\n// never get updated.\nthis.cache_.currentTime=this.techGet_('currentTime')||0;return this.cache_.currentTime;};/**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */Player.prototype.duration=function duration(seconds){if(seconds===undefined){// return NaN if the duration is not known\nreturn this.cache_.duration!==undefined?this.cache_.duration:NaN;}seconds=parseFloat(seconds);// Standardize on Inifity for signaling video is live\nif(seconds<0){seconds=Infinity;}if(seconds!==this.cache_.duration){// Cache the last set value for optimized scrubbing (esp. Flash)\nthis.cache_.duration=seconds;if(seconds===Infinity){this.addClass('vjs-live');}else{this.removeClass('vjs-live');}/**\n       * @event Player#durationchange\n       * @type {EventTarget~Event}\n       */this.trigger('durationchange');}};/**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */Player.prototype.remainingTime=function remainingTime(){return this.duration()-this.currentTime();};/**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */Player.prototype.remainingTimeDisplay=function remainingTimeDisplay(){return Math.floor(this.duration())-Math.floor(this.currentTime());};//\n// Kind of like an array of portions of the video that have been downloaded.\n/**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */Player.prototype.buffered=function buffered(){var buffered=this.techGet_('buffered');if(!buffered||!buffered.length){buffered=createTimeRanges(0,0);}return buffered;};/**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is bufferred 0 being 0% and 1 being 100%\n   */Player.prototype.bufferedPercent=function bufferedPercent$$1(){return bufferedPercent(this.buffered(),this.duration());};/**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */Player.prototype.bufferedEnd=function bufferedEnd(){var buffered=this.buffered();var duration=this.duration();var end=buffered.end(buffered.length-1);if(end>duration){end=duration;}return end;};/**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */Player.prototype.volume=function volume(percentAsDecimal){var vol=void 0;if(percentAsDecimal!==undefined){// Force value to between 0 and 1\nvol=Math.max(0,Math.min(1,parseFloat(percentAsDecimal)));this.cache_.volume=vol;this.techCall_('setVolume',vol);if(vol>0){this.lastVolume_(vol);}return;}// Default to 1 when returning current volume.\nvol=parseFloat(this.techGet_('volume'));return isNaN(vol)?1:vol;};/**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */Player.prototype.muted=function muted(_muted){if(_muted!==undefined){this.techCall_('setMuted',_muted);return;}return this.techGet_('muted')||false;};/**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on intial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */Player.prototype.defaultMuted=function defaultMuted(_defaultMuted){if(_defaultMuted!==undefined){return this.techCall_('setDefaultMuted',_defaultMuted);}return this.techGet_('defaultMuted')||false;};/**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */Player.prototype.lastVolume_=function lastVolume_(percentAsDecimal){if(percentAsDecimal!==undefined&&percentAsDecimal!==0){this.cache_.lastVolume=percentAsDecimal;return;}return this.cache_.lastVolume;};/**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */Player.prototype.supportsFullScreen=function supportsFullScreen(){return this.techGet_('supportsFullScreen')||false;};/**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */Player.prototype.isFullscreen=function isFullscreen(isFS){if(isFS!==undefined){this.isFullscreen_=!!isFS;return;}return!!this.isFullscreen_;};/**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @fires Player#fullscreenchange\n   */Player.prototype.requestFullscreen=function requestFullscreen(){var fsApi=FullscreenApi;this.isFullscreen(true);if(fsApi.requestFullscreen){// the browser supports going fullscreen at the element level so we can\n// take the controls fullscreen as well as the video\n// Trigger fullscreenchange event after change\n// We have to specifically add this each time, and remove\n// when canceling fullscreen. Otherwise if there's multiple\n// players on a page, they would all be reacting to the same fullscreen\n// events\non(document,fsApi.fullscreenchange,bind(this,function documentFullscreenChange(e){this.isFullscreen(document[fsApi.fullscreenElement]);// If cancelling fullscreen, remove event listener.\nif(this.isFullscreen()===false){off(document,fsApi.fullscreenchange,documentFullscreenChange);}/**\n         * @event Player#fullscreenchange\n         * @type {EventTarget~Event}\n         */this.trigger('fullscreenchange');}));this.el_[fsApi.requestFullscreen]();}else if(this.tech_.supportsFullScreen()){// we can't take the video.js controls fullscreen but we can go fullscreen\n// with native controls\nthis.techCall_('enterFullScreen');}else{// fullscreen isn't supported so we'll just stretch the video element to\n// fill the viewport\nthis.enterFullWindow();/**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */this.trigger('fullscreenchange');}};/**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */Player.prototype.exitFullscreen=function exitFullscreen(){var fsApi=FullscreenApi;this.isFullscreen(false);// Check for browser element fullscreen support\nif(fsApi.requestFullscreen){document[fsApi.exitFullscreen]();}else if(this.tech_.supportsFullScreen()){this.techCall_('exitFullScreen');}else{this.exitFullWindow();/**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */this.trigger('fullscreenchange');}};/**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */Player.prototype.enterFullWindow=function enterFullWindow(){this.isFullWindow=true;// Storing original doc overflow value to return to when fullscreen is off\nthis.docOrigOverflow=document.documentElement.style.overflow;// Add listener for esc key to exit fullscreen\non(document,'keydown',bind(this,this.fullWindowOnEscKey));// Hide any scroll bars\ndocument.documentElement.style.overflow='hidden';// Apply fullscreen styles\naddClass(document.body,'vjs-full-window');/**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */this.trigger('enterFullWindow');};/**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */Player.prototype.fullWindowOnEscKey=function fullWindowOnEscKey(event){if(event.keyCode===27){if(this.isFullscreen()===true){this.exitFullscreen();}else{this.exitFullWindow();}}};/**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */Player.prototype.exitFullWindow=function exitFullWindow(){this.isFullWindow=false;off(document,'keydown',this.fullWindowOnEscKey);// Unhide scroll bars.\ndocument.documentElement.style.overflow=this.docOrigOverflow;// Remove fullscreen styles\nremoveClass(document.body,'vjs-full-window');// Resize the box, controller, and poster to original sizes\n// this.positionAll();\n/**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */this.trigger('exitFullWindow');};/**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */Player.prototype.canPlayType=function canPlayType(type){var can=void 0;// Loop through each playback technology in the options order\nfor(var i=0,j=this.options_.techOrder;i<j.length;i++){var techName=j[i];var tech=Tech.getTech(techName);// Support old behavior of techs being registered as components.\n// Remove once that deprecated behavior is removed.\nif(!tech){tech=Component.getComponent(techName);}// Check if the current tech is defined before continuing\nif(!tech){log$1.error('The \"'+techName+'\" tech is undefined. Skipped browser support check for that tech.');continue;}// Check if the browser supports this technology\nif(tech.isSupported()){can=tech.canPlayType(type);if(can){return can;}}}return'';};/**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */Player.prototype.selectSource=function selectSource(sources){var _this6=this;// Get only the techs specified in `techOrder` that exist and are supported by the\n// current platform\nvar techs=this.options_.techOrder.map(function(techName){return[techName,Tech.getTech(techName)];}).filter(function(_ref){var techName=_ref[0],tech=_ref[1];// Check if the current tech is defined before continuing\nif(tech){// Check if the browser supports this technology\nreturn tech.isSupported();}log$1.error('The \"'+techName+'\" tech is undefined. Skipped browser support check for that tech.');return false;});// Iterate over each `innerArray` element once per `outerArray` element and execute\n// `tester` with both. If `tester` returns a non-falsy value, exit early and return\n// that value.\nvar findFirstPassingTechSourcePair=function findFirstPassingTechSourcePair(outerArray,innerArray,tester){var found=void 0;outerArray.some(function(outerChoice){return innerArray.some(function(innerChoice){found=tester(outerChoice,innerChoice);if(found){return true;}});});return found;};var foundSourceAndTech=void 0;var flip=function flip(fn){return function(a,b){return fn(b,a);};};var finder=function finder(_ref2,source){var techName=_ref2[0],tech=_ref2[1];if(tech.canPlaySource(source,_this6.options_[techName.toLowerCase()])){return{source:source,tech:techName};}};// Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n// to select from them based on their priority.\nif(this.options_.sourceOrder){// Source-first ordering\nfoundSourceAndTech=findFirstPassingTechSourcePair(sources,techs,flip(finder));}else{// Tech-first ordering\nfoundSourceAndTech=findFirstPassingTechSourcePair(techs,sources,finder);}return foundSourceAndTech||false;};/**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */Player.prototype.src=function src(source){var _this7=this;// getter usage\nif(typeof source==='undefined'){return this.cache_.src||'';}// filter out invalid sources and turn our source into\n// an array of source objects\nvar sources=filterSource(source);// if a source was passed in then it is invalid because\n// it was filtered to a zero length Array. So we have to\n// show an error\nif(!sources.length){this.setTimeout(function(){this.error({code:4,message:this.localize(this.options_.notSupportedMessage)});},0);return;}// intial sources\nthis.cache_.sources=sources;this.changingSrc_=true;// intial source\nthis.cache_.source=sources[0];// middlewareSource is the source after it has been changed by middleware\nsetSource(this,sources[0],function(middlewareSource,mws){_this7.middleware_=mws;var err=_this7.src_(middlewareSource);if(err){if(sources.length>1){return _this7.src(sources.slice(1));}// We need to wrap this in a timeout to give folks a chance to add error event handlers\n_this7.setTimeout(function(){this.error({code:4,message:this.localize(this.options_.notSupportedMessage)});},0);// we could not find an appropriate tech, but let's still notify the delegate that this is it\n// this needs a better comment about why this is needed\n_this7.triggerReady();return;}_this7.changingSrc_=false;// video element listed source\n_this7.cache_.src=middlewareSource.src;setTech(mws,_this7.tech_);});};/**\n   * Set the source object on the tech, returns a boolean that indicates wether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {Boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */Player.prototype.src_=function src_(source){var sourceTech=this.selectSource([source]);if(!sourceTech){return true;}if(!titleCaseEquals(sourceTech.tech,this.techName_)){this.changingSrc_=true;// load this technology with the chosen source\nthis.loadTech_(sourceTech.tech,sourceTech.source);return false;}// wait until the tech is ready to set the source\nthis.ready(function(){// The setSource tech method was added with source handlers\n// so older techs won't support it\n// We need to check the direct prototype for the case where subclasses\n// of the tech do not support source handlers\nif(this.tech_.constructor.prototype.hasOwnProperty('setSource')){this.techCall_('setSource',source);}else{this.techCall_('src',source.src);}if(this.options_.preload==='auto'){this.load();}// Set the source synchronously if possible (#2326)\n},true);return false;};/**\n   * Begin loading the src data.\n   */Player.prototype.load=function load(){this.techCall_('load');};/**\n   * Reset the player. Loads the first tech in the techOrder,\n   * and calls `reset` on the tech`.\n   */Player.prototype.reset=function reset(){this.loadTech_(this.options_.techOrder[0],null);this.techCall_('reset');};/**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */Player.prototype.currentSources=function currentSources(){var source=this.currentSource();var sources=[];// assume `{}` or `{ src }`\nif(Object.keys(source).length!==0){sources.push(source);}return this.cache_.sources||sources;};/**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */Player.prototype.currentSource=function currentSource(){return this.cache_.source||{};};/**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */Player.prototype.currentSrc=function currentSrc(){return this.currentSource()&&this.currentSource().src||'';};/**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */Player.prototype.currentType=function currentType(){return this.currentSource()&&this.currentSource().type||'';};/**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false maens that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */Player.prototype.preload=function preload(value){if(value!==undefined){this.techCall_('setPreload',value);this.options_.preload=value;return;}return this.techGet_('preload');};/**\n   * Get or set the autoplay attribute.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should autoplay\n   *        - false means that we should not autoplay\n   *\n   * @return {string}\n   *         The current value of autoplay when getting\n   */Player.prototype.autoplay=function autoplay(value){if(value!==undefined){this.techCall_('setAutoplay',value);this.options_.autoplay=value;this.ready(this.forceAutoplayInChrome_);return;}return this.techGet_('autoplay',value);};/**\n   * chrome started pausing the video when moving in the DOM\n   * causing autoplay to not continue due to how Video.js functions.\n   * See #4720 for more info.\n   *\n   * @private\n   */Player.prototype.forceAutoplayInChrome_=function forceAutoplayInChrome_(){if(this.paused()&&(// read from the video element or options\nthis.autoplay()||this.options_.autoplay)&&// only target desktop chrome\nIS_CHROME&&!IS_ANDROID){this.play();}};/**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */Player.prototype.playsinline=function playsinline(value){if(value!==undefined){this.techCall_('setPlaysinline',value);this.options_.playsinline=value;return this;}return this.techGet_('playsinline');};/**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {string}\n   *         The current value of loop when getting\n   */Player.prototype.loop=function loop(value){if(value!==undefined){this.techCall_('setLoop',value);this.options_.loop=value;return;}return this.techGet_('loop');};/**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */Player.prototype.poster=function poster(src){if(src===undefined){return this.poster_;}// The correct way to remove a poster is to set as an empty string\n// other falsey values will throw errors\nif(!src){src='';}// update the internal poster variable\nthis.poster_=src;// update the tech's poster\nthis.techCall_('setPoster',src);// alert components that the poster has been set\n/**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */this.trigger('posterchange');};/**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */Player.prototype.handleTechPosterChange_=function handleTechPosterChange_(){if(!this.poster_&&this.tech_&&this.tech_.poster){this.poster_=this.tech_.poster()||'';// Let components know the poster has changed\nthis.trigger('posterchange');}};/**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */Player.prototype.controls=function controls(bool){if(bool===undefined){return!!this.controls_;}bool=!!bool;// Don't trigger a change event unless it actually changed\nif(this.controls_===bool){return;}this.controls_=bool;if(this.usingNativeControls()){this.techCall_('setControls',bool);}if(this.controls_){this.removeClass('vjs-controls-disabled');this.addClass('vjs-controls-enabled');/**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */this.trigger('controlsenabled');if(!this.usingNativeControls()){this.addTechControlsListeners_();}}else{this.removeClass('vjs-controls-enabled');this.addClass('vjs-controls-disabled');/**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */this.trigger('controlsdisabled');if(!this.usingNativeControls()){this.removeTechControlsListeners_();}}};/**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */Player.prototype.usingNativeControls=function usingNativeControls(bool){if(bool===undefined){return!!this.usingNativeControls_;}bool=!!bool;// Don't trigger a change event unless it actually changed\nif(this.usingNativeControls_===bool){return;}this.usingNativeControls_=bool;if(this.usingNativeControls_){this.addClass('vjs-using-native-controls');/**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */this.trigger('usingnativecontrols');}else{this.removeClass('vjs-using-native-controls');/**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */this.trigger('usingcustomcontrols');}};/**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */Player.prototype.error=function error(err){if(err===undefined){return this.error_||null;}// restoring to default\nif(err===null){this.error_=err;this.removeClass('vjs-error');if(this.errorDisplay){this.errorDisplay.close();}return;}this.error_=new MediaError(err);// add the vjs-error classname to the player\nthis.addClass('vjs-error');// log the name of the error type and any message\n// ie8 just logs \"[object object]\" if you just log the error object\nlog$1.error('(CODE:'+this.error_.code+' '+MediaError.errorTypes[this.error_.code]+')',this.error_.message,this.error_);/**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */this.trigger('error');return;};/**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */Player.prototype.reportUserActivity=function reportUserActivity(event){this.userActivity_=true;};/**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */Player.prototype.userActive=function userActive(bool){if(bool===undefined){return this.userActive_;}bool=!!bool;if(bool===this.userActive_){return;}this.userActive_=bool;if(this.userActive_){this.userActivity_=true;this.removeClass('vjs-user-inactive');this.addClass('vjs-user-active');/**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */this.trigger('useractive');return;}// Chrome/Safari/IE have bugs where when you change the cursor it can\n// trigger a mousemove event. This causes an issue when you're hiding\n// the cursor when the user is inactive, and a mousemove signals user\n// activity. Making it impossible to go into inactive mode. Specifically\n// this happens in fullscreen when we really need to hide the cursor.\n//\n// When this gets resolved in ALL browsers it can be removed\n// https://code.google.com/p/chromium/issues/detail?id=103041\nif(this.tech_){this.tech_.one('mousemove',function(e){e.stopPropagation();e.preventDefault();});}this.userActivity_=false;this.removeClass('vjs-user-active');this.addClass('vjs-user-inactive');/**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */this.trigger('userinactive');};/**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */Player.prototype.listenForUserActivity_=function listenForUserActivity_(){var mouseInProgress=void 0;var lastMoveX=void 0;var lastMoveY=void 0;var handleActivity=bind(this,this.reportUserActivity);var handleMouseMove=function handleMouseMove(e){// #1068 - Prevent mousemove spamming\n// Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\nif(e.screenX!==lastMoveX||e.screenY!==lastMoveY){lastMoveX=e.screenX;lastMoveY=e.screenY;handleActivity();}};var handleMouseDown=function handleMouseDown(){handleActivity();// For as long as the they are touching the device or have their mouse down,\n// we consider them active even if they're not moving their finger or mouse.\n// So we want to continue to update that they are active\nthis.clearInterval(mouseInProgress);// Setting userActivity=true now and setting the interval to the same time\n// as the activityCheck interval (250) should ensure we never miss the\n// next activityCheck\nmouseInProgress=this.setInterval(handleActivity,250);};var handleMouseUp=function handleMouseUp(event){handleActivity();// Stop the interval that maintains activity if the mouse/touch is down\nthis.clearInterval(mouseInProgress);};// Any mouse movement will be considered user activity\nthis.on('mousedown',handleMouseDown);this.on('mousemove',handleMouseMove);this.on('mouseup',handleMouseUp);// Listen for keyboard navigation\n// Shouldn't need to use inProgress interval because of key repeat\nthis.on('keydown',handleActivity);this.on('keyup',handleActivity);// Run an interval every 250 milliseconds instead of stuffing everything into\n// the mousemove/touchmove function itself, to prevent performance degradation.\n// `this.reportUserActivity` simply sets this.userActivity_ to true, which\n// then gets picked up by this loop\n// http://ejohn.org/blog/learning-from-twitter/\nvar inactivityTimeout=void 0;this.setInterval(function(){// Check to see if mouse/touch activity has happened\nif(!this.userActivity_){return;}// Reset the activity tracker\nthis.userActivity_=false;// If the user state was inactive, set the state to active\nthis.userActive(true);// Clear any existing inactivity timeout to start the timer over\nthis.clearTimeout(inactivityTimeout);var timeout=this.options_.inactivityTimeout;if(timeout<=0){return;}// In <timeout> milliseconds, if no more activity has occurred the\n// user will be considered inactive\ninactivityTimeout=this.setTimeout(function(){// Protect against the case where the inactivityTimeout can trigger just\n// before the next user activity is picked up by the activity check loop\n// causing a flicker\nif(!this.userActivity_){this.userActive(false);}},timeout);},250);};/**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */Player.prototype.playbackRate=function playbackRate(rate){if(rate!==undefined){this.techCall_('setPlaybackRate',rate);return;}if(this.tech_&&this.tech_.featuresPlaybackRate){return this.techGet_('playbackRate');}return 1.0;};/**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */Player.prototype.defaultPlaybackRate=function defaultPlaybackRate(rate){if(rate!==undefined){return this.techCall_('setDefaultPlaybackRate',rate);}if(this.tech_&&this.tech_.featuresPlaybackRate){return this.techGet_('defaultPlaybackRate');}return 1.0;};/**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */Player.prototype.isAudio=function isAudio(bool){if(bool!==undefined){this.isAudio_=!!bool;return;}return!!this.isAudio_;};/**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */Player.prototype.addTextTrack=function addTextTrack(kind,label,language){if(this.tech_){return this.tech_.addTextTrack(kind,label,language);}};/**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will\n   * automatically removed from the video element whenever the source changes, unless\n   * manualCleanup is set to false.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */Player.prototype.addRemoteTextTrack=function addRemoteTextTrack(options,manualCleanup){if(this.tech_){return this.tech_.addRemoteTextTrack(options,manualCleanup);}};/**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */Player.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(){var _ref3=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref3$track=_ref3.track,track=_ref3$track===undefined?arguments[0]:_ref3$track;// destructure the input into an object with a track argument, defaulting to arguments[0]\n// default the whole argument to an empty object if nothing was passed in\nif(this.tech_){return this.tech_.removeRemoteTextTrack(track);}};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */Player.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){return this.techGet_('getVideoPlaybackQuality');};/**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */Player.prototype.videoWidth=function videoWidth(){return this.tech_&&this.tech_.videoWidth&&this.tech_.videoWidth()||0;};/**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */Player.prototype.videoHeight=function videoHeight(){return this.tech_&&this.tech_.videoHeight&&this.tech_.videoHeight()||0;};/**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the lanugage\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */Player.prototype.language=function language(code){if(code===undefined){return this.language_;}this.language_=String(code).toLowerCase();};/**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */Player.prototype.languages=function languages(){return mergeOptions(Player.prototype.options_.languages,this.languages_);};/**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */Player.prototype.toJSON=function toJSON(){var options=mergeOptions(this.options_);var tracks=options.tracks;options.tracks=[];for(var i=0;i<tracks.length;i++){var track=tracks[i];// deep merge tracks and null out player so no circular references\ntrack=mergeOptions(track);track.player=undefined;options.tracks[i]=track;}return options;};/**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */Player.prototype.createModal=function createModal(content,options){var _this8=this;options=options||{};options.content=content||'';var modal=new ModalDialog(this,options);this.addChild(modal);modal.on('dispose',function(){_this8.removeChild(modal);});modal.open();return modal;};/**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */Player.getTagSettings=function getTagSettings(tag){var baseOptions={sources:[],tracks:[]};var tagOptions=getAttributes(tag);var dataSetup=tagOptions['data-setup'];if(hasClass(tag,'vjs-fluid')){tagOptions.fluid=true;}// Check if data-setup attr exists.\nif(dataSetup!==null){// Parse options JSON\n// If empty string, make it a parsable json object.\nvar _safeParseTuple=safeParseTuple(dataSetup||'{}'),err=_safeParseTuple[0],data=_safeParseTuple[1];if(err){log$1.error(err);}assign(tagOptions,data);}assign(baseOptions,tagOptions);// Get tag children settings\nif(tag.hasChildNodes()){var children=tag.childNodes;for(var i=0,j=children.length;i<j;i++){var child=children[i];// Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\nvar childName=child.nodeName.toLowerCase();if(childName==='source'){baseOptions.sources.push(getAttributes(child));}else if(childName==='track'){baseOptions.tracks.push(getAttributes(child));}}}return baseOptions;};/**\n   * Determine wether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */Player.prototype.flexNotSupported_=function flexNotSupported_(){var elem=document.createElement('i');// Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n// common flex features that we can rely on when checking for flex support.\nreturn!('flexBasis'in elem.style||'webkitFlexBasis'in elem.style||'mozFlexBasis'in elem.style||'msFlexBasis'in elem.style||// IE10-specific (2012 flex spec)\n'msFlexOrder'in elem.style);};return Player;}(Component);/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n *//**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n *//**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n *//**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n *//**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */ALL.names.forEach(function(name$$1){var props=ALL[name$$1];Player.prototype[props.getterName]=function(){if(this.tech_){return this.tech_[props.getterName]();}// if we have not yet loadTech_, we create {video,audio,text}Tracks_\n// these will be passed to the tech during loading\nthis[props.privateName]=this[props.privateName]||new props.ListClass();return this[props.privateName];};});/**\n * Global player list\n *\n * @type {Object}\n */Player.players={};var navigator=window.navigator;/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */Player.prototype.options_={// Default order of fallback technology\ntechOrder:Tech.defaultTechOrder_,html5:{},flash:{},// default inactivity timeout\ninactivityTimeout:2000,// default playback rates\nplaybackRates:[],// Add playback rate selection by adding rates\n// 'playbackRates': [0.5, 1, 1.5, 2],\n// Included control sets\nchildren:['mediaLoader','posterImage','textTrackDisplay','loadingSpinner','bigPlayButton','controlBar','errorDisplay','textTrackSettings'],language:navigator&&(navigator.languages&&navigator.languages[0]||navigator.userLanguage||navigator.language)||'en',// locales and their language translations\nlanguages:{},// Default message to show when a video cannot be played.\nnotSupportedMessage:'No compatible source was found for this media.'};[/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */'ended',/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */'seeking',/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */'seekable',/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */'networkState',/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */'readyState'].forEach(function(fn){Player.prototype[fn]=function(){return this.techGet_(fn);};});TECH_EVENTS_RETRIGGER.forEach(function(event){Player.prototype['handleTech'+toTitleCase(event)+'_']=function(){return this.trigger(event);};});/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n *//**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n *//**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n *//**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n *//**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n *//**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */Component.registerComponent('Player',Player);/**\n * @file plugin.js\n *//**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */var BASE_PLUGIN_NAME='plugin';/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */var PLUGIN_CACHE_KEY='activePlugins_';/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */var pluginStorage={};/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {boolean}\n *          Whether or not the plugin has been registered.\n */var pluginExists=function pluginExists(name){return pluginStorage.hasOwnProperty(name);};/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {Function|undefined}\n *          The plugin (or undefined).\n */var getPlugin=function getPlugin(name){return pluginExists(name)?pluginStorage[name]:undefined;};/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */var markPluginAsActive=function markPluginAsActive(player,name){player[PLUGIN_CACHE_KEY]=player[PLUGIN_CACHE_KEY]||{};player[PLUGIN_CACHE_KEY][name]=true;};/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {Boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */var triggerSetupEvent=function triggerSetupEvent(player,hash,before){var eventName=(before?'before':'')+'pluginsetup';player.trigger(eventName,hash);player.trigger(eventName+':'+hash.name,hash);};/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @returns {Function}\n *          A wrapper function for the given plugin.\n */var createBasicPlugin=function createBasicPlugin(name,plugin){var basicPluginWrapper=function basicPluginWrapper(){// We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n// regardless, but we want the hash to be consistent with the hash provided\n// for advanced plugins.\n//\n// The only potentially counter-intuitive thing here is the `instance` in\n// the \"pluginsetup\" event is the value returned by the `plugin` function.\ntriggerSetupEvent(this,{name:name,plugin:plugin,instance:null},true);var instance=plugin.apply(this,arguments);markPluginAsActive(this,name);triggerSetupEvent(this,{name:name,plugin:plugin,instance:instance});return instance;};Object.keys(plugin).forEach(function(prop){basicPluginWrapper[prop]=plugin[prop];});return basicPluginWrapper;};/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @returns {Function}\n */var createPluginFactory=function createPluginFactory(name,PluginSubClass){// Add a `name` property to the plugin prototype so that each plugin can\n// refer to itself by name.\nPluginSubClass.prototype.name=name;return function(){triggerSetupEvent(this,{name:name,plugin:PluginSubClass,instance:null},true);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var instance=new(Function.prototype.bind.apply(PluginSubClass,[null].concat([this].concat(args))))();// The plugin is replaced by a function that returns the current instance.\nthis[name]=function(){return instance;};triggerSetupEvent(this,instance.getEventHash());return instance;};};/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */var Plugin=function(){/**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */function Plugin(player){classCallCheck(this,Plugin);if(this.constructor===Plugin){throw new Error('Plugin must be sub-classed; not directly instantiated.');}this.player=player;// Make this object evented, but remove the added `trigger` method so we\n// use the prototype version instead.\nevented(this);delete this.trigger;stateful(this,this.constructor.defaultState);markPluginAsActive(player,this.name);// Auto-bind the dispose method so we can use it as a listener and unbind\n// it later easily.\nthis.dispose=bind(this,this.dispose);// If the player is disposed, dispose the plugin.\nplayer.on('dispose',this.dispose);}/**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */Plugin.prototype.version=function version(){return this.constructor.VERSION;};/**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @returns {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */Plugin.prototype.getEventHash=function getEventHash(){var hash=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};hash.name=this.name;hash.plugin=this.constructor;hash.instance=this;return hash;};/**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @returns {boolean}\n   *          Whether or not default was prevented.\n   */Plugin.prototype.trigger=function trigger$$1(event){var hash=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return trigger(this.eventBusEl_,event,this.getEventHash(hash));};/**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */Plugin.prototype.handleStateChanged=function handleStateChanged(e){};/**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */Plugin.prototype.dispose=function dispose(){var name=this.name,player=this.player;/**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */this.trigger('dispose');this.off();player.off('dispose',this.dispose);// Eliminate any possible sources of leaking memory by clearing up\n// references between the player and the plugin instance and nulling out\n// the plugin's state and replacing methods with a function that throws.\nplayer[PLUGIN_CACHE_KEY][name]=false;this.player=this.state=null;// Finally, replace the plugin name on the player with a new factory\n// function, so that the plugin is ready to be set up again.\nplayer[name]=createPluginFactory(name,pluginStorage[name]);};/**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @returns {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */Plugin.isBasic=function isBasic(plugin){var p=typeof plugin==='string'?getPlugin(plugin):plugin;return typeof p==='function'&&!Plugin.prototype.isPrototypeOf(p.prototype);};/**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @returns {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */Plugin.registerPlugin=function registerPlugin(name,plugin){if(typeof name!=='string'){throw new Error('Illegal plugin name, \"'+name+'\", must be a string, was '+(typeof name==='undefined'?'undefined':_typeof(name))+'.');}if(pluginExists(name)){log$1.warn('A plugin named \"'+name+'\" already exists. You may want to avoid re-registering plugins!');}else if(Player.prototype.hasOwnProperty(name)){throw new Error('Illegal plugin name, \"'+name+'\", cannot share a name with an existing player method!');}if(typeof plugin!=='function'){throw new Error('Illegal plugin for \"'+name+'\", must be a function, was '+(typeof plugin==='undefined'?'undefined':_typeof(plugin))+'.');}pluginStorage[name]=plugin;// Add a player prototype method for all sub-classed plugins (but not for\n// the base Plugin class).\nif(name!==BASE_PLUGIN_NAME){if(Plugin.isBasic(plugin)){Player.prototype[name]=createBasicPlugin(name,plugin);}else{Player.prototype[name]=createPluginFactory(name,plugin);}}return plugin;};/**\n   * De-register a Video.js plugin.\n   *\n   * @param {string} name\n   *        The name of the plugin to be deregistered.\n   */Plugin.deregisterPlugin=function deregisterPlugin(name){if(name===BASE_PLUGIN_NAME){throw new Error('Cannot de-register base plugin.');}if(pluginExists(name)){delete pluginStorage[name];delete Player.prototype[name];}};/**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @returns {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */Plugin.getPlugins=function getPlugins(){var names=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Object.keys(pluginStorage);var result=void 0;names.forEach(function(name){var plugin=getPlugin(name);if(plugin){result=result||{};result[name]=plugin;}});return result;};/**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @returns {string}\n   *          The plugin's version or an empty string.\n   */Plugin.getPluginVersion=function getPluginVersion(name){var plugin=getPlugin(name);return plugin&&plugin.VERSION||'';};return Plugin;}();/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */Plugin.getPlugin=getPlugin;/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */Plugin.BASE_PLUGIN_NAME=BASE_PLUGIN_NAME;Plugin.registerPlugin(BASE_PLUGIN_NAME,Plugin);/**\n * Documented in player.js\n *\n * @ignore\n */Player.prototype.usingPlugin=function(name){return!!this[PLUGIN_CACHE_KEY]&&this[PLUGIN_CACHE_KEY][name]===true;};/**\n * Documented in player.js\n *\n * @ignore\n */Player.prototype.hasPlugin=function(name){return!!pluginExists(name);};/**\n * Signals that a plugin is about to be set up on a player.\n *\n * @event    Player#beforepluginsetup\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin is about to be set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#beforepluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin has just been set up on a player.\n *\n * @event    Player#pluginsetup\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin has just been set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#pluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n *//**\n * @typedef  {Object} Plugin~PluginEventHash\n *\n * @property {string} instance\n *           For basic plugins, the return value of the plugin function. For\n *           advanced plugins, the plugin instance on which the event is fired.\n *\n * @property {string} name\n *           The name of the plugin.\n *\n * @property {string} plugin\n *           For basic plugins, the plugin function. For advanced plugins, the\n *           plugin class/constructor.\n *//**\n * @file extend.js\n * @module extend\n *//**\n * A combination of node inherits and babel's inherits (after transpile).\n * Both work the same but node adds `super_` to the subClass\n * and Bable adds the superClass as __proto__. Both seem useful.\n *\n * @param {Object} subClass\n *        The class to inherit to\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @private\n */var _inherits=function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+(typeof superClass==='undefined'?'undefined':_typeof(superClass)));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass){// node\nsubClass.super_=superClass;}};/**\n * Function for subclassing using the same inheritance that\n * videojs uses internally\n *\n * @static\n * @const\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @param {Object} [subClassMethods={}]\n *        The class to inherit to\n *\n * @return {Object}\n *         The new object with subClassMethods that inherited superClass.\n */var extendFn=function extendFn(superClass){var subClassMethods=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var subClass=function subClass(){superClass.apply(this,arguments);};var methods={};if((typeof subClassMethods==='undefined'?'undefined':_typeof(subClassMethods))==='object'){if(subClassMethods.constructor!==Object.prototype.constructor){subClass=subClassMethods.constructor;}methods=subClassMethods;}else if(typeof subClassMethods==='function'){subClass=subClassMethods;}_inherits(subClass,superClass);// Extend subObj's prototype with functions and other properties from props\nfor(var name in methods){if(methods.hasOwnProperty(name)){subClass.prototype[name]=methods[name];}}return subClass;};/**\n * @file video.js\n * @module videojs\n */// Include the built-in techs\n// HTML5 Element Shim for IE8\nif(typeof HTMLVideoElement==='undefined'&&isReal()){document.createElement('video');document.createElement('audio');document.createElement('track');document.createElement('video-js');}/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n * The `videojs` function can be used to initialize or retrieve a player.\n  *\n * @param {string|Element} id\n *        Video element or video element ID\n *\n * @param {Object} [options]\n *        Optional options object for config/settings\n *\n * @param {Component~ReadyCallback} [ready]\n *        Optional ready callback\n *\n * @return {Player}\n *         A player instance\n */function videojs(id,options,ready){var tag=void 0;// Allow for element or ID to be passed in\n// String ID\nif(typeof id==='string'){var players=videojs.getPlayers();// Adjust for jQuery ID syntax\nif(id.indexOf('#')===0){id=id.slice(1);}// If a player instance has already been created for this ID return it.\nif(players[id]){// If options or ready function are passed, warn\nif(options){log$1.warn('Player \"'+id+'\" is already initialised. Options will not be applied.');}if(ready){players[id].ready(ready);}return players[id];}// Otherwise get element for ID\ntag=$('#'+id);// ID is a media element\n}else{tag=id;}// Check for a useable element\n// re: nodeName, could be a box div also\nif(!tag||!tag.nodeName){throw new TypeError('The element or ID supplied is not valid. (videojs)');}// Element may have a player attr referring to an already created player instance.\n// If so return that otherwise set up a new player below\nif(tag.player||Player.players[tag.playerId]){return tag.player||Player.players[tag.playerId];}// Check if element is included in the DOM\nif(isEl(tag)&&!document.body.contains(tag)){log$1.warn('The element supplied is not included in the DOM');}options=options||{};videojs.hooks('beforesetup').forEach(function(hookFunction){var opts=hookFunction(tag,mergeOptions(options));if(!isObject(opts)||Array.isArray(opts)){log$1.error('please return an object in beforesetup hooks');return;}options=mergeOptions(options,opts);});var PlayerComponent=Component.getComponent('Player');// If not, set up a new player\nvar player=new PlayerComponent(tag,options,ready);videojs.hooks('setup').forEach(function(hookFunction){return hookFunction(player);});return player;}/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n */videojs.hooks_={};/**\n * Get a list of hooks for a specific lifecycle\n * @function videojs.hooks\n *\n * @param {string} type\n *        the lifecyle to get hooks from\n *\n * @param {Function|Function[]} [fn]\n *        Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */videojs.hooks=function(type,fn){videojs.hooks_[type]=videojs.hooks_[type]||[];if(fn){videojs.hooks_[type]=videojs.hooks_[type].concat(fn);}return videojs.hooks_[type];};/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */videojs.hook=function(type,fn){videojs.hooks(type,fn);};/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */videojs.hookOnce=function(type,fn){videojs.hooks(type,[].concat(fn).map(function(original){var wrapper=function wrapper(){videojs.removeHook(type,wrapper);original.apply(undefined,arguments);};return wrapper;}));};/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle that the function hooked to\n *\n * @param {Function} fn\n *        The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */videojs.removeHook=function(type,fn){var index=videojs.hooks(type).indexOf(fn);if(index<=-1){return false;}videojs.hooks_[type]=videojs.hooks_[type].slice();videojs.hooks_[type].splice(index,1);return true;};// Add default styles\nif(window.VIDEOJS_NO_DYNAMIC_STYLE!==true&&isReal()){var style=$('.vjs-styles-defaults');if(!style){style=createStyleElement('vjs-styles-defaults');var head=$('head');if(head){head.insertBefore(style,head.firstChild);}setTextContent(style,'\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    ');}}// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\nautoSetupTimeout(1,videojs);/**\n * Current software version. Follows semver.\n *\n * @type {string}\n */videojs.VERSION=version;/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */videojs.options=Player.prototype.options_;/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */videojs.getPlayers=function(){return Player.players;};/**\n * Expose players object.\n *\n * @memberOf videojs\n * @property {Object} players\n */videojs.players=Player.players;/**\n * Get a component class object by name\n *\n * @borrows Component.getComponent as videojs.getComponent\n */videojs.getComponent=Component.getComponent;/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */videojs.registerComponent=function(name$$1,comp){if(Tech.isTech(comp)){log$1.warn('The '+name$$1+' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');}Component.registerComponent.call(Component,name$$1,comp);};/**\n * Get a Tech class object by name\n *\n * @borrows Tech.getTech as videojs.getTech\n */videojs.getTech=Tech.getTech;/**\n * Register a Tech so it can referred to by name.\n * This is used in the tech order for the player.\n *\n * @borrows Tech.registerTech as videojs.registerTech\n */videojs.registerTech=Tech.registerTech;videojs.use=use;/**\n * A suite of browser and device tests from {@link browser}.\n *\n * @type {Object}\n * @private\n */videojs.browser=browser;/**\n * Whether or not the browser supports touch events. Included for backward\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\n * instead going forward.\n *\n * @deprecated since version 5.0\n * @type {boolean}\n */videojs.TOUCH_ENABLED=TOUCH_ENABLED;/**\n * Subclass an existing class\n * Mimics ES6 subclassing with the `extend` keyword\n *\n * @borrows extend:extendFn as videojs.extend\n */videojs.extend=extendFn;/**\n * Merge two options objects recursively\n * Performs a deep merge like lodash.merge but **only merges plain objects**\n * (not arrays, elements, anything else)\n * Other values will be copied directly from the second object.\n *\n * @borrows merge-options:mergeOptions as videojs.mergeOptions\n */videojs.mergeOptions=mergeOptions;/**\n * Change the context (this) of a function\n *\n * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native\n * `function() {}.bind(newContext);` instead of this.\n *\n * @borrows fn:bind as videojs.bind\n */videojs.bind=bind;/**\n * Register a Video.js plugin.\n *\n * @borrows plugin:registerPlugin as videojs.registerPlugin\n * @method registerPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be registered. Must be a string and\n *         must not match an existing plugin or a method on the `Player`\n *         prototype.\n *\n * @param  {Function} plugin\n *         A sub-class of `Plugin` or a function for basic plugins.\n *\n * @return {Function}\n *         For advanced plugins, a factory function for that plugin. For\n *         basic plugins, a wrapper function that initializes the plugin.\n */videojs.registerPlugin=Plugin.registerPlugin;/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated\n *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */videojs.plugin=function(name$$1,plugin){log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');return Plugin.registerPlugin(name$$1,plugin);};/**\n * Gets an object containing multiple Video.js plugins.\n *\n * @param  {Array} [names]\n *         If provided, should be an array of plugin names. Defaults to _all_\n *         plugin names.\n *\n * @return {Object|undefined}\n *         An object containing plugin(s) associated with their name(s) or\n *         `undefined` if no matching plugins exist).\n */videojs.getPlugins=Plugin.getPlugins;/**\n * Gets a plugin by name if it exists.\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {Function|undefined}\n *         The plugin (or `undefined`).\n */videojs.getPlugin=Plugin.getPlugin;/**\n * Gets a plugin's version, if available\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {string}\n *         The plugin's version or an empty string.\n */videojs.getPluginVersion=Plugin.getPluginVersion;/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */videojs.addLanguage=function(code,data){var _mergeOptions;code=(''+code).toLowerCase();videojs.options.languages=mergeOptions(videojs.options.languages,(_mergeOptions={},_mergeOptions[code]=data,_mergeOptions));return videojs.options.languages[code];};/**\n * Log messages\n *\n * @borrows log:log as videojs.log\n */videojs.log=log$1;/**\n * Creates an emulated TimeRange object.\n *\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRange\n *//**\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges\n */videojs.createTimeRange=videojs.createTimeRanges=createTimeRanges;/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n *\n * @borrows format-time:formatTime as videojs.formatTime\n */videojs.formatTime=formatTime;/**\n * Resolve and parse the elements of a URL\n *\n * @borrows url:parseUrl as videojs.parseUrl\n */videojs.parseUrl=parseUrl;/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @borrows url:isCrossOrigin as videojs.isCrossOrigin\n */videojs.isCrossOrigin=isCrossOrigin;/**\n * Event target class.\n *\n * @borrows EventTarget as videojs.EventTarget\n */videojs.EventTarget=EventTarget;/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @borrows events:on as videojs.on\n */videojs.on=on;/**\n * Trigger a listener only once for an event\n *\n * @borrows events:one as videojs.one\n */videojs.one=one;/**\n * Removes event listeners from an element\n *\n * @borrows events:off as videojs.off\n */videojs.off=off;/**\n * Trigger an event for an element\n *\n * @borrows events:trigger as videojs.trigger\n */videojs.trigger=trigger;/**\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\n *\n * @param {Object} options\n *        settings for the request.\n *\n * @return {XMLHttpRequest|XDomainRequest}\n *         The request object.\n *\n * @see https://github.com/Raynos/xhr\n */videojs.xhr=xhr;/**\n * TextTrack class\n *\n * @borrows TextTrack as videojs.TextTrack\n */videojs.TextTrack=TextTrack;/**\n * export the AudioTrack class so that source handlers can create\n * AudioTracks and then add them to the players AudioTrackList\n *\n * @borrows AudioTrack as videojs.AudioTrack\n */videojs.AudioTrack=AudioTrack;/**\n * export the VideoTrack class so that source handlers can create\n * VideoTracks and then add them to the players VideoTrackList\n *\n * @borrows VideoTrack as videojs.VideoTrack\n */videojs.VideoTrack=VideoTrack;/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @borrows dom:isEl as videojs.isEl\n * @deprecated Use videojs.dom.isEl() instead\n *//**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @borrows dom:isTextNode as videojs.isTextNode\n * @deprecated Use videojs.dom.isTextNode() instead\n *//**\n * Creates an element and applies properties.\n *\n * @borrows dom:createEl as videojs.createEl\n * @deprecated Use videojs.dom.createEl() instead\n *//**\n * Check if an element has a CSS class\n *\n * @borrows dom:hasElClass as videojs.hasClass\n * @deprecated Use videojs.dom.hasClass() instead\n *//**\n * Add a CSS class name to an element\n *\n * @borrows dom:addElClass as videojs.addClass\n * @deprecated Use videojs.dom.addClass() instead\n *//**\n * Remove a CSS class name from an element\n *\n * @borrows dom:removeElClass as videojs.removeClass\n * @deprecated Use videojs.dom.removeClass() instead\n *//**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @borrows dom:toggleElClass as videojs.toggleClass\n * @deprecated Use videojs.dom.toggleClass() instead\n *//**\n * Apply attributes to an HTML element.\n *\n * @borrows dom:setElAttributes as videojs.setAttribute\n * @deprecated Use videojs.dom.setAttributes() instead\n *//**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @borrows dom:getElAttributes as videojs.getAttributes\n * @deprecated Use videojs.dom.getAttributes() instead\n *//**\n * Empties the contents of an element.\n *\n * @borrows dom:emptyEl as videojs.emptyEl\n * @deprecated Use videojs.dom.emptyEl() instead\n *//**\n * Normalizes and appends content to an element.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:appendContents as videojs.appendContet\n * @deprecated Use videojs.dom.appendContent() instead\n *//**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:insertContent as videojs.insertContent\n * @deprecated Use videojs.dom.insertContent() instead\n */['isEl','isTextNode','createEl','hasClass','addClass','removeClass','toggleClass','setAttributes','getAttributes','emptyEl','appendContent','insertContent'].forEach(function(k){videojs[k]=function(){log$1.warn('videojs.'+k+'() is deprecated; use videojs.dom.'+k+'() instead');return Dom[k].apply(null,arguments);};});/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is because in Firefox, if the player is loaded in an iframe with `display:none`,\n * then `getComputedStyle` returns `null`, so, we do a null-check to make sure\n * that the player doesn't break in these cases.\n * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.\n *\n * @borrows computed-style:computedStyle as videojs.computedStyle\n */videojs.computedStyle=computedStyle;/**\n * Export the Dom utilities for use in external plugins\n * and Tech's\n */videojs.dom=Dom;/**\n * Export the Url utilities for use in external plugins\n * and Tech's\n */videojs.url=Url;module.exports=videojs;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjYuMEB2aWRlby5qcy9kaXN0L3ZpZGVvLmNqcy5qcz9lM2E5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIFZpZGVvLmpzIDYuNi4wIDxodHRwOi8vdmlkZW9qcy5jb20vPlxuICogQ29weXJpZ2h0IEJyaWdodGNvdmUsIEluYy4gPGh0dHBzOi8vd3d3LmJyaWdodGNvdmUuY29tLz5cbiAqIEF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMFxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0U+XG4gKlxuICogSW5jbHVkZXMgdnR0LmpzIDxodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanM+XG4gKiBBdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjBcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cbiAqL1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHdpbmRvdyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdnbG9iYWwvd2luZG93JykpO1xudmFyIGRvY3VtZW50ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2dsb2JhbC9kb2N1bWVudCcpKTtcbnZhciB0c21sID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3RzbWwnKSk7XG52YXIgc2FmZVBhcnNlVHVwbGUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnc2FmZS1qc29uLXBhcnNlL3R1cGxlJykpO1xudmFyIHhociA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd4aHInKSk7XG52YXIgdnR0ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3ZpZGVvanMtdnR0LmpzJykpO1xuXG52YXIgdmVyc2lvbiA9IFwiNi42LjBcIjtcblxuLyoqXG4gKiBAZmlsZSBicm93c2VyLmpzXG4gKiBAbW9kdWxlIGJyb3dzZXJcbiAqL1xudmFyIFVTRVJfQUdFTlQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xudmFyIHdlYmtpdFZlcnNpb25NYXAgPSAvQXBwbGVXZWJLaXRcXC8oW1xcZC5dKykvaS5leGVjKFVTRVJfQUdFTlQpO1xudmFyIGFwcGxlV2Via2l0VmVyc2lvbiA9IHdlYmtpdFZlcnNpb25NYXAgPyBwYXJzZUZsb2F0KHdlYmtpdFZlcnNpb25NYXAucG9wKCkpIDogbnVsbDtcblxuLypcbiAqIERldmljZSBpcyBhbiBpUGhvbmVcbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIElTX0lQQUQgPSAvaVBhZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG5cbi8vIFRoZSBGYWNlYm9vayBhcHAncyBVSVdlYlZpZXcgaWRlbnRpZmllcyBhcyBib3RoIGFuIGlQaG9uZSBhbmQgaVBhZCwgc29cbi8vIHRvIGlkZW50aWZ5IGlQaG9uZXMsIHdlIG5lZWQgdG8gZXhjbHVkZSBpUGFkcy5cbi8vIGh0dHA6Ly9hcnRzeS5naXRodWIuaW8vYmxvZy8yMDEyLzEwLzE4L3RoZS1wZXJpbHMtb2YtaW9zLXVzZXItYWdlbnQtc25pZmZpbmcvXG52YXIgSVNfSVBIT05FID0gL2lQaG9uZS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0lQQUQ7XG52YXIgSVNfSVBPRCA9IC9pUG9kL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xuXG52YXIgSU9TX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL09TIChcXGQrKV8vaSk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIG1hdGNoWzFdO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xuXG52YXIgSVNfQU5EUk9JRCA9IC9BbmRyb2lkL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBBTkRST0lEX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoaXMgbWF0Y2hlcyBBbmRyb2lkIE1ham9yLk1pbm9yLlBhdGNoIHZlcnNpb25zXG4gIC8vIEFORFJPSURfVkVSU0lPTiBpcyBNYWpvci5NaW5vciBhcyBhIE51bWJlciwgaWYgTWlub3IgaXNuJ3QgYXZhaWxhYmxlLCB0aGVuIG9ubHkgTWFqb3IgaXMgcmV0dXJuZWRcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYWpvciA9IG1hdGNoWzFdICYmIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgbWlub3IgPSBtYXRjaFsyXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzJdKTtcblxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSArICcuJyArIG1hdGNoWzJdKTtcbiAgfSBlbHNlIGlmIChtYWpvcikge1xuICAgIHJldHVybiBtYWpvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxuLy8gT2xkIEFuZHJvaWQgaXMgZGVmaW5lZCBhcyBWZXJzaW9uIG9sZGVyIHRoYW4gMi4zLCBhbmQgcmVxdWlyaW5nIGEgd2Via2l0IHZlcnNpb24gb2YgdGhlIGFuZHJvaWQgYnJvd3NlclxudmFyIElTX09MRF9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiAvd2Via2l0L2kudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XG52YXIgSVNfTkFUSVZFX0FORFJPSUQgPSBJU19BTkRST0lEICYmIEFORFJPSURfVkVSU0lPTiA8IDUgJiYgYXBwbGVXZWJraXRWZXJzaW9uIDwgNTM3O1xuXG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19FREdFID0gL0VkZ2UvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIElTX0NIUk9NRSA9ICFJU19FREdFICYmIC9DaHJvbWUvaS50ZXN0KFVTRVJfQUdFTlQpO1xudmFyIENIUk9NRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG52YXIgSVNfSUU4ID0gL01TSUVcXHM4XFwuMC8udGVzdChVU0VSX0FHRU5UKTtcbnZhciBJRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gL01TSUVcXHMoXFxkKylcXC5cXGQvLmV4ZWMoVVNFUl9BR0VOVCk7XG4gIHZhciB2ZXJzaW9uID0gcmVzdWx0ICYmIHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcblxuICBpZiAoIXZlcnNpb24gJiYgL1RyaWRlbnRcXC83LjAvaS50ZXN0KFVTRVJfQUdFTlQpICYmIC9ydjoxMS4wLy50ZXN0KFVTRVJfQUdFTlQpKSB7XG4gICAgLy8gSUUgMTEgaGFzIGEgZGlmZmVyZW50IHVzZXIgYWdlbnQgc3RyaW5nIHRoYW4gb3RoZXIgSUUgdmVyc2lvbnNcbiAgICB2ZXJzaW9uID0gMTEuMDtcbiAgfVxuXG4gIHJldHVybiB2ZXJzaW9uO1xufSgpO1xuXG52YXIgSVNfU0FGQVJJID0gL1NhZmFyaS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0NIUk9NRSAmJiAhSVNfQU5EUk9JRCAmJiAhSVNfRURHRTtcbnZhciBJU19BTllfU0FGQVJJID0gSVNfU0FGQVJJIHx8IElTX0lPUztcblxudmFyIFRPVUNIX0VOQUJMRUQgPSBpc1JlYWwoKSAmJiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIHdpbmRvdy5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKTtcblxudmFyIEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSBpc1JlYWwoKSAmJiAnYmFja2dyb3VuZFNpemUnIGluIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLnN0eWxlO1xuXG52YXIgYnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRJU19JUEFEOiBJU19JUEFELFxuXHRJU19JUEhPTkU6IElTX0lQSE9ORSxcblx0SVNfSVBPRDogSVNfSVBPRCxcblx0SVNfSU9TOiBJU19JT1MsXG5cdElPU19WRVJTSU9OOiBJT1NfVkVSU0lPTixcblx0SVNfQU5EUk9JRDogSVNfQU5EUk9JRCxcblx0QU5EUk9JRF9WRVJTSU9OOiBBTkRST0lEX1ZFUlNJT04sXG5cdElTX09MRF9BTkRST0lEOiBJU19PTERfQU5EUk9JRCxcblx0SVNfTkFUSVZFX0FORFJPSUQ6IElTX05BVElWRV9BTkRST0lELFxuXHRJU19GSVJFRk9YOiBJU19GSVJFRk9YLFxuXHRJU19FREdFOiBJU19FREdFLFxuXHRJU19DSFJPTUU6IElTX0NIUk9NRSxcblx0Q0hST01FX1ZFUlNJT046IENIUk9NRV9WRVJTSU9OLFxuXHRJU19JRTg6IElTX0lFOCxcblx0SUVfVkVSU0lPTjogSUVfVkVSU0lPTixcblx0SVNfU0FGQVJJOiBJU19TQUZBUkksXG5cdElTX0FOWV9TQUZBUkk6IElTX0FOWV9TQUZBUkksXG5cdFRPVUNIX0VOQUJMRUQ6IFRPVUNIX0VOQUJMRUQsXG5cdEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQ6IEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURURcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSA9IGZ1bmN0aW9uIChzdHJpbmdzLCByYXcpIHtcbiAgc3RyaW5ncy5yYXcgPSByYXc7XG4gIHJldHVybiBzdHJpbmdzO1xufTtcblxuLyoqXG4gKiBAZmlsZSBvYmouanNcbiAqIEBtb2R1bGUgb2JqXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOkVhY2hDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb2JqOlJlZHVjZUNhbGxiYWNrXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYWNjdW1cbiAqICAgICAgICBUaGUgdmFsdWUgdGhhdCBpcyBhY2N1bXVsYXRpbmcgb3ZlciB0aGUgcmVkdWNlIGxvb3AuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXkgZm9yIHRoZSBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXktdmFsdWUgZm9yIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXJcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIG5ldyBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBHZXQgdGhlIGtleXMgb2YgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiAgICAgICAgVGhlIE9iamVjdCB0byBnZXQgdGhlIGtleXMgZnJvbVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogICAgICAgICBBbiBhcnJheSBvZiB0aGUga2V5cyBmcm9tIHRoZSBvYmplY3QuIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgdGhlXG4gKiAgICAgICAgIG9iamVjdCBwYXNzZWQgaW4gd2FzIGludmFsaWQgb3IgaGFkIG5vIGtleXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IE9iamVjdC5rZXlzKG9iamVjdCkgOiBbXTtcbn07XG5cbi8qKlxuICogQXJyYXktbGlrZSBpdGVyYXRpb24gZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyXG4gKlxuICogQHBhcmFtIHtvYmo6RWFjaENhbGxiYWNrfSBmblxuICogICAgICAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqZWN0LCBmbikge1xuICBrZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZuKG9iamVjdFtrZXldLCBrZXkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBcnJheS1saWtlIHJlZHVjZSBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgVGhlIE9iamVjdCB0aGF0IHlvdSB3YW50IHRvIHJlZHVjZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBmb3IgZWFjaCBrZXkgaW4gdGhlIG9iamVjdC4gSXRcbiAqICAgICAgICAgcmVjZWl2ZXMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlIGFuZCB0aGUgcGVyLWl0ZXJhdGlvbiB2YWx1ZSBhbmQga2V5XG4gKiAgICAgICAgIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBbaW5pdGlhbCA9IDBdXG4gKiAgICAgICAgU3RhcnRpbmcgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgVGhlIGZpbmFsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiByZWR1Y2Uob2JqZWN0LCBmbikge1xuICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICByZXR1cm4ga2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGtleSkge1xuICAgIHJldHVybiBmbihhY2N1bSwgb2JqZWN0W2tleV0sIGtleSk7XG4gIH0sIGluaXRpYWwpO1xufVxuXG4vKipcbiAqIE9iamVjdC5hc3NpZ24tc3R5bGUgb2JqZWN0IHNoYWxsb3cgbWVyZ2UvZXh0ZW5kLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChPYmplY3QuYXNzaWduKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbdGFyZ2V0XS5jb25jYXQoc291cmNlcykpO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgb2YgYW55IGtpbmQgLSBpbmNsdWRpbmcgRE9NIG5vZGVzLFxuICogYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBldGMuIE5vdCBmdW5jdGlvbnMsIHRob3VnaC5cbiAqXG4gKiBUaGlzIGF2b2lkcyB0aGUgZ290Y2hhIHdoZXJlIHVzaW5nIGB0eXBlb2ZgIG9uIGEgYG51bGxgIHZhbHVlXG4gKiByZXN1bHRzIGluIGAnb2JqZWN0J2AuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBhcHBlYXJzIHRvIGJlIGEgXCJwbGFpblwiIG9iamVjdCAtIHRoYXQgaXMsIGFcbiAqIGRpcmVjdCBpbnN0YW5jZSBvZiBgT2JqZWN0YC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogQGZpbGUgbG9nLmpzXG4gKiBAbW9kdWxlIGxvZ1xuICovXG52YXIgbG9nID0gdm9pZCAwO1xuXG4vLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciBsb2dnaW5nIGxldmVsLlxudmFyIGxldmVsID0gJ2luZm8nO1xuXG4vLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciB0aGUgbG9nZ2luZyBoaXN0b3J5LlxudmFyIGhpc3RvcnkgPSBbXTtcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUgYW5kIGhpc3RvcnkgYmFzZWQgb24gdGhlIHR5cGUgb2YgbWVzc2FnZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbnNvbGUgbWV0aG9kIHRvIHVzZS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xuICogICAgICAgICBUaGUgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgbWF0Y2hpbmcgY29uc29sZSBtZXRob2QuXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW3N0cmluZ2lmeV1cbiAqICAgICAgICAgQnkgZGVmYXVsdCwgb25seSBvbGQgSUVzIHNob3VsZCBnZXQgY29uc29sZSBhcmd1bWVudCBzdHJpbmdpZmljYXRpb24sXG4gKiAgICAgICAgIGJ1dCB0aGlzIGlzIGV4cG9zZWQgYXMgYSBwYXJhbWV0ZXIgdG8gZmFjaWxpdGF0ZSB0ZXN0aW5nLlxuICovXG52YXIgbG9nQnlUeXBlID0gZnVuY3Rpb24gbG9nQnlUeXBlKHR5cGUsIGFyZ3MpIHtcbiAgdmFyIHN0cmluZ2lmeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogISFJRV9WRVJTSU9OICYmIElFX1ZFUlNJT04gPCAxMTtcblxuICB2YXIgbHZsID0gbG9nLmxldmVsc1tsZXZlbF07XG4gIHZhciBsdmxSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKCcgKyBsdmwgKyAnKSQnKTtcblxuICBpZiAodHlwZSAhPT0gJ2xvZycpIHtcblxuICAgIC8vIEFkZCB0aGUgdHlwZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2Ugd2hlbiBpdCdzIG5vdCBcImxvZ1wiLlxuICAgIGFyZ3MudW5zaGlmdCh0eXBlLnRvVXBwZXJDYXNlKCkgKyAnOicpO1xuICB9XG5cbiAgLy8gQWRkIGEgY2xvbmUgb2YgdGhlIGFyZ3MgYXQgdGhpcyBwb2ludCB0byBoaXN0b3J5LlxuICBpZiAoaGlzdG9yeSkge1xuICAgIGhpc3RvcnkucHVzaChbXS5jb25jYXQoYXJncykpO1xuICB9XG5cbiAgLy8gQWRkIGNvbnNvbGUgcHJlZml4IGFmdGVyIGFkZGluZyB0byBoaXN0b3J5LlxuICBhcmdzLnVuc2hpZnQoJ1ZJREVPSlM6Jyk7XG5cbiAgLy8gSWYgdGhlcmUncyBubyBjb25zb2xlIHRoZW4gZG9uJ3QgdHJ5IHRvIG91dHB1dCBtZXNzYWdlcywgYnV0IHRoZXkgd2lsbFxuICAvLyBzdGlsbCBiZSBzdG9yZWQgaW4gaGlzdG9yeS5cbiAgaWYgKCF3aW5kb3cuY29uc29sZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdhcyBzZXR0aW5nIHRoZXNlIG9uY2Ugb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgY29udGFpbmluZyB0aGVtXG4gIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcbiAgLy8gd2hlbiB0aGUgbW9kdWxlIGlzIGV4ZWN1dGVkLlxuICB2YXIgZm4gPSB3aW5kb3cuY29uc29sZVt0eXBlXTtcblxuICBpZiAoIWZuICYmIHR5cGUgPT09ICdkZWJ1ZycpIHtcbiAgICAvLyBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhdmUgc3VwcG9ydCBmb3IgY29uc29sZS5kZWJ1Zy4gRm9yIHRob3NlLCB3ZVxuICAgIC8vIHNob3VsZCBkZWZhdWx0IHRvIHRoZSBjbG9zZXN0IGNvbXBhcmFibGUgbG9nLlxuICAgIGZuID0gd2luZG93LmNvbnNvbGUuaW5mbyB8fCB3aW5kb3cuY29uc29sZS5sb2c7XG4gIH1cblxuICAvLyBCYWlsIG91dCBpZiB0aGVyZSdzIG5vIGNvbnNvbGUgb3IgaWYgdGhpcyB0eXBlIGlzIG5vdCBhbGxvd2VkIGJ5IHRoZVxuICAvLyBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gIGlmICghZm4gfHwgIWx2bCB8fCAhbHZsUmVnRXhwLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJRXMgcHJldmlvdXMgdG8gMTEgbG9nIG9iamVjdHMgdXNlbGVzc2x5IGFzIFwiW29iamVjdCBPYmplY3RdXCI7IHNvLCBKU09OaWZ5XG4gIC8vIG9iamVjdHMgYW5kIGFycmF5cyBmb3IgdGhvc2UgbGVzcy1jYXBhYmxlIGJyb3dzZXJzLlxuICBpZiAoc3RyaW5naWZ5KSB7XG4gICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICBpZiAoaXNPYmplY3QoYSkgfHwgQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FzdCB0byBzdHJpbmcgYmVmb3JlIGpvaW5pbmcsIHNvIHdlIGdldCBudWxsIGFuZCB1bmRlZmluZWQgZXhwbGljaXRseVxuICAgICAgLy8gaW5jbHVkZWQgaW4gb3V0cHV0IChhcyB3ZSB3b3VsZCBpbiBhIG1vZGVybiBjb25zb2xlKS5cbiAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgLy8gT2xkIElFIHZlcnNpb25zIGRvIG5vdCBhbGxvdyAuYXBwbHkoKSBmb3IgY29uc29sZSBtZXRob2RzICh0aGV5IGFyZVxuICAvLyByZXBvcnRlZCBhcyBvYmplY3RzIHJhdGhlciB0aGFuIGZ1bmN0aW9ucykuXG4gIGlmICghZm4uYXBwbHkpIHtcbiAgICBmbihhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICBmbltBcnJheS5pc0FycmF5KGFyZ3MpID8gJ2FwcGx5JyA6ICdjYWxsJ10od2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIExvZ3MgcGxhaW4gZGVidWcgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSAgICB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkLlxuICovXG5sb2cgPSBmdW5jdGlvbiBsb2coKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGxvZ0J5VHlwZSgnbG9nJywgYXJncyk7XG59O1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIGF2YWlsYWJsZSBsb2dnaW5nIGxldmVscywgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBsZXZlbCBuYW1lc1xuICogYW5kIHRoZSB2YWx1ZXMgYXJlIGB8YC1zZXBhcmF0ZWQgc3RyaW5ncyBjb250YWluaW5nIGxvZ2dpbmcgbWV0aG9kcyBhbGxvd2VkXG4gKiBpbiB0aGF0IGxvZ2dpbmcgbGV2ZWwuIFRoZXNlIHN0cmluZ3MgYXJlIHVzZWQgdG8gY3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uXG4gKiBtYXRjaGluZyB0aGUgZnVuY3Rpb24gbmFtZSBiZWluZyBjYWxsZWQuXG4gKlxuICogTGV2ZWxzIHByb3ZpZGVkIGJ5IHZpZGVvLmpzIGFyZTpcbiAqXG4gKiAtIGBvZmZgOiBNYXRjaGVzIG5vIGNhbGxzLiBBbnkgdmFsdWUgdGhhdCBjYW4gYmUgY2FzdCB0byBgZmFsc2VgIHdpbGwgaGF2ZVxuICogICB0aGlzIGVmZmVjdC4gVGhlIG1vc3QgcmVzdHJpY3RpdmUuXG4gKiAtIGBhbGxgOiBNYXRjaGVzIG9ubHkgVmlkZW8uanMtcHJvdmlkZWQgZnVuY3Rpb25zIChgZGVidWdgLCBgbG9nYCxcbiAqICAgYGxvZy53YXJuYCwgYW5kIGBsb2cuZXJyb3JgKS5cbiAqIC0gYGRlYnVnYDogTWF0Y2hlcyBgbG9nLmRlYnVnYCwgYGxvZ2AsIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCBjYWxscy5cbiAqIC0gYGluZm9gIChkZWZhdWx0KTogTWF0Y2hlcyBgbG9nYCwgYGxvZy53YXJuYCwgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICogLSBgd2FybmA6IE1hdGNoZXMgYGxvZy53YXJuYCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKiAtIGBlcnJvcmA6IE1hdGNoZXMgb25seSBgbG9nLmVycm9yYCBjYWxscy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5sb2cubGV2ZWxzID0ge1xuICBhbGw6ICdkZWJ1Z3xsb2d8d2FybnxlcnJvcicsXG4gIG9mZjogJycsXG4gIGRlYnVnOiAnZGVidWd8bG9nfHdhcm58ZXJyb3InLFxuICBpbmZvOiAnbG9nfHdhcm58ZXJyb3InLFxuICB3YXJuOiAnd2FybnxlcnJvcicsXG4gIGVycm9yOiAnZXJyb3InLFxuICBERUZBVUxUOiBsZXZlbFxufTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuIElmIGEgc3RyaW5nIG1hdGNoaW5nIGEga2V5IGZyb21cbiAqIHtAbGluayBsb2cubGV2ZWxzfSBpcyBwcm92aWRlZCwgYWN0cyBhcyBhIHNldHRlci4gUmVnYXJkbGVzcyBvZiBhcmd1bWVudCxcbiAqIHJldHVybnMgdGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsdmxdXG4gKiAgICAgICAgIFBhc3MgdG8gc2V0IGEgbmV3IGxvZ2dpbmcgbGV2ZWwuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICovXG5sb2cubGV2ZWwgPSBmdW5jdGlvbiAobHZsKSB7XG4gIGlmICh0eXBlb2YgbHZsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghbG9nLmxldmVscy5oYXNPd25Qcm9wZXJ0eShsdmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGx2bCArICdcIiBpbiBub3QgYSB2YWxpZCBsb2cgbGV2ZWwnKTtcbiAgICB9XG4gICAgbGV2ZWwgPSBsdmw7XG4gIH1cbiAgcmV0dXJuIGxldmVsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZXZlcnl0aGluZyB0aGF0IGhhcyBiZWVuIGxvZ2dlZCB0byB0aGUgaGlzdG9yeS5cbiAqXG4gKiBUaGlzIGFycmF5IGlzIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgaW50ZXJuYWwgaGlzdG9yeSByZWNvcmQuIEhvd2V2ZXIsIGl0c1xuICogY29udGVudHMgYXJlIF9ub3RfIGNsb25lZDsgc28sIG11dGF0aW5nIG9iamVjdHMgaW5zaWRlIHRoaXMgYXJyYXkgd2lsbFxuICogbXV0YXRlIHRoZW0gaW4gaGlzdG9yeS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xubG9nLmhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoaXN0b3J5ID8gW10uY29uY2F0KGhpc3RvcnkpIDogW107XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgaGlzdG9yeSB0cmFja2luZywgYnV0IGRvZXMgbm90IHByZXZlbnQgZnVydGhlciBoaXN0b3J5XG4gKiB0cmFja2luZy5cbiAqL1xubG9nLmhpc3RvcnkuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5KSB7XG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIERpc2FibGUgaGlzdG9yeSB0cmFja2luZyBpZiBpdCBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAqL1xubG9nLmhpc3RvcnkuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGhpc3RvcnkgIT09IG51bGwpIHtcbiAgICBoaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgaGlzdG9yeSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIGhpc3RvcnkgdHJhY2tpbmcgaWYgaXQgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICovXG5sb2cuaGlzdG9yeS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5ID09PSBudWxsKSB7XG4gICAgaGlzdG9yeSA9IFtdO1xuICB9XG59O1xuXG4vKipcbiAqIExvZ3MgZXJyb3IgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUuZXJyb3JgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGFuIGVycm9yXG4gKi9cbmxvZy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCdlcnJvcicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUud2FybmAuXG4gKlxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXG4gKiAgICAgICAgT25lIG9yIG1vcmUgbWVzc2FnZXMgb3Igb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBsb2dnZWQgYXMgYSB3YXJuaW5nLlxuICovXG5sb2cud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCd3YXJuJywgYXJncyk7XG59O1xuXG4vKipcbiAqIExvZ3MgZGVidWcgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUuZGVidWdgLCBidXQgbWF5IGFsc28gYWN0IGFzIGEgY29tcGFyYWJsZVxuICogbG9nIGlmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlXG4gKlxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXG4gKiAgICAgICAgT25lIG9yIG1vcmUgbWVzc2FnZXMgb3Igb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBsb2dnZWQgYXMgZGVidWcuXG4gKi9cbmxvZy5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCdkZWJ1ZycsIGFyZ3MpO1xufTtcblxudmFyIGxvZyQxID0gbG9nO1xuXG4vKipcbiAqIEBmaWxlIGNvbXB1dGVkLXN0eWxlLmpzXG4gKiBAbW9kdWxlIGNvbXB1dGVkLXN0eWxlXG4gKi9cbi8qKlxuICogQSBzYWZlIGdldENvbXB1dGVkU3R5bGUgd2l0aCBhbiBJRTggZmFsbGJhY2suXG4gKlxuICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aFxuICogYGRpc3BsYXk6bm9uZWAsIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvXG4gKiBtYWtlIHN1cmUgIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IGJyZWFrIGluIHRoZXNlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB5b3Ugd2FudCB0aGUgY29tcHV0ZWQgc3R5bGUgb2ZcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogICAgICAgIFRoZSBwcm9wZXJ0eSBuYW1lIHlvdSB3YW50XG4gKlxuICogQHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlbCwgcHJvcCkge1xuICBpZiAoIWVsIHx8ICFwcm9wKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICAgIHJldHVybiBjcyA/IGNzW3Byb3BdIDogJyc7XG4gIH1cblxuICByZXR1cm4gZWwuY3VycmVudFN0eWxlW3Byb3BdIHx8ICcnO1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0ID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSwgWydTZXR0aW5nIGF0dHJpYnV0ZXMgaW4gdGhlIHNlY29uZCBhcmd1bWVudCBvZiBjcmVhdGVFbCgpXFxuICAgICAgICAgICAgICAgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSB0aGUgdGhpcmQgYXJndW1lbnQgaW5zdGVhZC5cXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwodHlwZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykuIEF0dGVtcHRpbmcgdG8gc2V0ICcsICcgdG8gJywgJy4nXSk7XG5cbi8qKlxuICogQGZpbGUgZG9tLmpzXG4gKiBAbW9kdWxlIGRvbVxuICovXG4vKipcbiAqIERldGVjdCBpZiBhIHZhbHVlIGlzIGEgc3RyaW5nIHdpdGggYW55IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogICAgICAgIFRoZSBzdHJpbmcgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIHN0cmluZyBpcyBub24tYmxhbmtcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqXG4gKi9cbmZ1bmN0aW9uIGlzTm9uQmxhbmtTdHJpbmcoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiAvXFxTLy50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwYXNzZWQgc3RyaW5nIGhhcyB3aGl0ZXNwYWNlLiBUaGlzIGlzIHVzZWQgYnlcbiAqIGNsYXNzIG1ldGhvZHMgdG8gYmUgcmVsYXRpdmVseSBjb25zaXN0ZW50IHdpdGggdGhlIGNsYXNzTGlzdCBBUEkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrIGZvciB3aGl0ZXNwYWNlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxuICpcbiAqL1xuZnVuY3Rpb24gdGhyb3dJZldoaXRlc3BhY2Uoc3RyKSB7XG4gIGlmICgvXFxzLy50ZXN0KHN0cikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGhhcyBpbGxlZ2FsIHdoaXRlc3BhY2UgY2hhcmFjdGVycycpO1xuICB9XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgYSBjbGFzc05hbWUgd2l0aGluIGFuIGVsZW1lbnRzIGNsYXNzTmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiAgICAgICAgIFRoZSBjbGFzc05hbWUgdG8gZ2VuZXJhdGUgdGhlIFJlZ0V4cCBmb3IuXG4gKlxuICogQHJldHVybiB7UmVnRXhwfVxuICogICAgICAgICBUaGUgUmVnRXhwIHRoYXQgd2lsbCBjaGVjayBmb3IgYSBzcGVjaWZpYyBgY2xhc3NOYW1lYCBpbiBhbiBlbGVtZW50c1xuICogICAgICAgICBjbGFzc05hbWUuXG4gKi9cbmZ1bmN0aW9uIGNsYXNzUmVnRXhwKGNsYXNzTmFtZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoJHxcXFxccyknKTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBjdXJyZW50IERPTSBpbnRlcmZhY2UgYXBwZWFycyB0byBiZSByZWFsLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUmVhbCgpIHtcbiAgcmV0dXJuIChcblxuICAgIC8vIEJvdGggZG9jdW1lbnQgYW5kIHdpbmRvdyB3aWxsIG5ldmVyIGJlIHVuZGVmaW5lZCB0aGFua3MgdG8gYGdsb2JhbGAuXG4gICAgZG9jdW1lbnQgPT09IHdpbmRvdy5kb2N1bWVudCAmJlxuXG4gICAgLy8gSW4gSUUgPCA5LCBET00gbWV0aG9kcyByZXR1cm4gXCJvYmplY3RcIiBhcyB0aGVpciB0eXBlLCBzbyBhbGwgd2UgY2FuXG4gICAgLy8gY29uZmlkZW50bHkgY2hlY2sgaXMgdGhhdCBpdCBleGlzdHMuXG4gICAgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqICAgICAgICBUaGUgdGhpbmcgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSBET00gZWxlbWVudFxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBpc0VsKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBET00gaXMgZW1iZWRkZWQgaW4gYW4gaWZyYW1lLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICovXG5mdW5jdGlvbiBpc0luRnJhbWUoKSB7XG5cbiAgLy8gV2UgbmVlZCBhIHRyeS9jYXRjaCBoZXJlIGJlY2F1c2UgU2FmYXJpIHdpbGwgdGhyb3cgZXJyb3JzIHdoZW4gYXR0ZW1wdGluZ1xuICAvLyB0byBnZXQgZWl0aGVyIGBwYXJlbnRgIG9yIGBzZWxmYFxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cucGFyZW50ICE9PSB3aW5kb3cuc2VsZjtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBmdW5jdGlvbnMgdG8gcXVlcnkgdGhlIERPTSB1c2luZyBhIGdpdmVuIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKiAgICAgICAgIFRoZSBtZXRob2QgdG8gY3JlYXRlIHRoZSBxdWVyeSB3aXRoLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBUaGUgcXVlcnkgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJpZXIobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzTm9uQmxhbmtTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnRbbWV0aG9kXShudWxsKTtcbiAgICB9XG4gICAgaWYgKGlzTm9uQmxhbmtTdHJpbmcoY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHZhciBjdHggPSBpc0VsKGNvbnRleHQpID8gY29udGV4dCA6IGRvY3VtZW50O1xuXG4gICAgcmV0dXJuIGN0eFttZXRob2RdICYmIGN0eFttZXRob2RdKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgYW5kIGFwcGxpZXMgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhZ05hbWU9J2RpdiddXG4gKiAgICAgICAgIE5hbWUgb2YgdGFnIHRvIGJlIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XVxuICogICAgICAgICBFbGVtZW50IHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gKiAgICAgICAgIEVsZW1lbnQgYXR0cmlidXRlcyB0byBiZSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IFtjb250ZW50XVxuICogICAgICAgICBDb250ZW50cyBmb3IgdGhlIGVsZW1lbnQgKHNlZToge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fSlcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgdmFyIHRhZ05hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkaXYnO1xuICB2YXIgcHJvcGVydGllcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHNbM107XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHZhciB2YWwgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgIC8vIFNlZSAjMjE3NlxuICAgIC8vIFdlIG9yaWdpbmFsbHkgd2VyZSBhY2NlcHRpbmcgYm90aCBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzIGluIHRoZVxuICAgIC8vIHNhbWUgb2JqZWN0LCBidXQgdGhhdCBkb2Vzbid0IHdvcmsgc28gd2VsbC5cbiAgICBpZiAocHJvcE5hbWUuaW5kZXhPZignYXJpYS0nKSAhPT0gLTEgfHwgcHJvcE5hbWUgPT09ICdyb2xlJyB8fCBwcm9wTmFtZSA9PT0gJ3R5cGUnKSB7XG4gICAgICBsb2ckMS53YXJuKHRzbWwoX3RlbXBsYXRlT2JqZWN0LCBwcm9wTmFtZSwgdmFsKSk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHZhbCk7XG5cbiAgICAgIC8vIEhhbmRsZSB0ZXh0Q29udGVudCBzaW5jZSBpdCdzIG5vdCBzdXBwb3J0ZWQgZXZlcnl3aGVyZSBhbmQgd2UgaGF2ZSBhXG4gICAgICAvLyBtZXRob2QgZm9yIGl0LlxuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgIHRleHRDb250ZW50KGVsLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbFtwcm9wTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cmlidXRlc1thdHRyTmFtZV0pO1xuICB9KTtcblxuICBpZiAoY29udGVudCkge1xuICAgIGFwcGVuZENvbnRlbnQoZWwsIGNvbnRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEluamVjdHMgdGV4dCBpbnRvIGFuIGVsZW1lbnQsIHJlcGxhY2luZyBhbnkgZXhpc3RpbmcgY29udGVudHMgZW50aXJlbHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGFkZCB0ZXh0IGNvbnRlbnQgaW50b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiAgICAgICAgVGhlIHRleHQgY29udGVudCB0byBhZGQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhZGRlZCB0ZXh0IGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uIHRleHRDb250ZW50KGVsLCB0ZXh0KSB7XG4gIGlmICh0eXBlb2YgZWwudGV4dENvbnRlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZWwuaW5uZXJUZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEluc2VydCBhbiBlbGVtZW50IGFzIHRoZSBmaXJzdCBjaGlsZCBub2RlIG9mIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNoaWxkXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxuICogICAgICAgIEVsZW1lbnQgdG8gaW5zZXJ0IGNoaWxkIGludG9cbiAqL1xuZnVuY3Rpb24gcHJlcGVuZFRvKGNoaWxkLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gY2hlY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0NoZWNrXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBjaGVjayBmb3JcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIGVsZW1lbnQgaGFkIHRoZSBjbGFzc1xuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGlmIGBjbGFzc1RvQ2hlY2tgIGhhcyB3aGl0ZSBzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0NoZWNrKSB7XG4gIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9DaGVjayk7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQ2hlY2spO1xuICB9XG4gIHJldHVybiBjbGFzc1JlZ0V4cChjbGFzc1RvQ2hlY2spLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGFkZCBjbGFzcyBuYW1lIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQWRkXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBhZGQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggdGhlIGFkZGVkIGNsYXNzIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9BZGQpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzVG9BZGQpO1xuXG4gICAgLy8gRG9uJ3QgbmVlZCB0byBgdGhyb3dJZldoaXRlc3BhY2VgIGhlcmUgYmVjYXVzZSBgaGFzRWxDbGFzc2Agd2lsbCBkbyBpdFxuICAgIC8vIGluIHRoZSBjYXNlIG9mIGNsYXNzTGlzdCBub3QgYmVpbmcgc3VwcG9ydGVkLlxuICB9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gKGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NUb0FkZCkudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byByZW1vdmUgYSBjbGFzcyBuYW1lIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIHJlbW92ZVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB3aXRoIGNsYXNzIG5hbWUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1JlbW92ZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NUb1JlbW92ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb1JlbW92ZSk7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgIT09IGNsYXNzVG9SZW1vdmU7XG4gICAgfSkuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogVGhlIGNhbGxiYWNrIGRlZmluaXRpb24gZm9yIHRvZ2dsZUVsQ2xhc3MuXG4gKlxuICogQGNhbGxiYWNrIERvbX5QcmVkaWNhdGVDYWxsYmFja1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgVGhlIERPTSBlbGVtZW50IG9mIHRoZSBDb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAqICAgICAgICBUaGUgYGNsYXNzTmFtZWAgdGhhdCB3YW50cyB0byBiZSB0b2dnbGVkXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIC0gSWYgdHJ1ZSB0aGUgYGNsYXNzVG9Ub2dnbGVgIHdpbGwgZ2V0IGFkZGVkIHRvIGBlbGVtZW50YC5cbiAqICAgICAgICAgLSBJZiBmYWxzZSB0aGUgYGNsYXNzVG9Ub2dnbGVgIHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSBgZWxlbWVudGAuXG4gKiAgICAgICAgIC0gSWYgdW5kZWZpbmVkIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBpZ25vcmVkXG4gKi9cblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBDU1MgY2xhc3MgbmFtZSBvbiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiBhbiBvcHRpb25hbFxuICogY29uZGl0aW9uIG9yIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSBjbGFzcyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIHRvZ2dsZSBhIGNsYXNzIG5hbWUgb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAqICAgICAgICBUaGUgY2xhc3MgdGhhdCBzaG91bGQgYmUgdG9nZ2xlZFxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbnxQcmVkaWNhdGVDYWxsYmFja30gW3ByZWRpY2F0ZV1cbiAqICAgICAgICBTZWUgdGhlIHJldHVybiB2YWx1ZSBmb3Ige0BsaW5rIERvbX5QcmVkaWNhdGVDYWxsYmFja31cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGEgY2xhc3MgdGhhdCBoYXMgYmVlbiB0b2dnbGVkLlxuICovXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcblxuICAvLyBUaGlzIENBTk5PVCB1c2UgYGNsYXNzTGlzdGAgaW50ZXJuYWxseSBiZWNhdXNlIElFIGRvZXMgbm90IHN1cHBvcnQgdGhlXG4gIC8vIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhlIGBjbGFzc0xpc3QudG9nZ2xlKClgIG1ldGhvZCEgV2hpY2ggaXMgZmluZSBiZWNhdXNlXG4gIC8vIGBjbGFzc0xpc3RgIHdpbGwgYmUgdXNlZCBieSB0aGUgYWRkL3JlbW92ZSBmdW5jdGlvbnMuXG4gIHZhciBoYXMgPSBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZShlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICBwcmVkaWNhdGUgPSAhaGFzO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5lY2Vzc2FyeSBjbGFzcyBvcGVyYXRpb24gbWF0Y2hlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcbiAgLy8gZWxlbWVudCwgbm8gYWN0aW9uIGlzIHJlcXVpcmVkLlxuICBpZiAocHJlZGljYXRlID09PSBoYXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJlZGljYXRlKSB7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBhZGQgYXR0cmlidXRlcyB0by5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gKiAgICAgICAgQXR0cmlidXRlcyB0byBiZSBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsLCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuXG4gICAgaWYgKGF0dHJWYWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgYXR0clZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBhdHRyVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYXR0clZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlcywgYXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0YWdcbiAqIEF0dHJpYnV0ZXMgYXJlIG5vdCB0aGUgc2FtZSBhcyBwcm9wZXJ0aWVzLiBUaGV5J3JlIGRlZmluZWQgb24gdGhlIHRhZ1xuICogb3Igd2l0aCBzZXRBdHRyaWJ1dGUgKHdoaWNoIHNob3VsZG4ndCBiZSB1c2VkIHdpdGggSFRNTClcbiAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCB0YWcgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEFsbCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKHRhZykge1xuICB2YXIgb2JqID0ge307XG5cbiAgLy8ga25vd24gYm9vbGVhbiBhdHRyaWJ1dGVzXG4gIC8vIHdlIGNhbiBjaGVjayBmb3IgbWF0Y2hpbmcgYm9vbGVhbiBwcm9wZXJ0aWVzLCBidXQgb2xkZXIgYnJvd3NlcnNcbiAgLy8gd29uJ3Qga25vdyBhYm91dCBIVE1MNSBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCB3ZSBzdGlsbCByZWFkIGZyb21cbiAgdmFyIGtub3duQm9vbGVhbnMgPSAnLCcgKyAnYXV0b3BsYXksY29udHJvbHMscGxheXNpbmxpbmUsbG9vcCxtdXRlZCxkZWZhdWx0LGRlZmF1bHRNdXRlZCcgKyAnLCc7XG5cbiAgaWYgKHRhZyAmJiB0YWcuYXR0cmlidXRlcyAmJiB0YWcuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICB2YXIgYXR0clZhbCA9IGF0dHJzW2ldLnZhbHVlO1xuXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBlbGVtZW50IHByb3BlcnR5IHdpbGwgcmV0dXJuIGEgdmFsdWUgZm9yIHR5cGVvZlxuICAgICAgaWYgKHR5cGVvZiB0YWdbYXR0ck5hbWVdID09PSAnYm9vbGVhbicgfHwga25vd25Cb29sZWFucy5pbmRleE9mKCcsJyArIGF0dHJOYW1lICsgJywnKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxuICAgICAgICAvLyBzdHJpbmcgKCcnKSB3aGljaCB3b3VsZCBlcXVhbCBmYWxzZSBpZiB3ZSBqdXN0IGNoZWNrIGZvciBhIGZhbHNlIHZhbHVlLlxuICAgICAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgc3VwcG9ydCBiYWQgY29kZSBsaWtlIGF1dG9wbGF5PSdmYWxzZSdcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgb2ZcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBzZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0b1xuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBlbGVtZW50J3MgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiAgICAgICAgQXR0cmlidXRlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGJsb2NrIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCB0ZXh0IHdoaWxlIGRyYWdnaW5nIGNvbnRyb2xzXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJuIG9mZiB0ZXh0IHNlbGVjdGlvbiBibG9ja2luZ1xuICovXG5mdW5jdGlvbiB1bmJsb2NrVGV4dFNlbGVjdGlvbigpIHtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJZGVudGljYWwgdG8gdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBmdW5jdGlvbiwgYnV0IGVuc3VyZXMgdGhhdFxuICogdGhlIG1ldGhvZCBpcyBzdXBwb3J0ZWQgYXQgYWxsIChpdCBpcyBpbiBhbGwgYnJvd3NlcnMgd2UgY2xhaW0gdG8gc3VwcG9ydClcbiAqIGFuZCB0aGF0IHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYmVmb3JlIGNvbnRpbnVpbmcuXG4gKlxuICogVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGFsc28gc2hpbXMgcHJvcGVydGllcyB3aGljaCBhcmUgbm90IHByb3ZpZGVkIGJ5IHNvbWVcbiAqIG9sZGVyIGJyb3dzZXJzIChuYW1lbHksIElFOCkuXG4gKlxuICogQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGFcbiAqIGBDbGllbnRSZWN0YC9gRE9NUmVjdGAgb2JqZWN0OyBzbywgd2Ugc2hhbGxvdy1jb3B5IGl0IHdpdGggdGhlIHN0YW5kYXJkXG4gKiBwcm9wZXJ0aWVzIChleGNlcHQgYHhgIGFuZCBgeWAgd2hpY2ggYXJlIG5vdCB3aWRlbHkgc3VwcG9ydGVkKS4gVGhpcyBoZWxwc1xuICogYXZvaWQgaW1wbGVtZW50YXRpb25zIHdoZXJlIGtleXMgYXJlIG5vbi1lbnVtZXJhYmxlLlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIEVsZW1lbnQgd2hvc2UgYENsaWVudFJlY3RgIHdlIHdhbnQgdG8gY2FsY3VsYXRlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFsd2F5cyByZXR1cm5zIGEgcGxhaW5cbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XG4gIGlmIChlbCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydib3R0b20nLCAnaGVpZ2h0JywgJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ3dpZHRoJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKHJlY3Rba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRba10gPSByZWN0W2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQuaGVpZ2h0KSB7XG4gICAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnaGVpZ2h0JykpO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0LndpZHRoKSB7XG4gICAgICByZXN1bHQud2lkdGggPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUoZWwsICd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3Rpb24gb2YgYSBET00gZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZG9tflBvc2l0aW9uXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnRcbiAqICAgICAgICAgICBQaXhlbHMgdG8gdGhlIGxlZnRcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wXG4gKiAgICAgICAgICAgUGl4ZWxzIG9uIHRvcFxuICovXG5cbi8qKlxuICogT2Zmc2V0IExlZnQuXG4gKiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdGVjaG5pcXVlIGZyb21cbiAqIEpvaG4gUmVzaWdcbiAqXG4gKiBAc2VlIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9nZXRib3VuZGluZ2NsaWVudHJlY3QtaXMtYXdlc29tZS9cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCBmcm9tIHdoaWNoIHRvIGdldCBvZmZzZXRcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6ZG9tflBvc2l0aW9ufVxuICogICAgICAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oZWwpIHtcbiAgdmFyIGJveCA9IHZvaWQgMDtcblxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGlmICghYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgdmFyIGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XG4gIHZhciBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICB2YXIgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgYm9keS5zY3JvbGxUb3A7XG4gIHZhciB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xuXG4gIC8vIEFuZHJvaWQgc29tZXRpbWVzIHJldHVybnMgc2xpZ2h0bHkgb2ZmIGRlY2ltYWwgdmFsdWVzLCBzbyBuZWVkIHRvIHJvdW5kXG4gIHJldHVybiB7XG4gICAgbGVmdDogTWF0aC5yb3VuZChsZWZ0KSxcbiAgICB0b3A6IE1hdGgucm91bmQodG9wKVxuICB9O1xufVxuXG4vKipcbiAqIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yIGEgZG9tIGVsZW1lbnQgb3IgbW91c2UgcG9pbnRlclxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvbX5Db29yZGluYXRlc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gKiAgICAgICAgICAgeCBjb29yZGluYXRlIGluIHBpeGVsc1xuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiAgICAgICAgICAgeSBjb29yZGluYXRlIGluIHBpeGVsc1xuICovXG5cbi8qKlxuICogR2V0IHBvaW50ZXIgcG9zaXRpb24gaW4gZWxlbWVudFxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuICogVGhlIGJhc2Ugb24gdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgYm90dG9tIGxlZnQgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgb24gd2hpY2ggdG8gZ2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uIG9uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtEb21+Q29vcmRpbmF0ZXN9XG4gKiAgICAgICAgIEEgQ29vcmRpbmF0ZXMgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGVsLCBldmVudCkge1xuICB2YXIgcG9zaXRpb24gPSB7fTtcbiAgdmFyIGJveCA9IGZpbmRQb3NpdGlvbihlbCk7XG4gIHZhciBib3hXID0gZWwub2Zmc2V0V2lkdGg7XG4gIHZhciBib3hIID0gZWwub2Zmc2V0SGVpZ2h0O1xuXG4gIHZhciBib3hZID0gYm94LnRvcDtcbiAgdmFyIGJveFggPSBib3gubGVmdDtcbiAgdmFyIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gIHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgIHBhZ2VYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgcGFnZVkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgfVxuXG4gIHBvc2l0aW9uLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYm94WSAtIHBhZ2VZICsgYm94SCkgLyBib3hIKSk7XG4gIHBvc2l0aW9uLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGFnZVggLSBib3hYKSAvIGJveFcpKTtcblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgQ2hlY2sgaWYgdGhpcyB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZXh0IG5vZGVcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xufVxuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGVtcHR5IGNoaWxkcmVuIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIG5vIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RWwoZWwpIHtcbiAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBjb250ZW50IGZvciBldmVudHVhbCBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICpcbiAqIFRoaXMgYWxsb3dzIGEgd2lkZSByYW5nZSBvZiBjb250ZW50IGRlZmluaXRpb24gbWV0aG9kcywgYnV0IHByb3RlY3RzXG4gKiBmcm9tIGZhbGxpbmcgaW50byB0aGUgdHJhcCBvZiBzaW1wbHkgd3JpdGluZyB0byBgaW5uZXJIVE1MYCwgd2hpY2ggaXNcbiAqIGFuIFhTUyBjb25jZXJuLlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIC0gU3RyaW5nOiBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKiAgICAgICAgLSBFbGVtZW50L1RleHROb2RlOiBQYXNzZWQgdGhyb3VnaC5cbiAqICAgICAgICAtIEFycmF5OiBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9uc1xuICogICAgICAgICAgKHdoaWNoIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqICAgICAgICAtIEZ1bmN0aW9uOiBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgICAgICAgIG5vZGUsIG9yIGFycmF5IGFzIGRlZmluZWQgYWJvdmUuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIEFsbCBvZiB0aGUgY29udGVudCB0aGF0IHdhcyBwYXNzZWQgaW4gbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChjb250ZW50KSB7XG5cbiAgLy8gRmlyc3QsIGludm9rZSBjb250ZW50IGlmIGl0IGlzIGEgZnVuY3Rpb24uIElmIGl0IHByb2R1Y2VzIGFuIGFycmF5LFxuICAvLyB0aGF0IG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgbm9ybWFsaXphdGlvbi5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQoKTtcbiAgfVxuXG4gIC8vIE5leHQgdXAsIG5vcm1hbGl6ZSB0byBhbiBhcnJheSwgc28gb25lIG9yIG1hbnkgaXRlbXMgY2FuIGJlIG5vcm1hbGl6ZWQsXG4gIC8vIGZpbHRlcmVkLCBhbmQgcmV0dXJuZWQuXG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIC8vIEZpcnN0LCBpbnZva2UgdmFsdWUgaWYgaXQgaXMgYSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgbmV3IHZhbHVlLFxuICAgIC8vIHdoaWNoIHdpbGwgYmUgc3Vic2VxdWVudGx5IG5vcm1hbGl6ZWQgdG8gYSBOb2RlIG9mIHNvbWUga2luZC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWwodmFsdWUpIHx8IGlzVGV4dE5vZGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgfVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBhcHBlbmQgbm9ybWFsaXplZCBjb250ZW50IHRvLlxuICpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYXBwZW5kZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICovXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KSB7XG4gIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBub3JtYWxpemVkIGNvbnRlbnQgaW50by5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggaW5zZXJ0ZWQgbm9ybWFsaXplZCBjb250ZW50LlxuICpcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q29udGVudChlbCwgY29udGVudCkge1xuICByZXR1cm4gYXBwZW5kQ29udGVudChlbXB0eUVsKGVsKSwgY29udGVudCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgZXZlbnQgd2FzIGEgc2luZ2xlIGxlZnQgY2xpY2tcbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICogICAgICAgIEV2ZW50IG9iamVjdFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBhIGxlZnQgY2xpY2tcbiAqICAgICAgICAgLSBGYWxzZSBpZiBub3QgYSBsZWZ0IGNsaWNrXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSB7XG4gIC8vIE5vdGU6IGlmIHlvdSBjcmVhdGUgc29tZXRoaW5nIGRyYWdnYWJsZSwgYmUgc3VyZSB0b1xuICAvLyBjYWxsIGl0IG9uIGJvdGggYG1vdXNlZG93bmAgYW5kIGBtb3VzZW1vdmVgIGV2ZW50LFxuICAvLyBvdGhlcndpc2UgYG1vdXNlZG93bmAgc2hvdWxkIGJlIGVub3VnaCBmb3IgYSBidXR0b25cblxuICBpZiAoZXZlbnQuYnV0dG9uID09PSB1bmRlZmluZWQgJiYgZXZlbnQuYnV0dG9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2h5IGRvIHdlIG5lZWQgYGJ1dHR0b25zYCA/XG4gICAgLy8gQmVjYXVzZSwgbWlkZGxlIG1vdXNlIHNvbWV0aW1lcyBoYXZlIHRoaXM6XG4gICAgLy8gZS5idXR0b24gPT09IDAgYW5kIGUuYnV0dG9ucyA9PT0gNFxuICAgIC8vIEZ1cnRoZXJtb3JlLCB3ZSB3YW50IHRvIHByZXZlbnQgY29tYmluYXRpb24gY2xpY2ssIHNvbWV0aGluZyBsaWtlXG4gICAgLy8gSE9MRCBtaWRkbGVtb3VzZSB0aGVuIGxlZnQgY2xpY2ssIHRoYXQgd291bGQgYmVcbiAgICAvLyBlLmJ1dHRvbiA9PT0gMCwgZS5idXR0b25zID09PSA1XG4gICAgLy8ganVzdCBgYnV0dG9uYCBpcyBub3QgZ29ubmEgd29ya1xuXG4gICAgLy8gQWxyaWdodCwgdGhlbiB3aGF0IHRoaXMgYmxvY2sgZG9lcyA/XG4gICAgLy8gdGhpcyBpcyBmb3IgY2hyb21lIGBzaW11bGF0ZSBtb2JpbGUgZGV2aWNlc2BcbiAgICAvLyBJIHdhbnQgdG8gc3VwcG9ydCB0aGlzIGFzIHdlbGxcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiBldmVudC5idXR0b25zID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUb3VjaCBzY3JlZW4sIHNvbWV0aW1lcyBvbiBzb21lIHNwZWNpZmljIGRldmljZSwgYGJ1dHRvbnNgXG4gICAgLy8gZG9lc24ndCBoYXZlIGFueXRoaW5nIChzYWZhcmkgb24gaW9zLCBibGFja2JlcnJ5Li4uKVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoSUVfVkVSU0lPTiA9PT0gOSkge1xuICAgIC8vIElnbm9yZSBJRTlcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5idXR0b25zICE9PSAxKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgcmVhc29uIHdlIGhhdmUgdGhvc2UgaWYgZWxzZSBibG9jayBhYm92ZVxuICAgIC8vIGlmIGFueSBzcGVjaWFsIGNhc2Ugd2UgY2FuIGNhdGNoIGFuZCBsZXQgaXQgc2xpZGVcbiAgICAvLyB3ZSBkbyBpdCBhYm92ZSwgd2hlbiBnZXQgdG8gaGVyZSwgdGhpcyBkZWZpbml0ZWx5XG4gICAgLy8gaXMtbm90LWxlZnQtY2xpY2tcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxuICogYGNvbnRleHRgIG9mIGFub3RoZXIgRE9NIGVsZW1lbnQgKGRlZmF1bHRpbmcgdG8gYGRvY3VtZW50YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cbiAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvclxuICogICAgICAgIHN0cmluZyBpbiB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgYmUgdXNlZFxuICogICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXG4gKiAgICAgICAgYmFjayB0byBgZG9jdW1lbnRgLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgbnVsbC5cbiAqL1xudmFyICQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yJyk7XG5cbi8qKlxuICogRmluZHMgYSBhbGwgRE9NIGVsZW1lbnRzIG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxuICogYGNvbnRleHRgIG9mIGFub3RoZXIgRE9NIGVsZW1lbnQgKGRlZmF1bHRpbmcgdG8gYGRvY3VtZW50YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiAgICAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yQWxsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cbiAqICAgICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvclxuICogICAgICAgICAgIHN0cmluZyBpbiB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgYmUgdXNlZFxuICogICAgICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXG4gKiAgICAgICAgICAgYmFjayB0byBgZG9jdW1lbnRgLlxuICpcbiAqIEByZXR1cm4ge05vZGVMaXN0fVxuICogICAgICAgICBBIGVsZW1lbnQgbGlzdCBvZiBlbGVtZW50cyB0aGF0IHdlcmUgZm91bmQuIFdpbGwgYmUgZW1wdHkgaWYgbm9uZSB3ZXJlIGZvdW5kLlxuICpcbiAqL1xudmFyICQkID0gY3JlYXRlUXVlcmllcigncXVlcnlTZWxlY3RvckFsbCcpO1xuXG5cblxudmFyIERvbSA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRpc1JlYWw6IGlzUmVhbCxcblx0aXNFbDogaXNFbCxcblx0aXNJbkZyYW1lOiBpc0luRnJhbWUsXG5cdGNyZWF0ZUVsOiBjcmVhdGVFbCxcblx0dGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuXHRwcmVwZW5kVG86IHByZXBlbmRUbyxcblx0aGFzQ2xhc3M6IGhhc0NsYXNzLFxuXHRhZGRDbGFzczogYWRkQ2xhc3MsXG5cdHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcblx0dG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuXHRzZXRBdHRyaWJ1dGVzOiBzZXRBdHRyaWJ1dGVzLFxuXHRnZXRBdHRyaWJ1dGVzOiBnZXRBdHRyaWJ1dGVzLFxuXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGUsXG5cdHJlbW92ZUF0dHJpYnV0ZTogcmVtb3ZlQXR0cmlidXRlLFxuXHRibG9ja1RleHRTZWxlY3Rpb246IGJsb2NrVGV4dFNlbGVjdGlvbixcblx0dW5ibG9ja1RleHRTZWxlY3Rpb246IHVuYmxvY2tUZXh0U2VsZWN0aW9uLFxuXHRnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldEJvdW5kaW5nQ2xpZW50UmVjdCxcblx0ZmluZFBvc2l0aW9uOiBmaW5kUG9zaXRpb24sXG5cdGdldFBvaW50ZXJQb3NpdGlvbjogZ2V0UG9pbnRlclBvc2l0aW9uLFxuXHRpc1RleHROb2RlOiBpc1RleHROb2RlLFxuXHRlbXB0eUVsOiBlbXB0eUVsLFxuXHRub3JtYWxpemVDb250ZW50OiBub3JtYWxpemVDb250ZW50LFxuXHRhcHBlbmRDb250ZW50OiBhcHBlbmRDb250ZW50LFxuXHRpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuXHRpc1NpbmdsZUxlZnRDbGljazogaXNTaW5nbGVMZWZ0Q2xpY2ssXG5cdCQ6ICQsXG5cdCQkOiAkJFxufSk7XG5cbi8qKlxuICogQGZpbGUgZ3VpZC5qc1xuICogQG1vZHVsZSBndWlkXG4gKi9cblxuLyoqXG4gKiBVbmlxdWUgSUQgZm9yIGFuIGVsZW1lbnQgb3IgZnVuY3Rpb25cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbnZhciBfZ3VpZCA9IDE7XG5cbi8qKlxuICogR2V0IGEgdW5pcXVlIGF1dG8taW5jcmVtZW50aW5nIElEIGJ5IG51bWJlciB0aGF0IGhhcyBub3QgYmVlbiByZXR1cm5lZCBiZWZvcmUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBBIG5ldyB1bmlxdWUgSUQuXG4gKi9cbmZ1bmN0aW9uIG5ld0dVSUQoKSB7XG4gIHJldHVybiBfZ3VpZCsrO1xufVxuXG4vKipcbiAqIEBmaWxlIGRvbS1kYXRhLmpzXG4gKiBAbW9kdWxlIGRvbS1kYXRhXG4gKi9cbi8qKlxuICogRWxlbWVudCBEYXRhIFN0b3JlLlxuICpcbiAqIEFsbG93cyBmb3IgYmluZGluZyBkYXRhIHRvIGFuIGVsZW1lbnQgd2l0aG91dCBwdXR0aW5nIGl0IGRpcmVjdGx5IG9uIHRoZVxuICogZWxlbWVudC4gRXguIEV2ZW50IGxpc3RlbmVycyBhcmUgc3RvcmVkIGhlcmUuXG4gKiAoYWxzbyBmcm9tIGpzbmluamEuY29tLCBzbGlnaHRseSBtb2RpZmllZCBhbmQgdXBkYXRlZCBmb3IgY2xvc3VyZSBjb21waWxlcilcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGVsRGF0YSA9IHt9O1xuXG4vKlxuICogVW5pcXVlIGF0dHJpYnV0ZSBuYW1lIHRvIHN0b3JlIGFuIGVsZW1lbnQncyBndWlkIGluXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIGVsSWRBdHRyID0gJ3ZkYXRhJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCB3aGVyZSBkYXRhIGZvciBhbiBlbGVtZW50IGlzIHN0b3JlZFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIHN0b3JlIGRhdGEgZm9yLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIGNhY2hlIG9iamVjdCBmb3IgdGhhdCBlbCB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIGdldERhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICBpZCA9IGVsW2VsSWRBdHRyXSA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIGlmICghZWxEYXRhW2lkXSkge1xuICAgIGVsRGF0YVtpZF0gPSB7fTtcbiAgfVxuXG4gIHJldHVybiBlbERhdGFbaWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgQ2hlY2sgaWYgdGhpcyBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YS5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0RhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbERhdGFbaWRdKS5sZW5ndGg7XG59XG5cbi8qKlxuICogRGVsZXRlIGRhdGEgZm9yIHRoZSBlbGVtZW50IGZyb20gdGhlIGNhY2hlIGFuZCB0aGUgZ3VpZCBhdHRyIGZyb20gZ2V0RWxlbWVudEJ5SWRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgUmVtb3ZlIGNhY2hlZCBkYXRhIGZvciB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHN0b3JlZCBkYXRhXG4gIGRlbGV0ZSBlbERhdGFbaWRdO1xuXG4gIC8vIFJlbW92ZSB0aGUgZWxJZEF0dHIgcHJvcGVydHkgZnJvbSB0aGUgRE9NIG5vZGVcbiAgdHJ5IHtcbiAgICBkZWxldGUgZWxbZWxJZEF0dHJdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGVsSWRBdHRyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgZG9lc24ndCBhcHBlYXIgdG8gc3VwcG9ydCByZW1vdmVBdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgIGVsW2VsSWRBdHRyXSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGZpbGUgZXZlbnRzLmpzLiBBbiBFdmVudCBTeXN0ZW0gKEpvaG4gUmVzaWcgLSBTZWNyZXRzIG9mIGEgSlMgTmluamEgaHR0cDovL2pzbmluamEuY29tLylcbiAqIChPcmlnaW5hbCBib29rIHZlcnNpb24gd2Fzbid0IGNvbXBsZXRlbHkgdXNhYmxlLCBzbyBmaXhlZCBzb21lIHRoaW5ncyBhbmQgbWFkZSBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUpXG4gKiBUaGlzIHNob3VsZCB3b3JrIHZlcnkgc2ltaWxhcmx5IHRvIGpRdWVyeSdzIGV2ZW50cywgaG93ZXZlciBpdCdzIGJhc2VkIG9mZiB0aGUgYm9vayB2ZXJzaW9uIHdoaWNoIGlzbid0IGFzXG4gKiByb2J1c3QgYXMganF1ZXJ5J3MsIHNvIHRoZXJlJ3MgcHJvYmFibHkgc29tZSBkaWZmZXJlbmNlcy5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50c1xuICovXG5cbi8qKlxuICogQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIGNhY2hlIGFuZCBkaXNwYXRjaGVyc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIGNsZWFuIHVwXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGNsZWFuIHVwXG4gKi9cbmZ1bmN0aW9uIF9jbGVhblVwRXZlbnRzKGVsZW0sIHR5cGUpIHtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9mIGEgcGFydGljdWxhciB0eXBlIGlmIHRoZXJlIGFyZSBub25lIGxlZnRcbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnNbdHlwZV07XG4gICAgLy8gZGF0YS5oYW5kbGVyc1t0eXBlXSA9IG51bGw7XG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdhcyBjYXVzaW5nIGFuIGVycm9yIHdpdGggZGF0YS5oYW5kbGVyc1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBtZXRhLWhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyB0eXBlcyBsZWZ0XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhLmhhbmRsZXJzKS5sZW5ndGggPD0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzO1xuICAgIGRlbGV0ZSBkYXRhLmRpc3BhdGNoZXI7XG4gICAgZGVsZXRlIGRhdGEuZGlzYWJsZWQ7XG4gIH1cblxuICAvLyBGaW5hbGx5IHJlbW92ZSB0aGUgZWxlbWVudCBkYXRhIGlmIHRoZXJlIGlzIG5vIGRhdGEgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgcmVtb3ZlRGF0YShlbGVtKTtcbiAgfVxufVxuXG4vKipcbiAqIExvb3BzIHRocm91Z2ggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYW5kIGNhbGxzIHRoZSByZXF1ZXN0ZWQgbWV0aG9kIGZvciBlYWNoIHR5cGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgZXZlbnQgbWV0aG9kIHdlIHdhbnQgdG8gdXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gY2FsbGJhY2tcbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gX2hhbmRsZU11bHRpcGxlRXZlbnRzKGZuLCBlbGVtLCB0eXBlcywgY2FsbGJhY2spIHtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIENhbGwgdGhlIGV2ZW50IG1ldGhvZCBmb3IgZWFjaCBvbmUgb2YgdGhlIHR5cGVzXG4gICAgZm4oZWxlbSwgdHlwZSwgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGaXggYSBuYXRpdmUgZXZlbnQgdG8gaGF2ZSBzdGFuZGFyZCBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3QgdG8gZml4LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgRml4ZWQgZXZlbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGlmIGZpeGluZyB1cCBpcyBuZWVkZWRcbiAgLy8gVXNlZCB0byBjaGVjayBpZiAhZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGluc3RlYWQgb2YgaXNQcm9wYWdhdGlvblN0b3BwZWRcbiAgLy8gQnV0IG5hdGl2ZSBldmVudHMgcmV0dXJuIHRydWUgZm9yIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGRvbid0IGhhdmVcbiAgLy8gb3RoZXIgZXhwZWN0ZWQgbWV0aG9kcyBsaWtlIGlzUHJvcGFnYXRpb25TdG9wcGVkLiBTZWVtcyB0byBiZSBhIHByb2JsZW1cbiAgLy8gd2l0aCB0aGUgSmF2YXNjcmlwdCBOaW5qYSBjb2RlLiBTbyB3ZSdyZSBqdXN0IG92ZXJyaWRpbmcgYWxsIGV2ZW50cyBub3cuXG4gIGlmICghZXZlbnQgfHwgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgdmFyIG9sZCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIGV2ZW50ID0ge307XG4gICAgLy8gQ2xvbmUgdGhlIG9sZCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZSB2YWx1ZXMgZXZlbnQgPSB7fTtcbiAgICAvLyBJRTggRG9lc24ndCBsaWtlIHdoZW4geW91IG1lc3Mgd2l0aCBuYXRpdmUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBmYWxzZSBmb3IgZXZlbnQuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSBhbmQgb3RoZXIgcHJvcHNcbiAgICAvLyAgd2hpY2ggbWFrZXMgY29weWluZyBtb3JlIGRpZmZpY3VsdC5cbiAgICAvLyBUT0RPOiBQcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBhIHdoaXRlbGlzdCBvZiBldmVudCBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgIC8vIFNhZmFyaSA2LjAuMyB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgbGF5ZXJYL1lcbiAgICAgIC8vIENocm9tZSB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQga2V5Ym9hcmRFdmVudC5rZXlMb2NhdGlvblxuICAgICAgLy8gYW5kIHdlYmtpdE1vdmVtZW50WC9ZXG4gICAgICBpZiAoa2V5ICE9PSAnbGF5ZXJYJyAmJiBrZXkgIT09ICdsYXllclknICYmIGtleSAhPT0gJ2tleUxvY2F0aW9uJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFgnICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WScpIHtcbiAgICAgICAgLy8gQ2hyb21lIDMyKyB3YXJucyBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCByZXR1cm5WYWx1ZSwgYnV0XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gaWYgcHJldmVudERlZmF1bHQgaXNuJ3Qgc3VwcG9ydGVkIChJRTgpLlxuICAgICAgICBpZiAoIShrZXkgPT09ICdyZXR1cm5WYWx1ZScgJiYgb2xkLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgIGV2ZW50W2tleV0gPSBvbGRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2hpY2ggb3RoZXIgZWxlbWVudCB0aGUgZXZlbnQgaXMgcmVsYXRlZCB0b1xuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIG9sZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIG9sZC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgb2xkLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIGFuZCBleGVjdXRpbmcgb3RoZXIgaGFuZGxlcnNcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxuICAgIGlmIChldmVudC5jbGllbnRYICE9PSBudWxsICYmIGV2ZW50LmNsaWVudFggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIEZpeCBidXR0b24gZm9yIG1vdXNlIGNsaWNrczpcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gbnVsbCAmJiBldmVudC5idXR0b24gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGRpc2FibGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgcGFzcyB2aWRlb2pzLXN0YW5kYXJkXG4gICAgICAvLyBhbmQuLi4geWlrZXMuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgZXZlbnQuYnV0dG9uID0gZXZlbnQuYnV0dG9uICYgMSA/IDAgOiBldmVudC5idXR0b24gJiA0ID8gMSA6IGV2ZW50LmJ1dHRvbiAmIDIgPyAyIDogMDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGZpeGVkLXVwIGluc3RhbmNlXG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZSBzdXBwb3J0ZWRcbiAqL1xudmFyIF9zdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBkaXNyZWdhcmRcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgQ2hyb21lIGV4cGVjdHMgdG8gYmUgcGFzc2l2ZVxuICovXG52YXIgcGFzc2l2ZUV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgbGlzdGVuZXJzIHRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIEV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBvbihlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob24sIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBXZSBuZWVkIGEgcGxhY2UgdG8gc3RvcmUgYWxsIG91ciBoYW5kbGVyIGRhdGFcbiAgaWYgKCFkYXRhLmhhbmRsZXJzKSB7XG4gICAgZGF0YS5oYW5kbGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKCFkYXRhLmhhbmRsZXJzW3R5cGVdKSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgaWYgKCFmbi5ndWlkKSB7XG4gICAgZm4uZ3VpZCA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIGRhdGEuaGFuZGxlcnNbdHlwZV0ucHVzaChmbik7XG5cbiAgaWYgKCFkYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBkYXRhLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICBkYXRhLmRpc3BhdGNoZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGhhc2gpIHtcblxuICAgICAgaWYgKGRhdGEuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAgICAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1tldmVudC50eXBlXTtcblxuICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgIC8vIENvcHkgaGFuZGxlcnMgc28gaWYgaGFuZGxlcnMgYXJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIHRoZSBwcm9jZXNzIGl0IGRvZXNuJ3QgdGhyb3cgZXZlcnl0aGluZyBvZmYuXG4gICAgICAgIHZhciBoYW5kbGVyc0NvcHkgPSBoYW5kbGVycy5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBtID0gMCwgbiA9IGhhbmRsZXJzQ29weS5sZW5ndGg7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICBpZiAoZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJzQ29weVttXS5jYWxsKGVsZW0sIGV2ZW50LCBoYXNoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgbG9nJDEuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFsc2U7XG5cbiAgICAgIGlmIChfc3VwcG9ydHNQYXNzaXZlICYmIHBhc3NpdmVFdmVudHMuaW5kZXhPZih0eXBlKSA+IC0xKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3R5cGVdXG4gKiAgICAgICAgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gW2ZuXVxuICogICAgICAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudFxuICogICAgICAgIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIG9mZihlbGVtLCB0eXBlLCBmbikge1xuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGNhY2hlIG9iamVjdCB0aHJvdWdoIGdldEVsRGF0YSBpZiBub3QgbmVlZGVkXG4gIGlmICghaGFzRGF0YShlbGVtKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBJZiBubyBldmVudHMgZXhpc3QsIG5vdGhpbmcgdG8gdW5iaW5kXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvZmYsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25cbiAgdmFyIHJlbW92ZVR5cGUgPSBmdW5jdGlvbiByZW1vdmVUeXBlKGVsLCB0KSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0XSA9IFtdO1xuICAgIF9jbGVhblVwRXZlbnRzKGVsLCB0KTtcbiAgfTtcblxuICAvLyBBcmUgd2UgcmVtb3ZpbmcgYWxsIGJvdW5kIGV2ZW50cz9cbiAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIHQgaW4gZGF0YS5oYW5kbGVycykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmhhbmRsZXJzIHx8IHt9LCB0KSkge1xuICAgICAgICByZW1vdmVUeXBlKGVsZW0sIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuXG4gIC8vIElmIG5vIGhhbmRsZXJzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbm8gbGlzdGVuZXIgd2FzIHByb3ZpZGVkLCByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdHlwZVxuICBpZiAoIWZuKSB7XG4gICAgcmVtb3ZlVHlwZShlbGVtLCB0eXBlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSdyZSBvbmx5IHJlbW92aW5nIGEgc2luZ2xlIGhhbmRsZXJcbiAgaWYgKGZuLmd1aWQpIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGhhbmRsZXJzLmxlbmd0aDsgbisrKSB7XG4gICAgICBpZiAoaGFuZGxlcnNbbl0uZ3VpZCA9PT0gZm4uZ3VpZCkge1xuICAgICAgICBoYW5kbGVycy5zcGxpY2Uobi0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IGZvciBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgdG8gdHJpZ2dlciBhbiBldmVudCBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR8c3RyaW5nfSBldmVudFxuICogICAgICAgIEEgc3RyaW5nICh0aGUgdHlwZSkgb3IgYW4gZXZlbnQgb2JqZWN0IHdpdGggYSB0eXBlIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzaF1cbiAqICAgICAgICBkYXRhIGhhc2ggdG8gcGFzcyBhbG9uZyB3aXRoIHRoZSBldmVudFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICogICAgICAgICAtIFJldHVybnMgdGhlIG9wcG9zaXRlIG9mIGBkZWZhdWx0UHJldmVudGVkYCBpZiBkZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAqICAgICAgICAgLSBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlcihlbGVtLCBldmVudCwgaGFzaCkge1xuICAvLyBGZXRjaGVzIGVsZW1lbnQgZGF0YSBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCAoZm9yIGJ1YmJsaW5nKS5cbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBkYXRhIG9iamVjdCB0byBjYWNoZSBmb3IgZXZlcnkgcGFyZW50LFxuICAvLyBzbyBjaGVja2luZyBoYXNFbERhdGEgZmlyc3QuXG4gIHZhciBlbGVtRGF0YSA9IGhhc0RhdGEoZWxlbSkgPyBnZXREYXRhKGVsZW0pIDoge307XG4gIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUgfHwgZWxlbS5vd25lckRvY3VtZW50O1xuICAvLyB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudCxcbiAgLy8gaGFuZGxlcjtcblxuICAvLyBJZiBhbiBldmVudCBuYW1lIHdhcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGNyZWF0ZXMgYW4gZXZlbnQgb3V0IG9mIGl0XG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6IGV2ZW50LCB0YXJnZXQ6IGVsZW0gfTtcbiAgfVxuICAvLyBOb3JtYWxpemVzIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICAvLyBJZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIGEgZGlzcGF0Y2hlciwgZXhlY3V0ZXMgdGhlIGVzdGFibGlzaGVkIGhhbmRsZXJzLlxuICBpZiAoZWxlbURhdGEuZGlzcGF0Y2hlcikge1xuICAgIGVsZW1EYXRhLmRpc3BhdGNoZXIuY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gIH1cblxuICAvLyBVbmxlc3MgZXhwbGljaXRseSBzdG9wcGVkIG9yIHRoZSBldmVudCBkb2VzIG5vdCBidWJibGUgKGUuZy4gbWVkaWEgZXZlbnRzKVxuICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cbiAgaWYgKHBhcmVudCAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBldmVudC5idWJibGVzID09PSB0cnVlKSB7XG4gICAgdHJpZ2dlci5jYWxsKG51bGwsIHBhcmVudCwgZXZlbnQsIGhhc2gpO1xuXG4gICAgLy8gSWYgYXQgdGhlIHRvcCBvZiB0aGUgRE9NLCB0cmlnZ2VycyB0aGUgZGVmYXVsdCBhY3Rpb24gdW5sZXNzIGRpc2FibGVkLlxuICB9IGVsc2UgaWYgKCFwYXJlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IGdldERhdGEoZXZlbnQudGFyZ2V0KTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdGFyZ2V0IGhhcyBhIGRlZmF1bHQgYWN0aW9uIGZvciB0aGlzIGV2ZW50LlxuICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcbiAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVzIGV2ZW50IGRpc3BhdGNoaW5nIG9uIHRoZSB0YXJnZXQgYXMgd2UgaGF2ZSBhbHJlYWR5IGV4ZWN1dGVkIHRoZSBoYW5kbGVyLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICBpZiAodHlwZW9mIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudC50YXJnZXRbZXZlbnQudHlwZV0oKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlLWVuYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5mb3JtIHRoZSB0cmlnZ2VyZXIgaWYgdGhlIGRlZmF1bHQgd2FzIHByZXZlbnRlZCBieSByZXR1cm5pbmcgZmFsc2VcbiAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIEVsZW1lbnQgb3Igb2JqZWN0IHRvIGJpbmQgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBOYW1lL3R5cGUgb2YgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgRXZlbnQgTGlzdGVuZXIgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gb25lKGVsZW0sIHR5cGUsIGZuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbmUsIGVsZW0sIHR5cGUsIGZuKTtcbiAgfVxuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgb2ZmKGVsZW0sIHR5cGUsIGZ1bmMpO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gY29weSB0aGUgZ3VpZCB0byB0aGUgbmV3IGZ1bmN0aW9uIHNvIGl0IGNhbiByZW1vdmVkIHVzaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbidzIElEXG4gIGZ1bmMuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IG5ld0dVSUQoKTtcbiAgb24oZWxlbSwgdHlwZSwgZnVuYyk7XG59XG5cbnZhciBFdmVudHMgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0Zml4RXZlbnQ6IGZpeEV2ZW50LFxuXHRvbjogb24sXG5cdG9mZjogb2ZmLFxuXHR0cmlnZ2VyOiB0cmlnZ2VyLFxuXHRvbmU6IG9uZVxufSk7XG5cbi8qKlxuICogQGZpbGUgc2V0dXAuanMgLSBGdW5jdGlvbnMgZm9yIHNldHRpbmcgdXAgYSBwbGF5ZXIgd2l0aG91dFxuICogdXNlciBpbnRlcmFjdGlvbiBiYXNlZCBvbiB0aGUgZGF0YS1zZXR1cCBgYXR0cmlidXRlYCBvZiB0aGUgdmlkZW8gdGFnLlxuICpcbiAqIEBtb2R1bGUgc2V0dXBcbiAqL1xudmFyIF93aW5kb3dMb2FkZWQgPSBmYWxzZTtcbnZhciB2aWRlb2pzJDIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHVwIGFueSB0YWdzIHRoYXQgaGF2ZSBhIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgd2hlbiB0aGUgcGxheWVyIGlzIHN0YXJ0ZWQuXG4gKi9cbnZhciBhdXRvU2V0dXAgPSBmdW5jdGlvbiBhdXRvU2V0dXAoKSB7XG5cbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IGJyZWFrYWdlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgaWYgKCFpc1JlYWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE9uZSBkYXksIHdoZW4gd2Ugc3RvcCBzdXBwb3J0aW5nIElFOCwgZ28gYmFjayB0byB0aGlzLCBidXQgaW4gdGhlIG1lYW50aW1lLi4uKmhhY2sgaGFjayBoYWNrKlxuICAvLyB2YXIgdmlkcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpKTtcbiAgLy8gdmFyIGF1ZGlvcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpKTtcbiAgLy8gdmFyIG1lZGlhRWxzID0gdmlkcy5jb25jYXQoYXVkaW9zKTtcblxuICAvLyBCZWNhdXNlIElFOCBkb2Vzbid0IHN1cHBvcnQgY2FsbGluZyBzbGljZSBvbiBhIG5vZGUgbGlzdCwgd2UgbmVlZCB0byBsb29wXG4gIC8vIHRocm91Z2ggZWFjaCBsaXN0IG9mIGVsZW1lbnRzIHRvIGJ1aWxkIHVwIGEgbmV3LCBjb21iaW5lZCBsaXN0IG9mIGVsZW1lbnRzLlxuICB2YXIgdmlkcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlbycpO1xuICB2YXIgYXVkaW9zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2F1ZGlvJyk7XG4gIHZhciBkaXZzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvLWpzJyk7XG4gIHZhciBtZWRpYUVscyA9IFtdO1xuXG4gIGlmICh2aWRzICYmIHZpZHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gdmlkcy5sZW5ndGg7IGkgPCBlOyBpKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2godmlkc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGF1ZGlvcyAmJiBhdWRpb3MubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2UgPSBhdWRpb3MubGVuZ3RoOyBfaSA8IF9lOyBfaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKGF1ZGlvc1tfaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXZzICYmIGRpdnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIF9pMiA9IDAsIF9lMiA9IGRpdnMubGVuZ3RoOyBfaTIgPCBfZTI7IF9pMisrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKGRpdnNbX2kyXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IG1lZGlhIGVsZW1lbnRzIGV4aXN0XG4gIGlmIChtZWRpYUVscyAmJiBtZWRpYUVscy5sZW5ndGggPiAwKSB7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwLCBfZTMgPSBtZWRpYUVscy5sZW5ndGg7IF9pMyA8IF9lMzsgX2kzKyspIHtcbiAgICAgIHZhciBtZWRpYUVsID0gbWVkaWFFbHNbX2kzXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBleGlzdHMsIGhhcyBnZXRBdHRyaWJ1dGUgZnVuYy5cbiAgICAgIC8vIElFIHNlZW1zIHRvIGNvbnNpZGVyIHR5cGVvZiBlbC5nZXRBdHRyaWJ1dGUgPT0gJ29iamVjdCcgaW5zdGVhZCBvZlxuICAgICAgLy8gJ2Z1bmN0aW9uJyBsaWtlIGV4cGVjdGVkLCBhdCBsZWFzdCB3aGVuIGxvYWRpbmcgdGhlIHBsYXllciBpbW1lZGlhdGVseS5cbiAgICAgIGlmIChtZWRpYUVsICYmIG1lZGlhRWwuZ2V0QXR0cmlidXRlKSB7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgcGxheWVyIGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0IHVwLlxuICAgICAgICBpZiAobWVkaWFFbC5wbGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gbWVkaWFFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2V0dXAnKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEtc2V0dXAgYXR0ciBleGlzdHMuXG4gICAgICAgICAgLy8gV2Ugb25seSBhdXRvLXNldHVwIGlmIHRoZXkndmUgYWRkZWQgdGhlIGRhdGEtc2V0dXAgYXR0ci5cbiAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB2aWRlby5qcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZpZGVvanMkMihtZWRpYUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBnZXRBdHRyaWJ1dGUgaXNuJ3QgZGVmaW5lZCwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgRE9NLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXV0b1NldHVwVGltZW91dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlkZW9zIHdlcmUgZm91bmQsIHNvIGtlZXAgbG9vcGluZyB1bmxlc3MgcGFnZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxuICB9IGVsc2UgaWYgKCFfd2luZG93TG9hZGVkKSB7XG4gICAgYXV0b1NldHVwVGltZW91dCgxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWl0IHVudGlsIHRoZSBwYWdlIGlzIGxvYWRlZCBiZWZvcmUgcnVubmluZyBhdXRvU2V0dXAuIFRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAqIGF1dG9TZXR1cCBpZiBgaGFzTG9hZGVkYCByZXR1cm5zIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0XG4gKiAgICAgICAgSG93IGxvbmcgdG8gd2FpdCBpbiBtc1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnZpZGVvanN9IFt2anNdXG4gKiAgICAgICAgVGhlIHZpZGVvanMgbGlicmFyeSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBhdXRvU2V0dXBUaW1lb3V0KHdhaXQsIHZqcykge1xuICBpZiAodmpzKSB7XG4gICAgdmlkZW9qcyQyID0gdmpzO1xuICB9XG5cbiAgd2luZG93LnNldFRpbWVvdXQoYXV0b1NldHVwLCB3YWl0KTtcbn1cblxuaWYgKGlzUmVhbCgpICYmIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG59IGVsc2Uge1xuICAvKipcbiAgICogTGlzdGVuIGZvciB0aGUgbG9hZCBldmVudCBvbiB3aW5kb3csIGFuZCBzZXQgX3dpbmRvd0xvYWRlZCB0byB0cnVlLlxuICAgKlxuICAgKiBAbGlzdGVucyBsb2FkXG4gICAqL1xuICBvbmUod2luZG93LCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGZpbGUgc3R5bGVzaGVldC5qc1xuICogQG1vZHVsZSBzdHlsZXNoZWV0XG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgRE9NIHN5bGUgZWxlbWVudCBnaXZlbiBhIGNsYXNzTmFtZSBmb3IgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgIFRoZSBjbGFzc05hbWUgdG8gYWRkIHRvIHRoZSBjcmVhdGVkIHN0eWxlIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xudmFyIGNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChjbGFzc05hbWUpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLyoqXG4gKiBBZGQgdGV4dCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgRWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiAgICAgICAgVGhlIHRleHQgdG8gYWRkIHRvIHRoZSBlbGVtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiBzZXRUZXh0Q29udGVudChlbCwgY29udGVudCkge1xuICBpZiAoZWwuc3R5bGVTaGVldCkge1xuICAgIGVsLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICB9XG59O1xuXG4vKipcbiAqIEBmaWxlIGZuLmpzXG4gKiBAbW9kdWxlIGZuXG4gKi9cbi8qKlxuICogQmluZCAoYS5rLmEgcHJveHkgb3IgQ29udGV4dCkuIEEgc2ltcGxlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvblxuICogSXQgYWxzbyBzdG9yZXMgYSB1bmlxdWUgaWQgb24gdGhlIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBlYXNpbHkgcmVtb3ZlZCBmcm9tIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0XG4gKiAgICAgICAgVGhlIG9iamVjdCB0byBiaW5kIGFzIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kIHRvIGEgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt1aWRdXG4gKiAgICAgICAgQW4gb3B0aW9uYWwgdW5pcXVlIElEIGZvciB0aGUgZnVuY3Rpb24gdG8gYmUgc2V0XG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIFRoZSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGJvdW5kIGludG8gdGhlIGNvbnRleHQgZ2l2ZW5cbiAqL1xudmFyIGJpbmQgPSBmdW5jdGlvbiBiaW5kKGNvbnRleHQsIGZuLCB1aWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRoZSBmdW5jdGlvbiBoYXMgYSB1bmlxdWUgSURcbiAgaWYgKCFmbi5ndWlkKSB7XG4gICAgZm4uZ3VpZCA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IGZ1bmN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgY29udGV4dFxuICB2YXIgYm91bmQgPSBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBbGxvdyBmb3IgdGhlIGFiaWxpdHkgdG8gaW5kaXZpZHVhbGl6ZSB0aGlzIGZ1bmN0aW9uXG4gIC8vIE5lZWRlZCBpbiB0aGUgY2FzZSB3aGVyZSBtdWx0aXBsZSBvYmplY3RzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZVxuICAvLyBJRiBib3RoIGl0ZW1zIGFkZCBhbiBldmVudCBsaXN0ZW5lciB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uLCB0aGVuIHlvdSB0cnkgdG8gcmVtb3ZlIGp1c3Qgb25lXG4gIC8vIGl0IHdpbGwgcmVtb3ZlIGJvdGggYmVjYXVzZSB0aGV5IGJvdGggaGF2ZSB0aGUgc2FtZSBndWlkLlxuICAvLyB3aGVuIHVzaW5nIHRoaXMsIHlvdSBuZWVkIHRvIHVzZSB0aGUgYmluZCBtZXRob2Qgd2hlbiB5b3UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhcyB3ZWxsLlxuICAvLyBjdXJyZW50bHkgdXNlZCBpbiB0ZXh0IHRyYWNrc1xuICBib3VuZC5ndWlkID0gdWlkID8gdWlkICsgJ18nICsgZm4uZ3VpZCA6IGZuLmd1aWQ7XG5cbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGBmbmAsIHdpdGggYSBuZXcgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZuYFxuICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgdGhyb3R0bGVkLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gICB3YWl0XG4gKiAgICAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJ5IHdoaWNoIHRvIHRocm90dGxlLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgdGhyb3R0bGUgPSBmdW5jdGlvbiB0aHJvdHRsZShmbiwgd2FpdCkge1xuICB2YXIgbGFzdCA9IERhdGUubm93KCk7XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChub3cgLSBsYXN0ID49IHdhaXQpIHtcbiAgICAgIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59O1xuXG4vKipcbiAqIEBmaWxlIHNyYy9qcy9ldmVudC10YXJnZXQuanNcbiAqL1xuLyoqXG4gKiBgRXZlbnRUYXJnZXRgIGlzIGEgY2xhc3MgdGhhdCBjYW4gaGF2ZSB0aGUgc2FtZSBBUEkgYXMgdGhlIERPTSBgRXZlbnRUYXJnZXRgLiBJdFxuICogYWRkcyBzaG9ydGhhbmQgZnVuY3Rpb25zIHRoYXQgd3JhcCBhcm91bmQgbGVuZ3RoeSBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICogdGhlIGBvbmAgZnVuY3Rpb24gaXMgYSB3cmFwcGVyIGFyb3VuZCBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQHNlZSBbRXZlbnRUYXJnZXQgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXR9XG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fTtcblxuLyoqXG4gKiBBIEN1c3RvbSBET00gZXZlbnQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRUYXJnZXR+RXZlbnRcbiAqIEBzZWUgW1Byb3BlcnRpZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudH1cbiAqL1xuXG4vKipcbiAqIEFsbCBldmVudCBsaXN0ZW5lcnMgc2hvdWxkIGZvbGxvdyB0aGUgZm9sbG93aW5nIGZvcm1hdC5cbiAqXG4gKiBAY2FsbGJhY2sgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lclxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgaGFzaCBvZiBkYXRhIHNlbnQgZHVyaW5nIHRoZSBldmVudFxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgZXZlbnQgbmFtZXMgYXMga2V5cyBhbmQgYm9vbGVhbnMgYXMgdmFsdWVzLlxuICpcbiAqID4gTk9URTogSWYgYW4gZXZlbnQgbmFtZSBpcyBzZXQgdG8gYSB0cnVlIHZhbHVlIGhlcmUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XG4gKiAgICAgICAgIHdpbGwgaGF2ZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBTZWUgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkgRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfXG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7fTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudCBsaXN0ZW5lcmAgdG8gYW4gaW5zdGFuY2Ugb2YgYW4gYEV2ZW50VGFyZ2V0YC4gQW4gYGV2ZW50IGxpc3RlbmVyYCBpcyBhXG4gKiBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZCB3aGVuIGFuIGV2ZW50IHdpdGggYSBjZXJ0YWluIG5hbWUgZ2V0cyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGBFdmVudFRhcmdldGBzXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICBvbih0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29ufS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb259XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gYGV2ZW50IGxpc3RlbmVyYCBmb3IgYSBzcGVjaWZpYyBldmVudCBmcm9tIGFuIGluc3RhbmNlIG9mIGBFdmVudFRhcmdldGAuXG4gKiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgdGhlIGBldmVudCBsaXN0ZW5lcmAgd2lsbCBubyBsb25nZXIgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogbmFtZWQgZXZlbnQgaGFwcGVucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byByZW1vdmUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgb2ZmKHRoaXMsIHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub2ZmO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYW4gYGV2ZW50IGxpc3RlbmVyYCB0aGF0IGdldHMgdHJpZ2dlcmVkIG9ubHkgb25jZS4gQWZ0ZXIgdGhlXG4gKiBmaXJzdCB0cmlnZ2VyIGl0IHdpbGwgZ2V0IHJlbW92ZWQuIFRoaXMgaXMgbGlrZSBhZGRpbmcgYW4gYGV2ZW50IGxpc3RlbmVyYFxuICogd2l0aCB7QGxpbmsgRXZlbnRUYXJnZXQjb259IHRoYXQgY2FsbHMge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0gb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGV2ZW50IG5hbWUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgdmFyIGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgb25lKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhdXNlcyBhbiBldmVudCB0byBoYXBwZW4uIFRoaXMgd2lsbCB0aGVuIGNhdXNlIGFueSBgZXZlbnQgbGlzdGVuZXJzYFxuICogdGhhdCBhcmUgd2FpdGluZyBmb3IgdGhhdCBldmVudCwgdG8gZ2V0IGNhbGxlZC4gSWYgdGhlcmUgYXJlIG5vIGBldmVudCBsaXN0ZW5lcnNgXG4gKiBmb3IgYW4gZXZlbnQgdGhlbiBub3RoaW5nIHdpbGwgaGFwcGVuLlxuICpcbiAqIElmIHRoZSBuYW1lIG9mIHRoZSBgRXZlbnRgIHRoYXQgaXMgYmVpbmcgdHJpZ2dlcmVkIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AuXG4gKiBUcmlnZ2VyIHdpbGwgYWxzbyBjYWxsIHRoZSBgb25gICsgYHVwcGVyY2FzZUV2ZW50TmFtZWAgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqICdjbGljaycgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYCwgc28sIHRyaWdnZXIgd2lsbCBhdHRlbXB0IHRvIGNhbGxcbiAqIGBvbkNsaWNrYCBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RXZlbnRUYXJnZXR+RXZlbnR8T2JqZWN0fSBldmVudFxuICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgYW4gYEV2ZW50YCwgb3IgYW4gb2JqZWN0IHdpdGggYSBrZXkgb2YgdHlwZSBzZXQgdG9cbiAqICAgICAgICBhbiBldmVudCBuYW1lLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudCA9IHsgdHlwZTogdHlwZSB9O1xuICB9XG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gIGlmICh0aGlzLmFsbG93ZWRFdmVudHNfW3R5cGVdICYmIHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xuICB9XG5cbiAgdHJpZ2dlcih0aGlzLCBldmVudCk7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBFdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlcjtcblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvZXZlbnRlZC5qc1xuICogQG1vZHVsZSBldmVudGVkXG4gKi9cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGhhZCB0aGUgZXZlbnRlZCBtaXhpbiBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgYXBwZWFycyB0byBiZSBldmVudGVkLlxuICovXG52YXIgaXNFdmVudGVkID0gZnVuY3Rpb24gaXNFdmVudGVkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQgfHwgISFvYmplY3QuZXZlbnRCdXNFbF8gJiYgWydvbicsICdvbmUnLCAnb2ZmJywgJ3RyaWdnZXInXS5ldmVyeShmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W2tdID09PSAnZnVuY3Rpb24nO1xuICB9KTtcbn07XG5cbi8qKlxuICogV2hldGhlciBhIHZhbHVlIGlzIGEgdmFsaWQgZXZlbnQgdHlwZSAtIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBUaGUgdHlwZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB0eXBlIGlzIGEgdmFsaWQgZXZlbnQgdHlwZS5cbiAqL1xudmFyIGlzVmFsaWRFdmVudFR5cGUgPSBmdW5jdGlvbiBpc1ZhbGlkRXZlbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBUaGUgcmVnZXggaGVyZSB2ZXJpZmllcyB0aGF0IHRoZSBgdHlwZWAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG5vbi1cbiAgICAvLyB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh0eXBlKSB8fCBBcnJheS5pc0FycmF5KHR5cGUpICYmICEhdHlwZS5sZW5ndGhcbiAgKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIHRhcmdldCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBldmVudCB0YXJnZXQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVUYXJnZXQgPSBmdW5jdGlvbiB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQubm9kZU5hbWUgJiYgIWlzRXZlbnRlZCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhcmdldDsgbXVzdCBiZSBhIERPTSBub2RlIG9yIGV2ZW50ZWQgb2JqZWN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSB0eXBlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGV2ZW50IHR5cGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIFRoZSB0eXBlIHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZUV2ZW50VHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpIHtcbiAgaWYgKCFpc1ZhbGlkRXZlbnRUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGU7IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5LicpO1xuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGxpc3RlbmVyLiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIGxpc3RlbmVyIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICAgICAgICBUaGUgbGlzdGVuZXIgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdGVuZXI7IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYG9uKClgIG9yIGBvbmUoKWAsIHZhbGlkYXRlcyB0aGVtLCBhbmRcbiAqIG5vcm1hbGl6ZXMgdGhlbSBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBzZWxmXG4gKiAgICAgICAgIFRoZSBldmVudGVkIG9iamVjdCBvbiB3aGljaCBgb24oKWAgb3IgYG9uZSgpYCB3YXMgY2FsbGVkLiBUaGlzXG4gKiAgICAgICAgIG9iamVjdCB3aWxsIGJlIGJvdW5kIGFzIHRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xuICogICAgICAgICBBbiBhcnJheSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGBvbigpYCBvciBgb25lKClgLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdXNlZnVsIHZhbHVlcyBmb3IgYG9uKClgIG9yIGBvbmUoKWAgY2FsbHMuXG4gKi9cbnZhciBub3JtYWxpemVMaXN0ZW5BcmdzID0gZnVuY3Rpb24gbm9ybWFsaXplTGlzdGVuQXJncyhzZWxmLCBhcmdzKSB7XG5cbiAgLy8gSWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgbGVzcyB0aGFuIDMsIHRoZSB0YXJnZXQgaXMgYWx3YXlzIHRoZVxuICAvLyBldmVudGVkIG9iamVjdCBpdHNlbGYuXG4gIHZhciBpc1RhcmdldGluZ1NlbGYgPSBhcmdzLmxlbmd0aCA8IDMgfHwgYXJnc1swXSA9PT0gc2VsZiB8fCBhcmdzWzBdID09PSBzZWxmLmV2ZW50QnVzRWxfO1xuICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgdmFyIGxpc3RlbmVyID0gdm9pZCAwO1xuXG4gIGlmIChpc1RhcmdldGluZ1NlbGYpIHtcbiAgICB0YXJnZXQgPSBzZWxmLmV2ZW50QnVzRWxfO1xuXG4gICAgLy8gRGVhbCB3aXRoIGNhc2VzIHdoZXJlIHdlIGdvdCAzIGFyZ3VtZW50cywgYnV0IHdlIGFyZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyB0aGUgZXZlbnRlZCBvYmplY3QgaXRzZWxmLlxuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdHlwZSA9IGFyZ3NbMF07XG4gICAgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IGFyZ3NbMF07XG4gICAgdHlwZSA9IGFyZ3NbMV07XG4gICAgbGlzdGVuZXIgPSBhcmdzWzJdO1xuICB9XG5cbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcbiAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XG4gIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGxpc3RlbmVyID0gYmluZChzZWxmLCBsaXN0ZW5lcik7XG5cbiAgcmV0dXJuIHsgaXNUYXJnZXRpbmdTZWxmOiBpc1RhcmdldGluZ1NlbGYsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgbGlzdGVuZXIgdG8gdGhlIGV2ZW50IHR5cGUocykgb24gdGhlIHRhcmdldCwgbm9ybWFsaXppbmcgZm9yXG4gKiB0aGUgdHlwZSBvZiB0YXJnZXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgQSBET00gbm9kZSBvciBldmVudGVkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZFxuICogICAgICAgICBUaGUgZXZlbnQgYmluZGluZyBtZXRob2QgdG8gdXNlIChcIm9uXCIgb3IgXCJvbmVcIikuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIE9uZSBvciBtb3JlIGV2ZW50IHR5cGUocykuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgICAgICAgIEEgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKi9cbnZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBtZXRob2QsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG5cbiAgaWYgKHRhcmdldC5ub2RlTmFtZSkge1xuICAgIEV2ZW50c1ttZXRob2RdKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFttZXRob2RdKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBldmVudCBjYXBhYmlsaXRlcyB0byBhbiBvYmplY3Qgd2hpY2ggaXMgcGFzc2VkXG4gKiB0byB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0uXG4gKlxuICogQG1peGluIEV2ZW50ZWRNaXhpblxuICovXG52YXIgRXZlbnRlZE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcbiAgICogICAgICAgICB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgIGNhdXNlIHRoZSBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGV2ZW50cyBvbiBfdGhhdF8gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xuICAgKiAgICAgICAgIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24kJDEoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBfbm9ybWFsaXplTGlzdGVuQXJncyA9IG5vcm1hbGl6ZUxpc3RlbkFyZ3ModGhpcywgYXJncyksXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudHlwZSxcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5saXN0ZW5lcjtcblxuICAgIGxpc3Rlbih0YXJnZXQsICdvbicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGxpc3RlbmluZyB0byBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmICghaXNUYXJnZXRpbmdTZWxmKSB7XG5cbiAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXRcbiAgICAgIC8vIHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZS5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcblxuICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCdzIGRpc3Bvc2UgZXZlbnQgYXMgd2VsbC4gVGhpcyBlbnN1cmVzXG4gICAgICAvLyB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgZGlzcG9zZWQgQkVGT1JFIHRoaXMgb2JqZWN0LCB3ZSByZW1vdmUgdGhlXG4gICAgICAvLyByZW1vdmFsIGxpc3RlbmVyIHRoYXQgd2FzIGp1c3QgYWRkZWQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXG4gICAgICB2YXIgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYoJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuXG4gICAgICBsaXN0ZW4odGhpcywgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCAnZGlzcG9zZScsIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LiBUaGUgbGlzdGVuZXIgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gdGFyZ2V0T3JUeXBlXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXG4gICAqXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIG9uZTogZnVuY3Rpb24gb25lJCQxKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MyID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcbiAgICAgICAgaXNUYXJnZXRpbmdTZWxmID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50eXBlLFxuICAgICAgICBsaXN0ZW5lciA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi5saXN0ZW5lcjtcblxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxuXG5cbiAgICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb25lJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGxhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBsYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLm9mZih0YXJnZXQsIHR5cGUsIHdyYXBwZXIpO1xuICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBsYXJncyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICB3cmFwcGVyLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uZScsIHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVyKHMpIGZyb20gZXZlbnQocykgb24gYW4gZXZlbnRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gW3RhcmdldE9yVHlwZV1cbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIGluIHdoaWNoIGNhc2VcbiAgICogICAgICAgICBBTEwgMyBhcmd1bWVudHMgYXJlIF9yZXF1aXJlZF8uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gW3R5cGVPckxpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgbWF5IGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uOyBvdGhlcndpc2UsIF9hbGxfIGxpc3RlbmVycyBib3VuZCB0byB0aGVcbiAgICogICAgICAgICBldmVudCB0eXBlKHMpIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmJCQxKHRhcmdldE9yVHlwZSwgdHlwZU9yTGlzdGVuZXIsIGxpc3RlbmVyKSB7XG5cbiAgICAvLyBUYXJnZXRpbmcgdGhpcyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoIXRhcmdldE9yVHlwZSB8fCBpc1ZhbGlkRXZlbnRUeXBlKHRhcmdldE9yVHlwZSkpIHtcbiAgICAgIG9mZih0aGlzLmV2ZW50QnVzRWxfLCB0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyKTtcblxuICAgICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRPclR5cGU7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVPckxpc3RlbmVyO1xuXG4gICAgICAvLyBGYWlsIGZhc3QgYW5kIGluIGEgbWVhbmluZ2Z1bCB3YXkhXG4gICAgICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XG4gICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXG4gICAgICBsaXN0ZW5lciA9IGJpbmQodGhpcywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGRpc3Bvc2UgbGlzdGVuZXIgb24gdGhpcyBldmVudGVkIG9iamVjdCwgd2hpY2ggd2FzIGdpdmVuXG4gICAgICAvLyB0aGUgc2FtZSBndWlkIGFzIHRoZSBldmVudCBsaXN0ZW5lciBpbiBvbigpLlxuICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgb2ZmKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBvZmYodGFyZ2V0LCAnZGlzcG9zZScsIGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZpcmUgYW4gZXZlbnQgb24gdGhpcyBldmVudGVkIG9iamVjdCwgY2F1c2luZyBpdHMgbGlzdGVuZXJzIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICAgIEFuIGV2ZW50IHR5cGUgb3IgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaF1cbiAgICogICAgICAgICAgQW4gYWRkaXRpb25hbCBvYmplY3QgdG8gcGFzcyBhbG9uZyB0byBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3YXMgcHJldmVudGVkLlxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCwgaGFzaCkge1xuICAgIHJldHVybiB0cmlnZ2VyKHRoaXMuZXZlbnRCdXNFbF8sIGV2ZW50LCBoYXNoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW58RXZlbnRlZE1peGlufSB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgZXZlbnQgbWV0aG9kcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogICAgICAgICBPcHRpb25zIGZvciBjdXN0b21pemluZyB0aGUgbWl4aW4gYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudEJ1c0tleV1cbiAqICAgICAgICAgQnkgZGVmYXVsdCwgYWRkcyBhIGBldmVudEJ1c0VsX2AgRE9NIGVsZW1lbnQgdG8gdGhlIHRhcmdldCBvYmplY3QsXG4gKiAgICAgICAgIHdoaWNoIGlzIHVzZWQgYXMgYW4gZXZlbnQgYnVzLiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhXG4gKiAgICAgICAgIERPTSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQsIHBhc3MgaXRzIGtleSBoZXJlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50ZWQodGFyZ2V0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGV2ZW50QnVzS2V5ID0gb3B0aW9ucy5ldmVudEJ1c0tleTtcblxuICAvLyBTZXQgb3IgY3JlYXRlIHRoZSBldmVudEJ1c0VsXy5cblxuICBpZiAoZXZlbnRCdXNLZXkpIHtcbiAgICBpZiAoIXRhcmdldFtldmVudEJ1c0tleV0ubm9kZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGV2ZW50QnVzS2V5IFwiJyArIGV2ZW50QnVzS2V5ICsgJ1wiIGRvZXMgbm90IHJlZmVyIHRvIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IHRhcmdldFtldmVudEJ1c0tleV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gY3JlYXRlRWwoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ3Zqcy1ldmVudC1idXMnIH0pO1xuICB9XG5cbiAgYXNzaWduKHRhcmdldCwgRXZlbnRlZE1peGluKTtcblxuICAvLyBXaGVuIGFueSBldmVudGVkIG9iamVjdCBpcyBkaXNwb3NlZCwgaXQgcmVtb3ZlcyBhbGwgaXRzIGxpc3RlbmVycy5cbiAgdGFyZ2V0Lm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5vZmYoKTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSBudWxsO1xuICAgIH0sIDApO1xuICB9KTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBmaWxlIG1peGlucy9zdGF0ZWZ1bC5qc1xuICogQG1vZHVsZSBzdGF0ZWZ1bFxuICovXG4vKipcbiAqIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBwcm92aWRlIHN0YXRlZnVsbmVzcyB0byBhbiBvYmplY3Qgd2hpY2ggaXMgcGFzc2VkXG4gKiB0byB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsfS5cbiAqXG4gKiBAbWl4aW4gU3RhdGVmdWxNaXhpblxuICovXG52YXIgU3RhdGVmdWxNaXhpbiA9IHtcblxuICAvKipcbiAgICogQSBoYXNoIGNvbnRhaW5pbmcgYXJiaXRyYXJ5IGtleXMgYW5kIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mXG4gICAqIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0ZToge30sXG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgYW4gb2JqZWN0IGJ5IG11dGF0aW5nIGl0c1xuICAgKiB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4uc3RhdGV8c3RhdGV9IG9iamVjdCBpbiBwbGFjZS5cbiAgICpcbiAgICogQGZpcmVzICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXG4gICAqIEBwYXJhbSAgIHtPYmplY3R8RnVuY3Rpb259IHN0YXRlVXBkYXRlc1xuICAgKiAgICAgICAgICBBIG5ldyBzZXQgb2YgcHJvcGVydGllcyB0byBzaGFsbG93LW1lcmdlIGludG8gdGhlIHBsdWdpbiBzdGF0ZS5cbiAgICogICAgICAgICAgQ2FuIGJlIGEgcGxhaW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcGxhaW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgY2hhbmdlcyB0aGF0IG9jY3VycmVkLiBJZiBubyBjaGFuZ2VzXG4gICAqICAgICAgICAgIG9jY3VycmVkLCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgc2V0U3RhdGU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlVXBkYXRlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBTdXBwb3J0IHByb3ZpZGluZyB0aGUgYHN0YXRlVXBkYXRlc2Agc3RhdGUgYXMgYSBmdW5jdGlvbi5cbiAgICBpZiAodHlwZW9mIHN0YXRlVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGVVcGRhdGVzID0gc3RhdGVVcGRhdGVzKCk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZXMgPSB2b2lkIDA7XG5cbiAgICBlYWNoKHN0YXRlVXBkYXRlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFuZ2UgaWYgdGhlIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHdoYXQncyBpbiB0aGVcbiAgICAgIC8vIGN1cnJlbnQgc3RhdGUuXG4gICAgICBpZiAoX3RoaXMuc3RhdGVba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfHwge307XG4gICAgICAgIGNoYW5nZXNba2V5XSA9IHtcbiAgICAgICAgICBmcm9tOiBfdGhpcy5zdGF0ZVtrZXldLFxuICAgICAgICAgIHRvOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHRyaWdnZXIgXCJzdGF0ZWNoYW5nZVwiIGlmIHRoZXJlIHdlcmUgY2hhbmdlcyBBTkQgd2UgaGF2ZSBhIHRyaWdnZXJcbiAgICAvLyBmdW5jdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG8gbm90IHJlcXVpcmUgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCBiZSBhblxuICAgIC8vIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmIChjaGFuZ2VzICYmIGlzRXZlbnRlZCh0aGlzKSkge1xuXG4gICAgICAvKipcbiAgICAgICAqIEFuIGV2ZW50IHRyaWdnZXJlZCBvbiBhbiBvYmplY3QgdGhhdCBpcyBib3RoXG4gICAgICAgKiB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsfHN0YXRlZnVsfSBhbmQge0BsaW5rIG1vZHVsZTpldmVudGVkfGV2ZW50ZWR9XG4gICAgICAgKiBpbmRpY2F0aW5nIHRoYXQgaXRzIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCAgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbiNzdGF0ZWNoYW5nZWRcbiAgICAgICAqIEB0eXBlICAgICB7T2JqZWN0fVxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNoYW5nZXNcbiAgICAgICAqICAgICAgICAgICBBIGhhc2ggY29udGFpbmluZyB0aGUgcHJvcGVydGllcyB0aGF0IHdlcmUgY2hhbmdlZCBhbmRcbiAgICAgICAqICAgICAgICAgICB0aGUgdmFsdWVzIHRoZXkgd2VyZSBjaGFuZ2VkIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgY2hhbmdlczogY2hhbmdlcyxcbiAgICAgICAgdHlwZTogJ3N0YXRlY2hhbmdlZCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VzO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGlufFN0YXRlZnVsTWl4aW59IHRvIGEgdGFyZ2V0XG4gKiBvYmplY3QuXG4gKlxuICogSWYgdGhlIHRhcmdldCBvYmplY3QgaXMge0BsaW5rIG1vZHVsZTpldmVudGVkfGV2ZW50ZWR9IGFuZCBoYXMgYVxuICogYGhhbmRsZVN0YXRlQ2hhbmdlZGAgbWV0aG9kLCB0aGF0IG1ldGhvZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gdGhlXG4gKiBgc3RhdGVjaGFuZ2VkYCBldmVudCBvbiBpdHNlbGYuXG4gKlxuICogQHBhcmFtICAge09iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgICBUaGUgb2JqZWN0IHRvIGJlIG1hZGUgc3RhdGVmdWwuXG4gKlxuICogQHBhcmFtICAge09iamVjdH0gW2RlZmF1bHRTdGF0ZV1cbiAqICAgICAgICAgIEEgZGVmYXVsdCBzZXQgb2YgcHJvcGVydGllcyB0byBwb3B1bGF0ZSB0aGUgbmV3bHktc3RhdGVmdWwgb2JqZWN0J3NcbiAqICAgICAgICAgIGBzdGF0ZWAgcHJvcGVydHkuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqICAgICAgICAgIFJldHVybnMgdGhlIGB0YXJnZXRgLlxuICovXG5mdW5jdGlvbiBzdGF0ZWZ1bCh0YXJnZXQsIGRlZmF1bHRTdGF0ZSkge1xuICBhc3NpZ24odGFyZ2V0LCBTdGF0ZWZ1bE1peGluKTtcblxuICAvLyBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIG1peGluZy1pbiBiZWNhdXNlIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgYHN0YXRlYFxuICAvLyBhZGRlZCBpbiB0aGF0IHN0ZXAuXG4gIHRhcmdldC5zdGF0ZSA9IGFzc2lnbih7fSwgdGFyZ2V0LnN0YXRlLCBkZWZhdWx0U3RhdGUpO1xuXG4gIC8vIEF1dG8tYmluZCB0aGUgYGhhbmRsZVN0YXRlQ2hhbmdlZGAgbWV0aG9kIG9mIHRoZSB0YXJnZXQgb2JqZWN0IGlmIGl0IGV4aXN0cy5cbiAgaWYgKHR5cGVvZiB0YXJnZXQuaGFuZGxlU3RhdGVDaGFuZ2VkID09PSAnZnVuY3Rpb24nICYmIGlzRXZlbnRlZCh0YXJnZXQpKSB7XG4gICAgdGFyZ2V0Lm9uKCdzdGF0ZWNoYW5nZWQnLCB0YXJnZXQuaGFuZGxlU3RhdGVDaGFuZ2VkKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQGZpbGUgdG8tdGl0bGUtY2FzZS5qc1xuICogQG1vZHVsZSB0by10aXRsZS1jYXNlXG4gKi9cblxuLyoqXG4gKiBVcHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiAgICAgICAgU3RyaW5nIHRvIGJlIHVwcGVyY2FzZWRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSBzdHJpbmcgd2l0aCBhbiB1cHBlcmNhc2VkIGZpcnN0IGxldHRlclxuICovXG5mdW5jdGlvbiB0b1RpdGxlQ2FzZShzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgdHdvIHN0cmluZ3MgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIxXG4gKiAgICAgICAgVGhlIGZpcnN0IHN0cmluZyB0byBjb21wYXJlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjJcbiAqICAgICAgICBUaGUgc2Vjb25kIHN0cmluZyB0byBjb21wYXJlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciB0aGUgVGl0bGVDYXNlIHZlcnNpb25zIG9mIHRoZSBzdHJpbmdzIGFyZSBlcXVhbFxuICovXG5mdW5jdGlvbiB0aXRsZUNhc2VFcXVhbHMoc3RyMSwgc3RyMikge1xuICByZXR1cm4gdG9UaXRsZUNhc2Uoc3RyMSkgPT09IHRvVGl0bGVDYXNlKHN0cjIpO1xufVxuXG4vKipcbiAqIEBmaWxlIG1lcmdlLW9wdGlvbnMuanNcbiAqIEBtb2R1bGUgbWVyZ2Utb3B0aW9uc1xuICovXG4vKipcbiAqIERlZXAtbWVyZ2Ugb25lIG9yIG1vcmUgb3B0aW9ucyBvYmplY3RzLCByZWN1cnNpdmVseSBtZXJnaW5nICoqb25seSoqIHBsYWluXG4gKiBvYmplY3QgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0W119IHNvdXJjZXNcbiAqICAgICAgICAgIE9uZSBvciBtb3JlIG9iamVjdHMgdG8gbWVyZ2UgaW50byBhIG5ldyBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqICAgICAgICAgIEEgbmV3IG9iamVjdCB0aGF0IGlzIHRoZSBtZXJnZWQgcmVzdWx0IG9mIGFsbCBzb3VyY2VzLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChzb3VyY2UsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoIWlzUGxhaW4odmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1BsYWluKHJlc3VsdFtrZXldKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlT3B0aW9ucyhyZXN1bHRba2V5XSwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBsYXllciBDb21wb25lbnQgLSBCYXNlIGNsYXNzIGZvciBhbGwgVUkgb2JqZWN0c1xuICpcbiAqIEBmaWxlIGNvbXBvbmVudC5qc1xuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBDb21wb25lbnRzLlxuICogQ29tcG9uZW50cyBhcmUgVUkgb2JqZWN0cyB3aGljaCByZXByZXNlbnQgYm90aCBhIGphdmFzY3JpcHQgb2JqZWN0IGFuZCBhbiBlbGVtZW50XG4gKiBpbiB0aGUgRE9NLiBUaGV5IGNhbiBiZSBjaGlsZHJlbiBvZiBvdGhlciBjb21wb25lbnRzLCBhbmQgY2FuIGhhdmVcbiAqIGNoaWxkcmVuIHRoZW1zZWx2ZXMuXG4gKlxuICogQ29tcG9uZW50cyBjYW4gYWxzbyB1c2UgbWV0aG9kcyBmcm9tIHtAbGluayBFdmVudFRhcmdldH1cbiAqL1xuXG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVhZHkuIERvZXMgbm90IGhhdmUgYW55XG4gICAqIHBhcmFtdGVycyBhbmQgYW55IGNhbGxiYWNrIHZhbHVlIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQGNhbGxiYWNrIENvbXBvbmVudH5SZWFkeUNhbGxiYWNrXG4gICAqIEB0aGlzIENvbXBvbmVudFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gW29wdGlvbnMuY2hpbGRyZW5dXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIHRvIGludGlhbGl6ZSB0aGlzIGNvbXBvbmVudCB3aXRoLiBDaGlsZHJlbiBvYmplY3RzIGhhdmVcbiAgICogICAgICAgIGEgbmFtZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdXNlZCBpZiBtb3JlIHRoYW4gb25lIGNvbXBvbmVudCBvZiB0aGUgc2FtZSB0eXBlIG5lZWRzIHRvIGJlXG4gICAqICAgICAgICBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgRnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBgQ29tcG9uZW50YCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudChwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50KTtcblxuXG4gICAgLy8gVGhlIGNvbXBvbmVudCBtaWdodCBiZSB0aGUgcGxheWVyIGl0c2VsZiBhbmQgd2UgY2FuJ3QgcGFzcyBgdGhpc2AgdG8gc3VwZXJcbiAgICBpZiAoIXBsYXllciAmJiB0aGlzLnBsYXkpIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllciA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyO1xuICAgIH1cblxuICAgIC8vIE1ha2UgYSBjb3B5IG9mIHByb3RvdHlwZS5vcHRpb25zXyB0byBwcm90ZWN0IGFnYWluc3Qgb3ZlcnJpZGluZyBkZWZhdWx0c1xuICAgIHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnMoe30sIHRoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gVXBkYXRlZCBvcHRpb25zIHdpdGggc3VwcGxpZWQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIG9wdGlvbnMpO1xuXG4gICAgLy8gR2V0IElEIGZyb20gb3B0aW9ucyBvciBvcHRpb25zIGVsZW1lbnQgaWYgb25lIGlzIHN1cHBsaWVkXG4gICAgdGhpcy5pZF8gPSBvcHRpb25zLmlkIHx8IG9wdGlvbnMuZWwgJiYgb3B0aW9ucy5lbC5pZDtcblxuICAgIC8vIElmIHRoZXJlIHdhcyBubyBJRCBmcm9tIHRoZSBvcHRpb25zLCBnZW5lcmF0ZSBvbmVcbiAgICBpZiAoIXRoaXMuaWRfKSB7XG4gICAgICAvLyBEb24ndCByZXF1aXJlIHRoZSBwbGF5ZXIgSUQgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2YgbW9jayBwbGF5ZXJzXG4gICAgICB2YXIgaWQgPSBwbGF5ZXIgJiYgcGxheWVyLmlkICYmIHBsYXllci5pZCgpIHx8ICdub19wbGF5ZXInO1xuXG4gICAgICB0aGlzLmlkXyA9IGlkICsgJ19jb21wb25lbnRfJyArIG5ld0dVSUQoKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG5cbiAgICAvLyBDcmVhdGUgZWxlbWVudCBpZiBvbmUgd2Fzbid0IHByb3ZpZGVkIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5lbCkge1xuICAgICAgdGhpcy5lbF8gPSBvcHRpb25zLmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jcmVhdGVFbCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xuICAgIH1cblxuICAgIC8vIGlmIGV2ZW50ZWQgaXMgYW55dGhpbmcgZXhjZXB0IGZhbHNlLCB3ZSB3YW50IHRvIG1peGluIGluIGV2ZW50ZWRcbiAgICBpZiAob3B0aW9ucy5ldmVudGVkICE9PSBmYWxzZSkge1xuICAgICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AsIGlmIGF2YWlsYWJsZSwgYXMgaXRzIGV2ZW50IGJ1c1xuICAgICAgZXZlbnRlZCh0aGlzLCB7IGV2ZW50QnVzS2V5OiB0aGlzLmVsXyA/ICdlbF8nIDogbnVsbCB9KTtcbiAgICB9XG4gICAgc3RhdGVmdWwodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0U3RhdGUpO1xuXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0ge307XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSB7fTtcblxuICAgIC8vIEFkZCBhbnkgY2hpbGQgY29tcG9uZW50cyBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaW5pdENoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5KHJlYWR5KTtcbiAgICAvLyBEb24ndCB3YW50IHRvIHRyaWdnZXIgcmVhZHkgaGVyZSBvciBpdCB3aWxsIGJlZm9yZSBpbml0IGlzIGFjdHVhbGx5XG4gICAgLy8gZmluaXNoZWQgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJ1biB0aGlzIGNvbnN0cnVjdG9yXG5cbiAgICBpZiAob3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbmFibGVUb3VjaEFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGBDb21wb25lbnRgIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGZpcmVzIENvbXBvbmVudCNkaXNwb3NlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidWJibGVzPWZhbHNlXVxuICAgICAqICAgICAgICAgICBzZXQgdG8gZmFsc2Ugc28gdGhhdCB0aGUgY2xvc2UgZXZlbnQgZG9lcyBub3RcbiAgICAgKiAgICAgICAgICAgYnViYmxlIHVwXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Rpc3Bvc2UnLCBidWJibGVzOiBmYWxzZSB9KTtcblxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxuICAgIGlmICh0aGlzLmNoaWxkcmVuXykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcbiAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZWxfKSB7XG4gICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgICAgaWYgKHRoaXMuZWxfLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5lbF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsXyk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZURhdGEodGhpcy5lbF8pO1xuICAgICAgdGhpcy5lbF8gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBhZnRlciBkaXNwb3Npbmcgb2YgdGhlIGVsZW1lbnRcbiAgICB0aGlzLnBsYXllcl8gPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBQbGF5ZXJ9IHRoYXQgdGhlIGBDb21wb25lbnRgIGhhcyBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKiAgICAgICAgIFRoZSBwbGF5ZXIgdGhhdCB0aGlzIGBDb21wb25lbnRgIGhhcyBhdHRhY2hlZCB0by5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnBsYXllciA9IGZ1bmN0aW9uIHBsYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWVwIG1lcmdlIG9mIG9wdGlvbnMgb2JqZWN0cyB3aXRoIG5ldyBvcHRpb25zLlxuICAgKiA+IE5vdGU6IFdoZW4gYm90aCBgb2JqYCBhbmQgYG9wdGlvbnNgIGNvbnRhaW4gcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIG9iamVjdHMuXG4gICAqICAgICAgICAgVGhlIHR3byBwcm9wZXJ0aWVzIGdldCBtZXJnZWQgdXNpbmcge0BsaW5rIG1vZHVsZTptZXJnZU9wdGlvbnN9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogICAgICAgIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBuZXcgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEEgbmV3IG9iamVjdCBvZiBgdGhpcy5vcHRpb25zX2AgYW5kIGBvYmpgIG1lcmdlZCB0b2dldGhlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gb3B0aW9ucyhvYmopIHtcbiAgICBsb2ckMS53YXJuKCd0aGlzLm9wdGlvbnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIG1vdmVkIHRvIHRoZSBjb25zdHJ1Y3RvciBpbiA2LjAnKTtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18sIG9iaik7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZWwgPSBmdW5jdGlvbiBlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZ05hbWVdXG4gICAqICAgICAgICBFbGVtZW50J3MgRE9NIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc11cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjcmVhdGVFbCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9jYWxpemUgYSBzdHJpbmcgZ2l2ZW4gdGhlIHN0cmluZyBpbiBlbmdsaXNoLlxuICAgKlxuICAgKiBJZiB0b2tlbnMgYXJlIHByb3ZpZGVkLCBpdCdsbCB0cnkgYW5kIHJ1biBhIHNpbXBsZSB0b2tlbiByZXBsYWNlbWVudCBvbiB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgKiBUaGUgdG9rZW5zIGl0IGxvb29rcyBmb3IgbG9vayBsaWtlIGB7MX1gIHdpdGggdGhlIGluZGV4IGJlaW5nIDEtaW5kZXhlZCBpbnRvIHRoZSB0b2tlbnMgYXJyYXkuXG4gICAqXG4gICAqIElmIGEgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGl0J2xsIHVzZSB0aGF0IG92ZXIgYHN0cmluZ2AsXG4gICAqIGlmIGEgdmFsdWUgaXNuJ3QgZm91bmQgaW4gcHJvdmlkZWQgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGhhdmUgYSBkZXNjcmlwdGl2ZSBrZXkgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqIGJ1dCBoYXZlIGEgc3VjY2luY3QgbG9jYWxpemVkIHN0cmluZyBhbmQgbm90IHJlcXVpcmUgYGVuLmpzb25gIHRvIGJlIGluY2x1ZGVkLlxuICAgKlxuICAgKiBDdXJyZW50bHksIGl0IGlzIHVzZWQgZm9yIHRoZSBwcm9ncmVzcyBiYXIgdGltaW5nLlxuICAgKiBgYGBqc1xuICAgKiB7XG4gICAqICAgXCJwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb249ezJ9XCI6IFwiezF9IG9mIHsyfVwiXG4gICAqIH1cbiAgICogYGBgXG4gICAqIEl0IGlzIHRoZW4gdXNlZCBsaWtlIHNvOlxuICAgKiBgYGBqc1xuICAgKiB0aGlzLmxvY2FsaXplKCdwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb257Mn0nLFxuICAgKiAgICAgICAgICAgICAgIFt0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCldLFxuICAgKiAgICAgICAgICAgICAgICd7MX0gb2YgezJ9Jyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGljaCBvdXRwdXRzIHNvbWV0aGluZyBsaWtlOiBgMDE6MjMgb2YgMjQ6NTZgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqICAgICAgICBUaGUgc3RyaW5nIHRvIGxvY2FsaXplIGFuZCB0aGUga2V5IHRvIGxvb2t1cCBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0b2tlbnNdXG4gICAqICAgICAgICBJZiB0aGUgY3VycmVudCBpdGVtIGhhcyB0b2tlbiByZXBsYWNlbWVudHMsIHByb3ZpZGUgdGhlIHRva2VucyBoZXJlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cbiAgICogICAgICAgIERlZmF1bHRzIHRvIGBzdHJpbmdgLiBDYW4gYmUgYSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBmb3IgdG9rZW4gcmVwbGFjZW1lbnRcbiAgICogICAgICAgIGlmIHRoZSBsb29rdXAga2V5IGlzIG5lZWRlZCB0byBiZSBzZXBhcmF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBsb2NhbGl6ZWQgc3RyaW5nIG9yIGlmIG5vIGxvY2FsaXphdGlvbiBleGlzdHMgdGhlIGVuZ2xpc2ggc3RyaW5nLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZShzdHJpbmcsIHRva2Vucykge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0cmluZztcblxuICAgIHZhciBjb2RlID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZSgpO1xuICAgIHZhciBsYW5ndWFnZXMgPSB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZXMoKTtcbiAgICB2YXIgbGFuZ3VhZ2UgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW2NvZGVdO1xuICAgIHZhciBwcmltYXJ5Q29kZSA9IGNvZGUgJiYgY29kZS5zcGxpdCgnLScpWzBdO1xuICAgIHZhciBwcmltYXJ5TGFuZyA9IGxhbmd1YWdlcyAmJiBsYW5ndWFnZXNbcHJpbWFyeUNvZGVdO1xuXG4gICAgdmFyIGxvY2FsaXplZFN0cmluZyA9IGRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChsYW5ndWFnZSAmJiBsYW5ndWFnZVtzdHJpbmddKSB7XG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsYW5ndWFnZVtzdHJpbmddO1xuICAgIH0gZWxzZSBpZiAocHJpbWFyeUxhbmcgJiYgcHJpbWFyeUxhbmdbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gcHJpbWFyeUxhbmdbc3RyaW5nXTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsb2NhbGl6ZWRTdHJpbmcucmVwbGFjZSgvXFx7KFxcZCspXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdG9rZW5zW2luZGV4IC0gMV07XG4gICAgICAgIHZhciByZXQgPSB2YWx1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldCA9IG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGl6ZWRTdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LiBUaGlzIGlzIHdoZXJlIGNoaWxkcmVuIGdldCBpbnNlcnRlZC5cbiAgICogVGhpcyB3aWxsIHVzdWFsbHkgYmUgdGhlIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50IHJldHVybmVkIGluIHtAbGluayBDb21wb25lbnQjZWx9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBjb250ZW50IGVsZW1lbnQgZm9yIHRoaXMgYENvbXBvbmVudGAuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jb250ZW50RWwgPSBmdW5jdGlvbiBjb250ZW50RWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudEVsXyB8fCB0aGlzLmVsXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoaXMgYENvbXBvbmVudGBzIElEXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgaWQgb2YgdGhpcyBgQ29tcG9uZW50YFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIG5hbWUuIFRoZSBuYW1lIGdldHMgdXNlZCB0byByZWZlcmVuY2UgdGhlIGBDb21wb25lbnRgXG4gICAqIGFuZCBpcyBzZXQgZHVyaW5nIHJlZ2lzdHJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoaXMgYENvbXBvbmVudGAuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIGFycmF5IG9mIGFsbCBjaGlsZCBjb21wb25lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIFRoZSBjaGlsZHJlblxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbiBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAgb3IgdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2hpbGRCeUlkID0gZnVuY3Rpb24gZ2V0Q2hpbGRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRJbmRleF9baWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgb3IgdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2hpbGROYW1lSW5kZXhfW25hbWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaGlsZCBgQ29tcG9uZW50YCBpbnNpZGUgdGhlIGN1cnJlbnQgYENvbXBvbmVudGAuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcbiAgICogICAgICAgIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD10aGlzLmNoaWxkcmVuXy5sZW5ndGhdXG4gICAqICAgICAgICBUaGUgaW5kZXggdG8gYXR0ZW1wdCB0byBhZGQgYSBjaGlsZCBpbnRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ2V0cyBhZGRlZCBhcyBhIGNoaWxkLiBXaGVuIHVzaW5nIGEgc3RyaW5nIHRoZVxuICAgKiAgICAgICAgIGBDb21wb25lbnRgIHdpbGwgZ2V0IGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuY2hpbGRyZW5fLmxlbmd0aDtcblxuICAgIHZhciBjb21wb25lbnQgPSB2b2lkIDA7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSB2b2lkIDA7XG5cbiAgICAvLyBJZiBjaGlsZCBpcyBhIHN0cmluZywgY3JlYXRlIGNvbXBvbmVudCB3aXRoIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRvVGl0bGVDYXNlKGNoaWxkKTtcblxuICAgICAgdmFyIGNvbXBvbmVudENsYXNzTmFtZSA9IG9wdGlvbnMuY29tcG9uZW50Q2xhc3MgfHwgY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gU2V0IG5hbWUgdGhyb3VnaCBvcHRpb25zXG4gICAgICBvcHRpb25zLm5hbWUgPSBjb21wb25lbnROYW1lO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0ICYgZWxlbWVudCBmb3IgdGhpcyBjb250cm9scyBzZXRcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gLnBsYXllcl8sIHRoaXMgaXMgYSBwbGF5ZXJcbiAgICAgIHZhciBDb21wb25lbnRDbGFzcyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY29tcG9uZW50Q2xhc3NOYW1lKTtcblxuICAgICAgaWYgKCFDb21wb25lbnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCAnICsgY29tcG9uZW50Q2xhc3NOYW1lICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBkYXRhIHN0b3JlZCBkaXJlY3RseSBvbiB0aGUgdmlkZW9qcyBvYmplY3QgbWF5IGJlXG4gICAgICAvLyBtaXNpZGVudGlmaWVkIGFzIGEgY29tcG9uZW50IHRvIHJldGFpblxuICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCA0LnguIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbXBvbmVudCBjbGFzcyBjYW4gYmUgaW5zdGFudGlhdGVkLlxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHRoaXMucGxheWVyXyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gY2hpbGQgaXMgYSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50ID0gY2hpbGQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGluZGV4LCAwLCBjb21wb25lbnQpO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIElmIGEgbmFtZSB3YXNuJ3QgdXNlZCB0byBjcmVhdGUgdGhlIGNvbXBvbmVudCwgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGVcbiAgICAvLyBuYW1lIGZ1bmN0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBjb21wb25lbnQubmFtZSAmJiB0b1RpdGxlQ2FzZShjb21wb25lbnQubmFtZSgpKTtcblxuICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIFVJIG9iamVjdCdzIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lciBkaXYgKGJveClcbiAgICAvLyBIYXZpbmcgYW4gZWxlbWVudCBpcyBub3QgcmVxdWlyZWRcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5lbCA9PT0gJ2Z1bmN0aW9uJyAmJiBjb21wb25lbnQuZWwoKSkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmNvbnRlbnRFbCgpLmNoaWxkcmVuO1xuICAgICAgdmFyIHJlZk5vZGUgPSBjaGlsZE5vZGVzW2luZGV4XSB8fCBudWxsO1xuXG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLmluc2VydEJlZm9yZShjb21wb25lbnQuZWwoKSwgcmVmTm9kZSk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHNvIGl0IGNhbiBzdG9yZWQgb24gcGFyZW50IG9iamVjdCBpZiBkZXNpcmVkLlxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGNoaWxkIGBDb21wb25lbnRgIGZyb20gdGhpcyBgQ29tcG9uZW50YHMgbGlzdCBvZiBjaGlsZHJlbi4gQWxzbyByZW1vdmVzXG4gICAqIHRoZSBjaGlsZCBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byByZW1vdmUuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNvbXBvbmVudCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZEZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICAgIGNoaWxkRm91bmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hpbGRGb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnQubmFtZSgpXSA9IG51bGw7XG5cbiAgICB2YXIgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XG5cbiAgICBpZiAoY29tcEVsICYmIGNvbXBFbC5wYXJlbnROb2RlID09PSB0aGlzLmNvbnRlbnRFbCgpKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbmQgaW5pdGlhbGl6ZSBkZWZhdWx0IGNoaWxkIGBDb21wb25lbnRgcyBiYXNlZCB1cG9uIG9wdGlvbnMuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5pbml0Q2hpbGRyZW4gPSBmdW5jdGlvbiBpbml0Q2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMub3B0aW9uc18uY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIC8vIGB0aGlzYCBpcyBgcGFyZW50YFxuICAgICAgdmFyIHBhcmVudE9wdGlvbnMgPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgdmFyIG9wdHMgPSBjaGlsZC5vcHRzO1xuXG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgZm9yIGNoaWxkcmVuIHRvIGJlIHNldCBhdCB0aGUgcGFyZW50IG9wdGlvbnNcbiAgICAgICAgLy8gZS5nLiB2aWRlb2pzKGlkLCB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHZpZGVvanMoaWQsIHsgY2hpbGRyZW46IHsgY29udHJvbEJhcjogZmFsc2UgfSk7XG4gICAgICAgIGlmIChwYXJlbnRPcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRzID0gcGFyZW50T3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGZvciBkaXNhYmxpbmcgZGVmYXVsdCBjb21wb25lbnRzXG4gICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXG4gICAgICAgIGlmIChvcHRzID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IG9wdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGEgc2ltcGxlIGJvb2xlYW4gaWYgbm8gY29uZmlndXJhdGlvblxuICAgICAgICAvLyBpcyBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChvcHRzID09PSB0cnVlKSB7XG4gICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zXG4gICAgICAgIC8vIHRvIGVhY2ggY29tcG9uZW50IGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvXG4gICAgICAgIC8vIHJlYWNoIGJhY2sgaW50byB0aGUgcGxheWVyIGZvciBvcHRpb25zIGxhdGVyLlxuICAgICAgICBvcHRzLnBsYXllck9wdGlvbnMgPSBfdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIC8vIEFkZCBhIGRpcmVjdCByZWZlcmVuY2UgdG8gdGhlIGNoaWxkIGJ5IG5hbWUgb24gdGhlIHBhcmVudCBpbnN0YW5jZS5cbiAgICAgICAgLy8gSWYgdHdvIG9mIHRoZSBzYW1lIGNvbXBvbmVudCBhcmUgdXNlZCwgZGlmZmVyZW50IG5hbWVzIHNob3VsZCBiZSBzdXBwbGllZFxuICAgICAgICAvLyBmb3IgZWFjaFxuICAgICAgICB2YXIgbmV3Q2hpbGQgPSBfdGhpcy5hZGRDaGlsZChuYW1lLCBvcHRzKTtcblxuICAgICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgICBfdGhpc1tuYW1lXSA9IG5ld0NoaWxkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBBbGxvdyBmb3IgYW4gYXJyYXkgb2YgY2hpbGRyZW4gZGV0YWlscyB0byBwYXNzZWQgaW4gdGhlIG9wdGlvbnNcbiAgICAgIHZhciB3b3JraW5nQ2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya2luZ0NoaWxkcmVuID0gT2JqZWN0LmtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICB3b3JraW5nQ2hpbGRyZW5cbiAgICAgIC8vIGNoaWxkcmVuIHRoYXQgYXJlIGluIHRoaXMub3B0aW9uc18gYnV0IGFsc28gaW4gd29ya2luZ0NoaWxkcmVuICB3b3VsZFxuICAgICAgLy8gZ2l2ZSB1cyBleHRyYSBjaGlsZHJlbiB3ZSBkbyBub3Qgd2FudC4gU28sIHdlIHdhbnQgdG8gZmlsdGVyIHRoZW0gb3V0LlxuICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnNfKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiAhd29ya2luZ0NoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKHdjaGlsZCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2NoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID09PSB3Y2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgfSkpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBvcHRzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkO1xuICAgICAgICAgIG9wdHMgPSBjaGlsZHJlbltuYW1lXSB8fCBfdGhpcy5vcHRpb25zX1tuYW1lXSB8fCB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgICBvcHRzID0gY2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBvcHRzOiBvcHRzIH07XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgY2hpbGQubmFtZSBpc24ndCBpbiB0aGUgdGVjaE9yZGVyIHNpbmNlXG4gICAgICAgIC8vIHRlY2hzIGFyZSByZWdpc3RlcmQgYXMgQ29tcG9uZW50cyBidXQgY2FuJ3QgYXJlbid0IGNvbXBhdGlibGVcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNzcyXG4gICAgICAgIHZhciBjID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjaGlsZC5vcHRzLmNvbXBvbmVudENsYXNzIHx8IHRvVGl0bGVDYXNlKGNoaWxkLm5hbWUpKTtcblxuICAgICAgICByZXR1cm4gYyAmJiAhVGVjaC5pc1RlY2goYyk7XG4gICAgICB9KS5mb3JFYWNoKGhhbmRsZUFkZCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGNsYXNzIG5hbWUuIFNob3VsZCBiZSBvdmVycmlkZW4gYnkgc3ViLWNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGNsYXNzIG5hbWUgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIC8vIENoaWxkIGNsYXNzZXMgY2FuIGluY2x1ZGUgYSBmdW5jdGlvbiB0aGF0IGRvZXM6XG4gICAgLy8gcmV0dXJuICdDTEFTUyBOQU1FJyArIHRoaXMuX3N1cGVyKCk7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kIGEgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJlYWR5IHN0YXRlLlxuICAgKiBEaWZmZXJlbnQgZnJvbSBldmVudCBsaXN0ZW5lcnMgaW4gdGhhdCBpZiB0aGUgcmVhZHkgZXZlbnQgaGFzIGFscmVhZHkgaGFwcGVuZWRcbiAgICogaXQgd2lsbCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFJldHVybnMgaXRzZWxmOyBtZXRob2QgY2FuIGJlIGNoYWluZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgdmFyIHN5bmMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKCFmbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlYWR5Xykge1xuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IHRoaXMucmVhZHlRdWV1ZV8gfHwgW107XG4gICAgICB0aGlzLnJlYWR5UXVldWVfLnB1c2goZm4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBmbi5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvbiBhc3luY2hyb25vdXNseSBieSBkZWZhdWx0IGZvciBjb25zaXN0ZW5jeVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZuLCAxKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYWxsIHRoZSByZWFkeSBsaXN0ZW5lcnMgZm9yIHRoaXMgYENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjcmVhZHlcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJSZWFkeSA9IGZ1bmN0aW9uIHRyaWdnZXJSZWFkeSgpIHtcbiAgICB0aGlzLmlzUmVhZHlfID0gdHJ1ZTtcblxuICAgIC8vIEVuc3VyZSByZWFkeSBpcyB0cmlnZ2VyZCBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVhZHlRdWV1ZSA9IHRoaXMucmVhZHlRdWV1ZV87XG5cbiAgICAgIC8vIFJlc2V0IFJlYWR5IFF1ZXVlXG4gICAgICB0aGlzLnJlYWR5UXVldWVfID0gW107XG5cbiAgICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICByZWFkeVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGZvciB1c2luZyBldmVudCBsaXN0ZW5lcnMgYWxzb1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBDb21wb25lbnQjcmVhZHlcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuICAgIH0sIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gICAqICAgICAgICAgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2FzIGZvdW5kLCBvciBudWxsXG4gICAqXG4gICAqIEBzZWUgW0luZm9ybWF0aW9uIG9uIENTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCA9IGZ1bmN0aW9uICQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJChzZWxlY3RvciwgY29udGV4dCB8fCB0aGlzLmNvbnRlbnRFbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgYWxsIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcbiAgICogYGNvbnRlbnRFbCgpYCBvciBhbm90aGVyIGN1c3RvbSBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXG4gICAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvciBzdHJpbmcgaW5cbiAgICogICAgICAgIHdoaWNoIGNhc2UgdGhlIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnQgd2lsbCBnZXQgdXNlZCBhcyBjb250ZXh0LiBJZlxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcbiAgICogICAgICAgIG5vdGhpbmcgaXQgZmFsbHMgYmFjayB0byBgZG9jdW1lbnRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAgICogICAgICAgICBhIGxpc3Qgb2YgZG9tIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQkID0gZnVuY3Rpb24gJCQkJDEoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJCQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBgQ29tcG9uZW50YCBoYXMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIGBDb21wb25lbnRgIGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzYFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyQkMShjbGFzc1RvQ2hlY2spIHtcbiAgICByZXR1cm4gaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGFkZFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyQkMShjbGFzc1RvQWRkKSB7XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9BZGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyQkMShjbGFzc1RvUmVtb3ZlKSB7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgb3IgcmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyBhZGRlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiBmYWxzZS5cbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyByZW1vdmVkIHdoZW4ge0BsaW5rIENvbXBvbmVudCNoYXNDbGFzc30gd291bGQgcmV0dXJuIHRydWUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICAgKiAgICAgICAgIFRoZSBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlIGJhc2VkIG9uIChAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9XG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW58RG9tfnByZWRpY2F0ZX0gW3ByZWRpY2F0ZV1cbiAgICogICAgICAgICBBbiB7QGxpbmsgRG9tfnByZWRpY2F0ZX0gZnVuY3Rpb24gb3IgYSBib29sZWFuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzJCQxKGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBoaWRkZW4gYnkgcmVtb3ZpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuJyBjbGFzcyBuYW1lIGZyb20gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IGlmIGl0IGlzIGN1cnJlbnRseSBzaG93aW5nIGJ5IGFkZGluZyB0aGVcbiAgICogJ3Zqcy1oaWRkZW5gIGNsYXNzIG5hbWUgdG8gaXQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBpbiBpdHMgdmlzaWJsZSBzdGF0ZSBieSBhZGRpbmcgdGhlICd2anMtbG9jay1zaG93aW5nJ1xuICAgKiBjbGFzcyBuYW1lIHRvIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2tTaG93aW5nID0gZnVuY3Rpb24gbG9ja1Nob3dpbmcoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvY2sgYSBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIGl0cyB2aXNpYmxlIHN0YXRlIGJ5IHJlbW92aW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSBmcm9tIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnVubG9ja1Nob3dpbmcgPSBmdW5jdGlvbiB1bmxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgd2FzIGFza2VkIGZvci5cbiAgICogICAgICAgICAtIENhbiBiZSBhbiBlbXB0eSBzdHJpbmcgb24gc29tZSBicm93c2VycyBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0XG4gICAqICAgICAgICAgICBvciBoYXMgbm8gdmFsdWVcbiAgICogICAgICAgICAtIE1vc3QgYnJvd3NlcnMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgYXR0aWJ1dGUgZG9lcyBub3QgZXhpc3Qgb3IgaGFzXG4gICAqICAgICAgICAgICBubyB2YWx1ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YCdzIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2V0QXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlLlxuICAgKlxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZW1vdmVBdHRyaWJ1dGV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUkJDEoYXR0cmlidXRlKSB7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSB3aWR0aCB0aGF0IHlvdSB3YW50IHRvIHNldCBwb3N0Zml4ZWQgd2l0aCAnJScsICdweCcgb3Igbm90aGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIHdoZW4gZ2V0dGluZywgemVybyBpZiB0aGVyZSBpcyBubyB3aWR0aC4gQ2FuIGJlIGEgc3RyaW5nXG4gICAqICAgICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCd3aWR0aCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cbiAgICogICAgICAgIFRoZSBoZWlnaHQgdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgIHBvc3RwaXhlZCB3aXRoICclJyBvciAncHgnLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgbnVtLCBza2lwTGlzdGVuZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGJvdGggdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gd2lkdGhcbiAgICogICAgICAgICBXaWR0aCB0byBzZXQgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcbiAgICogICAgICAgICBIZWlnaHQgdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBTa2lwIGNvbXBvbmVudHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxuICAgIHRoaXMud2lkdGgod2lkdGgsIHRydWUpO1xuICAgIHRoaXMuaGVpZ2h0KGhlaWdodCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50LiBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZVxuICAgKiBmb3IgdGhlIHtAbGluayBDb21wb25lbnQjd2lkdGh9IGFuZCB7QGxpbmsgQ29tcG9uZW50I2hlaWdodH0uXG4gICAqXG4gICAqIFRoaW5ncyB0byBrbm93OlxuICAgKiAtIElmIHRoZSB3aWR0aCBvciBoZWlnaHQgaW4gYW4gbnVtYmVyIHRoaXMgd2lsbCByZXR1cm4gdGhlIG51bWJlciBwb3N0Zml4ZWQgd2l0aCAncHgnLlxuICAgKiAtIElmIHRoZSB3aWR0aC9oZWlnaHQgaXMgYSBwZXJjZW50IHRoaXMgd2lsbCByZXR1cm4gdGhlIHBlcmNlbnQgcG9zdGZpeGVkIHdpdGggJyUnXG4gICAqIC0gSGlkZGVuIGVsZW1lbnRzIGhhdmUgYSB3aWR0aCBvZiAwIHdpdGggYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC4gVGhpcyBmdW5jdGlvblxuICAgKiAgIGRlZmF1bHRzIHRvIHRoZSBgQ29tcG9uZW50YHMgYHN0eWxlLndpZHRoYCBhbmQgZmFsbHMgYmFjayB0byBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKiAgIFNlZSBbdGhpc117QGxpbmsgaHR0cDovL3d3dy5mb2xpb3Rlay5jb20vZGV2YmxvZy9nZXR0aW5nLXRoZS13aWR0aC1vZi1hLWhpZGRlbi1lbGVtZW50LXdpdGgtanF1ZXJ5LXVzaW5nLXdpZHRoL31cbiAgICogICBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgKiAtIElmIHlvdSB3YW50IHRoZSBjb21wdXRlZCBzdHlsZSBvZiB0aGUgY29tcG9uZW50LCB1c2Uge0BsaW5rIENvbXBvbmVudCNjdXJyZW50V2lkdGh9XG4gICAqICAgYW5kIHtAbGluayB7Q29tcG9uZW50I2N1cnJlbnRIZWlnaHR9XG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICA4ICAgICAgICAnd2lkdGgnIG9yICdoZWlnaHQnXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICA4ICAgICAgICAgTmV3IGRpbWVuc2lvblxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgICBTa2lwIGNvbXBvbmVudHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIHdoZW4gZ2V0dGluZyBvciAwIGlmIHVuc2V0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24od2lkdGhPckhlaWdodCwgbnVtLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgaWYgKG51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTZXQgdG8gemVybyBpZiBudWxsIG9yIGxpdGVyYWxseSBOYU4gKE5hTiAhPT0gTmFOKVxuICAgICAgaWYgKG51bSA9PT0gbnVsbCB8fCBudW0gIT09IG51bSkge1xuICAgICAgICBudW0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2luZyBjc3Mgd2lkdGgvaGVpZ2h0ICglIG9yIHB4KSBhbmQgYWRqdXN0XG4gICAgICBpZiAoKCcnICsgbnVtKS5pbmRleE9mKCclJykgIT09IC0xIHx8ICgnJyArIG51bSkuaW5kZXhPZigncHgnKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW07XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bSArICdweCc7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIXNraXBMaXN0ZW5lcnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlc2l6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBDb21wb25lbnQjY29tcG9uZW50cmVzaXplXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignY29tcG9uZW50cmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3Qgc2V0dGluZyBhIHZhbHVlLCBzbyBnZXR0aW5nIGl0XG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gR2V0IGRpbWVuc2lvbiB2YWx1ZSBmcm9tIHN0eWxlXG4gICAgdmFyIHZhbCA9IHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIHZhciBweEluZGV4ID0gdmFsLmluZGV4T2YoJ3B4Jyk7XG5cbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgdmFsdWUgd2l0aCBubyAncHgnXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsLnNsaWNlKDAsIHB4SW5kZXgpLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gTm8gcHggc28gdXNpbmcgJSBvciBubyBzdHlsZSB3YXMgc2V0LCBzbyBmYWxsaW5nIGJhY2sgdG8gb2Zmc2V0V2lkdGgvaGVpZ2h0XG4gICAgLy8gSWYgY29tcG9uZW50IGhhcyBkaXNwbGF5Om5vbmUsIG9mZnNldCB3aWxsIHJldHVybiAwXG4gICAgLy8gVE9ETzogaGFuZGxlIGRpc3BsYXk6bm9uZSBhbmQgbm8gZGltZW5zaW9uIHN0eWxlIHVzaW5nIHB4XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZWxfWydvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCldLCAxMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2lkdGggb3IgdGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudHMgY29tcHV0ZWQgc3R5bGUuIFVzZXNcbiAgICogYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoT3JIZWlnaHRcbiAgICogICAgICAgIEEgc3RyaW5nIGNvbnRhaW5pbmcgJ3dpZHRoJyBvciAnaGVpZ2h0Jy4gV2hpY2hldmVyIG9uZSB5b3Ugd2FudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIHRoYXQgZ2V0cyBhc2tlZCBmb3Igb3IgMCBpZiBub3RoaW5nIHdhcyBzZXRcbiAgICogICAgICAgICBmb3IgdGhhdCBkaW1lbnNpb24uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9uID0gZnVuY3Rpb24gY3VycmVudERpbWVuc2lvbih3aWR0aE9ySGVpZ2h0KSB7XG4gICAgdmFyIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IDA7XG5cbiAgICBpZiAod2lkdGhPckhlaWdodCAhPT0gJ3dpZHRoJyAmJiB3aWR0aE9ySGVpZ2h0ICE9PSAnaGVpZ2h0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50RGltZW5zaW9uIG9ubHkgYWNjZXB0cyB3aWR0aCBvciBoZWlnaHQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxfKTtcblxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHdpZHRoT3JIZWlnaHQpIHx8IGNvbXB1dGVkU3R5bGVbd2lkdGhPckhlaWdodF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlICdweCcgZnJvbSB2YXJpYWJsZSBhbmQgcGFyc2UgYXMgaW50ZWdlclxuICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0KTtcblxuICAgIC8vIGlmIHRoZSBjb21wdXRlZCB2YWx1ZSBpcyBzdGlsbCAwLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgaXMgbHlpbmdcbiAgICAvLyBhbmQgd2Ugd2FudCB0byBjaGVjayB0aGUgb2Zmc2V0IHZhbHVlcy5cbiAgICAvLyBUaGlzIGNvZGUgYWxzbyBydW5zIG9uIElFOCBhbmQgd2hlcmV2ZXIgZ2V0Q29tcHV0ZWRTdHlsZSBkb2Vzbid0IGV4aXN0LlxuICAgIGlmIChjb21wdXRlZFdpZHRoT3JIZWlnaHQgPT09IDApIHtcbiAgICAgIHZhciBydWxlID0gJ29mZnNldCcgKyB0b1RpdGxlQ2FzZSh3aWR0aE9ySGVpZ2h0KTtcblxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gdGhpcy5lbF9bcnVsZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGVkV2lkdGhPckhlaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS4gVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDb21wb25lbnR+RGltZW5zaW9uT2JqZWN0XG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICAgKiAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgdGhhdCBjb250YWlucyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBvZiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR+RGltZW5zaW9uT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb21wb25lbnRzIGVsZW1lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnREaW1lbnNpb25zID0gZnVuY3Rpb24gY3VycmVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHRoaXMuY3VycmVudERpbWVuc2lvbignaGVpZ2h0JylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSB3aWR0aFxuICAgKiAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50V2lkdGggPSBmdW5jdGlvbiBjdXJyZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERpbWVuc2lvbignd2lkdGgnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS4gVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGhlaWdodFxuICAgKiAgICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudEhlaWdodCA9IGZ1bmN0aW9uIGN1cnJlbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERpbWVuc2lvbignaGVpZ2h0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhpcyBjb21wb25lbnRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdGhpcy5lbF8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gYmx1cigpIHtcbiAgICB0aGlzLmVsXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtaXQgYSAndGFwJyBldmVudHMgd2hlbiB0b3VjaCBldmVudCBzdXBwb3J0IGdldHMgZGV0ZWN0ZWQuIFRoaXMgZ2V0cyB1c2VkIHRvXG4gICAqIHN1cHBvcnQgdG9nZ2xpbmcgdGhlIGNvbnRyb2xzIHRocm91Z2ggYSB0YXAgb24gdGhlIHZpZGVvLiBUaGV5IGdldCBlbmFibGVkXG4gICAqIGJlY2F1c2UgZXZlcnkgc3ViLWNvbXBvbmVudCB3b3VsZCBoYXZlIGV4dHJhIG92ZXJoZWFkIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIENvbXBvbmVudCN0YXBcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hsZWF2ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoZW5kXG4gICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZW1pdFRhcEV2ZW50cyA9IGZ1bmN0aW9uIGVtaXRUYXBFdmVudHMoKSB7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgdmFyIHRvdWNoU3RhcnQgPSAwO1xuICAgIHZhciBmaXJzdFRvdWNoID0gbnVsbDtcblxuICAgIC8vIE1heGltdW0gbW92ZW1lbnQgYWxsb3dlZCBkdXJpbmcgYSB0b3VjaCBldmVudCB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgdGFwXG4gICAgLy8gT3RoZXIgcG9wdWxhciBsaWJzIHVzZSBhbnl3aGVyZSBmcm9tIDIgKGhhbW1lci5qcykgdG8gMTUsXG4gICAgLy8gc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cbiAgICB2YXIgdGFwTW92ZW1lbnRUaHJlc2hvbGQgPSAxMDtcblxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXG4gICAgdmFyIHRvdWNoVGltZVRocmVzaG9sZCA9IDIwMDtcblxuICAgIHZhciBjb3VsZEJlVGFwID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENvcHkgcGFnZVgvcGFnZVkgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgIGZpcnN0VG91Y2ggPSB7XG4gICAgICAgICAgcGFnZVg6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVjb3JkIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVjdCBhIHRhcCB2cy4gXCJ0b3VjaCBhbmQgaG9sZFwiXG4gICAgICAgIHRvdWNoU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xuICAgICAgICBjb3VsZEJlVGFwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcbiAgICAgICAgLy8gU29tZSBkZXZpY2VzIHdpbGwgdGhyb3cgdG91Y2htb3ZlcyBmb3IgYWxsIGJ1dCB0aGUgc2xpZ2h0ZXN0IG9mIHRhcHMuXG4gICAgICAgIC8vIFNvLCBpZiB3ZSBtb3ZlZCBvbmx5IGEgc21hbGwgZGlzdGFuY2UsIHRoaXMgY291bGQgc3RpbGwgYmUgYSB0YXBcbiAgICAgICAgdmFyIHhkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGZpcnN0VG91Y2gucGFnZVg7XG4gICAgICAgIHZhciB5ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBmaXJzdFRvdWNoLnBhZ2VZO1xuICAgICAgICB2YXIgdG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydCh4ZGlmZiAqIHhkaWZmICsgeWRpZmYgKiB5ZGlmZik7XG5cbiAgICAgICAgaWYgKHRvdWNoRGlzdGFuY2UgPiB0YXBNb3ZlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgIGNvdWxkQmVUYXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG5vVGFwID0gZnVuY3Rpb24gbm9UYXAoKSB7XG4gICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IExpc3RlbiB0byB0aGUgb3JpZ2luYWwgdGFyZ2V0LiBodHRwOi8veW91dHUuYmUvRHVqZnBYT0tVcDg/dD0xM204c1xuICAgIHRoaXMub24oJ3RvdWNobGVhdmUnLCBub1RhcCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCBub1RhcCk7XG5cbiAgICAvLyBXaGVuIHRoZSB0b3VjaCBlbmRzLCBtZWFzdXJlIGhvdyBsb25nIGl0IHRvb2sgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZmlyc3RUb3VjaCA9IG51bGw7XG4gICAgICAvLyBQcm9jZWVkIG9ubHkgaWYgdGhlIHRvdWNobW92ZS9sZWF2ZS9jYW5jZWwgZXZlbnQgZGlkbid0IGhhcHBlblxuICAgICAgaWYgKGNvdWxkQmVUYXAgPT09IHRydWUpIHtcbiAgICAgICAgLy8gTWVhc3VyZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXG4gICAgICAgIHZhciB0b3VjaFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRvdWNoU3RhcnQ7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgICAgICBpZiAodG91Y2hUaW1lIDwgdG91Y2hUaW1lVGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgbGV0IGJyb3dzZXIgdHVybiB0aGlzIGludG8gYSBjbGlja1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyB0YXBwZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3RhcFxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RhcCcpO1xuICAgICAgICAgIC8vIEl0IG1heSBiZSBnb29kIHRvIGNvcHkgdGhlIHRvdWNoZW5kIGV2ZW50IG9iamVjdCBhbmQgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIHR5cGUgdG8gdGFwLCBpZiB0aGUgb3RoZXIgZXZlbnQgcHJvcGVydGllcyBhcmVuJ3QgZXhhY3QgYWZ0ZXJcbiAgICAgICAgICAvLyBFdmVudHMuZml4RXZlbnQgcnVucyAoZS5nLiBldmVudC50YXJnZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiByZXBvcnRzIHVzZXIgYWN0aXZpdHkgd2hlbmV2ZXIgdG91Y2ggZXZlbnRzIGhhcHBlbi4gVGhpcyBjYW4gZ2V0XG4gICAqIHR1cm5lZCBvZmYgYnkgYW55IHN1Yi1jb21wb25lbnRzIHRoYXQgd2FudHMgdG91Y2ggZXZlbnRzIHRvIGFjdCBhbm90aGVyIHdheS5cbiAgICpcbiAgICogUmVwb3J0IHVzZXIgdG91Y2ggYWN0aXZpdHkgd2hlbiB0b3VjaCBldmVudHMgb2NjdXIuIFVzZXIgYWN0aXZpdHkgZ2V0cyB1c2VkIHRvXG4gICAqIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0IGlzIHNpbXBsZSB3aGVuIGl0IGNvbWVzIHRvIG1vdXNlXG4gICAqIGV2ZW50cywgYmVjYXVzZSBhbnkgbW91c2UgZXZlbnQgc2hvdWxkIHNob3cgdGhlIGNvbnRyb2xzLiBTbyB3ZSBjYXB0dXJlIG1vdXNlXG4gICAqIGV2ZW50cyB0aGF0IGJ1YmJsZSB1cCB0byB0aGUgcGxheWVyIGFuZCByZXBvcnQgYWN0aXZpdHkgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqIFdpdGggdG91Y2ggZXZlbnRzIGl0IGlzbid0IGFzIGVhc3kgYXMgYHRvdWNoc3RhcnRgIGFuZCBgdG91Y2hlbmRgIHRvZ2dsZSBwbGF5ZXJcbiAgICogY29udHJvbHMuIFNvIHRvdWNoIGV2ZW50cyBjYW4ndCBoZWxwIHVzIGF0IHRoZSBwbGF5ZXIgbGV2ZWwgZWl0aGVyLlxuICAgKlxuICAgKiBVc2VyIGFjdGl2aXR5IGdldHMgY2hlY2tlZCBhc3luY2hyb25vdXNseS4gU28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnRcbiAgICogb24gdGhlIHZpZGVvIHR1cm5zIHRoZSBjb250cm9scyBvZmYuIFRoZW4gdGhlIGB0b3VjaGVuZGAgZXZlbnQgYnViYmxlcyB1cCB0b1xuICAgKiB0aGUgcGxheWVyLiBXaGljaCwgaWYgaXQgcmVwb3J0ZWQgdXNlciBhY3Rpdml0eSwgd291bGQgdHVybiB0aGUgY29udHJvbHMgcmlnaHRcbiAgICogYmFjayBvbi4gV2UgYWxzbyBkb24ndCB3YW50IHRvIGNvbXBsZXRlbHkgYmxvY2sgdG91Y2ggZXZlbnRzIGZyb20gYnViYmxpbmcgdXAuXG4gICAqIEZ1cnRoZXJtb3JlIGEgYHRvdWNobW92ZWAgZXZlbnQgYW5kIGFueXRoaW5nIG90aGVyIHRoYW4gYSB0YXAsIHNob3VsZCBub3QgdHVyblxuICAgKiBjb250cm9scyBiYWNrIG9uLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hzdGFydFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2htb3ZlXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZVRvdWNoQWN0aXZpdHkgPSBmdW5jdGlvbiBlbmFibGVUb3VjaEFjdGl2aXR5KCkge1xuICAgIC8vIERvbid0IGNvbnRpbnVlIGlmIHRoZSByb290IHBsYXllciBkb2Vzbid0IHN1cHBvcnQgcmVwb3J0aW5nIHVzZXIgYWN0aXZpdHlcbiAgICBpZiAoIXRoaXMucGxheWVyKCkgfHwgIXRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gbGlzdGVuZXIgZm9yIHJlcG9ydGluZyB0aGF0IHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgIHZhciByZXBvcnQgPSBiaW5kKHRoaXMucGxheWVyKCksIHRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHZhciB0b3VjaEhvbGRpbmcgPSB2b2lkIDA7XG5cbiAgICB0aGlzLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgICAvLyByZXBvcnQgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYXMgYWN0aXZpdHlDaGVja1xuICAgICAgdG91Y2hIb2xkaW5nID0gdGhpcy5zZXRJbnRlcnZhbChyZXBvcnQsIDI1MCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdG91Y2hFbmQgPSBmdW5jdGlvbiB0b3VjaEVuZChldmVudCkge1xuICAgICAgcmVwb3J0KCk7XG4gICAgICAvLyBzdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgdG91Y2ggaXMgaG9sZGluZ1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XG4gICAgfTtcblxuICAgIHRoaXMub24oJ3RvdWNobW92ZScsIHJlcG9ydCk7XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XG4gICAgdGhpcy5vbigndG91Y2hjYW5jZWwnLCB0b3VjaEVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBoYXMgbm8gcGFyYW1ldGVycyBhbmQgaXMgYm91bmQgaW50byBgQ29tcG9uZW50YHMgY29udGV4dC5cbiAgICpcbiAgICogQGNhbGxiYWNrIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBydW5zIGFmdGVyIGFuIGB4YCBtaWxsaXNlY29uZCB0aW1lb3V0LiBUaGlzIGZ1bmN0aW9uIGlzIGFcbiAgICogd3JhcHBlciBhcm91bmQgYHdpbmRvdy5zZXRUaW1lb3V0YC4gVGhlcmUgYXJlIGEgZmV3IHJlYXNvbnMgdG8gdXNlIHRoaXMgb25lXG4gICAqIGluc3RlYWQgdGhvdWdoOlxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gd2hlblxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxuICAgKiAyLiBUaGUgZnVuY3Rpb24gY2FsbGJhY2sgd2lsbCBnZXRzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqID4gTm90ZTogWW91IGNhbiB1c2UgYHdpbmRvdy5jbGVhclRpbWVvdXRgIG9uIHRoZSBpZCByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAqICAgICAgICAgd2lsbCBjYXVzZSBpdHMgZGlzcG9zZSBsaXN0ZW5lciBub3QgdG8gZ2V0IGNsZWFuZWQgdXAhIFBsZWFzZSB1c2VcbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gb3Ige0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfS5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gYWZ0ZXIgYHRpbWVvdXRgLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICAgKiAgICAgICAgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhIHRpbWVvdXQgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhbiBhbHNvXG4gICAqICAgICAgICAgZ2V0IHVzZWQgaW4ge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHRvIGNsZWFyIHRoZSB0aW1lb3V0IHRoYXRcbiAgICogICAgICAgICB3YXMgc2V0LlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldFRpbWVvdXR9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gc2V0VGltZW91dChmbiwgdGltZW91dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcblxuICAgIHZhciB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChmbiwgdGltZW91dCk7XG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgIHJldHVybiBfdGhpczIuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhIHRpbWVvdXQgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0VGltZW91dGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fS4gSWYgeW91IHNldCBhIHRpbWVvdXQgdmlhIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFyVGltb3V0YC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIHRpbWVvdXQgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2ZcbiAgICogICAgICAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0gb3IgYHdpbmRvdy5zZXRUaW1lb3V0YC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIHRpbWVvdXQgaWQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9jbGVhclRpbWVvdXR9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhclRpbWVvdXQodGltZW91dElkKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXRpbWVvdXQtJyArIHRpbWVvdXRJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiB0aW1lb3V0SWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgcnVuIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuIFRoaXMgZnVuY3Rpb24gaXMgYSB3cmFwcGVyXG4gICAqIGFyb3VuZCBgd2luZG93LnNldEludGVydmFsYC4gVGhlcmUgYXJlIGEgZmV3IHJlYXNvbnMgdG8gdXNlIHRoaXMgb25lIGluc3RlYWQgdGhvdWdoLlxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgYmUgYSB7QGxpbmsgQ29tcG9uZW50fkdlbmVyaWNDYWxsYmFja31cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIHJ1biBldmVyeSBgeGAgc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsXG4gICAqICAgICAgICBFeGVjdXRlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gZXZlcnkgYHhgIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYW4gaWQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgaW50ZXJ2YWwuIEl0IGNhbiBhbHNvIGJlIGJlIHVzZWQgaW5cbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHRvIGNsZWFyIHRoZSBpbnRlcnZhbC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRJbnRlcnZhbH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgdmFyIGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRJbnRlcnZhbGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0uIElmIHlvdSBzZXQgYW4gaW50ZXZhbCB2aWEge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFySW50ZXJ2YWxgLiBJZiB5b3UgZG9uJ3QgeW91ciBkaXNwb3NlXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGludGVydmFsIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfSBvciBgd2luZG93LnNldEludGVydmFsYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGludGVydmFsIGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJJbnRlcnZhbH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBRdWV1ZXMgdXAgYSBjYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLCBidXRcbiAgICogd2l0aCBhIGZldyBleHRyYSBib251c2VzOlxuICAgKlxuICAgKiAtIFN1cHBvcnRzIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgckFGIGJ5IGZhbGxpbmcgYmFjayB0b1xuICAgKiAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uXG4gICAqXG4gICAqIC0gVGhlIGNhbGxiYWNrIGlzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IChpLmUuXG4gICAqICAgYm91bmQgdG8gdGhlIGNvbXBvbmVudCkuXG4gICAqXG4gICAqIC0gQXV0b21hdGljIGNhbmNlbGxhdGlvbiBvZiB0aGUgckFGIGNhbGxiYWNrIGlzIGhhbmRsZWQgaWYgdGhlIGNvbXBvbmVudFxuICAgKiAgIGlzIGRpc3Bvc2VkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhpcyBjb21wb25lbnQgYW5kIGV4ZWN1dGVkIGp1c3RcbiAgICogICAgICAgICBiZWZvcmUgdGhlIGJyb3dzZXIncyBuZXh0IHJlcGFpbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIHJBRiBJRCB0aGF0IGdldHMgdXNlZCB0byBpZGVudGlmeSB0aGUgdGltZW91dC4gSXQgY2FuXG4gICAqICAgICAgICAgYWxzbyBiZSB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2FuY2VsQW5pbWF0aW9uRnJhbWV9IHRvIGNhbmNlbFxuICAgKiAgICAgICAgIHRoZSBhbmltYXRpb24gZnJhbWUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICAgIHZhciBpZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICB9O1xuXG4gICAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtcmFmLScgKyBpZDtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nIGEgdGltZXIuXG4gICAgcmV0dXJuIHRoaXMuc2V0VGltZW91dChmbiwgMTAwMCAvIDYwKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHF1ZXVlZCBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9XG4gICAqIChyQUYpLlxuICAgKlxuICAgKiBJZiB5b3UgcXVldWUgYW4gckFGIGNhbGxiYWNrIHZpYSB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0sXG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZWAuIElmIHlvdSBkb24ndCxcbiAgICogeW91ciBkaXNwb3NlIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiAgICAgICAgVGhlIHJBRiBJRCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSByQUYgSUQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG5cbiAgICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XG5cbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxuICAgIHJldHVybiB0aGlzLmNsZWFyVGltZW91dChpZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgYENvbXBvbmVudGAgd2l0aCBgdmlkZW9qc2AgZ2l2ZW4gdGhlIG5hbWUgYW5kIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqID4gTk9URToge0BsaW5rIFRlY2h9cyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgYXMgYSBgQ29tcG9uZW50YC4ge0BsaW5rIFRlY2h9c1xuICAgKiAgICAgICAgIHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHtAbGluayBUZWNoLnJlZ2lzdGVyVGVjaH0gb3JcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyVGVjaH0uXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBiZSBzZWVuIG9uIHZpZGVvanMgYXNcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50fS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBgQ29tcG9uZW50YCB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IENvbXBvbmVudFRvUmVnaXN0ZXJcbiAgICogICAgICAgIFRoZSBgQ29tcG9uZW50YCBjbGFzcyB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIENvbXBvbmVudFRvUmVnaXN0ZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50IG5hbWUsIFwiJyArIG5hbWUgKyAnXCI7IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIHZhciBUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnVGVjaCcpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBjaGVjayBpcyBvbmx5IGRvbmUgaWYgVGVjaCBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgIHZhciBpc1RlY2ggPSBUZWNoICYmIFRlY2guaXNUZWNoKENvbXBvbmVudFRvUmVnaXN0ZXIpO1xuICAgIHZhciBpc0NvbXAgPSBDb21wb25lbnQgPT09IENvbXBvbmVudFRvUmVnaXN0ZXIgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKENvbXBvbmVudFRvUmVnaXN0ZXIucHJvdG90eXBlKTtcblxuICAgIGlmIChpc1RlY2ggfHwgIWlzQ29tcCkge1xuICAgICAgdmFyIHJlYXNvbiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGlzVGVjaCkge1xuICAgICAgICByZWFzb24gPSAndGVjaHMgbXVzdCBiZSByZWdpc3RlcmVkIHVzaW5nIFRlY2gucmVnaXN0ZXJUZWNoKCknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ211c3QgYmUgYSBDb21wb25lbnQgc3ViY2xhc3MnO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50LCBcIicgKyBuYW1lICsgJ1wiOyAnICsgcmVhc29uICsgJy4nKTtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoIUNvbXBvbmVudC5jb21wb25lbnRzXykge1xuICAgICAgQ29tcG9uZW50LmNvbXBvbmVudHNfID0ge307XG4gICAgfVxuXG4gICAgdmFyIFBsYXllciA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1BsYXllcicpO1xuXG4gICAgaWYgKG5hbWUgPT09ICdQbGF5ZXInICYmIFBsYXllciAmJiBQbGF5ZXIucGxheWVycykge1xuICAgICAgdmFyIHBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcbiAgICAgIHZhciBwbGF5ZXJOYW1lcyA9IE9iamVjdC5rZXlzKHBsYXllcnMpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHBsYXllcnMgdGhhdCB3ZXJlIGRpc3Bvc2VkLCB0aGVuIHRoZWlyIG5hbWUgd2lsbCBzdGlsbCBiZVxuICAgICAgLy8gaW4gUGxheWVycy5wbGF5ZXJzLiBTbywgd2UgbXVzdCBsb29wIHRocm91Z2ggYW5kIHZlcmlmeSB0aGF0IHRoZSB2YWx1ZVxuICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpcyBub3QgbnVsbC4gVGhpcyBhbGxvd3MgcmVnaXN0cmF0aW9uIG9mIHRoZSBQbGF5ZXIgY29tcG9uZW50XG4gICAgICAvLyBhZnRlciBhbGwgcGxheWVycyBoYXZlIGJlZW4gZGlzcG9zZWQgb3IgYmVmb3JlIGFueSB3ZXJlIGNyZWF0ZWQuXG4gICAgICBpZiAocGxheWVycyAmJiBwbGF5ZXJOYW1lcy5sZW5ndGggPiAwICYmIHBsYXllck5hbWVzLm1hcChmdW5jdGlvbiAocG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllcnNbcG5hbWVdO1xuICAgICAgfSkuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIFBsYXllciBjb21wb25lbnQgYWZ0ZXIgcGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdID0gQ29tcG9uZW50VG9SZWdpc3RlcjtcblxuICAgIHJldHVybiBDb21wb25lbnRUb1JlZ2lzdGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgbmFtZSBpdCB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIE5hbWUgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnb3QgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW4gYHZpZGVvanNgIDYgdGhpcyB3aWxsIG5vdCByZXR1cm4gYENvbXBvbmVudGBzIHRoYXQgd2VyZSBub3RcbiAgICogICAgICAgICAgICAgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50fS4gQ3VycmVudGx5IHdlXG4gICAqICAgICAgICAgICAgIGNoZWNrIHRoZSBnbG9iYWwgYHZpZGVvanNgIG9iamVjdCBmb3IgYSBgQ29tcG9uZW50YCBuYW1lIGFuZFxuICAgKiAgICAgICAgICAgICByZXR1cm4gdGhhdCBpZiBpdCBleGlzdHMuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgc3VwcG9ydHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKlxuICogVGhpcyBpcyBleHBvc2VkIHByaW1hcmlseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLnN1cHBvcnRzUmFmXyA9IHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29tcG9uZW50JywgQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xuICogQG1vZHVsZSB0aW1lLXJhbmdlc1xuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uIHRpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdXG4gKiAgICAgICAgVGhlIHJhbmdlIG51bWJlciB0byByZXR1cm4gdGhlIHRpbWUgZm9yLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZGVwcmljYXRlZCBpbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJhbmdlcyBvZiB0aW1lIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZVJhbmdlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogICAgICAgICAgIFRoZSBudW1iZXIgb2YgdGltZSByYW5nZXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IHN0YXJ0XG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBlbmRcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGJlZ2lucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UaW1lUmFuZ2VzXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhbnkgb2YgdGhlIHRpbWUgcmFuZ2VzIGFyZSBvdmVyIHRoZSBtYXhpbXVtIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gbmFtZSB0byB1c2UgZm9yIGxvZ2dpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgICAgICBUaGUgaW5kZXggdG8gY2hlY2tcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SW5kZXhcbiAqICAgICAgICBUaGUgbWF4aW11bSBwb3NzaWJsZSBpbmRleFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgdGltZVJhbmdlcyBwcm92aWRlZCBhcmUgb3ZlciB0aGUgbWF4SW5kZXhcbiAqL1xuZnVuY3Rpb24gcmFuZ2VDaGVjayhmbk5hbWUsIGluZGV4LCBtYXhJbmRleCkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXFwnJyArIGZuTmFtZSArICdcXCcgb24gXFwnVGltZVJhbmdlc1xcJzogVGhlIGluZGV4IHByb3ZpZGVkICgnICsgaW5kZXggKyAnKSBpcyBub24tbnVtZXJpYyBvciBvdXQgb2YgYm91bmRzICgwLScgKyBtYXhJbmRleCArICcpLicpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlSW5kZXhcbiAqICAgICAgICBUaGUgcHJvcHJldHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZXQgdGhlIHRpbWUuIHNob3VsZCBiZSAnc3RhcnQnIG9yICdlbmQnXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcmFuZ2VzXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbcmFuZ2VJbmRleD0wXVxuICogICAgICAgIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0XG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdGltZSB0aGF0IG9mZnNldCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqXG4gKiBAZGVwcmljYXRlZCByYW5nZUluZGV4IG11c3QgYmUgc2V0IHRvIGEgdmFsdWUsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHJhbmdlSW5kZXggaXMgbW9yZSB0aGFuIHRoZSBsZW5ndGggb2YgcmFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGdldFJhbmdlKGZuTmFtZSwgdmFsdWVJbmRleCwgcmFuZ2VzLCByYW5nZUluZGV4KSB7XG4gIHJhbmdlQ2hlY2soZm5OYW1lLCByYW5nZUluZGV4LCByYW5nZXMubGVuZ3RoIC0gMSk7XG4gIHJldHVybiByYW5nZXNbcmFuZ2VJbmRleF1bdmFsdWVJbmRleF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdGltZSByYW5nZSBvYmplY3QgZ2l2ZW50IHJhbmdlcyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtyYW5nZXNdXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXNPYmoocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMgPT09IHVuZGVmaW5lZCB8fCByYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHJhbmdlcy5sZW5ndGgsXG4gICAgc3RhcnQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ3N0YXJ0JywgMCwgcmFuZ2VzKSxcbiAgICBlbmQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ2VuZCcsIDEsIHJhbmdlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIGEgZmFrZSBgVGltZVJhbmdlYCBvYmplY3Qgd2hpY2ggbWltaWNzIGFuIEhUTUw1IHRpbWUgcmFuZ2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl9IHN0YXJ0XG4gKiAgICAgICAgVGhlIHN0YXJ0IG9mIGEgc2luZ2xlIHJhbmdlIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqICAgICAgICBUaGUgZW5kIG9mIGEgc2luZ2xlIHJhbmdlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXMoc3RhcnQsIGVuZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaihzdGFydCk7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooW1tzdGFydCwgZW5kXV0pO1xufVxuXG4vKipcbiAqIEBmaWxlIGJ1ZmZlci5qc1xuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuLyoqXG4gKiBDb21wdXRlIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBtZWRpYSB0aGF0IGhhcyBiZWVuIGJ1ZmZlcmVkLlxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBidWZmZXJlZFxuICogICAgICAgIFRoZSBjdXJyZW50IGBUaW1lUmFuZ2VgIG9iamVjdCByZXByZXNlbnRpbmcgYnVmZmVyZWQgdGltZSByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqICAgICAgICBUb3RhbCBkdXJhdGlvbiBvZiB0aGUgbWVkaWFcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFBlcmNlbnQgYnVmZmVyZWQgb2YgdGhlIHRvdGFsIGR1cmF0aW9uIGluIGRlY2ltYWwgZm9ybS5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50KGJ1ZmZlcmVkLCBkdXJhdGlvbikge1xuICB2YXIgYnVmZmVyZWREdXJhdGlvbiA9IDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcblxuICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XG5cbiAgICAvLyBidWZmZXJlZCBlbmQgY2FuIGJlIGJpZ2dlciB0aGFuIGR1cmF0aW9uIGJ5IGEgdmVyeSBzbWFsbCBmcmFjdGlvblxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgfVxuXG4gICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZER1cmF0aW9uIC8gZHVyYXRpb247XG59XG5cbi8qKlxuICogQGZpbGUgZnVsbHNjcmVlbi1hcGkuanNcbiAqIEBtb2R1bGUgZnVsbHNjcmVlbi1hcGlcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogU3RvcmUgdGhlIGJyb3dzZXItc3BlY2lmaWMgbWV0aG9kcyBmb3IgdGhlIGZ1bGxzY3JlZW4gQVBJLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc2VlIFtTcGVjaWZpY2F0aW9uXXtAbGluayBodHRwczovL2Z1bGxzY3JlZW4uc3BlYy53aGF0d2cub3JnfVxuICogQHNlZSBbTWFwIEFwcHJvYWNoIEZyb20gU2NyZWVuZnVsbC5qc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zY3JlZW5mdWxsLmpzfVxuICovXG52YXIgRnVsbHNjcmVlbkFwaSA9IHt9O1xuXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXG52YXIgYXBpTWFwID0gW1sncmVxdWVzdEZ1bGxzY3JlZW4nLCAnZXhpdEZ1bGxzY3JlZW4nLCAnZnVsbHNjcmVlbkVsZW1lbnQnLCAnZnVsbHNjcmVlbkVuYWJsZWQnLCAnZnVsbHNjcmVlbmNoYW5nZScsICdmdWxsc2NyZWVuZXJyb3InXSxcbi8vIFdlYktpdFxuWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gT2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTW96aWxsYVxuWydtb3pSZXF1ZXN0RnVsbFNjcmVlbicsICdtb3pDYW5jZWxGdWxsU2NyZWVuJywgJ21vekZ1bGxTY3JlZW5FbGVtZW50JywgJ21vekZ1bGxTY3JlZW5FbmFibGVkJywgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAnbW96ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBNaWNyb3NvZnRcblsnbXNSZXF1ZXN0RnVsbHNjcmVlbicsICdtc0V4aXRGdWxsc2NyZWVuJywgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLCAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAnTVNGdWxsc2NyZWVuRXJyb3InXV07XG5cbnZhciBzcGVjQXBpID0gYXBpTWFwWzBdO1xudmFyIGJyb3dzZXJBcGkgPSB2b2lkIDA7XG5cbi8vIGRldGVybWluZSB0aGUgc3VwcG9ydGVkIHNldCBvZiBmdW5jdGlvbnNcbmZvciAodmFyIGkgPSAwOyBpIDwgYXBpTWFwLmxlbmd0aDsgaSsrKSB7XG4gIC8vIGNoZWNrIGZvciBleGl0RnVsbHNjcmVlbiBmdW5jdGlvblxuICBpZiAoYXBpTWFwW2ldWzFdIGluIGRvY3VtZW50KSB7XG4gICAgYnJvd3NlckFwaSA9IGFwaU1hcFtpXTtcbiAgICBicmVhaztcbiAgfVxufVxuXG4vLyBtYXAgdGhlIGJyb3dzZXIgQVBJIG5hbWVzIHRvIHRoZSBzcGVjIEFQSSBuYW1lc1xuaWYgKGJyb3dzZXJBcGkpIHtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJyb3dzZXJBcGkubGVuZ3RoOyBfaSsrKSB7XG4gICAgRnVsbHNjcmVlbkFwaVtzcGVjQXBpW19pXV0gPSBicm93c2VyQXBpW19pXTtcbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIG1lZGlhLWVycm9yLmpzXG4gKi9cbi8qKlxuICogQSBDdXN0b20gYE1lZGlhRXJyb3JgIGNsYXNzIHdoaWNoIG1pbWljcyB0aGUgc3RhbmRhcmQgSFRNTDUgYE1lZGlhRXJyb3JgIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xPYmplY3R8TWVkaWFFcnJvcn0gdmFsdWVcbiAqICAgICAgICBUaGlzIGNhbiBiZSBvZiBtdWx0aXBsZSB0eXBlczpcbiAqICAgICAgICAtIG51bWJlcjogc2hvdWxkIGJlIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxuICogICAgICAgIC0gc3RyaW5nOiBhbiBlcnJvciBtZXNzYWdlICh0aGUgY29kZSB3aWxsIGJlIDApXG4gKiAgICAgICAgLSBPYmplY3Q6IGFyYml0cmFyeSBwcm9wZXJ0aWVzXG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0XG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKHZpZGVvLmpzKTogd2lsbCByZXR1cm4gaXRzZWxmIGlmIGl0J3MgYWxyZWFkeSBhXG4gKiAgICAgICAgICB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzZWUgW01lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvdmlkZW8uaHRtbCNtZWRpYWVycm9yfVxuICogQHNlZSBbRW5jcnlwdGVkIE1lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtZW5jcnlwdGVkLW1lZGlhLTIwMTMwNTEwLyNlcnJvci1jb2Rlc31cbiAqXG4gKiBAY2xhc3MgTWVkaWFFcnJvclxuICovXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XG5cbiAgLy8gQWxsb3cgcmVkdW5kYW50IGNhbGxzIHRvIHRoaXMgY29uc3RydWN0b3IgdG8gYXZvaWQgaGF2aW5nIGBpbnN0YW5jZW9mYFxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblxuICAgIC8vIFdlIGFzc2lnbiB0aGUgYGNvZGVgIHByb3BlcnR5IG1hbnVhbGx5IGJlY2F1c2UgbmF0aXZlIGBNZWRpYUVycm9yYCBvYmplY3RzXG4gICAgLy8gZG8gbm90IGV4cG9zZSBpdCBhcyBhbiBvd24vZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29kZSA9IHZhbHVlLmNvZGU7XG4gICAgfVxuXG4gICAgYXNzaWduKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWQgYE1lZGlhRXJyb3JgIHR5cGVzXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuY29kZSA9IDA7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHRvIHNob3cgd2l0aCB0aGUgZXJyb3IuIE1lc3NhZ2UgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUw1XG4gKiB2aWRlbyBzcGVjIGJ1dCBhbGxvd3MgZm9yIG1vcmUgaW5mb3JtYXRpdmUgY3VzdG9tIGVycm9ycy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnMgdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dFxuICogdGhlIGVycm9yLiBGb3IgZXhhbXBsZSBhIHBsdWdpbiBtaWdodCBwcm92aWRlIGEgc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZSBhbmQgYW5cbiAqIGVycm9yIG1lc3NhZ2UgZm9yIHRoYXQgY29kZS4gVGhlbiB3aGVuIHRoZSBwbHVnaW4gZ2V0cyB0aGF0IGVycm9yIHRoaXMgY2xhc3Mgd2lsbFxuICoga25vdyBob3cgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGZvciBpdC4gVGhpcyBhbGxvd3MgYSBjdXN0b20gbWVzc2FnZSB0byBzaG93XG4gKiB1cCBvbiB0aGUgYFBsYXllcmAgZXJyb3Igb3ZlcmxheS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbi8qKlxuICogRXJyb3JzIGluZGV4ZWQgYnkgdGhlIFczQyBzdGFuZGFyZC4gVGhlIG9yZGVyICoqQ0FOTk9UIENIQU5HRSoqISBTZWUgdGhlXG4gKiBzcGVjaWZpY2F0aW9uIGxpc3RlZCB1bmRlciB7QGxpbmsgTWVkaWFFcnJvcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGVudW0ge2FycmF5fVxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gMCAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAxIC0gTUVESUFfRVJSX0NVU1RPTVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDIgLSBNRURJQV9FUlJfQUJPUlRFRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IDMgLSBNRURJQV9FUlJfTkVUV09SS1xuICogQHByb3BlcnR5IHtzdHJpbmd9IDQgLSBNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA1IC0gTUVESUFfRVJSX0VOQ1JZUFRFRFxuICovXG5NZWRpYUVycm9yLmVycm9yVHlwZXMgPSBbJ01FRElBX0VSUl9DVVNUT00nLCAnTUVESUFfRVJSX0FCT1JURUQnLCAnTUVESUFfRVJSX05FVFdPUksnLCAnTUVESUFfRVJSX0RFQ09ERScsICdNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQnLCAnTUVESUFfRVJSX0VOQ1JZUFRFRCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBNZWRpYUVycm9yYCBtZXNzYWdlcyBiYXNlZCBvbiB0aGUge0BsaW5rIE1lZGlhRXJyb3IuZXJyb3JUeXBlc30uXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGNvbnN0YW50XG4gKi9cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIG1lZGlhIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSBtZWRpYSBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgbWVkaWEgdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgbWVkaWEgY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGBQcm9taXNlYC1saWtlIChpLmUuIGhhcyBhIGB0aGVuYCBtZXRob2QpLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHZhbHVlXG4gKiAgICAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBvciBtYXkgbm90IGJlIGBQcm9taXNlYC1saWtlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBTaWxlbmNlIGEgUHJvbWlzZS1saWtlIG9iamVjdC5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmcgbm9uLWhhcm1mdWwsIGJ1dCBwb3RlbnRpYWxseSBjb25mdXNpbmcgXCJ1bmNhdWdodFxuICogcGxheSBwcm9taXNlXCIgcmVqZWN0aW9uIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqICAgICAgICAgQW4gb2JqZWN0IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIHNpbGVuY2VQcm9taXNlKHZhbHVlKSB7XG4gIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgdmFsdWUudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xuICB9XG59XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlci5qcyBVdGlsaXRpZXMgZm9yIGNhcHR1cmluZyB0ZXh0IHRyYWNrIHN0YXRlIGFuZFxuICogcmUtY3JlYXRpbmcgdHJhY2tzIGJhc2VkIG9uIGEgY2FwdHVyZS5cbiAqXG4gKiBAbW9kdWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXJcbiAqL1xuXG4vKipcbiAqIEV4YW1pbmUgYSBzaW5nbGUge0BsaW5rIFRleHRUcmFja30gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gKiByZXByZXNlbnRzIHRoZSB7QGxpbmsgVGV4dFRyYWNrfSdzIHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIHF1ZXJ5LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVGV4dFRyYWNrLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHRyYWNrVG9Kc29uXyA9IGZ1bmN0aW9uIHRyYWNrVG9Kc29uXyh0cmFjaykge1xuICB2YXIgcmV0ID0gWydraW5kJywgJ2xhYmVsJywgJ2xhbmd1YWdlJywgJ2lkJywgJ2luQmFuZE1ldGFkYXRhVHJhY2tEaXNwYXRjaFR5cGUnLCAnbW9kZScsICdzcmMnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCwgaSkge1xuXG4gICAgaWYgKHRyYWNrW3Byb3BdKSB7XG4gICAgICBhY2NbcHJvcF0gPSB0cmFja1twcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7XG4gICAgY3VlczogdHJhY2suY3VlcyAmJiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2suY3VlcywgZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRUaW1lOiBjdWUuc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lOiBjdWUuZW5kVGltZSxcbiAgICAgICAgdGV4dDogY3VlLnRleHQsXG4gICAgICAgIGlkOiBjdWUuaWRcbiAgICAgIH07XG4gICAgfSlcbiAgfSk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogRXhhbWluZSBhIHtAbGluayBUZWNofSBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZVxuICogc3RhdGUgb2YgYWxsIHtAbGluayBUZXh0VHJhY2t9cyBjdXJyZW50bHkgY29uZmlndXJlZC4gVGhlIHJldHVybiBhcnJheSBpcyBjb21wYXRpYmxlIHdpdGhcbiAqIHtAbGluayB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyOmpzb25Ub1RleHRUcmFja3N9LlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSB0ZWNoIG9iamVjdCB0byBxdWVyeVxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBIHNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7QGxpbmsgVGVjaH1zXG4gKiAgICAgICAgIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAqL1xudmFyIHRleHRUcmFja3NUb0pzb24gPSBmdW5jdGlvbiB0ZXh0VHJhY2tzVG9Kc29uKHRlY2gpIHtcblxuICB2YXIgdHJhY2tFbHMgPSB0ZWNoLiQkKCd0cmFjaycpO1xuXG4gIHZhciB0cmFja09ianMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudHJhY2s7XG4gIH0pO1xuICB2YXIgdHJhY2tzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodHJhY2tFbCkge1xuICAgIHZhciBqc29uID0gdHJhY2tUb0pzb25fKHRyYWNrRWwudHJhY2spO1xuXG4gICAgaWYgKHRyYWNrRWwuc3JjKSB7XG4gICAgICBqc29uLnNyYyA9IHRyYWNrRWwuc3JjO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYWNrcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRlY2gudGV4dFRyYWNrcygpLCBmdW5jdGlvbiAodHJhY2spIHtcbiAgICByZXR1cm4gdHJhY2tPYmpzLmluZGV4T2YodHJhY2spID09PSAtMTtcbiAgfSkubWFwKHRyYWNrVG9Kc29uXykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzZXQgb2YgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9cyBvbiBhIHtAbGluayBUZWNofSBiYXNlZCBvbiBhbiBhcnJheSBvZiBqYXZhc2NyaXB0XG4gKiBvYmplY3Qge0BsaW5rIFRleHRUcmFja30gcmVwcmVzZW50YXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25cbiAqICAgICAgICBBbiBhcnJheSBvZiBgVGV4dFRyYWNrYCByZXByZXNlbnRhdGlvbiBvYmplY3RzLCBsaWtlIHRob3NlIHRoYXQgd291bGQgYmVcbiAqICAgICAgICBwcm9kdWNlZCBieSBgdGV4dFRyYWNrc1RvSnNvbmAuXG4gKlxuICogQHBhcmFtIHtUZWNofSB0ZWNoXG4gKiAgICAgICAgVGhlIGBUZWNoYCB0byBjcmVhdGUgdGhlIGBUZXh0VHJhY2tgcyBvbi5cbiAqL1xudmFyIGpzb25Ub1RleHRUcmFja3MgPSBmdW5jdGlvbiBqc29uVG9UZXh0VHJhY2tzKGpzb24sIHRlY2gpIHtcbiAganNvbi5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHZhciBhZGRlZFRyYWNrID0gdGVjaC5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spLnRyYWNrO1xuXG4gICAgaWYgKCF0cmFjay5zcmMgJiYgdHJhY2suY3Vlcykge1xuICAgICAgdHJhY2suY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZGVkVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZWNoLnRleHRUcmFja3MoKTtcbn07XG5cbnZhciB0ZXh0VHJhY2tDb252ZXJ0ZXIgPSB7IHRleHRUcmFja3NUb0pzb246IHRleHRUcmFja3NUb0pzb24sIGpzb25Ub1RleHRUcmFja3M6IGpzb25Ub1RleHRUcmFja3MsIHRyYWNrVG9Kc29uXzogdHJhY2tUb0pzb25fIH07XG5cbi8qKlxuICogQGZpbGUgbW9kYWwtZGlhbG9nLmpzXG4gKi9cbnZhciBNT0RBTF9DTEFTU19OQU1FID0gJ3Zqcy1tb2RhbC1kaWFsb2cnO1xudmFyIEVTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBgTW9kYWxEaWFsb2dgIGRpc3BsYXlzIG92ZXIgdGhlIHZpZGVvIGFuZCBpdHMgY29udHJvbHMsIHdoaWNoIGJsb2Nrc1xuICogaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGxheWVyIHVudGlsIGl0IGlzIGNsb3NlZC5cbiAqXG4gKiBNb2RhbCBkaWFsb2dzIGluY2x1ZGUgYSBcIkNsb3NlXCIgYnV0dG9uIGFuZCB3aWxsIGNsb3NlIHdoZW4gdGhhdCBidXR0b25cbiAqIGlzIGFjdGl2YXRlZCAtIG9yIHdoZW4gRVNDIGlzIHByZXNzZWQgYW55d2hlcmUuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1vZGFsRGlhbG9nID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTW9kYWxEaWFsb2csIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtvcHRpb25zLmNvbnRlbnQ9dW5kZWZpbmVkXVxuICAgKiAgICAgICAgUHJvdmlkZSBjdXN0b21pemVkIGNvbnRlbnQgZm9yIHRoaXMgbW9kYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl1cbiAgICogICAgICAgIEEgdGV4dCBkZXNjcmlwdGlvbiBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmlsbEFsd2F5cz1mYWxzZV1cbiAgICogICAgICAgIE5vcm1hbGx5LCBtb2RhbHMgYXJlIGF1dG9tYXRpY2FsbHkgZmlsbGVkIG9ubHkgdGhlIGZpcnN0IHRpbWVcbiAgICogICAgICAgIHRoZXkgb3Blbi4gVGhpcyB0ZWxscyB0aGUgbW9kYWwgdG8gcmVmcmVzaCBpdHMgY29udGVudFxuICAgKiAgICAgICAgZXZlcnkgdGltZSBpdCBvcGVucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXVxuICAgKiAgICAgICAgQSB0ZXh0IGxhYmVsIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZW1wb3Jhcnk9dHJ1ZV1cbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIG1vZGFsIGNhbiBvbmx5IGJlIG9wZW5lZCBvbmNlOyBpdCB3aWxsIGJlXG4gICAqICAgICAgICBkaXNwb3NlZCBhcyBzb29uIGFzIGl0J3MgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuY2xvc2VhYmxlPWZhbHNlXVxuICAgKiAgICAgICAgSWYgYHRydWVgLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvIGNsb3NlIHRoZSBtb2RhbFxuICAgKiAgICAgICAgdGhyb3VnaCB0aGUgVUkgaW4gdGhlIG5vcm1hbCB3YXlzLiBQcm9ncmFtbWF0aWMgY2xvc2luZyBpc1xuICAgKiAgICAgICAgc3RpbGwgcG9zc2libGUuXG4gICAqL1xuICBmdW5jdGlvbiBNb2RhbERpYWxvZyhwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbERpYWxvZyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9wZW5lZF8gPSBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5jbG9zZWFibGUoIV90aGlzLm9wdGlvbnNfLnVuY2xvc2VhYmxlKTtcbiAgICBfdGhpcy5jb250ZW50KF90aGlzLm9wdGlvbnNfLmNvbnRlbnQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjb250ZW50RWwgaXMgZGVmaW5lZCBBRlRFUiBhbnkgY2hpbGRyZW4gYXJlIGluaXRpYWxpemVkXG4gICAgLy8gYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdGhlIGNvbnRlbnRzIG9mIHRoZSBtb2RhbCBpbiB0aGUgY29udGVudEVsXG4gICAgLy8gKG5vdCB0aGUgVUkgZWxlbWVudHMgbGlrZSB0aGUgY2xvc2UgYnV0dG9uKS5cbiAgICBfdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogTU9EQUxfQ0xBU1NfTkFNRSArICctY29udGVudCdcbiAgICB9LCB7XG4gICAgICByb2xlOiAnZG9jdW1lbnQnXG4gICAgfSk7XG5cbiAgICBfdGhpcy5kZXNjRWxfID0gY3JlYXRlRWwoJ3AnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWRlc2NyaXB0aW9uIHZqcy1jb250cm9sLXRleHQnLFxuICAgICAgaWQ6IF90aGlzLmVsKCkuZ2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICB9KTtcblxuICAgIHRleHRDb250ZW50KF90aGlzLmRlc2NFbF8sIF90aGlzLmRlc2NyaXB0aW9uKCkpO1xuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5kZXNjRWxfKTtcbiAgICBfdGhpcy5lbF8uYXBwZW5kQ2hpbGQoX3RoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1vZGFsRGlhbG9nYCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwge1xuICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLmlkKCkgKyAnX2Rlc2NyaXB0aW9uJyxcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sYWJlbCgpLFxuICAgICAgJ3JvbGUnOiAnZGlhbG9nJ1xuICAgIH0pO1xuICB9O1xuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuICAgIHRoaXMuZGVzY0VsXyA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gTU9EQUxfQ0xBU1NfTkFNRSArICcgdmpzLWhpZGRlbiAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGBrZXlkb3duYCBldmVudHMgb24gdGhlIGRvY3VtZW50LCBsb29raW5nIGZvciBFU0MsIHdoaWNoIGNsb3Nlc1xuICAgKiB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGVcbiAgICogICAgICAgIFRoZSBrZXlwcmVzcyB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZSkge1xuICAgIGlmIChlLndoaWNoID09PSBFU0MgJiYgdGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFiZWwgc3RyaW5nIGZvciB0aGlzIG1vZGFsLiBQcmltYXJpbHkgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIHRoZSBsb2NhbGl6ZWQgb3IgcmF3IGxhYmVsIG9mIHRoaXMgbW9kYWwuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCB8fCAnTW9kYWwgV2luZG93Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0aW9uIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yXG4gICAqIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIG9yIHJhdyBkZXNjcmlwdGlvbiBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHZhciBkZXNjID0gdGhpcy5vcHRpb25zXy5kZXNjcmlwdGlvbiB8fCB0aGlzLmxvY2FsaXplKCdUaGlzIGlzIGEgbW9kYWwgd2luZG93LicpO1xuXG4gICAgLy8gQXBwZW5kIGEgdW5pdmVyc2FsIGNsb3NlYWJpbGl0eSBtZXNzYWdlIGlmIHRoZSBtb2RhbCBpcyBjbG9zZWFibGUuXG4gICAgaWYgKHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIGRlc2MgKz0gJyAnICsgdGhpcy5sb2NhbGl6ZSgnVGhpcyBtb2RhbCBjYW4gYmUgY2xvc2VkIGJ5IHByZXNzaW5nIHRoZSBFc2NhcGUga2V5IG9yIGFjdGl2YXRpbmcgdGhlIGNsb3NlIGJ1dHRvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzYztcbiAgfTtcblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxvcGVuXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcbiAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxuICAgICAgICAqXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxvcGVuJyk7XG4gICAgICB0aGlzLm9wZW5lZF8gPSB0cnVlO1xuXG4gICAgICAvLyBGaWxsIGNvbnRlbnQgaWYgdGhlIG1vZGFsIGhhcyBuZXZlciBvcGVuZWQgYmVmb3JlIGFuZFxuICAgICAgLy8gbmV2ZXIgYmVlbiBmaWxsZWQuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5maWxsQWx3YXlzIHx8ICF0aGlzLmhhc0JlZW5PcGVuZWRfICYmICF0aGlzLmhhc0JlZW5GaWxsZWRfKSB7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nLCBwYXVzZSBpdCBhbmQgdGFrZSBub3RlIG9mIGl0cyBwcmV2aW91c2x5XG4gICAgICAvLyBwbGF5aW5nIHN0YXRlLlxuICAgICAgdGhpcy53YXNQbGF5aW5nXyA9ICFwbGF5ZXIucGF1c2VkKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuICYmIHRoaXMud2FzUGxheWluZ18pIHtcbiAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICAgIHRoaXMub24odGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGlkZSBjb250cm9scyBhbmQgbm90ZSBpZiB0aGV5IHdlcmUgZW5hYmxlZC5cbiAgICAgIHRoaXMuaGFkQ29udHJvbHNfID0gcGxheWVyLmNvbnRyb2xzKCk7XG4gICAgICBwbGF5ZXIuY29udHJvbHMoZmFsc2UpO1xuXG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxGb2N1c18oKTtcbiAgICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ21vZGFsb3BlbicpO1xuICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkXyA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjdXJyZW50bHkgb3BlbiBvciBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBnaXZlbiwgaXQgd2lsbCBvcGVuIChgdHJ1ZWApIG9yIGNsb3NlIChgZmFsc2VgKSB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiB0aGUgbW9kYWxkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbmVkID0gZnVuY3Rpb24gb3BlbmVkKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzW3ZhbHVlID8gJ29wZW4nIDogJ2Nsb3NlJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3BlbmVkXztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbCwgZG9lcyBub3RoaW5nIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzXG4gICAqIG5vdCBvcGVuLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgLyoqXG4gICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5vcGVuZWRfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy53YXNQbGF5aW5nXyAmJiB0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuKSB7XG4gICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICB0aGlzLm9mZih0aGlzLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhZENvbnRyb2xzXykge1xuICAgICAgcGxheWVyLmNvbnRyb2xzKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgIC8qKlxuICAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5jb25kaXRpb25hbEJsdXJfKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy50ZW1wb3JhcnkpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzIGNsb3NlYWJsZSB2aWEgdGhlIFVJLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZ2l2ZW4gYXMgYSBib29sZWFuLCBpdCB3aWxsIHNldCB0aGUgYGNsb3NlYWJsZWAgb3B0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGZpbmFsIHZhbHVlIG9mIHRoZSBjbG9zYWJsZSBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNsb3NlYWJsZSA9IGZ1bmN0aW9uIGNsb3NlYWJsZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIGNsb3NlYWJsZSA9IHRoaXMuY2xvc2VhYmxlXyA9ICEhdmFsdWU7XG4gICAgICB2YXIgY2xvc2UgPSB0aGlzLmdldENoaWxkKCdjbG9zZUJ1dHRvbicpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgY2xvc2VhYmxlIGFuZCBoYXMgbm8gY2xvc2UgYnV0dG9uLCBhZGQgb25lLlxuICAgICAgaWYgKGNsb3NlYWJsZSAmJiAhY2xvc2UpIHtcblxuICAgICAgICAvLyBUaGUgY2xvc2UgYnV0dG9uIHNob3VsZCBiZSBhIGNoaWxkIG9mIHRoZSBtb2RhbCAtIG5vdCBpdHNcbiAgICAgICAgLy8gY29udGVudCBlbGVtZW50LCBzbyB0ZW1wb3JhcmlseSBjaGFuZ2UgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNvbnRlbnRFbF87XG5cbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGhpcy5lbF87XG4gICAgICAgIGNsb3NlID0gdGhpcy5hZGRDaGlsZCgnY2xvc2VCdXR0b24nLCB7IGNvbnRyb2xUZXh0OiAnQ2xvc2UgTW9kYWwgRGlhbG9nJyB9KTtcbiAgICAgICAgdGhpcy5jb250ZW50RWxfID0gdGVtcDtcbiAgICAgICAgdGhpcy5vbihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSB1bmNsb3NlYWJsZSBhbmQgaGFzIGEgY2xvc2UgYnV0dG9uLCByZW1vdmUgaXQuXG4gICAgICBpZiAoIWNsb3NlYWJsZSAmJiBjbG9zZSkge1xuICAgICAgICB0aGlzLm9mZihjbG9zZSwgJ2Nsb3NlJywgdGhpcy5jbG9zZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2xvc2UpO1xuICAgICAgICBjbG9zZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlYWJsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbGwgdGhlIG1vZGFsJ3MgY29udGVudCBlbGVtZW50IHdpdGggdGhlIG1vZGFsJ3MgXCJjb250ZW50XCIgb3B0aW9uLlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKCkge1xuICAgIHRoaXMuZmlsbFdpdGgodGhpcy5jb250ZW50KCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIGFyYml0cmFyeSBjb250ZW50LlxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGZpbGxcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZmlsbFxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbY29udGVudF1cbiAgICogICAgICAgIFRoZSBzYW1lIHJ1bGVzIGFwcGx5IHRvIHRoaXMgYXMgYXBwbHkgdG8gdGhlIGBjb250ZW50YCBvcHRpb24uXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGxXaXRoID0gZnVuY3Rpb24gZmlsbFdpdGgoY29udGVudCkge1xuICAgIHZhciBjb250ZW50RWwgPSB0aGlzLmNvbnRlbnRFbCgpO1xuICAgIHZhciBwYXJlbnRFbCA9IGNvbnRlbnRFbC5wYXJlbnROb2RlO1xuICAgIHZhciBuZXh0U2libGluZ0VsID0gY29udGVudEVsLm5leHRTaWJsaW5nO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxmaWxsJyk7XG4gICAgdGhpcy5oYXNCZWVuRmlsbGVkXyA9IHRydWU7XG5cbiAgICAvLyBEZXRhY2ggdGhlIGNvbnRlbnQgZWxlbWVudCBmcm9tIHRoZSBET00gYmVmb3JlIHBlcmZvcm1pbmdcbiAgICAvLyBtYW5pcHVsYXRpb24gdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZSBsaXZlIERPTSBtdWx0aXBsZSB0aW1lcy5cbiAgICBwYXJlbnRFbC5yZW1vdmVDaGlsZChjb250ZW50RWwpO1xuICAgIHRoaXMuZW1wdHkoKTtcbiAgICBpbnNlcnRDb250ZW50KGNvbnRlbnRFbCwgY29udGVudCk7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGZpbGwnKTtcblxuICAgIC8vIFJlLWluamVjdCB0aGUgcmUtZmlsbGVkIGNvbnRlbnQgZWxlbWVudC5cbiAgICBpZiAobmV4dFNpYmxpbmdFbCkge1xuICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKGNvbnRlbnRFbCwgbmV4dFNpYmxpbmdFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNvbnRlbnRFbCk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NlIGJ1dHRvbiBpcyBsYXN0IGluIHRoZSBkaWFsb2cgRE9NXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgIGlmIChjbG9zZUJ1dHRvbikge1xuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24uZWxfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtcHRpZXMgdGhlIGNvbnRlbnQgZWxlbWVudC4gVGhpcyBoYXBwZW5zIGFueXRpbWUgdGhlIG1vZGFsIGlzIGZpbGxlZC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZW1wdHlcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxlbXB0eScpO1xuICAgIGVtcHR5RWwodGhpcy5jb250ZW50RWwoKSk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBlbXB0aWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsZW1wdHlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdtb2RhbGVtcHR5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbW9kYWwgY29udGVudCwgd2hpY2ggZ2V0cyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiByZW5kZXJlZCBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIFRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBET00gb3IgZmlsbCB0aGUgbW9kYWwsIGJ1dCBpdCBpcyBjYWxsZWQgZHVyaW5nXG4gICAqIHRoYXQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtICB7TWl4ZWR9IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBkZWZpbmVkLCBzZXRzIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlIHRvIGJlIHVzZWQgb24gdGhlXG4gICAqICAgICAgICAgbmV4dCBjYWxsKHMpIHRvIGBmaWxsYC4gVGhpcyB2YWx1ZSBpcyBub3JtYWxpemVkIGJlZm9yZSBiZWluZ1xuICAgKiAgICAgICAgIGluc2VydGVkLiBUbyBcImNsZWFyXCIgdGhlIGludGVybmFsIGNvbnRlbnQgdmFsdWUsIHBhc3MgYG51bGxgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBtb2RhbCBkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jb250ZW50XyA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBmb2N1cyB0aGUgbW9kYWwgZGlhbG9nIGlmIGZvY3VzIHdhcyBwcmV2aW91c2x5IG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsRm9jdXNfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxGb2N1c18oKSB7XG4gICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB2YXIgcGxheWVyRWwgPSB0aGlzLnBsYXllcl8uZWxfO1xuXG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcblxuICAgIGlmIChwbGF5ZXJFbC5jb250YWlucyhhY3RpdmVFbCkgfHwgcGxheWVyRWwgPT09IGFjdGl2ZUVsKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBhY3RpdmVFbDtcblxuICAgICAgdGhpcy5mb2N1cygpO1xuXG4gICAgICB0aGlzLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbmRpdGlvbmFsQmx1cl8gPSBmdW5jdGlvbiBjb25kaXRpb25hbEJsdXJfKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8pIHtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXy5mb2N1cygpO1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLZXlkb3duIGhhbmRsZXIuIEF0dGFjaGVkIHdoZW4gbW9kYWwgaXMgZm9jdXNlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIC8vIGV4aXQgZWFybHkgaWYgaXQgaXNuJ3QgYSB0YWIga2V5XG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZvY3VzYWJsZUVscyA9IHRoaXMuZm9jdXNhYmxlRWxzXygpO1xuICAgIHZhciBhY3RpdmVFbCA9IHRoaXMuZWxfLnF1ZXJ5U2VsZWN0b3IoJzpmb2N1cycpO1xuICAgIHZhciBmb2N1c0luZGV4ID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2FibGVFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3RpdmVFbCA9PT0gZm9jdXNhYmxlRWxzW2ldKSB7XG4gICAgICAgIGZvY3VzSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5lbF8pIHtcbiAgICAgIGZvY3VzSW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSAwKSB7XG4gICAgICBmb2N1c2FibGVFbHNbZm9jdXNhYmxlRWxzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzSW5kZXggPT09IGZvY3VzYWJsZUVscy5sZW5ndGggLSAxKSB7XG4gICAgICBmb2N1c2FibGVFbHNbMF0uZm9jdXMoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBnZXQgYWxsIGZvY3VzYWJsZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5mb2N1c2FibGVFbHNfID0gZnVuY3Rpb24gZm9jdXNhYmxlRWxzXygpIHtcbiAgICB2YXIgYWxsQ2hpbGRyZW4gPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFsbENoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFuY2hvckVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEFyZWFFbGVtZW50KSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElucHV0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxCdXR0b25FbGVtZW50KSAmJiAhY2hpbGQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxPYmplY3RFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbWJlZEVsZW1lbnQgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAhPT0gLTEgfHwgY2hpbGQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW9kYWxEaWFsb2c7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW9kYWxEaWFsb2dgIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgcGF1c2VPbk9wZW46IHRydWUsXG4gIHRlbXBvcmFyeTogdHJ1ZVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNb2RhbERpYWxvZycsIE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogQ29tbW9uIGZ1bmN0aW9uYWxpeSBiZXR3ZWVuIHtAbGluayBUZXh0VHJhY2tMaXN0fSwge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKlxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuXG52YXIgVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFja0xpc3QsIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2tbXX0gdHJhY2tzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgdHJhY2tzIHRvIGluaXRpYWxpemUgdGhlIGxpc3Qgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0XVxuICAgKiAgICAgICAgVGhlIGNoaWxkIG9iamVjdCB3aXRoIGluaGVyaXRhbmNlIGRvbmUgbWFudWFsbHkgZm9yIGllOC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFja0xpc3QoKSB7XG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrTGlzdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIGlmICghbGlzdCkge1xuICAgICAgbGlzdCA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBpZiAoSVNfSUU4KSB7XG4gICAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QudHJhY2tzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRyYWNrYHMgaW4gdGhlIHRoaXMgVHJhY2tpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFjayh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIC8vIG11c3QgcmV0dXJuIHRoZSBvYmplY3QsIGFzIGZvciBpZTggaXQgd2lsbCBub3QgYmUgdGhpc1xuICAgIC8vIGJ1dCBhIHJlZmVyZW5jZSB0byBhIGRvY3VtZW50IG9iamVjdFxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRyYWNrfSB0byB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBhdWRpbywgdmlkZW8sIG9yIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja3NfLmxlbmd0aDtcblxuICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFja3NfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgdHJhY2tzXG4gICAgaWYgKHRoaXMudHJhY2tzXy5pbmRleE9mKHRyYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tzXy5wdXNoKHRyYWNrKTtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhIHRyYWNrIGxpc3QuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFRyYWNrTGlzdCNhZGR0cmFja1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyBhZGRlZC5cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICB0eXBlOiAnYWRkdHJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBUcmFja30gZnJvbSB0aGUgYFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHJ0cmFjaykge1xuICAgIHZhciB0cmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0aGlzW2ldID09PSBydHJhY2spIHtcbiAgICAgICAgdHJhY2sgPSB0aGlzW2ldO1xuICAgICAgICBpZiAodHJhY2sub2ZmKSB7XG4gICAgICAgICAgdHJhY2sub2ZmKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrc18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRyYWNrIGlzIHJlbW92ZWQgZnJvbSB0cmFjayBsaXN0LlxuICAgICAqXG4gICAgICogQGV2ZW50IFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKiBAcHJvcGVydHkge1RyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICB0cmFjazogdHJhY2ssXG4gICAgICB0eXBlOiAncmVtb3ZldHJhY2snXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIHRyYWNrIHRvIGdldFxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxuICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUcmFja0xpc3QucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uIGdldFRyYWNrQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdGhpc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSB0cmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVHJhY2tMaXN0O1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogVHJpZ2dlcmVkIHdoZW4gYSBkaWZmZXJlbnQgdHJhY2sgaXMgc2VsZWN0ZWQvZW5hYmxlZC5cbiAqXG4gKiBAZXZlbnQgVHJhY2tMaXN0I2NoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRXZlbnRzIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoIG9uICsgZXZlbnROYW1lLiBTZWUge0BsaW5rIEV2ZW50SGFuZGxlcn0uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFRyYWNrTGlzdCNhbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuXG5cblRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGNoYW5nZTogJ2NoYW5nZScsXG4gIGFkZHRyYWNrOiAnYWRkdHJhY2snLFxuICByZW1vdmV0cmFjazogJ3JlbW92ZXRyYWNrJ1xufTtcblxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5mb3IgKHZhciBldmVudCBpbiBUcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfKSB7XG4gIFRyYWNrTGlzdC5wcm90b3R5cGVbJ29uJyArIGV2ZW50XSA9IG51bGw7XG59XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIEFueXdoZXJlIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3ZSBkaXZlcmdlIGZyb20gdGhlIHNwZWNcbiAqIGFzIHdlIG9ubHkgc3VwcG9ydCBvbmUgZW5hYmxlZCBhdWRpb3RyYWNrIGF0IGEgdGltZVxuICpcbiAqIEBwYXJhbSB7QXVkaW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyA9IGZ1bmN0aW9uIGRpc2FibGVPdGhlcnMobGlzdCwgdHJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhsaXN0W2ldKS5sZW5ndGggfHwgdHJhY2suaWQgPT09IGxpc3RbaV0uaWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBhbm90aGVyIGF1ZGlvIHRyYWNrIGlzIGVuYWJsZWQsIGRpc2FibGUgaXRcbiAgICBsaXN0W2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBBdWRpb1RyYWNrfSBmb3IgYSBtZWRpYSBmaWxlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBBdWRpb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBBdWRpb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XG4gICAgICAgIGRpc2FibGVPdGhlcnModHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBBdWRpb1RyYWNrfSB0byB0aGUgYEF1ZGlvVHJhY2tMaXN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGhlIEF1ZGlvVHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0XG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRyYWNrLmVuYWJsZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnModGhpcywgdHJhY2spO1xuICAgIH1cblxuICAgIF9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuICAgIC8vIG5hdGl2ZSB0cmFja3MgZG9uJ3QgaGF2ZSB0aGlzXG4gICAgaWYgKCF0cmFjay5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2hlbiB3ZSBhcmUgZGlzYWJsaW5nIG90aGVyIHRyYWNrcyAoc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbW9yZSB0aGFuIG9uZSB0cmFjayBhdCBhIHRpbWUpIHdlIHdpbGwgc2V0IGNoYW5naW5nX1xuICAgICAgLy8gdG8gdHJ1ZSBzbyB0aGF0IHdlIGRvbid0IHRyaWdnZXIgYWRkaXRpb25hbCBjaGFuZ2UgZXZlbnRzXG4gICAgICBpZiAoX3RoaXMyLmNoYW5naW5nXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gdHJ1ZTtcbiAgICAgIGRpc2FibGVPdGhlcnMoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHZpZGVvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBVbi1zZWxlY3QgYWxsIG90aGVyIHtAbGluayBWaWRlb1RyYWNrfXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtWaWRlb1RyYWNrTGlzdH0gbGlzdFxuICogICAgICAgIGxpc3QgdG8gd29yayBvblxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdHJhY2sgdG8gc2tpcFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBkaXNhYmxlT3RoZXJzJDEgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciB2aWRlbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFZpZGVvVHJhY2t9IGZvciBhIHZpZGVvLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBWaWRlb1RyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFZpZGVvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBWaWRlb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVmlkZW9UcmFja0xpc3QoKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcbiAgICAvLyBzb3J0ZWQgZnJvbSBsYXN0IGluZGV4IHRvIGZpcnN0IGluZGV4XG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKHRyYWNrc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzJDEodHJhY2tzLCB0cmFja3NbaV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBWaWRlb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gVmlkZW9UcmFja0xpc3Qjc2VsZWN0ZWRJbmRleFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHtAbGluayBWaWRlb1RyYWNrYH0uXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdzZWxlY3RlZEluZGV4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGlmICh0aGlzW19pXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9yZXQgPSBsaXN0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgVmlkZW9UcmFja30gdG8gdGhlIGBWaWRlb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VmlkZW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBWaWRlb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgVmlkZW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5zZWxlY3RlZCkge1xuICAgICAgZGlzYWJsZU90aGVycyQxKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKiBAZmlyZXMgVHJhY2tMaXN0I2NoYW5nZVxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzJDEoX3RoaXMyLCB0cmFjayk7XG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gZmFsc2U7XG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2tMaXN0O1xufShUcmFja0xpc3QpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIFRleHRUcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdH1cbiAqIEBleHRlbmRzIFRyYWNrTGlzdFxuICovXG5cbnZhciBUZXh0VHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja1tdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBUZXh0VHJhY2tgIHRvIGluc3RhbnRpYXRlIHRoZSBsaXN0IHdpdGguXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0xpc3QpO1xuXG4gICAgdmFyIGxpc3QgPSB2b2lkIDA7XG5cbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcbiAgICAvLyBhcyBpdCBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBwcm9wZXJseVxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUcmFja0xpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAoX3Byb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W19wcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFRleHRUcmFja30gdG8gdGhlIGBUZXh0VHJhY2tMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRleHRUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pKTtcblxuICAgIHZhciBub25MYW5ndWFnZVRleHRUcmFja0tpbmQgPSBbJ21ldGFkYXRhJywgJ2NoYXB0ZXJzJ107XG5cbiAgICBpZiAobm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kLmluZGV4T2YodHJhY2sua2luZCkgPT09IC0xKSB7XG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQtbGlzdC5qc1xuICovXG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH1zLlxuICovXG5cbnZhciBIdG1sVHJhY2tFbGVtZW50TGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudFtdfSBbdHJhY2tzPVtdXVxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBIdG1sVHJhY2tFbGVtZW50YCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbFRyYWNrRWxlbWVudExpc3QoKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUcmFja0VsZW1lbnRMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrRWxlbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgSHRtbFRyYWNrRWxlbWVudExpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0cmFja0VsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LmFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gdG8gdGhlIGBIdG1sVHJhY2tFbGVtZW50TGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtIdG1sVHJhY2tFbGVtZW50fSB0cmFja0VsZW1lbnRcbiAgICogICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuYWRkVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIGFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50c19baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgYWRkIGR1cGxpY2F0ZSBlbGVtZW50c1xuICAgIGlmICh0aGlzLnRyYWNrRWxlbWVudHNfLmluZGV4T2YodHJhY2tFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudHJhY2tFbGVtZW50c18ucHVzaCh0cmFja0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgIGdpdmVuIGFuXG4gICAqIHtAbGluayBUZXh0VHJhY2t9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSB0cmFjayBhc3NvY2lhdGVkIHdpdGggYSB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfID0gZnVuY3Rpb24gZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odHJhY2spIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50XyA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0udHJhY2spIHtcbiAgICAgICAgdHJhY2tFbGVtZW50XyA9IHRoaXMudHJhY2tFbGVtZW50c19baV07XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYWNrRWxlbWVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmFja0VsZW1lbnQgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0pIHtcbiAgICAgICAgdGhpcy50cmFja0VsZW1lbnRzXy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBIdG1sVHJhY2tFbGVtZW50TGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWN1ZS1saXN0LmpzXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWVcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRcbiAqICAgICAgICAgICBUaGUgdW5pcXVlIGlkIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0VGltZVxuICogICAgICAgICAgIFRoZSBzdGFydCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZFRpbWVcbiAqICAgICAgICAgICBUaGUgZW5kIHRpbWUgZm9yIHRoaXMgdGV4dCB0cmFjayBjdWVcbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhdXNlT25FeGl0XG4gKiAgICAgICAgICAgUGF1c2Ugd2hlbiB0aGUgZW5kIHRpbWUgaXMgcmVhY2hlZCBpZiB0cnVlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2tjdWV9XG4gKi9cblxuLyoqXG4gKiBBIExpc3Qgb2YgVGV4dFRyYWNrQ3Vlcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlbGlzdH1cbiAqL1xuXG52YXIgVGV4dFRyYWNrQ3VlTGlzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBIGxpc3Qgb2YgY3VlcyB0byBiZSBpbml0aWFsaXplZCB3aXRoXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tDdWVMaXN0KGN1ZXMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tDdWVMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18uY2FsbChsaXN0LCBjdWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tDdWVMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVGV4dFRyYWNrQ3VlYHMgaW4gdGhlIFRleHRUcmFja0N1ZUxpc3QuXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNldHRlciBmb3IgY3VlcyBpbiB0aGlzIGxpc3QuIENyZWF0ZXMgZ2V0dGVyc1xuICAgKiBhbiBhbiBpbmRleCBmb3IgdGhlIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1ZXNcbiAgICogICAgICAgIEFuIGFycmF5IG9mIGN1ZXMgdG8gc2V0XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuc2V0Q3Vlc18gPSBmdW5jdGlvbiBzZXRDdWVzXyhjdWVzKSB7XG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB0aGlzLmN1ZXNfID0gY3VlcztcbiAgICB0aGlzLmxlbmd0aF8gPSBjdWVzLmxlbmd0aDtcblxuICAgIHZhciBkZWZpbmVQcm9wID0gZnVuY3Rpb24gZGVmaW5lUHJvcChpbmRleCkge1xuICAgICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJycgKyBpbmRleCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vlc19baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvbGRMZW5ndGggPCBsKSB7XG4gICAgICBpID0gb2xkTGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBkZWZpbmVQcm9wLmNhbGwodGhpcywgaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGV4dFRyYWNrQ3VlYCB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgYFRleHRUcmFja0N1ZUxpc3RgIGJ5IGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY3VlIHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWV8bnVsbH1cbiAgICogICAgICAgICBBIHNpbmdsZSBjdWUgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZS5nZXRDdWVCeUlkID0gZnVuY3Rpb24gZ2V0Q3VlQnlJZChpZCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGN1ZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmIChjdWUuaWQgPT09IGlkKSB7XG4gICAgICAgIHJlc3VsdCA9IGN1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQ3VlTGlzdDtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1raW5kcy5qc1xuICovXG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBWaWRlb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLXZpZGVvdHJhY2sta2luZFxuICogQHR5cGVkZWYgVmlkZW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVmlkZW9UcmFja0tpbmQgPSB7XG4gIGFsdGVybmF0aXZlOiAnYWx0ZXJuYXRpdmUnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgbWFpbjogJ21haW4nLFxuICBzaWduOiAnc2lnbicsXG4gIHN1YnRpdGxlczogJ3N1YnRpdGxlcycsXG4gIGNvbW1lbnRhcnk6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYEF1ZGlvVHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tYXVkaW90cmFjay1raW5kXG4gKiBAdHlwZWRlZiBBdWRpb1RyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBBdWRpb1RyYWNrS2luZCA9IHtcbiAgJ2FsdGVybmF0aXZlJzogJ2FsdGVybmF0aXZlJyxcbiAgJ2Rlc2NyaXB0aW9ucyc6ICdkZXNjcmlwdGlvbnMnLFxuICAnbWFpbic6ICdtYWluJyxcbiAgJ21haW4tZGVzYyc6ICdtYWluLWRlc2MnLFxuICAndHJhbnNsYXRpb24nOiAndHJhbnNsYXRpb24nLFxuICAnY29tbWVudGFyeSc6ICdjb21tZW50YXJ5J1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS10ZXh0dHJhY2sta2luZFxuICogQHR5cGVkZWYgVGV4dFRyYWNrfktpbmRcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tLaW5kID0ge1xuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjYXB0aW9uczogJ2NhcHRpb25zJyxcbiAgZGVzY3JpcHRpb25zOiAnZGVzY3JpcHRpb25zJyxcbiAgY2hhcHRlcnM6ICdjaGFwdGVycycsXG4gIG1ldGFkYXRhOiAnbWV0YWRhdGEnXG59O1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVGV4dFRyYWNrTW9kZWBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbW9kZVxuICogQHR5cGVkZWYgVGV4dFRyYWNrfk1vZGVcbiAqIEBlbnVtXG4gKi9cbnZhciBUZXh0VHJhY2tNb2RlID0ge1xuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgc2hvd2luZzogJ3Nob3dpbmcnXG59O1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLmpzXG4gKi9cbi8qKlxuICogQSBUcmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHtAbGluayBBdWRpb1RyYWNrfSxcbiAqIHtAbGluayBWaWRlb1RyYWNrfSwgYW5kIHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqID4gTm90ZTogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWx9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQGFic3RyYWN0XG4gKi9cblxudmFyIFRyYWNrID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhUcmFjaywgX0V2ZW50VGFyZ2V0KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQga2luZCBmb3IgdGhlIHRyYWNrIHR5cGUgeW91IGFyZSBjcmVhdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrKCkge1xuICAgIHZhciBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xuXG4gICAgdmFyIHRyYWNrID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrUHJvcHMgPSB7XG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCAndmpzX3RyYWNrXycgKyBuZXdHVUlEKCksXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQgfHwgJycsXG4gICAgICBsYWJlbDogb3B0aW9ucy5sYWJlbCB8fCAnJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8ICcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gaWRcbiAgICAgKiAgICAgICAgIFRoZSBpZCBvZiB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBraW5kXG4gICAgICogICAgICAgICBUaGUga2luZCBvZiB0cmFjayB0aGF0IHRoaXMgaXMuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhYmVsXG4gICAgICogICAgICAgICBUaGUgbGFiZWwgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgKiAgICAgICAgIFRoZSB0d28gbGV0dGVyIGxhbmd1YWdlIGNvZGUgZm9yIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXG4gICAgICogICAgICAgICBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJhY2tQcm9wc1trZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRyYWNrUHJvcHMpIHtcbiAgICAgIF9sb29wKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gVHJhY2s7XG59KEV2ZW50VGFyZ2V0KTtcblxuLyoqXG4gKiBAZmlsZSB1cmwuanNcbiAqIEBtb2R1bGUgdXJsXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gdXJsOlVSTE9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbFxuICogICAgICAgICAgIFRoZSBwcm90b2NvbCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdG5hbWVcbiAqICAgICAgICAgICBUaGUgaG9zdG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBvcnRcbiAqICAgICAgICAgICBUaGUgcG9ydCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aG5hbWVcbiAqICAgICAgICAgICBUaGUgcGF0aG5hbWUgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlYXJjaFxuICogICAgICAgICAgIFRoZSBzZWFyY2ggcXVlcnkgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2hcbiAqICAgICAgICAgICBUaGUgaGFzaCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdFxuICogICAgICAgICAgIFRoZSBob3N0IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICovXG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJsXG4gKiAgICAgICAgIFRoZSB1cmwgdG8gcGFyc2VcbiAqXG4gKiBAcmV0dXJuIHt1cmw6VVJMT2JqZWN0fVxuICogICAgICAgICBBbiBvYmplY3Qgb2YgdXJsIGRldGFpbHNcbiAqL1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gIHZhciBwcm9wcyA9IFsncHJvdG9jb2wnLCAnaG9zdG5hbWUnLCAncG9ydCcsICdwYXRobmFtZScsICdzZWFyY2gnLCAnaGFzaCcsICdob3N0J107XG5cbiAgLy8gYWRkIHRoZSB1cmwgdG8gYW4gYW5jaG9yIGFuZCBsZXQgdGhlIGJyb3dzZXIgcGFyc2UgdGhlIFVSTFxuICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBhLmhyZWYgPSB1cmw7XG5cbiAgLy8gSUU4IChhbmQgOT8pIEZpeFxuICAvLyBpZTggZG9lc24ndCBwYXJzZSB0aGUgVVJMIGNvcnJlY3RseSB1bnRpbCB0aGUgYW5jaG9yIGlzIGFjdHVhbGx5XG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXG4gIHZhciBhZGRUb0JvZHkgPSBhLmhvc3QgPT09ICcnICYmIGEucHJvdG9jb2wgIT09ICdmaWxlOic7XG4gIHZhciBkaXYgPSB2b2lkIDA7XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+PC9hPic7XG4gICAgYSA9IGRpdi5maXJzdENoaWxkO1xuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7IHBvc2l0aW9uOmFic29sdXRlOycpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxuICAvLyBUaGlzIGlzIGFsc28gbmVlZGVkIGZvciBJRTggYmVjYXVzZSB0aGUgYW5jaG9yIGxvc2VzIGl0c1xuICAvLyBwcm9wZXJ0aWVzIHdoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIGRvbVxuICB2YXIgZGV0YWlscyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xuICB9XG5cbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXG4gIC8vIGEgcG9ydCBpZGVudGlmaWVyIGlzIGFkZGVkIGZvciBzdGFuZGFyZCBwb3J0cywgc3RyaXAgaXQuXG4gIGlmIChkZXRhaWxzLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XG4gIH1cblxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBkZXRhaWxzLmhvc3QgPSBkZXRhaWxzLmhvc3QucmVwbGFjZSgvOjQ0MyQvLCAnJyk7XG4gIH1cblxuICBpZiAoIWRldGFpbHMucHJvdG9jb2wpIHtcbiAgICBkZXRhaWxzLnByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICB9XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHJldHVybiBkZXRhaWxzO1xufTtcblxuLyoqXG4gKiBHZXQgYWJzb2x1dGUgdmVyc2lvbiBvZiByZWxhdGl2ZSBVUkwuIFVzZWQgdG8gdGVsbCBmbGFzaCBjb3JyZWN0IFVSTC5cbiAqXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmxcbiAqICAgICAgICAgVVJMIHRvIG1ha2UgYWJzb2x1dGVcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIEFic29sdXRlIFVSTFxuICpcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzA4MzIvZ2V0dGluZy1hbi1hYnNvbHV0ZS11cmwtZnJvbS1hLXJlbGF0aXZlLW9uZS1pZTYtaXNzdWVcbiAqL1xudmFyIGdldEFic29sdXRlVVJMID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIENoZWNrIGlmIGFic29sdXRlIFVSTFxuICBpZiAoIXVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSkge1xuICAgIC8vIENvbnZlcnQgdG8gYWJzb2x1dGUgVVJMLiBGbGFzaCBob3N0ZWQgb2ZmLXNpdGUgbmVlZHMgYW4gYWJzb2x1dGUgVVJMLlxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+eDwvYT4nO1xuICAgIHVybCA9IGRpdi5maXJzdENoaWxkLmhyZWY7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhc3NlZCBmaWxlIG5hbWUuIEl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZ1xuICogaWYgcGFzc2VkIGFuIGludmFsaWQgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogICAgICAgIFRoZSBmaWxlTmFtZSBwYXRoIGxpa2UgJy9wYXRoL3RvL2ZpbGUubXA0J1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgICAgICAgICBUaGUgZXh0ZW5zaW9uIGluIGxvd2VyIGNhc2Ugb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vXG4gKiAgICAgICAgICBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXG4gKi9cbnZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rPykoXFwuKFteXFwuXFwvXFw/XSspKSkoPzpbXFwvXSp8W1xcP10uKikkL2k7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aCk7XG5cbiAgICBpZiAocGF0aFBhcnRzKSB7XG4gICAgICByZXR1cm4gcGF0aFBhcnRzLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogICAgICAgIFRoZSB1cmwgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBpdCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqL1xudmFyIGlzQ3Jvc3NPcmlnaW4gPSBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xuICB2YXIgd2luTG9jID0gd2luZG93LmxvY2F0aW9uO1xuICB2YXIgdXJsSW5mbyA9IHBhcnNlVXJsKHVybCk7XG5cbiAgLy8gSUU4IHByb3RvY29sIHJlbGF0aXZlIHVybHMgd2lsbCByZXR1cm4gJzonIGZvciBwcm90b2NvbFxuICB2YXIgc3JjUHJvdG9jb2wgPSB1cmxJbmZvLnByb3RvY29sID09PSAnOicgPyB3aW5Mb2MucHJvdG9jb2wgOiB1cmxJbmZvLnByb3RvY29sO1xuXG4gIC8vIENoZWNrIGlmIHVybCBpcyBmb3IgYW5vdGhlciBkb21haW4vb3JpZ2luXG4gIC8vIElFOCBkb2Vzbid0IGtub3cgbG9jYXRpb24ub3JpZ2luLCBzbyB3ZSB3b24ndCByZWx5IG9uIGl0IGhlcmVcbiAgdmFyIGNyb3NzT3JpZ2luID0gc3JjUHJvdG9jb2wgKyB1cmxJbmZvLmhvc3QgIT09IHdpbkxvYy5wcm90b2NvbCArIHdpbkxvYy5ob3N0O1xuXG4gIHJldHVybiBjcm9zc09yaWdpbjtcbn07XG5cbnZhciBVcmwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0cGFyc2VVcmw6IHBhcnNlVXJsLFxuXHRnZXRBYnNvbHV0ZVVSTDogZ2V0QWJzb2x1dGVVUkwsXG5cdGdldEZpbGVFeHRlbnNpb246IGdldEZpbGVFeHRlbnNpb24sXG5cdGlzQ3Jvc3NPcmlnaW46IGlzQ3Jvc3NPcmlnaW5cbn0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2suanNcbiAqL1xuLyoqXG4gKiBUYWtlcyBhIHdlYnZ0dCBmaWxlIGNvbnRlbnRzIGFuZCBwYXJzZXMgaXQgaW50byBjdWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY0NvbnRlbnRcbiAqICAgICAgICB3ZWJWVFQgZmlsZSBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRleHRUcmFjayB0byBhZGQgY3VlcyB0by4gQ3VlcyBjb21lIGZyb20gdGhlIHNyY0NvbnRlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlQ3VlcyA9IGZ1bmN0aW9uIHBhcnNlQ3VlcyhzcmNDb250ZW50LCB0cmFjaykge1xuICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvdy5XZWJWVFQuUGFyc2VyKHdpbmRvdywgd2luZG93LnZ0dGpzLCB3aW5kb3cuV2ViVlRULlN0cmluZ0RlY29kZXIoKSk7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG5cbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRyYWNrLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ2xvYWRlZGRhdGEnLFxuICAgICAgdGFyZ2V0OiB0cmFja1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlci5wYXJzZShzcmNDb250ZW50KTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cENvbGxhcHNlZCgnVGV4dCBUcmFjayBwYXJzaW5nIGVycm9ycyBmb3IgJyArIHRyYWNrLnNyYyk7XG4gICAgfVxuICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VyLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIExvYWQgYSBgVGV4dFRyYWNrYCBmcm9tIGEgc3BlY2lmZWQgdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICBVcmwgdG8gbG9hZCB0cmFjayBmcm9tLlxuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRyYWNrIHRvIGFkZCBjdWVzIHRvLiBDb21lcyBmcm9tIHRoZSBjb250ZW50IGF0IHRoZSBlbmQgb2YgYHVybGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGxvYWRUcmFjayA9IGZ1bmN0aW9uIGxvYWRUcmFjayhzcmMsIHRyYWNrKSB7XG4gIHZhciBvcHRzID0ge1xuICAgIHVyaTogc3JjXG4gIH07XG4gIHZhciBjcm9zc09yaWdpbiA9IGlzQ3Jvc3NPcmlnaW4oc3JjKTtcblxuICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICBvcHRzLmNvcnMgPSBjcm9zc09yaWdpbjtcbiAgfVxuXG4gIHhocihvcHRzLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gbG9nJDEuZXJyb3IoZXJyLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdHJhY2subG9hZGVkXyA9IHRydWU7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB2dHRqcyBoYXMgbG9hZGVkLCBvdGhlcndpc2UsIHdhaXQgdGlsbCBpdCBmaW5pc2hlZCBsb2FkaW5nXG4gICAgLy8gTk9URTogdGhpcyBpcyBvbmx5IHVzZWQgZm9yIHRoZSBhbHQvdmlkZW8ubm92dHQuanMgYnVpbGRcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0cmFjay50ZWNoXykge1xuICAgICAgICB2YXIgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkSGFuZGxlcigpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgdHJhY2sudGVjaF8ub24oJ3Z0dGpzZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG9nJDEuZXJyb3IoJ3Z0dGpzIGZhaWxlZCB0byBsb2FkLCBzdG9wcGluZyB0cnlpbmcgdG8gcHJvY2VzcyAnICsgdHJhY2suc3JjKTtcbiAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgIH1cbiAgfSkpO1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBUZXh0VHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBUZXh0VHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFRleHRUcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2spO1xuXG4gICAgaWYgKCFvcHRpb25zLnRlY2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSB0ZWNoIHdhcyBub3QgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IFRleHRUcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnc3VidGl0bGVzJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZyB8fCAnJ1xuICAgIH0pO1xuICAgIHZhciBtb2RlID0gVGV4dFRyYWNrTW9kZVtzZXR0aW5ncy5tb2RlXSB8fCAnZGlzYWJsZWQnO1xuICAgIHZhciBkZWZhdWx0XyA9IHNldHRpbmdzWydkZWZhdWx0J107XG5cbiAgICBpZiAoc2V0dGluZ3Mua2luZCA9PT0gJ21ldGFkYXRhJyB8fCBzZXR0aW5ncy5raW5kID09PSAnY2hhcHRlcnMnKSB7XG4gICAgICBtb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0dCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuXG4gICAgdHQudGVjaF8gPSBzZXR0aW5ncy50ZWNoO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHRbcHJvcF0gPSBUZXh0VHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHQuY3Vlc18gPSBbXTtcbiAgICB0dC5hY3RpdmVDdWVzXyA9IFtdO1xuXG4gICAgdmFyIGN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5jdWVzXyk7XG4gICAgdmFyIGFjdGl2ZUN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5hY3RpdmVDdWVzXyk7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgdGltZXVwZGF0ZUhhbmRsZXIgPSBiaW5kKHR0LCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIEFjY2Vzc2luZyB0aGlzLmFjdGl2ZUN1ZXMgZm9yIHRoZSBzaWRlLWVmZmVjdHMgb2YgdXBkYXRpbmcgaXRzZWxmXG4gICAgICAvLyBkdWUgdG8gaXQncyBuYXR1cmUgYXMgYSBnZXR0ZXIgZnVuY3Rpb24uIERvIG5vdCByZW1vdmUgb3IgY3VlcyB3aWxsXG4gICAgICAvLyBzdG9wIHVwZGF0aW5nIVxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICB0aGlzLmFjdGl2ZUN1ZXM7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjdWVjaGFuZ2UnKTtcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHR0LnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHQudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZGVmYXVsdFxuICAgICAqICAgICAgICAgSWYgdGhpcyB0cmFjayB3YXMgc2V0IHRvIGJlIG9uIG9yIG9mZiBieSBkZWZhdWx0LiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdkZWZhdWx0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0XztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBtb2RlXG4gICAgICogICAgICAgICBTZXQgdGhlIG1vZGUgb2YgdGhpcyBUZXh0VHJhY2sgdG8gYSB2YWxpZCB7QGxpbmsgVGV4dFRyYWNrfk1vZGV9LiBXaWxsXG4gICAgICogICAgICAgICBub3QgYmUgc2V0IGlmIHNldHRpbmcgdG8gYW4gaW52YWxpZCBtb2RlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnbW9kZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICghVGV4dFRyYWNrTW9kZVtuZXdNb2RlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RlID0gbmV3TW9kZTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdzaG93aW5nJykge1xuXG4gICAgICAgICAgdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBtb2RlIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIFRleHRUcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjIVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrQ3VlTGlzdH0gY3Vlc1xuICAgICAqICAgICAgICAgVGhlIHRleHQgdHJhY2sgY3VlIGxpc3QgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2N1ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdWVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBhY3RpdmVDdWVzXG4gICAgICogICAgICAgICBUaGUgbGlzdCB0ZXh0IHRyYWNrIGN1ZXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnYWN0aXZlQ3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICBpZiAodGhpcy5jdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0ID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgYWN0aXZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc1tpXTtcblxuICAgICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5lbmRUaW1lID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA9PT0gY3VlLmVuZFRpbWUgJiYgY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuc3RhcnRUaW1lICsgMC41ID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAhPT0gdGhpcy5hY3RpdmVDdWVzXy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYWN0aXZlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ3Vlc18uaW5kZXhPZihhY3RpdmVbX2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVDdWVzXyA9IGFjdGl2ZTtcbiAgICAgICAgYWN0aXZlQ3Vlcy5zZXRDdWVzXyh0aGlzLmFjdGl2ZUN1ZXNfKTtcblxuICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICBpZiAoc2V0dGluZ3Muc3JjKSB7XG4gICAgICB0dC5zcmMgPSBzZXR0aW5ncy5zcmM7XG4gICAgICBsb2FkVHJhY2soc2V0dGluZ3Muc3JjLCB0dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR0LmxvYWRlZF8gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHQsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1ZSB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35DdWV9IGN1ZVxuICAgKiAgICAgICAgVGhlIGN1ZSB0byBhZGQgdG8gb3VyIGludGVybmFsIGxpc3RcbiAgICovXG5cblxuICBUZXh0VHJhY2sucHJvdG90eXBlLmFkZEN1ZSA9IGZ1bmN0aW9uIGFkZEN1ZShvcmlnaW5hbEN1ZSkge1xuICAgIHZhciBjdWUgPSBvcmlnaW5hbEN1ZTtcblxuICAgIGlmICh3aW5kb3cudnR0anMgJiYgIShvcmlnaW5hbEN1ZSBpbnN0YW5jZW9mIHdpbmRvdy52dHRqcy5WVFRDdWUpKSB7XG4gICAgICBjdWUgPSBuZXcgd2luZG93LnZ0dGpzLlZUVEN1ZShvcmlnaW5hbEN1ZS5zdGFydFRpbWUsIG9yaWdpbmFsQ3VlLmVuZFRpbWUsIG9yaWdpbmFsQ3VlLnRleHQpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9yaWdpbmFsQ3VlKSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gY3VlKSkge1xuICAgICAgICAgIGN1ZVtwcm9wXSA9IG9yaWdpbmFsQ3VlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGBpZGAgaXMgY29waWVkIG92ZXJcbiAgICAgIGN1ZS5pZCA9IG9yaWdpbmFsQ3VlLmlkO1xuICAgICAgY3VlLm9yaWdpbmFsQ3VlXyA9IG9yaWdpbmFsQ3VlO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRlY2hfLnRleHRUcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XG4gICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1ZXNfLnB1c2goY3VlKTtcbiAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGN1ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gcmVtb3ZlQ3VlXG4gICAqICAgICAgICBUaGUgY3VlIHRvIHJlbW92ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbiByZW1vdmVDdWUoX3JlbW92ZUN1ZSkge1xuICAgIHZhciBpID0gdGhpcy5jdWVzXy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgY3VlID0gdGhpcy5jdWVzX1tpXTtcblxuICAgICAgaWYgKGN1ZSA9PT0gX3JlbW92ZUN1ZSB8fCBjdWUub3JpZ2luYWxDdWVfICYmIGN1ZS5vcmlnaW5hbEN1ZV8gPT09IF9yZW1vdmVDdWUpIHtcbiAgICAgICAgdGhpcy5jdWVzXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBjdWVjaGFuZ2UgLSBPbmUgb3IgbW9yZSBjdWVzIGluIHRoZSB0cmFjayBoYXZlIGJlY29tZSBhY3RpdmUgb3Igc3RvcHBlZCBiZWluZyBhY3RpdmUuXG4gKi9cblxuXG5UZXh0VHJhY2sucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjdWVjaGFuZ2U6ICdjdWVjaGFuZ2UnXG59O1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYEF1ZGlvVHJhY2tgLiBJZiBpdCBpcyBwYXJ0IG9mIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIG9ubHkgb25lIGBBdWRpb1RyYWNrYCBpbiB0aGUgbGlzdCB3aWxsIGJlIGVuYWJsZWQgYXQgYSB0aW1lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgQXVkaW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgYXVkaW8gdHJhY2sga2luZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgaXMgdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLiBJZiB0aGlzIHRyYWNrIGlzIHBhcnQgb2ZcbiAgICogICAgICAgIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIG9ubHkgb25lIHtAbGluayBBdWRpb1RyYWNrfSB3aWxsIGJlIGVuYWJsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBBdWRpb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XG4gICAgdmFyIHRyYWNrID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XG4gICAgdmFyIGVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gQXVkaW9UcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IEF1ZGlvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBBdWRpb1RyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqICAgICAgICAgSWYgdGhpcyBgQXVkaW9UcmFja2AgaXMgZW5hYmxlZCBvciBub3QuIFdoZW4gc2V0dGluZyB0aGlzIHdpbGxcbiAgICAgKiAgICAgICAgIGZpcmUge0BsaW5rIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZX0gaWYgdGhlIHN0YXRlIG9mIGVuYWJsZWQgaXMgY2hhbmdlZC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCAnZW5hYmxlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gZW5hYmxlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdFbmFibGVkKSB7XG4gICAgICAgIC8vIGFuIGludmFsaWQgb3IgdW5jaGFuZ2VkIHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgbmV3RW5hYmxlZCAhPT0gJ2Jvb2xlYW4nIHx8IG5ld0VuYWJsZWQgPT09IGVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW5hYmxlZCA9IG5ld0VuYWJsZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBlbmFibGVkIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIEF1ZGlvVHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyEgTmF0aXZlIHRyYWNrcyB3aWxsIGRvXG4gICAgICAgICAqICAgICAgICAgdGhpcyBpbnRlcm5hbGx5IHdpdGhvdXQgYW4gZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgICB0cmFjay5lbmFibGVkID0gc2V0dGluZ3MuZW5hYmxlZDtcbiAgICB9XG4gICAgdHJhY2subG9hZGVkXyA9IHRydWU7XG5cbiAgICByZXR1cm4gX3JldCA9IHRyYWNrLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIHJldHVybiBBdWRpb1RyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgVmlkZW9UcmFja2AuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBWaWRlb1RyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrLCBfVHJhY2spO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB7QGxpbmsgVmlkZW9UcmFja35LaW5kfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VsZWN0ZWRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIGlzIHRoZSBvbmUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZy5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2soKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IFZpZGVvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcblxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0cmFjayA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBWaWRlb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVmlkZW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVmlkZW9UcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogICAgICAgICBJZiB0aGlzIGBWaWRlb1RyYWNrYCBpcyBzZWxlY3RlZCBvciBub3QuIFdoZW4gc2V0dGluZyB0aGlzIHdpbGxcbiAgICAgKiAgICAgICAgIGZpcmUge0BsaW5rIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2V9IGlmIHRoZSBzdGF0ZSBvZiBzZWxlY3RlZCBjaGFuZ2VkLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdzZWxlY3RlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3U2VsZWN0ZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdTZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nIHx8IG5ld1NlbGVjdGVkID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RlZCA9IG5ld1NlbGVjdGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gc2VsZWN0ZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgVmlkZW9UcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cbiAgICAgICAgICogICAgICAgICB0aGlzIGludGVybmFsbHkgd2l0aG91dCBhbiBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3RlZGNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgdGhlIHVzZXIgc2V0cyB0aGlzIHRyYWNrIHRvIHNlbGVjdGVkIHRoZW5cbiAgICAvLyBzZXQgc2VsZWN0ZWQgdG8gdGhhdCB0cnVlIHZhbHVlIG90aGVyd2lzZVxuICAgIC8vIHdlIGtlZXAgaXQgZmFsc2VcbiAgICBpZiAoc2V0dGluZ3Muc2VsZWN0ZWQpIHtcbiAgICAgIHRyYWNrLnNlbGVjdGVkID0gc2V0dGluZ3Muc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gVmlkZW9UcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIEBmaWxlIGh0bWwtdHJhY2stZWxlbWVudC5qc1xuICovXG5cbi8qKlxuICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAqIEB0eXBlZGVmIHtIVE1MVHJhY2tFbGVtZW50flJlYWR5U3RhdGV9XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgTk9ORSA9IDA7XG52YXIgTE9BRElORyA9IDE7XG52YXIgTE9BREVEID0gMjtcbnZhciBFUlJPUiA9IDM7XG5cbi8qKlxuICogQSBzaW5nbGUgdHJhY2sgcmVwcmVzZW50ZWQgaW4gdGhlIERPTS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjaHRtbHRyYWNrZWxlbWVudH1cbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIEhUTUxUcmFja0VsZW1lbnQgPSBmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIGluaGVyaXRzKEhUTUxUcmFja0VsZW1lbnQsIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH0gb3B0aW9ucy50ZWNoXG4gICAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdGVjaCB0aGF0IG93bnMgdGhpcyBIVE1MVHJhY2tFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPSdzdWJ0aXRsZXMnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIGtpbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfk1vZGV9IFtvcHRpb25zLm1vZGU9J2Rpc2FibGVkJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY2xhbmc9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS4gQW4gYWx0ZXJuYXRpdmUsIGJ1dCBkZXByaW9yaXRpemVkXG4gICAqICAgICAgICB2ZXNpb24gb2YgYG9wdGlvbnMubGFuZ3VhZ2VgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNdXG4gICAqICAgICAgICBBIHVybCB0byBUZXh0VHJhY2sgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWZhdWx0XVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBzaG91bGQgZGVmYXVsdCB0byBvbiBvciBvZmYuXG4gICAqL1xuICBmdW5jdGlvbiBIVE1MVHJhY2tFbGVtZW50KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MVHJhY2tFbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xuXG4gICAgdmFyIHJlYWR5U3RhdGUgPSB2b2lkIDA7XG4gICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB0cmFja0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrRWxlbWVudFtwcm9wXSA9IEhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcblxuICAgIHRyYWNrRWxlbWVudC5raW5kID0gdHJhY2sua2luZDtcbiAgICB0cmFja0VsZW1lbnQuc3JjID0gdHJhY2suc3JjO1xuICAgIHRyYWNrRWxlbWVudC5zcmNsYW5nID0gdHJhY2subGFuZ3VhZ2U7XG4gICAgdHJhY2tFbGVtZW50LmxhYmVsID0gdHJhY2subGFiZWw7XG4gICAgdHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSB0cmFja1snZGVmYXVsdCddO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAgICAgKiBAbWVtYmVyIHtIVE1MVHJhY2tFbGVtZW50flJlYWR5U3RhdGV9IHJlYWR5U3RhdGVcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHJlYWR5IHN0YXRlIG9mIHRoZSB0cmFjayBlbGVtZW50LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja0VsZW1lbnQsICdyZWFkeVN0YXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiByZWFkeVN0YXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAgICogICAgICAgICBUaGUgdW5kZXJseWluZyBUZXh0VHJhY2sgb2JqZWN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3RyYWNrJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWR5U3RhdGUgPSBOT05FO1xuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgVGV4dFRyYWNrI2xvYWRlZGRhdGFcbiAgICAgKiBAZmlyZXMgSFRNTFRyYWNrRWxlbWVudCNsb2FkXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlYWR5U3RhdGUgPSBMT0FERUQ7XG5cbiAgICAgIHRyYWNrRWxlbWVudC50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrRWxlbWVudFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB2YXIgX3JldDtcblxuICAgICAgcmV0dXJuIF9yZXQgPSB0cmFja0VsZW1lbnQsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gSFRNTFRyYWNrRWxlbWVudDtcbn0oRXZlbnRUYXJnZXQpO1xuXG5IVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgbG9hZDogJ2xvYWQnXG59O1xuXG5IVE1MVHJhY2tFbGVtZW50Lk5PTkUgPSBOT05FO1xuSFRNTFRyYWNrRWxlbWVudC5MT0FESU5HID0gTE9BRElORztcbkhUTUxUcmFja0VsZW1lbnQuTE9BREVEID0gTE9BREVEO1xuSFRNTFRyYWNrRWxlbWVudC5FUlJPUiA9IEVSUk9SO1xuXG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFsbCB0cmFjayBwcm9wZXJ0aWVzIHRoYXQgYXJlIHVzZWQgaW5cbiAqIHBsYXllci5qcywgdGVjaC5qcywgaHRtbDUuanMgYW5kIHBvc3NpYmx5IG90aGVyIHRlY2hzIGluIHRoZSBmdXR1cmUuXG4gKi9cblxudmFyIE5PUk1BTCA9IHtcbiAgYXVkaW86IHtcbiAgICBMaXN0Q2xhc3M6IEF1ZGlvVHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IEF1ZGlvVHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdBdWRpbydcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBMaXN0Q2xhc3M6IFZpZGVvVHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFZpZGVvVHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdWaWRlbydcbiAgfSxcbiAgdGV4dDoge1xuICAgIExpc3RDbGFzczogVGV4dFRyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBUZXh0VHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdUZXh0J1xuICB9XG59O1xuXG5PYmplY3Qua2V5cyhOT1JNQUwpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgTk9STUFMW3R5cGVdLmdldHRlck5hbWUgPSB0eXBlICsgJ1RyYWNrcyc7XG4gIE5PUk1BTFt0eXBlXS5wcml2YXRlTmFtZSA9IHR5cGUgKyAnVHJhY2tzXyc7XG59KTtcblxudmFyIFJFTU9URSA9IHtcbiAgcmVtb3RlVGV4dDoge1xuICAgIExpc3RDbGFzczogVGV4dFRyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBUZXh0VHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdSZW1vdGVUZXh0JyxcbiAgICBnZXR0ZXJOYW1lOiAncmVtb3RlVGV4dFRyYWNrcycsXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tzXydcbiAgfSxcbiAgcmVtb3RlVGV4dEVsOiB7XG4gICAgTGlzdENsYXNzOiBIdG1sVHJhY2tFbGVtZW50TGlzdCxcbiAgICBUcmFja0NsYXNzOiBIVE1MVHJhY2tFbGVtZW50LFxuICAgIGNhcGl0YWxOYW1lOiAnUmVtb3RlVGV4dFRyYWNrRWxzJyxcbiAgICBnZXR0ZXJOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzJyxcbiAgICBwcml2YXRlTmFtZTogJ3JlbW90ZVRleHRUcmFja0Vsc18nXG4gIH1cbn07XG5cbnZhciBBTEwgPSBtZXJnZU9wdGlvbnMoTk9STUFMLCBSRU1PVEUpO1xuXG5SRU1PVEUubmFtZXMgPSBPYmplY3Qua2V5cyhSRU1PVEUpO1xuTk9STUFMLm5hbWVzID0gT2JqZWN0LmtleXMoTk9STUFMKTtcbkFMTC5uYW1lcyA9IFtdLmNvbmNhdChSRU1PVEUubmFtZXMpLmNvbmNhdChOT1JNQUwubmFtZXMpO1xuXG4vKipcbiAqIEBmaWxlIHRlY2guanNcbiAqL1xuXG4vKipcbiAqIEFuIE9iamVjdCBjb250YWluaW5nIGEgc3RydWN0dXJlIGxpa2U6IGB7c3JjOiAndXJsJywgdHlwZTogJ21pbWV0eXBlJ31gIG9yIHN0cmluZ1xuICogdGhhdCBqdXN0IGNvbnRhaW5zIHRoZSBzcmMgdXJsIGFsb25lLlxuICogKiBgdmFyIFNvdXJjZU9iamVjdCA9IHtzcmM6ICdodHRwOi8vZXguY29tL3ZpZGVvLm1wNCcsIHR5cGU6ICd2aWRlby9tcDQnfTtgXG4gICAqIGB2YXIgU291cmNlU3RyaW5nID0gJ2h0dHA6Ly9leGFtcGxlLmNvbS9zb21lLXZpZGVvLm1wNCc7YFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R8c3RyaW5nfSBUZWNoflNvdXJjZU9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICAgICBUaGUgdXJsIHRvIHRoZSBzb3VyY2VcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogICAgICAgICAgIFRoZSBtaW1lIHR5cGUgb2YgdGhlIHNvdXJjZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIGJ5IHtAbGluayBUZWNofSB0byBjcmVhdGUgYSBuZXcge0BsaW5rIFRleHRUcmFja30uXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHNlbGZcbiAqICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgVGVjaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogICAgICAgIEFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgdGV4dCB0cmFjayBvcHRpb25zXG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrfVxuICogICAgICAgICAgVGhlIHRleHQgdHJhY2sgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhY2tIZWxwZXIoc2VsZiwga2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICB2YXIgdHJhY2tzID0gc2VsZi50ZXh0VHJhY2tzKCk7XG5cbiAgb3B0aW9ucy5raW5kID0ga2luZDtcblxuICBpZiAobGFiZWwpIHtcbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XG4gIH1cbiAgaWYgKGxhbmd1YWdlKSB7XG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICB9XG4gIG9wdGlvbnMudGVjaCA9IHNlbGY7XG5cbiAgdmFyIHRyYWNrID0gbmV3IEFMTC50ZXh0LlRyYWNrQ2xhc3Mob3B0aW9ucyk7XG5cbiAgdHJhY2tzLmFkZFRyYWNrKHRyYWNrKTtcblxuICByZXR1cm4gdHJhY2s7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2sgdGVjaG5vbG9neSBjb250cm9sbGVycywgc3VjaCBhc1xuICoge0BsaW5rIEZsYXNofSBhbmQge0BsaW5rIEhUTUw1fVxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZWNoID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGVjaCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIFRlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IHJlYWR5XG4gICAqICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGBIVE1MNWAgVGVjaCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFRlY2goKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciByZWFkeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVjaCk7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSB0ZWNoIHRvIHJlcG9ydCB1c2VyIGFjdGl2aXR5IGF1dG9tYXRpY2FsbHkuXG4gICAgLy8gVGhpcyBpcyBkb25lIG1hbnVhbGx5IGluIGFkZENvbnRyb2xzTGlzdGVuZXJzXG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGN1cnJlbnQgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIHRvXG4gICAgLy8gaW1wbGVtZW50IGEgdmVyeSBsaW1pdGVkIHBsYXllZCgpXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIF90aGlzLmhhc1N0YXJ0ZWRfID0gZmFsc2U7XG4gICAgX3RoaXMub24oJ3BsYXlpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBfdGhpcy5vbignbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXSkge1xuICAgICAgICBfdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSBvcHRpb25zW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgcHJvZ3Jlc3MgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cykge1xuICAgICAgX3RoaXMubWFudWFsUHJvZ3Jlc3NPbigpO1xuICAgIH1cblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHRpbWV1cGRhdGVzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cykge1xuICAgICAgX3RoaXMubWFudWFsVGltZVVwZGF0ZXNPbigpO1xuICAgIH1cblxuICAgIFsnVGV4dCcsICdBdWRpbycsICdWaWRlbyddLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICBpZiAob3B0aW9uc1snbmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID09PSBmYWxzZSkge1xuICAgICAgICBfdGhpc1snZmVhdHVyZXNOYXRpdmUnICsgdHJhY2sgKyAnVHJhY2tzJ10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSBmYWxzZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubmF0aXZlQ2FwdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICBfdGhpcy5lbXVsYXRlVGV4dFRyYWNrcygpO1xuICAgIH1cblxuICAgIF90aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXyA9IG5ldyBBTEwudGV4dC5MaXN0Q2xhc3MoKTtcblxuICAgIF90aGlzLmluaXRUcmFja0xpc3RlbmVycygpO1xuXG4gICAgLy8gVHVybiBvbiBjb21wb25lbnQgdGFwIGV2ZW50cyBvbmx5IGlmIG5vdCB1c2luZyBuYXRpdmUgY29udHJvbHNcbiAgICBpZiAoIW9wdGlvbnMubmF0aXZlQ29udHJvbHNGb3JUb3VjaCkge1xuICAgICAgX3RoaXMuZW1pdFRhcEV2ZW50cygpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgX3RoaXMubmFtZV8gPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdVbmtub3duIFRlY2gnO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiBGYWxsYmFja3MgZm9yIHVuc3VwcG9ydGVkIGV2ZW50IHR5cGVzXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHkuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc31cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09uID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPbigpIHtcbiAgICB0aGlzLm9uKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG5cbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gdHJ1ZTtcblxuICAgIC8vIFRyaWdnZXIgcHJvZ3Jlc3Mgd2F0Y2hpbmcgd2hlbiBhIHNvdXJjZSBiZWdpbnMgbG9hZGluZ1xuICAgIHRoaXMub25lKCdyZWFkeScsIHRoaXMudHJhY2tQcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFByb2dyZXNzT2ZmID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcblxuICAgIHRoaXMub2ZmKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byB0cmlnZ2VyIGEgYHByb2dyZXNzYCBldmVudCB3aGVuIHRoZSBidWZmZXJlZCBwZXJjZW50IGNoYW5nZXMuIEl0XG4gICAqIHNldHMgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSA1MDAgbWlsbGlzZWNvbmRzIHRvIGNoZWNrIGlmIHRoZVxuICAgKiBidWZmZXIgZW5kIHBlcmNlbnQgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqID4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgcmVhZHlgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3JlYWR5XG4gICAqIEBmaXJlcyBUZWNoI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUudHJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIHRyYWNrUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChiaW5kKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgdW5sZXNzIGJ1ZmZlcmVkIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gbGFzdCB0aW1lXG5cbiAgICAgIHZhciBudW1CdWZmZXJlZFBlcmNlbnQgPSB0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBlcmNlbnRfICE9PSBudW1CdWZmZXJlZFBlcmNlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUGxheWVyI3Byb2dyZXNzfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGVjaCNwcm9ncmVzc1xuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVmZmVyZWRQZXJjZW50XyA9IG51bUJ1ZmZlcmVkUGVyY2VudDtcblxuICAgICAgaWYgKG51bUJ1ZmZlcmVkUGVyY2VudCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgICB9XG4gICAgfSksIDUwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvdXIgaW50ZXJuYWwgZHVyYXRpb24gb24gYSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IGJ5IGNhbGxpbmdcbiAgICoge0BsaW5rIFRlY2gjZHVyYXRpb259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5vbkR1cmF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25EdXJhdGlvbkNoYW5nZShldmVudCkge1xuICAgIHRoaXMuZHVyYXRpb25fID0gdGhpcy5kdXJhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW5kIGNyZWF0ZSBhIGBUaW1lUmFuZ2VgIG9iamVjdCBmb3IgYnVmZmVyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmFuZ2Ugb2JqZWN0IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBjdXJyZW50IHZpZGVvIHRoYXQgaXMgY3VycmVudGx5IGJ1ZmZlcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEgdGhhdCByZXByZXNlbnRzIHRoZSBkZWNpbWFsIHBlcmNlbnRhZ2Ugb2YgdGhlXG4gICAqICAgICAgICAgdmlkZW8gdGhhdCBpcyBidWZmZXJlZC5cbiAgICpcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb25fKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgcHJvZ3Jlc3NgIGV2ZW50cyB0aGF0IHdhcyBjcmVhdGVkIGluXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqIFN0b3AgbWFudWFsbHkgdHJhY2tpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGNsZWFyaW5nIHRoZSBpbnRlcnZhbCB0aGF0IHdhcyBzZXQgaW5cbiAgICoge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc30uXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdQcm9ncmVzcygpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0ludGVydmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogUG9seWZpbGwgdGhlIGB0aW1ldXBkYXRlYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrQ3VycmVudFRpbWV9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsVGltZVVwZGF0ZXNPbiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT24oKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IHRydWU7XG5cbiAgICB0aGlzLm9uKCdwbGF5JywgdGhpcy50cmFja0N1cnJlbnRUaW1lKTtcbiAgICB0aGlzLm9uKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGB0aW1ldXBkYXRlYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT2ZmID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdG8gdHJhY2sgY3VycmVudCB0aW1lIGFuZCB0cmlnZ2VyIGB0aW1ldXBkYXRlYCBldmVyeVxuICAgKiAyNTAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlcbiAgICogQHRyaWdnZXJzIFRlY2gjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrQ3VycmVudFRpbWUgPSBmdW5jdGlvbiB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCBhdCBhbiBpbnRlcnZhbCBvZiAyNTBtcyB0byBpbmRpY2F0ZWQgdGhhdCB0aW1lIGlzIHBhc3NpbmcgaW4gdGhlIHZpZGVvLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuXG4gICAgICAvLyA0MiA9IDI0IGZwcyAvLyAyNTAgaXMgd2hhdCBXZWJraXQgdXNlcyAvLyBGRiB1c2VzIDE1XG4gICAgfSwgMjUwKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCB0aGUgaW50ZXJ2YWwgZnVuY3Rpb24gY3JlYXRlZCBpbiB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfSBzbyB0aGF0IHRoZVxuICAgKiBgdGltZXVwZGF0ZWAgZXZlbnQgaXMgbm8gbG9uZ2VyIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQGxpc3RlbnMge1RlY2gjcGF1c2V9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50VGltZUludGVydmFsKTtcblxuICAgIC8vICMxMDAyIC0gaWYgdGhlIHZpZGVvIGVuZHMgcmlnaHQgYmVmb3JlIHRoZSBuZXh0IHRpbWV1cGRhdGUgd291bGQgaGFwcGVuLFxuICAgIC8vIHRoZSBwcm9ncmVzcyBiYXIgd29uJ3QgbWFrZSBpdCBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiBhbGwgZXZlbnQgcG9seWZpbGxzLCBjbGVhciB0aGUgYFRlY2hgcyB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LFxuICAgKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCBhbmQge0BsaW5rIFRleHRUcmFja0xpc3R9LCBhbmQgZGlzcG9zZSBvZiB0aGlzIFRlY2guXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjZGlzcG9zZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLy8gY2xlYXIgb3V0IGFsbCB0cmFja3MgYmVjYXVzZSB3ZSBjYW4ndCByZXVzZSB0aGVtIGJldHdlZW4gdGVjaHNcbiAgICB0aGlzLmNsZWFyVHJhY2tzKE5PUk1BTC5uYW1lcyk7XG5cbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykge1xuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09mZigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzT2ZmKCk7XG4gICAgfVxuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBvdXQgYSBzaW5nbGUgYFRyYWNrTGlzdGAgb3IgYW4gYXJyYXkgb2YgYFRyYWNrTGlzdHNgIGdpdmVuIHRoZWlyIG5hbWVzLlxuICAgKlxuICAgKiA+IE5vdGU6IFRlY2hzIHdpdGhvdXQgc291cmNlIGhhbmRsZXJzIHNob3VsZCBjYWxsIHRoaXMgYmV0d2VlbiBzb3VyY2VzIGZvciBgdmlkZW9gXG4gICAqICAgICAgICAgJiBgYXVkaW9gIHRyYWNrcy4gWW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZW0gYmV0d2VlbiB0cmFja3MhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW118c3RyaW5nfSB0eXBlc1xuICAgKiAgICAgICAgVHJhY2tMaXN0IG5hbWVzIHRvIGNsZWFyLCB2YWxpZCBuYW1lcyBhcmUgYHZpZGVvYCwgYGF1ZGlvYCwgYW5kXG4gICAqICAgICAgICBgdGV4dGAuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2xlYXJUcmFja3MgPSBmdW5jdGlvbiBjbGVhclRyYWNrcyh0eXBlcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdHlwZXMgPSBbXS5jb25jYXQodHlwZXMpO1xuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3QgPSBfdGhpczJbdHlwZSArICdUcmFja3MnXSgpIHx8IFtdO1xuICAgICAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBfdGhpczIucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBUZXh0VHJhY2tzIGFkZGVkIHZpYSBhZGRSZW1vdGVUZXh0VHJhY2sgdGhhdCBhcmVcbiAgICogZmxhZ2dlZCBmb3IgYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFudXBBdXRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFudXBBdXRvVGV4dFRyYWNrcygpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfIHx8IFtdO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCwgd2hpY2ggd2lsbCByZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgcmVhZHlTdGF0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGFuIGVycm9yIG9uIHRoZSBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhRXJyb3J9IFtlcnJdXG4gICAqICAgICAgICBFcnJvciB0byBzZXQgb24gdGhlIFRlY2hcbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGVycm9yIG9iamVjdCBvbiB0aGUgdGVjaCwgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZVJhbmdlYHMgdGhhdCBoYXZlIGJlZW4gcGxheWVkIHRocm91Z2ggZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICpcbiAgICogPiBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGUuIEl0IGRvZXMgbm90IHRyYWNrIHRoZSBwbGF5ZWQgYFRpbWVSYW5nZWAuXG4gICAqICAgICAgICAgSXQgb25seSBjaGVja3Mgd2V0aGVyIHRoZSBzb3VyY2UgaGFzIHBsYXllZCBhdCBhbGwgb3Igbm90LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgLSBBIHNpbmdsZSB0aW1lIHJhbmdlIGlmIHRoaXMgdmlkZW8gaGFzIHBsYXllZFxuICAgKiAgICAgICAgIC0gQW4gZW1wdHkgc2V0IG9mIHJhbmdlcyBpZiBub3QuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xuICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2F1c2VzIGEgbWFudWFsIHRpbWUgdXBkYXRlIHRvIG9jY3VyIGlmIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzT259IHdhc1xuICAgKiBwcmV2aW91c2x5IGNhbGxlZC5cbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtYW51YWwgYHRpbWV1cGRhdGVgIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvbiBsaXN0ZW5lcnMgZm9yIHtAbGluayBWaWRlb1RyYWNrTGlzdH0sIHtAbGluayB7QXVkaW9UcmFja0xpc3R9LCBhbmRcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGV2ZW50cy5cbiAgICpcbiAgICogVGhpcyBhZGRzIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyc30gZm9yIGBhZGR0cmFja2AsIGFuZCAgYHJlbW92ZXRyYWNrYC5cbiAgICpcbiAgICogQGZpcmVzIFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAqIEBmaXJlcyBUZWNoI3RleHR0cmFja2NoYW5nZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmluaXRUcmFja0xpc3RlbmVycyA9IGZ1bmN0aW9uIGluaXRUcmFja0xpc3RlbmVycygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCNhdWRpb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI3ZpZGVvdHJhY2tjaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciB0cmFja0xpc3RDaGFuZ2VzID0gZnVuY3Rpb24gdHJhY2tMaXN0Q2hhbmdlcygpIHtcbiAgICAgICAgX3RoaXMzLnRyaWdnZXIobmFtZSArICd0cmFja2NoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRyYWNrcyA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuXG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuXG4gICAgICBfdGhpczMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbXVsYXRlIFRleHRUcmFja3MgdXNpbmcgdnR0LmpzIGlmIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCN2dHRqc2xvYWRlZFxuICAgKiBAZmlyZXMgVGVjaCN2dHRqc2Vycm9yXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkV2ViVnR0U2NyaXB0XyA9IGZ1bmN0aW9uIGFkZFdlYlZ0dFNjcmlwdF8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAod2luZG93LldlYlZUVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSwgVGVjaC5lbF8gaXMgYSBjaGlsZCBvZiBhIGR1bW15LWRpdiB3YWl0IHVudGlsIHRoZSBDb21wb25lbnQgc3lzdGVtXG4gICAgLy8gc2lnbmFscyB0aGF0IHRoZSBUZWNoIGlzIHJlYWR5IGF0IHdoaWNoIHBvaW50IFRlY2guZWxfIGlzIHBhcnQgb2YgdGhlIERPTVxuICAgIC8vIGJlZm9yZSBpbnNlcnRpbmcgdGhlIFdlYlZUVCBzY3JpcHRcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmVsKCkpKSB7XG5cbiAgICAgIC8vIGxvYWQgdmlhIHJlcXVpcmUgaWYgYXZhaWxhYmxlIGFuZCB2dHQuanMgc2NyaXB0IGxvY2F0aW9uIHdhcyBub3QgcGFzc2VkIGluXG4gICAgICAvLyBhcyBhbiBvcHRpb24uIG5vdnR0IGJ1aWxkcyB3aWxsIHR1cm4gdGhlIGFib3ZlIHJlcXVpcmUgY2FsbCBpbnRvIGFuIGVtcHR5IG9iamVjdFxuICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB0aGlzIGlmIGNoZWNrIHRvIGFsd2F5cyBmYWlsLlxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnNfWyd2dHQuanMnXSAmJiBpc1BsYWluKHZ0dCkgJiYgT2JqZWN0LmtleXModnR0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndnR0anNsb2FkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIHZ0dC5qcyB2aWEgdGhlIHNjcmlwdCBsb2NhdGlvbiBvcHRpb24gb3IgdGhlIGNkbiBvZiBubyBsb2NhdGlvbiB3YXNcbiAgICAgIC8vIHBhc3NlZCBpblxuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICBzY3JpcHQuc3JjID0gdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gfHwgJ2h0dHBzOi8vdmpzLnplbmNkbi5uZXQvdnR0anMvMC4xMi40L3Z0dC5taW4uanMnO1xuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdnR0LmpzIGlzIGxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICB9O1xuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyB3YXMgbm90IGxvYWRlZCBkdWUgdG8gYW4gZXJyb3JcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ3Z0dGpzZXJyb3InKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICAvLyBidXQgaGF2ZSBub3QgbG9hZGVkIHlldCBhbmQgd2Ugc2V0IGl0IHRvIHRydWUgYmVmb3JlIHRoZSBpbmplY3Qgc28gdGhhdFxuICAgICAgLy8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbmplY3RlZCB3aW5kb3cuV2ViVlRUIGlmIGl0IGxvYWRzIHJpZ2h0IGF3YXlcbiAgICAgIHdpbmRvdy5XZWJWVFQgPSB0cnVlO1xuICAgICAgdGhpcy5lbCgpLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeSh0aGlzLmFkZFdlYlZ0dFNjcmlwdF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSB0ZXh0dHJhY2tzXG4gICAqXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZW11bGF0ZVRleHRUcmFja3MgPSBmdW5jdGlvbiBlbXVsYXRlVGV4dFRyYWNrcygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRleHRUcmFja3MoKTtcbiAgICB2YXIgcmVtb3RlVHJhY2tzID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCk7XG4gICAgdmFyIGhhbmRsZUFkZFRyYWNrID0gZnVuY3Rpb24gaGFuZGxlQWRkVHJhY2soZSkge1xuICAgICAgcmV0dXJuIHRyYWNrcy5hZGRUcmFjayhlLnRyYWNrKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVSZW1vdmVUcmFjayA9IGZ1bmN0aW9uIGhhbmRsZVJlbW92ZVRyYWNrKGUpIHtcbiAgICAgIHJldHVybiB0cmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgfTtcblxuICAgIHJlbW90ZVRyYWNrcy5vbignYWRkdHJhY2snLCBoYW5kbGVBZGRUcmFjayk7XG4gICAgcmVtb3RlVHJhY2tzLm9uKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcblxuICAgIHRoaXMuYWRkV2ViVnR0U2NyaXB0XygpO1xuXG4gICAgdmFyIHVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICB9O1xuXG4gICAgdmFyIHRleHRUcmFja3NDaGFuZ2VzID0gZnVuY3Rpb24gdGV4dFRyYWNrc0NoYW5nZXMoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRleHRUcmFja3NDaGFuZ2VzKCk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xuICAgICAgcmVtb3RlVHJhY2tzLm9mZigncmVtb3ZldHJhY2snLCBoYW5kbGVSZW1vdmVUcmFjayk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJucyBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t9XG4gICAqICAgICAgICAgVGhlIFRleHRUcmFjayB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCFraW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHRUcmFjayBraW5kIGlzIHJlcXVpcmVkIGJ1dCB3YXMgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVRyYWNrSGVscGVyKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZm9yIHVzZSBieSBhZGRSZW1vdGVUZXh0VHJhY2tcbiAgICpcbiAgICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb21cbiAgICogVGVjaCBpbiBvcmRlciB0byBjcmVhdGUgbmF0aXZlIG9yIGN1c3RvbSBUZXh0VHJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBUZXh0VHJhY2sgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmRdXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF0uXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIHZhciB0cmFjayA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICB0ZWNoOiB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFJFTU9URS5yZW1vdGVUZXh0RWwuVHJhY2tDbGFzcyh0cmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW1vdGUgdGV4dCB0cmFjayBvYmplY3QgYW5kIHJldHVybnMgYW4gaHRtbCB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiA+IE5vdGU6IFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBTZWUge0BsaW5rIFRlY2gjY3JlYXRlUmVtb3RlVGV4dFRyYWNrfSBmb3IgbW9yZSBkZXRhaWxlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdXG4gICAqICAgICAgICAtIFdoZW4gZmFsc2U6IHRoZSBUZXh0VHJhY2sgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdmlkZW9cbiAgICogICAgICAgICAgZWxlbWVudCB3aGVuZXZlciB0aGUgc291cmNlIGNoYW5nZXNcbiAgICogICAgICAgIC0gV2hlbiBUcnVlOiBUaGUgVGV4dFRyYWNrIHdpbGwgaGF2ZSB0byBiZSBjbGVhbmVkIHVwIG1hbnVhbGx5XG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgQW4gSHRtbCBUcmFjayBFbGVtZW50LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGZvciB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXF1aXZhbGVudFxuICAgKiAgICAgICAgICAgICB0byBcIm1hbnVhbENsZWFudXA9ZmFsc2VcIiBpbiB0aGUgZnV0dXJlLiBUaGUgbWFudWFsQ2xlYW51cCBwYXJhbWV0ZXIgd2lsbFxuICAgKiAgICAgICAgICAgICBhbHNvIGJlIHJlbW92ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBtYW51YWxDbGVhbnVwID0gYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKTtcblxuICAgIGlmIChtYW51YWxDbGVhbnVwICE9PSB0cnVlICYmIG1hbnVhbENsZWFudXAgIT09IGZhbHNlKSB7XG4gICAgICAvLyBkZXByZWNhdGlvbiB3YXJuaW5nXG4gICAgICBsb2ckMS53YXJuKCdDYWxsaW5nIGFkZFJlbW90ZVRleHRUcmFjayB3aXRob3V0IGV4cGxpY2l0bHkgc2V0dGluZyB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHRvIGB0cnVlYCBpcyBkZXByZWNhdGVkIGFuZCBkZWZhdWx0IHRvIGBmYWxzZWAgaW4gZnV0dXJlIHZlcnNpb24gb2YgdmlkZW8uanMnKTtcbiAgICAgIG1hbnVhbENsZWFudXAgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuYWRkVHJhY2tFbGVtZW50XyhodG1sVHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcblxuICAgIGlmIChtYW51YWxDbGVhbnVwICE9PSB0cnVlKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIFRleHRUcmFja0xpc3QgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuYXV0b1JlbW90ZVRleHRUcmFja3NfLmFkZFRyYWNrKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB0ZXh0IHRyYWNrIGZyb20gdGhlIHJlbW90ZSBgVGV4dFRyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2AgdG8gcmVtb3ZlIGZyb20gdGhlIGBUZXh0VHJhY2tMaXN0YFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIHZhciB0cmFja0VsZW1lbnQgPSB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKTtcblxuICAgIC8vIHJlbW92ZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgZnJvbSByZW1vdGUgbGlzdFxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkucmVtb3ZlVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICB0aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXy5yZW1vdmVUcmFjayh0cmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXG4gICAqIFBsYXliYWNrIFF1YWxpdHkgQVBJLlxuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBzZXQgYSBwb3N0ZXIgZnJvbSBhIGBUZWNoYC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc2V0UG9zdGVyID0gZnVuY3Rpb24gc2V0UG9zdGVyKCkge307XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlICdwbGF5c2luaW5lJyA8dmlkZW8+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSgpIHt9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBzZXQgb3IgdW5zZXQgdGhlICdwbGF5c2luaW5lJyA8dmlkZW8+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc2V0UGxheXNpbmxpbmUgPSBmdW5jdGlvbiBzZXRQbGF5c2lubGluZSgpIHt9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBtaW1lLXR5cGUuXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrIGZvciBzdXBwb3J0XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvY2FuUGxheVR5cGV9XG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyB0ZWNoLlxuICAgKlxuICAgKiBUaGUgYmFzZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgYW55IHR5cGUsIGJ1dCBzb3VyY2UgaGFuZGxlcnMgbWlnaHRcbiAgICogb3ZlcndyaXRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWVkaWEgdHlwZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5hdGl2ZSB2aWRlbyBlbGVtZW50J3MgcmVzcG9uc2VcbiAgICovXG5cblxuICBUZWNoLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNPYmpcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFRlY2guY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIGNhblBsYXlTb3VyY2Uoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFRlY2guY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xuICB9O1xuXG4gIC8qXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIFRlY2ggb3Igbm90LlxuICAgKiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhIENsYXNzIGxpa2UgYEh0bWw1YCBvciBhIGluc3RhbmNlIGxpa2UgYHBsYXllci50ZWNoX2BcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIGl0ZW0gdG8gY2hlY2tcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgdGVjaCBvciBub3RcbiAgICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZWNoXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiBpdCBpcyBub3RcbiAgICovXG5cblxuICBUZWNoLmlzVGVjaCA9IGZ1bmN0aW9uIGlzVGVjaChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50IGluc3RhbmNlb2YgVGVjaCB8fCBjb21wb25lbnQgPT09IFRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBUZWNoYCBpbnRvIGEgc2hhcmVkIGxpc3QgZm9yIHZpZGVvanMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBgVGVjaGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZWNoXG4gICAqICAgICAgICBUaGUgYFRlY2hgIGNsYXNzIHRvIHJlZ2lzdGVyLlxuICAgKi9cblxuXG4gIFRlY2gucmVnaXN0ZXJUZWNoID0gZnVuY3Rpb24gcmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpIHtcbiAgICBpZiAoIVRlY2gudGVjaHNfKSB7XG4gICAgICBUZWNoLnRlY2hzXyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghVGVjaC5pc1RlY2godGVjaCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaCAnICsgbmFtZSArICcgbXVzdCBiZSBhIFRlY2gnKTtcbiAgICB9XG5cbiAgICBpZiAoIVRlY2guY2FuUGxheVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaHMgbXVzdCBoYXZlIGEgc3RhdGljIGNhblBsYXlUeXBlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuICAgIGlmICghVGVjaC5jYW5QbGF5U291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5U291cmNlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgVGVjaC50ZWNoc19bbmFtZV0gPSB0ZWNoO1xuICAgIGlmIChuYW1lICE9PSAnVGVjaCcpIHtcbiAgICAgIC8vIGNhbWVsIGNhc2UgdGhlIHRlY2hOYW1lIGZvciB1c2UgaW4gdGVjaE9yZGVyXG4gICAgICBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0ZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGVjaGAgZnJvbSB0aGUgc2hhcmVkIGxpc3QgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIGBjYW1lbENhc2VgIG9yIGBUaXRsZUNhc2VgIG5hbWUgb2YgdGhlIFRlY2ggdG8gZ2V0XG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBgVGVjaGAgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIHdhcyBubyB0ZWNoIHdpdGggdGhlIG5hbWUgcmVxdXN0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5nZXRUZWNoID0gZnVuY3Rpb24gZ2V0VGVjaChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKFRlY2gudGVjaHNfICYmIFRlY2gudGVjaHNfW25hbWVdKSB7XG4gICAgICByZXR1cm4gVGVjaC50ZWNoc19bbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cudmlkZW9qcyAmJiB3aW5kb3cudmlkZW9qc1tuYW1lXSkge1xuICAgICAgbG9nJDEud2FybignVGhlICcgKyBuYW1lICsgJyB0ZWNoIHdhcyBhZGRlZCB0byB0aGUgdmlkZW9qcyBvYmplY3Qgd2hlbiBpdCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICAgICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGVjaDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VmlkZW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICBUZWNoLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3NcbiAqXG4gKiBAdHlwZSB7VGV4dFRyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN0ZXh0VHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIGF1ZGlvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7QXVkaW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjYXVkaW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdmlkZW8gdHJhY2tzLlxuICpcbiAqIEB0eXBlIHtWaWRlb1RyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN2aWRlb1RyYWNrc19cbiAqL1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVm9sdW1lQ29udHJvbCA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnQgZnVsbHNjcmVlbiByZXNpemUgY29udHJvbC5cbiAqIFJlc2l6aW5nIHBsdWdpbnMgdXNpbmcgcmVxdWVzdCBmdWxsc2NyZWVuIHJlbG9hZHMgdGhlIHBsdWdpblxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNGdWxsc2NyZWVuUmVzaXplID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGNoYW5naW5nIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgdmlkZW9cbiAqIHBsYXlzLiBFeGFtcGxlczpcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMnggKHR3aWNlKSBhcyBmYXN0XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDAuNXggKGhhbGYpIGFzIGZhc3RcbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50LiBUaGlzIGlzIGN1cnJlbnRseVxuICogbm90IHRyaWdnZXJlZCBieSB2aWRlby1qcy1zd2YuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBpZlxuICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn0gc2hvdWxkIGJlIGNhbGxlZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdGhlIGB0aW1ldXBkYXRlYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzfSBzaG91bGQgYmUgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBuYXRpdmUgYFRleHRUcmFja2BzLlxuICogVGhpcyB3aWxsIGhlbHAgdXMgaW50ZWdyYXRlIHdpdGggbmF0aXZlIGBUZXh0VHJhY2tgcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGVtLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG5cbi8qKlxuICogQSBmdW5jdGlvbmFsIG1peGluIGZvciB0ZWNocyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuLlxuICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxuICogVGhlIHNvdXJjZSBoYW5kbGVyIHBhdHRlcm4gaXMgdXNlZCBmb3IgYWRhcHRpdmUgZm9ybWF0cyAoSExTLCBEQVNIKSB0aGF0XG4gKiBtYW51YWxseSBsb2FkIHZpZGVvIGRhdGEgYW5kIGZlZWQgaXQgaW50byBhIFNvdXJjZSBCdWZmZXIgKE1lZGlhIFNvdXJjZSBFeHRlbnNpb25zKVxuICogRXhhbXBsZTogYFRlY2gud2l0aFNvdXJjZUhhbmRsZXJzLmNhbGwoTXlUZWNoKTtgXG4gKlxuICogQHBhcmFtIHtUZWNofSBfVGVjaFxuICogICAgICAgIFRoZSB0ZWNoIHRvIGFkZCBzb3VyY2UgaGFuZGxlciBmdW5jdGlvbnMgdG8uXG4gKlxuICogQG1peGVzIFRlY2h+U291cmNlSGFuZGxlckFkZGl0aW9uc1xuICovXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyA9IGZ1bmN0aW9uIChfVGVjaCkge1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHNvdXJjZSBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICAgICAgIFRoZSBzb3VyY2UgaGFuZGxlciBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuICAgKiAgICAgICAgUmVnaXN0ZXIgaXQgYXQgdGhlIGZvbGxvd2luZyBpbmRleFxuICAgKi9cbiAgX1RlY2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGluZGV4KSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICBpbmRleCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDAsIGhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gdHlwZS4gQWxzbyBjaGVja3MgdGhlXG4gICAqIFRlY2hzIHNvdXJjZUhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBfVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhblBsYXlUeXBlKHR5cGUpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBjYW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIFRPRE86IEFuc3dlciBxdWVzdGlvbjogc2hvdWxkICdwcm9iYWJseScgYmUgcHJpb3JpdGl6ZWQgb3ZlciAnbWF5YmUnXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VIYW5kbGVyfG51bGx9XG4gICAqICAgICAgICAgIFRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2Ugb3IgbnVsbCBpZlxuICAgKiAgICAgICAgICBubyBTb3VyY2VIYW5kbGVyIHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICovXG4gIF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhbkhhbmRsZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjT2JqXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIChzcmNPYmosIG9wdGlvbnMpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNyY09iaiwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2gpIHtcbiAgICAgIHJldHVybiBzaC5jYW5IYW5kbGVTb3VyY2Uoc3JjT2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNpbmcgYSBzb3VyY2UgaGFuZGxlciwgcHJlZmVyIGl0cyBpbXBsZW1lbnRhdGlvbiBvZlxuICAgKiBhbnkgZnVuY3Rpb24gbm9ybWFsbHkgcHJvdmlkZWQgYnkgdGhlIHRlY2guXG4gICAqL1xuICB2YXIgZGVmZXJyYWJsZSA9IFsnc2Vla2FibGUnLCAnZHVyYXRpb24nXTtcblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNzZWVrYWJsZX0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIHNlZWthYmxlXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgd2l0aCBhIGZhbGxiYWNrIHRvIHRoZSBUZWNocyBzZWVrYWJsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5zZWVrYWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNkdXJhdGlvbn0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIGR1cmF0aW9uXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGl0IHdpbGwgZmFsbGJhY2sgdG8gdGhlIHRlY2hzIGR1cmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9UZWNoLmR1cmF0aW9uXG4gICAqL1xuXG4gIGRlZmVycmFibGUuZm9yRWFjaChmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgdmFyIG9yaWdpbmFsRm4gPSB0aGlzW2ZuTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2ZuTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXS5hcHBseSh0aGlzLnNvdXJjZUhhbmRsZXJfLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCBfVGVjaC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgc291cmNlIHVzaW5nIGEgc291cmNlIG9iamVjdFxuICAgKiBhbmQgc291cmNlIGhhbmRsZXJzLlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyBhIHNvdXJjZSBoYW5kbGVyIHdhcyBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNvdXJjZSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICBpZiAoIXNoKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gYSBuYXRpdmUgc291cmNlIGhhbmRlciB3aGVuIHVuc3VwcG9ydGVkIHNvdXJjZXMgYXJlXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgc2V0XG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgICBzaCA9IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2ckMS5lcnJvcignTm8gc291cmNlIGhhbmRlciBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3Bvc2UgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcigpO1xuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICBpZiAoc2ggIT09IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IHNoLmhhbmRsZVNvdXJjZShzb3VyY2UsIHRoaXMsIHRoaXMub3B0aW9uc18pO1xuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgYW55IGV4aXN0aW5nIFNvdXJjZUhhbmRsZXJzIGFuZCBsaXN0ZW5lcnMgd2hlbiB0aGUgVGVjaCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNkaXNwb3NlXG4gICAqL1xuICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZVNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHNvdXJjZSBhbmQgZ2V0IGFub3RoZXIgb25lXG4gICAgLy8gdGhlbiB3ZSBhcmUgbG9hZGluZyBzb21ldGhpbmcgbmV3XG4gICAgLy8gdGhhbiBjbGVhciBhbGwgb2Ygb3VyIGN1cnJlbnQgdHJhY2tzXG4gICAgaWYgKHRoaXMuY3VycmVudFNvdXJjZV8pIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja3MoWydhdWRpbycsICd2aWRlbyddKTtcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBjbGVhbiB1cCBhdXRvLXRleHQgdHJhY2tzXG4gICAgdGhpcy5jbGVhbnVwQXV0b1RleHRUcmFja3MoKTtcblxuICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfKSB7XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBudWxsO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIFRoZSBiYXNlIFRlY2ggY2xhc3MgbmVlZHMgdG8gYmUgcmVnaXN0ZXJlZCBhcyBhIENvbXBvbmVudC4gSXQgaXMgdGhlIG9ubHlcbi8vIFRlY2ggdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBhcyBhIENvbXBvbmVudC5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGVjaCcsIFRlY2gpO1xuVGVjaC5yZWdpc3RlclRlY2goJ1RlY2gnLCBUZWNoKTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgdGVjaHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGVjaE9yZGVyIG9uIFBsYXllcnNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZWNoLmRlZmF1bHRUZWNoT3JkZXJfID0gW107XG5cbnZhciBtaWRkbGV3YXJlcyA9IHt9O1xuXG5mdW5jdGlvbiB1c2UodHlwZSwgbWlkZGxld2FyZSkge1xuICBtaWRkbGV3YXJlc1t0eXBlXSA9IG1pZGRsZXdhcmVzW3R5cGVdIHx8IFtdO1xuICBtaWRkbGV3YXJlc1t0eXBlXS5wdXNoKG1pZGRsZXdhcmUpO1xufVxuXG5cblxuZnVuY3Rpb24gc2V0U291cmNlKHBsYXllciwgc3JjLCBuZXh0KSB7XG4gIHBsYXllci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbc3JjLnR5cGVdLCBuZXh0LCBwbGF5ZXIpO1xuICB9LCAxKTtcbn1cblxuZnVuY3Rpb24gc2V0VGVjaChtaWRkbGV3YXJlLCB0ZWNoKSB7XG4gIG1pZGRsZXdhcmUuZm9yRWFjaChmdW5jdGlvbiAobXcpIHtcbiAgICByZXR1cm4gbXcuc2V0VGVjaCAmJiBtdy5zZXRUZWNoKHRlY2gpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0JDEobWlkZGxld2FyZSwgdGVjaCwgbWV0aG9kKSB7XG4gIHJldHVybiBtaWRkbGV3YXJlLnJlZHVjZVJpZ2h0KG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCB0ZWNoW21ldGhvZF0oKSk7XG59XG5cbmZ1bmN0aW9uIHNldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiB0ZWNoW21ldGhvZF0obWlkZGxld2FyZS5yZWR1Y2UobWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCksIGFyZykpO1xufVxuXG52YXIgYWxsb3dlZEdldHRlcnMgPSB7XG4gIGJ1ZmZlcmVkOiAxLFxuICBjdXJyZW50VGltZTogMSxcbiAgZHVyYXRpb246IDEsXG4gIHNlZWthYmxlOiAxLFxuICBwbGF5ZWQ6IDFcbn07XG5cbnZhciBhbGxvd2VkU2V0dGVycyA9IHtcbiAgc2V0Q3VycmVudFRpbWU6IDFcbn07XG5cbmZ1bmN0aW9uIG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgbXcpIHtcbiAgICBpZiAobXdbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuIG13W21ldGhvZF0odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0U291cmNlSGVscGVyKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgbmV4dCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHBsYXllciA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIGFjYyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIHZhciBsYXN0UnVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgdmFyIG13RmFjdG9yeSA9IG1pZGRsZXdhcmVbMF0sXG4gICAgICBtd3Jlc3QgPSBtaWRkbGV3YXJlLnNsaWNlKDEpO1xuXG4gIC8vIGlmIG13RmFjdG9yeSBpcyBhIHN0cmluZywgdGhlbiB3ZSdyZSBhdCBhIGZvcmsgaW4gdGhlIHJvYWRcblxuICBpZiAodHlwZW9mIG13RmFjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1ttd0ZhY3RvcnldLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFuIG13RmFjdG9yeSwgY2FsbCBpdCB3aXRoIHRoZSBwbGF5ZXIgdG8gZ2V0IHRoZSBtdyxcbiAgICAvLyB0aGVuIGNhbGwgdGhlIG13J3Mgc2V0U291cmNlIG1ldGhvZFxuICB9IGVsc2UgaWYgKG13RmFjdG9yeSkge1xuICAgIHZhciBtdyA9IG13RmFjdG9yeShwbGF5ZXIpO1xuXG4gICAgbXcuc2V0U291cmNlKGFzc2lnbih7fSwgc3JjKSwgZnVuY3Rpb24gKGVyciwgX3NyYykge1xuXG4gICAgICAvLyBzb21ldGhpbmcgaGFwcGVuZWQsIHRyeSB0aGUgbmV4dCBtaWRkbGV3YXJlIG9uIHRoZSBjdXJyZW50IGxldmVsXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gdXNlIHRoZSBvbGQgc3JjXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UndmUgc3VjY2VlZGVkLCBub3cgd2UgbmVlZCB0byBnbyBkZWVwZXJcbiAgICAgIGFjYy5wdXNoKG13KTtcblxuICAgICAgLy8gaWYgaXQncyB0aGUgc2FtZSB0aW1lLCBjb250aW51ZSBkb2VzIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICAvLyBvdGhlcndpc2UsIHdlIHdhbnQgdG8gZ28gZG93biB0aGUgbmV3IGNoYWluXG4gICAgICBzZXRTb3VyY2VIZWxwZXIoX3NyYywgc3JjLnR5cGUgPT09IF9zcmMudHlwZSA/IG13cmVzdCA6IG1pZGRsZXdhcmVzW19zcmMudHlwZV0sIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtd3Jlc3QubGVuZ3RoKSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbXdyZXN0LCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gIH0gZWxzZSBpZiAobGFzdFJ1bikge1xuICAgIG5leHQoc3JjLCBhY2MpO1xuICB9IGVsc2Uge1xuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzWycqJ10sIG5leHQsIHBsYXllciwgYWNjLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgZmlsdGVyLXNvdXJjZVxuICovXG4vKipcbiAqIEZpbHRlciBvdXQgc2luZ2xlIGJhZCBzb3VyY2Ugb2JqZWN0cyBvciBtdWx0aXBsZSBzb3VyY2Ugb2JqZWN0cyBpbiBhblxuICogYXJyYXkuIEFsc28gZmxhdHRlbnMgbmVzdGVkIHNvdXJjZSBvYmplY3QgYXJyYXlzIGludG8gYSAxIGRpbWVuc2lvbmFsXG4gKiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fFRlY2h+U291cmNlT2JqZWN0W119IHNyY1xuICogICAgICAgIFRoZSBzcmMgb2JqZWN0IHRvIGZpbHRlclxuICpcbiAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHNvdXJjZW9iamVjdHMgY29udGFpbmluZyBvbmx5IHZhbGlkIHNvdXJjZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZmlsdGVyU291cmNlID0gZnVuY3Rpb24gZmlsdGVyU291cmNlKHNyYykge1xuICAvLyB0cmF2ZXJzZSBhcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgdmFyIG5ld3NyYyA9IFtdO1xuXG4gICAgc3JjLmZvckVhY2goZnVuY3Rpb24gKHNyY29iaikge1xuICAgICAgc3Jjb2JqID0gZmlsdGVyU291cmNlKHNyY29iaik7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY29iaikpIHtcbiAgICAgICAgbmV3c3JjID0gbmV3c3JjLmNvbmNhdChzcmNvYmopO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzcmNvYmopKSB7XG4gICAgICAgIG5ld3NyYy5wdXNoKHNyY29iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzcmMgPSBuZXdzcmM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnRyaW0oKSkge1xuICAgIC8vIGNvbnZlcnQgc3RyaW5nIGludG8gb2JqZWN0XG4gICAgc3JjID0gW3sgc3JjOiBzcmMgfV07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3JjKSAmJiB0eXBlb2Ygc3JjLnNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnNyYyAmJiBzcmMuc3JjLnRyaW0oKSkge1xuICAgIC8vIHNyYyBpcyBhbHJlYWR5IHZhbGlkXG4gICAgc3JjID0gW3NyY107XG4gIH0gZWxzZSB7XG4gICAgLy8gaW52YWxpZCBzb3VyY2UsIHR1cm4gaXQgaW50byBhbiBlbXB0eSBhcnJheVxuICAgIHNyYyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHNyYztcbn07XG5cbi8qKlxuICogQGZpbGUgbG9hZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGBNZWRpYUxvYWRlcmAgaXMgdGhlIGBDb21wb25lbnRgIHRoYXQgZGVjaWRlcyB3aGljaCBwbGF5YmFjayB0ZWNobm9sb2d5IHRvIGxvYWRcbiAqIHdoZW4gYSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lZGlhTG9hZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVkaWFMb2FkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0cm9lIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBydW4gd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIE1lZGlhTG9hZGVyKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUxvYWRlcik7XG5cbiAgICAvLyBNZWRpYUxvYWRlciBoYXMgbm8gZWxlbWVudFxuICAgIHZhciBvcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7IGNyZWF0ZUVsOiBmYWxzZSB9LCBvcHRpb25zKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcbiAgICAvLyBsb2FkIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcGxheWJhY2sgdGVjaG5vbG9neS5cblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9uc18sIHJlYWR5KSk7XG5cbiAgICBpZiAoIW9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzIHx8IG9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBvcHRpb25zLnBsYXllck9wdGlvbnMudGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGVjaE5hbWUgPSB0b1RpdGxlQ2FzZShqW2ldKTtcbiAgICAgICAgdmFyIHRlY2ggPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgb2xkIGJlaGF2aW9yIG9mIHRlY2hzIGJlaW5nIHJlZ2lzdGVyZWQgYXMgY29tcG9uZW50cy5cbiAgICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICAgIGlmICghdGVjaE5hbWUpIHtcbiAgICAgICAgICB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRlY2ggJiYgdGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgcGxheWVyLmxvYWRUZWNoXyh0ZWNoTmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9vcCB0aHJvdWdoIHBsYXliYWNrIHRlY2hub2xvZ2llcyAoSFRNTDUsIEZsYXNoKSBhbmQgY2hlY2sgZm9yIHN1cHBvcnQuXG4gICAgICAvLyBUaGVuIGxvYWQgdGhlIGJlc3Qgc291cmNlLlxuICAgICAgLy8gQSBmZXcgYXNzdW1wdGlvbnMgaGVyZTpcbiAgICAgIC8vICAgQWxsIHBsYXliYWNrIHRlY2hub2xvZ2llcyByZXNwZWN0IHByZWxvYWQgZmFsc2UuXG4gICAgICBwbGF5ZXIuc3JjKG9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE1lZGlhTG9hZGVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lZGlhTG9hZGVyJywgTWVkaWFMb2FkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG4vKipcbiAqIENsaWNrYWJsZSBDb21wb25lbnQgd2hpY2ggaXMgY2xpY2thYmxlIG9yIGtleWJvYXJkIGFjdGlvbmFibGUsXG4gKiBidXQgaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBDbGlja2FibGVDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDbGlja2FibGVDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIENsaWNrYWJsZUNvbXBvbmVudChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlja2FibGVDb21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5lbWl0VGFwRXZlbnRzKCk7XG5cbiAgICBfdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPWRpdl1cbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkaXYnO1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdDcmVhdGluZyBhIENsaWNrYWJsZUNvbXBvbmVudCB3aXRoIGFuIEhUTUwgZWxlbWVudCBvZiAnICsgdGFnICsgJyBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBCdXR0b24gaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIGZvciBjbGlja2FibGUgZWxlbWVudCB3aGljaCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b25cbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcbiAgICAgICdyb2xlJzogJ2J1dHRvbicsXG5cbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgZWxlbWVudCBtYXkgY2hhbmdlXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFiSW5kZXhfID0gcHJvcHMudGFiSW5kZXg7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIHJlbW92ZSBjb250cm9sVGV4dEVsXyBvbiBkaXBvc2VcbiAgICB0aGlzLmNvbnRyb2xUZXh0RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29udHJvbCB0ZXh0IGVsZW1lbnQgb24gdGhpcyBgQ29tcG9uZW50YFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbF1cbiAgICogICAgICAgIFBhcmVudCBlbGVtZW50IGZvciB0aGUgY29udHJvbCB0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBjb250cm9sIHRleHQgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRyb2xUZXh0RWwgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sVGV4dEVsKGVsKSB7XG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCdcbiAgICB9KTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250cm9sVGV4dEVsXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sVGV4dCh0aGlzLmNvbnRyb2xUZXh0XywgZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbFRleHRFbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvY2FsaXplIHRleHQgdG8gdXNlIGZvciB0aGUgY29udHJvbHMgb24gdGhlIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAqICAgICAgICBDb250cm9sIHRleHQgZm9yIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsPXRoaXMuZWwoKV1cbiAgICogICAgICAgIEVsZW1lbnQgdG8gc2V0IHRoZSB0aXRsZSBvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIC0gVGhlIGNvbnRyb2wgdGV4dCB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNvbnRyb2xUZXh0ID0gZnVuY3Rpb24gY29udHJvbFRleHQodGV4dCkge1xuICAgIHZhciBlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5lbCgpO1xuXG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbFRleHRfIHx8ICdOZWVkIFRleHQnO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGl6ZWRUZXh0ID0gdGhpcy5sb2NhbGl6ZSh0ZXh0KTtcblxuICAgIHRoaXMuY29udHJvbFRleHRfID0gdGV4dDtcbiAgICB0ZXh0Q29udGVudCh0aGlzLmNvbnRyb2xUZXh0RWxfLCBsb2NhbGl6ZWRUZXh0KTtcbiAgICBpZiAoIXRoaXMubm9uSWNvbkNvbnRyb2wpIHtcbiAgICAgIC8vIFNldCB0aXRsZSBhdHRyaWJ1dGUgaWYgb25seSBhbiBpY29uIGlzIHNob3duXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbG9jYWxpemVkVGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jb250cm9sIHZqcy1idXR0b24gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgdGhpcy50YWJJbmRleF8pO1xuICAgICAgfVxuICAgICAgdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhpcyBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgIGlmICh0eXBlb2YgdGhpcy50YWJJbmRleF8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG4gICAgfVxuICAgIHRoaXMub2ZmKFsndGFwJywgJ2NsaWNrJ10sIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgIHRoaXMub2ZmKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub2ZmKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsaWNrYWJsZUNvbXBvbmVudGAgZ2V0czpcbiAgICogLSBDbGlja2VkICh2aWEgdGhlIGBjbGlja2AgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxuICAgKiAtIFRhcHBlZCAodmlhIHRoZSBgdGFwYCBldmVudCwgbGlzdGVuaW5nIHN0YXJ0cyBpbiB0aGUgY29uc3RydWN0b3IpXG4gICAqIC0gVGhlIGZvbGxvd2luZyB0aGluZ3MgaGFwcGVuIGluIG9yZGVyOlxuICAgKiAgIDEuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlRm9jdXN9IGlzIGNhbGxlZCB2aWEgYSBgZm9jdXNgIGV2ZW50IG9uIHRoZVxuICAgKiAgICAgIGBDbGlja2FibGVDb21wb25lbnRgLlxuICAgKiAgIDIuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlRm9jdXN9IGFkZHMgYSBsaXN0ZW5lciBmb3IgYGtleWRvd25gIG9uIHVzaW5nXG4gICAqICAgICAge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30uXG4gICAqICAgMy4gYENsaWNrYWJsZUNvbXBvbmVudGAgaGFzIG5vdCBoYWQgYSBgYmx1cmAgZXZlbnQgKGBibHVyYCBtZWFucyB0aGF0IGZvY3VzIHdhcyBsb3N0KS4gVGhlIHVzZXIgcHJlc3Nlc1xuICAgKiAgICAgIHRoZSBzcGFjZSBvciBlbnRlciBrZXkuXG4gICAqICAgNC4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBga2V5ZG93bmBcbiAgICogICAgICBldmVudCBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge307XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGdhaW5zIGZvY3VzIHZpYSBhIGBmb2N1c2AgZXZlbnQuXG4gICAqIFR1cm5zIG9uIGxpc3RlbmluZyBmb3IgYGtleWRvd25gIGV2ZW50cy4gV2hlbiB0aGV5IGhhcHBlbiBpdFxuICAgKiBjYWxscyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGZvY3VzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgZm9jdXNcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoZXZlbnQpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhpcyBDbGlja2FibGVDb21wb25lbnQgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQ2xpY2tgIHdoZW4gdGhlIGtleSBpcyBzcGFjZSBvciBlbnRlci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIFN1cHBvcnQgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24gdG8gZmlyZSBhIGNsaWNrIGV2ZW50XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgfSBlbHNlIGlmIChfQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcykge1xuXG4gICAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgYENsaWNrYWJsZUNvbXBvbmVudGAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgcmV0dXJuIENsaWNrYWJsZUNvbXBvbmVudDtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbGlja2FibGVDb21wb25lbnQnLCBDbGlja2FibGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBmaWxlIHBvc3Rlci1pbWFnZS5qc1xuICovXG4vKipcbiAqIEEgYENsaWNrYWJsZUNvbXBvbmVudGAgdGhhdCBoYW5kbGVzIHNob3dpbmcgdGhlIHBvc3RlciBpbWFnZSBmb3IgdGhlIHBsYXllci5cbiAqXG4gKiBAZXh0ZW5kcyBDbGlja2FibGVDb21wb25lbnRcbiAqL1xuXG52YXIgUG9zdGVySW1hZ2UgPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBpbmhlcml0cyhQb3N0ZXJJbWFnZSwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBhdHRhY2ggdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQb3N0ZXJJbWFnZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3N0ZXJJbWFnZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZSgpO1xuICAgIHBsYXllci5vbigncG9zdGVyY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFuZCBkaXNwb3NlIG9mIHRoZSBgUG9zdGVySW1hZ2VgLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLnBsYXllcigpLm9mZigncG9zdGVyY2hhbmdlJywgdGhpcy51cGRhdGUpO1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgUG9zdGVySW1hZ2VgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBvc3RlcicsXG5cbiAgICAgIC8vIERvbid0IHdhbnQgcG9zdGVyIHRvIGJlIHRhYmJhYmxlLlxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSk7XG5cbiAgICAvLyBUbyBlbnN1cmUgdGhlIHBvc3RlciBpbWFnZSByZXNpemVzIHdoaWxlIG1haW50YWluaW5nIGl0cyBvcmlnaW5hbCBhc3BlY3RcbiAgICAvLyByYXRpbywgdXNlIGEgZGl2IHdpdGggYGJhY2tncm91bmQtc2l6ZWAgd2hlbiBhdmFpbGFibGUuIEZvciBicm93c2VycyB0aGF0XG4gICAgLy8gZG8gbm90IHN1cHBvcnQgYGJhY2tncm91bmQtc2l6ZWAgKGUuZy4gSUU4KSwgZmFsbCBiYWNrIG9uIHVzaW5nIGEgcmVndWxhclxuICAgIC8vIGltZyBlbGVtZW50LlxuICAgIGlmICghQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRCkge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18gPSBjcmVhdGVFbCgnaW1nJyk7XG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmZhbGxiYWNrSW1nXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbiB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm9yIHtAbGluayBQbGF5ZXIjcG9zdGVyY2hhbmdlfSBldmVudHMuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXIjcG9zdGVyY2hhbmdlYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgdXJsID0gdGhpcy5wbGF5ZXIoKS5wb3N0ZXIoKTtcblxuICAgIHRoaXMuc2V0U3JjKHVybCk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBvc3RlciBzb3VyY2Ugd2Ugc2hvdWxkIGRpc3BsYXk6bm9uZSBvbiB0aGlzIGNvbXBvbmVudFxuICAgIC8vIHNvIGl0J3Mgbm90IHN0aWxsIGNsaWNrYWJsZSBvciByaWdodC1jbGlja2FibGVcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBvZiB0aGUgYFBvc3RlckltYWdlYCBkZXBlbmRpbmcgb24gdGhlIGRpc3BsYXkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqICAgICAgICBUaGUgVVJMIHRvIHRoZSBzb3VyY2UgZm9yIHRoZSBgUG9zdGVySW1hZ2VgLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5zZXRTcmMgPSBmdW5jdGlvbiBzZXRTcmModXJsKSB7XG4gICAgaWYgKHRoaXMuZmFsbGJhY2tJbWdfKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXy5zcmMgPSB1cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSAnJztcblxuICAgICAgLy8gQW55IGZhbHNleSB2YWx1ZXMgc2hvdWxkIHN0YXkgYXMgYW4gZW1wdHkgc3RyaW5nLCBvdGhlcndpc2VcbiAgICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBhbiBleHRyYSBlcnJvclxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIHVybCArICdcIiknO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsXy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbiB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm9yIGNsaWNrcyBvbiB0aGUgYFBvc3RlckltYWdlYC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICsgICAgICAgIFRoZSBgY2xpY2tgLCBgdGFwYCBvciBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IGEgY2xpY2sgdG8gdHJpZ2dlciBwbGF5YmFjayB3aGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZFxuICAgIGlmICghdGhpcy5wbGF5ZXJfLmNvbnRyb2xzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvc3RlckltYWdlO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Bvc3RlckltYWdlJywgUG9zdGVySW1hZ2UpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stZGlzcGxheS5qc1xuICovXG52YXIgZGFya0dyYXkgPSAnIzIyMic7XG52YXIgbGlnaHRHcmF5ID0gJyNjY2MnO1xudmFyIGZvbnRNYXAgPSB7XG4gIG1vbm9zcGFjZTogJ21vbm9zcGFjZScsXG4gIHNhbnNTZXJpZjogJ3NhbnMtc2VyaWYnLFxuICBzZXJpZjogJ3NlcmlmJyxcbiAgbW9ub3NwYWNlU2Fuc1NlcmlmOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZScsXG4gIG1vbm9zcGFjZVNlcmlmOiAnXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UnLFxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgcHJvcG9ydGlvbmFsU2VyaWY6ICdzZXJpZicsXG4gIGNhc3VhbDogJ1wiQ29taWMgU2FucyBNU1wiLCBJbXBhY3QsIGZhbnRhc3knLFxuICBzY3JpcHQ6ICdcIk1vbm90eXBlIENvcnNpdmFcIiwgY3Vyc2l2ZScsXG4gIHNtYWxsY2FwczogJ1wiQW5kYWxlIE1vbm9cIiwgXCJMdWNpZGEgQ29uc29sZVwiLCBtb25vc3BhY2UsIHNhbnMtc2VyaWYnXG59O1xuXG4vKipcbiAqIENvbnN0cnVjdCBhbiByZ2JhIGNvbG9yIGZyb20gYSBnaXZlbiBoZXggY29sb3IgY29kZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29sb3JcbiAqICAgICAgICBIZXggbnVtYmVyIGZvciBjb2xvciwgbGlrZSAjZjBlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5XG4gKiAgICAgICAgVmFsdWUgZm9yIG9wYWNpdHksIDAuMCAtIDEuMC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSByZ2JhIGNvbG9yIHRoYXQgd2FzIGNyZWF0ZWQsIGxpa2UgJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RDb2xvcihjb2xvciwgb3BhY2l0eSkge1xuICByZXR1cm4gJ3JnYmEoJyArXG4gIC8vIGNvbG9yIGxvb2tzIGxpa2UgXCIjZjBlXCJcbiAgcGFyc2VJbnQoY29sb3JbMV0gKyBjb2xvclsxXSwgMTYpICsgJywnICsgcGFyc2VJbnQoY29sb3JbMl0gKyBjb2xvclsyXSwgMTYpICsgJywnICsgcGFyc2VJbnQoY29sb3JbM10gKyBjb2xvclszXSwgMTYpICsgJywnICsgb3BhY2l0eSArICcpJztcbn1cblxuLyoqXG4gKiBUcnkgdG8gdXBkYXRlIHRoZSBzdHlsZSBvZiBhIERPTSBlbGVtZW50LiBTb21lIHN0eWxlIGNoYW5nZXMgd2lsbCB0aHJvdyBhbiBlcnJvcixcbiAqIHBhcnRpY3VsYXJseSBpbiBJRTguIFRob3NlIHNob3VsZCBiZSBub29wcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIERPTSBlbGVtZW50IHRvIGJlIHN0eWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqICAgICAgICBUaGUgQ1NTIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHN0eWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogICAgICAgIFRoZSBzdHlsZSBydWxlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyeVVwZGF0ZVN0eWxlKGVsLCBzdHlsZSwgcnVsZSkge1xuICB0cnkge1xuICAgIGVsLnN0eWxlW3N0eWxlXSA9IHJ1bGU7XG4gIH0gY2F0Y2ggKGUpIHtcblxuICAgIC8vIFNhdGlzZmllcyBsaW50ZXIuXG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgZGlzcGxheWluZyB0ZXh0IHRyYWNrIGN1ZXMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRleHRUcmFja0Rpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZXh0VHJhY2tEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBgVGV4dFRyYWNrRGlzcGxheWAgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tEaXNwbGF5KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgYmluZChfdGhpcywgX3RoaXMudG9nZ2xlRGlzcGxheSkpO1xuICAgIHBsYXllci5vbigndGV4dHRyYWNrY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSkpO1xuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgYmluZChfdGhpcywgX3RoaXMucHJlc2VsZWN0VHJhY2spKTtcblxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSBjYWxsZWQgZHVyaW5nIHBsYXllciBpbml0LCBidXQgd2FzIGNhdXNpbmcgYW4gZXJyb3JcbiAgICAvLyBpZiBhIHRyYWNrIHNob3VsZCBzaG93IGJ5IGRlZmF1bHQgYW5kIHRoZSBkaXNwbGF5IGhhZG4ndCBsb2FkZWQgeWV0LlxuICAgIC8vIFNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0byBhbiBleHRlcm5hbCB0cmFjayBsb2FkZXIgd2hlbiB3ZSBzdXBwb3J0XG4gICAgLy8gdHJhY2tzIHRoYXQgZG9uJ3QgbmVlZCBhIGRpc3BsYXkuXG4gICAgcGxheWVyLnJlYWR5KGJpbmQoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwbGF5ZXIudGVjaF8gJiYgcGxheWVyLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwbGF5ZXIub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBiaW5kKHRoaXMsIHRoaXMudXBkYXRlRGlzcGxheSkpO1xuXG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zLnRyYWNrcyB8fCBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wbGF5ZXJfLmFkZFJlbW90ZVRleHRUcmFjayh0cmFja3NbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXNlbGVjdFRyYWNrKCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFByZXNlbGVjdCBhIHRyYWNrIGZvbGxvd2luZyB0aGlzIHByZWNlZGVuY2U6XG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgKiAtIG1hdGNoZXMgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQge0BsaW5rIFRleHRUcmFja30ncyBsYW5ndWFnZSBvbmx5XG4gICogLSBpcyB0aGUgZmlyc3QgZGVmYXVsdCBjYXB0aW9ucyB0cmFja1xuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgZGVzY3JpcHRpb25zIHRyYWNrXG4gICpcbiAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS5wcmVzZWxlY3RUcmFjayA9IGZ1bmN0aW9uIHByZXNlbGVjdFRyYWNrKCkge1xuICAgIHZhciBtb2RlcyA9IHsgY2FwdGlvbnM6IDEsIHN1YnRpdGxlczogMSB9O1xuICAgIHZhciB0cmFja0xpc3QgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuICAgIHZhciB1c2VyUHJlZiA9IHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZTtcbiAgICB2YXIgZmlyc3REZXNjID0gdm9pZCAwO1xuICAgIHZhciBmaXJzdENhcHRpb25zID0gdm9pZCAwO1xuICAgIHZhciBwcmVmZXJyZWRUcmFjayA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja0xpc3RbaV07XG5cbiAgICAgIGlmICh1c2VyUHJlZiAmJiB1c2VyUHJlZi5lbmFibGVkICYmIHVzZXJQcmVmLmxhbmd1YWdlID09PSB0cmFjay5sYW5ndWFnZSkge1xuICAgICAgICAvLyBBbHdheXMgY2hvb3NlIHRoZSB0cmFjayB0aGF0IG1hdGNoZXMgYm90aCBsYW5ndWFnZSBhbmQga2luZFxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gdXNlclByZWYua2luZCkge1xuICAgICAgICAgIHByZWZlcnJlZFRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgLy8gb3IgY2hvb3NlIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgbGFuZ3VhZ2VcbiAgICAgICAgfSBlbHNlIGlmICghcHJlZmVycmVkVHJhY2spIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgZXZlcnl0aGluZyBpZiBvZmZUZXh0VHJhY2tNZW51SXRlbSB3YXMgY2xpY2tlZFxuICAgICAgfSBlbHNlIGlmICh1c2VyUHJlZiAmJiAhdXNlclByZWYuZW5hYmxlZCkge1xuICAgICAgICBwcmVmZXJyZWRUcmFjayA9IG51bGw7XG4gICAgICAgIGZpcnN0RGVzYyA9IG51bGw7XG4gICAgICAgIGZpcnN0Q2FwdGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0cmFja1snZGVmYXVsdCddKSB7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAnZGVzY3JpcHRpb25zJyAmJiAhZmlyc3REZXNjKSB7XG4gICAgICAgICAgZmlyc3REZXNjID0gdHJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCBpbiBtb2RlcyAmJiAhZmlyc3RDYXB0aW9ucykge1xuICAgICAgICAgIGZpcnN0Q2FwdGlvbnMgPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBwcmVmZXJyZWRUcmFjayBtYXRjaGVzIHRoZSB1c2VyIHByZWZlcmVuY2UgYW5kIHRha2VzXG4gICAgLy8gcHJlY2VuZGVuY2Ugb3ZlciBhbGwgdGhlIG90aGVyIHRyYWNrcy5cbiAgICAvLyBTbywgZGlzcGxheSB0aGUgcHJlZmVycmVkVHJhY2sgYmVmb3JlIHRoZSBmaXJzdCBkZWZhdWx0IHRyYWNrXG4gICAgLy8gYW5kIHRoZSBzdWJ0aXRsZXMvY2FwdGlvbnMgdHJhY2sgYmVmb3JlIHRoZSBkZXNjcmlwdGlvbnMgdHJhY2tcbiAgICBpZiAocHJlZmVycmVkVHJhY2spIHtcbiAgICAgIHByZWZlcnJlZFRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdENhcHRpb25zKSB7XG4gICAgICBmaXJzdENhcHRpb25zLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfSBlbHNlIGlmIChmaXJzdERlc2MpIHtcbiAgICAgIGZpcnN0RGVzYy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHVybiBkaXNwbGF5IG9mIHtAbGluayBUZXh0VHJhY2t9J3MgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBpbnRvIHRoZSBvdGhlciBzdGF0ZS5cbiAgICogVGhlcmUgYXJlIG9ubHkgdHdvIHN0YXRlczpcbiAgICogLSAnc2hvd24nXG4gICAqIC0gJ2hpZGRlbidcbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnRvZ2dsZURpc3BsYXkgPSBmdW5jdGlvbiB0b2dnbGVEaXNwbGF5KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaF8gJiYgdGhpcy5wbGF5ZXJfLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB7QGxpbmsgQ29tcG9uZW50fSdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRleHQtdHJhY2stZGlzcGxheSdcbiAgICB9LCB7XG4gICAgICAnYXJpYS1saXZlJzogJ29mZicsXG4gICAgICAnYXJpYS1hdG9taWMnOiAndHJ1ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGRpc3BsYXllZCB7QGxpbmsgVGV4dFRyYWNrfXMuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY2xlYXJEaXNwbGF5ID0gZnVuY3Rpb24gY2xlYXJEaXNwbGF5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlZUVCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93LldlYlZUVC5wcm9jZXNzQ3Vlcyh3aW5kb3csIFtdLCB0aGlzLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBUZXh0VHJhY2sgd2hlbiBhIGVpdGhlciBhIHtAbGluayBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlfSBvclxuICAgKiBhIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gaXMgZmlyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIHRoaXMuY2xlYXJEaXNwbGF5KCk7XG5cbiAgICAvLyBUcmFjayBkaXNwbGF5IHByaW9yaXRpemF0aW9uIG1vZGVsOiBpZiBtdWx0aXBsZSB0cmFja3MgYXJlICdzaG93aW5nJyxcbiAgICAvLyAgZGlzcGxheSB0aGUgZmlyc3QgJ3N1YnRpdGxlcycgb3IgJ2NhcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZycsXG4gICAgLy8gIG90aGVyd2lzZSBkaXNwbGF5IHRoZSBmaXJzdCAnZGVzY3JpcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZydcblxuICAgIHZhciBkZXNjcmlwdGlvbnNUcmFjayA9IG51bGw7XG4gICAgdmFyIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSBudWxsO1xuICAgIHZhciBpID0gdHJhY2tzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycpIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbnNUcmFjayA9IHRyYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnb2ZmJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uc1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnYXNzZXJ0aXZlJykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhkZXNjcmlwdGlvbnNUcmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIFRleHR0cmFja30gdG8gdG8gdGhlIHtAbGluayBUZWNofXMge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRleHQgdHJhY2sgb2JqZWN0IHRvIGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUZvclRyYWNrID0gZnVuY3Rpb24gdXBkYXRlRm9yVHJhY2sodHJhY2spIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgIT09ICdmdW5jdGlvbicgfHwgIXRyYWNrLmFjdGl2ZUN1ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcnJpZGVzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja1NldHRpbmdzLmdldFZhbHVlcygpO1xuICAgIHZhciBjdWVzID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHJhY2suYWN0aXZlQ3Vlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGN1ZXMucHVzaCh0cmFjay5hY3RpdmVDdWVzW19pXSk7XG4gICAgfVxuXG4gICAgd2luZG93LldlYlZUVC5wcm9jZXNzQ3Vlcyh3aW5kb3csIGN1ZXMsIHRoaXMuZWxfKTtcblxuICAgIHZhciBpID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgaWYgKCFjdWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdWVEaXYgPSBjdWUuZGlzcGxheVN0YXRlO1xuXG4gICAgICBpZiAob3ZlcnJpZGVzLmNvbG9yKSB7XG4gICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmNvbG9yID0gb3ZlcnJpZGVzLmNvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkge1xuICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYuZmlyc3RDaGlsZCwgJ2NvbG9yJywgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLmNvbG9yIHx8ICcjZmZmJywgb3ZlcnJpZGVzLnRleHRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kT3BhY2l0eSkge1xuICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYuZmlyc3RDaGlsZCwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IgfHwgJyMwMDAnLCBvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMud2luZG93Q29sb3IpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy53aW5kb3dPcGFjaXR5KSB7XG4gICAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LCAnYmFja2dyb3VuZENvbG9yJywgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLndpbmRvd0NvbG9yLCBvdmVycmlkZXMud2luZG93T3BhY2l0eSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVycmlkZXMud2luZG93Q29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZHJvcHNoYWRvdycpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzJweCAycHggM3B4ICcgKyBkYXJrR3JheSArICcsIDJweCAycHggNHB4ICcgKyBkYXJrR3JheSArICcsIDJweCAycHggNXB4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAncmFpc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4ICcgKyBkYXJrR3JheSArICcsIDNweCAzcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdkZXByZXNzZWQnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcxcHggMXB4ICcgKyBsaWdodEdyYXkgKyAnLCAwIDFweCAnICsgbGlnaHRHcmF5ICsgJywgLTFweCAtMXB4ICcgKyBkYXJrR3JheSArICcsIDAgLTFweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3VuaWZvcm0nKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5mb250UGVyY2VudCAmJiBvdmVycmlkZXMuZm9udFBlcmNlbnQgIT09IDEpIHtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gd2luZG93LnBhcnNlRmxvYXQoY3VlRGl2LnN0eWxlLmZvbnRTaXplKTtcblxuICAgICAgICBjdWVEaXYuc3R5bGUuZm9udFNpemUgPSBmb250U2l6ZSAqIG92ZXJyaWRlcy5mb250UGVyY2VudCArICdweCc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS50b3AgPSAnYXV0byc7XG4gICAgICAgIGN1ZURpdi5zdHlsZS5ib3R0b20gPSAnMnB4JztcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSAmJiBvdmVycmlkZXMuZm9udEZhbWlseSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMuZm9udEZhbWlseSA9PT0gJ3NtYWxsLWNhcHMnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udFZhcmlhbnQgPSAnc21hbGwtY2Fwcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udEZhbWlseSA9IGZvbnRNYXBbb3ZlcnJpZGVzLmZvbnRGYW1pbHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja0Rpc3BsYXknLCBUZXh0VHJhY2tEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBsb2FkaW5nLXNwaW5uZXIuanNcbiAqL1xuLyoqXG4gKiBBIGxvYWRpbmcgc3Bpbm5lciBmb3IgdXNlIGR1cmluZyB3YWl0aW5nL2xvYWRpbmcgZXZlbnRzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMb2FkaW5nU3Bpbm5lciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKExvYWRpbmdTcGlubmVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMb2FkaW5nU3Bpbm5lcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkaW5nU3Bpbm5lcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBMb2FkaW5nU3Bpbm5lcmBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG4gIExvYWRpbmdTcGlubmVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZGluZy1zcGlubmVyJyxcbiAgICAgIGRpcjogJ2x0cidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTG9hZGluZ1NwaW5uZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTG9hZGluZ1NwaW5uZXInLCBMb2FkaW5nU3Bpbm5lcik7XG5cbi8qKlxuICogQGZpbGUgYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJ1dHRvbnMuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKEJ1dHRvbiwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBCdXR0b25gcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9XCJidXR0b25cIl1cbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLiBUaGlzIGFyZ3VtZW50IGlzIElHTk9SRUQ6IG5vIG1hdHRlciB3aGF0XG4gICAqICAgICAgICBpcyBwYXNzZWQsIGl0IHdpbGwgYWx3YXlzIGNyZWF0ZSBhIGBidXR0b25gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG4gIEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0YWcpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHRhZyA9ICdidXR0b24nO1xuXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0sIHByb3BzKTtcblxuICAgIC8vIEFkZCBhdHRyaWJ1dGVzIGZvciBidXR0b24gZWxlbWVudFxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuXG4gICAgICAvLyBOZWNlc3Nhcnkgc2luY2UgdGhlIGRlZmF1bHQgYnV0dG9uIHR5cGUgaXMgXCJzdWJtaXRcIlxuICAgICAgJ3R5cGUnOiAnYnV0dG9uJyxcblxuICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBidXR0b24gbWF5IGNoYW5nZVxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSwgYXR0cmlidXRlcyk7XG5cbiAgICB2YXIgZWwgPSBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdGFnLCBwcm9wcywgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xUZXh0RWwoZWwpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjaGlsZCBgQ29tcG9uZW50YCBpbnNpZGUgb2YgdGhpcyBgQnV0dG9uYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8Q29tcG9uZW50fSBjaGlsZFxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2Ygb3B0aW9ucyB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBjaGlsZHJlbiBvZlxuICAgKiAgICAgICAgdGhlIGNoaWxkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ2V0cyBhZGRlZCBhcyBhIGNoaWxkLiBXaGVuIHVzaW5nIGEgc3RyaW5nIHRoZVxuICAgKiAgICAgICAgIGBDb21wb25lbnRgIHdpbGwgZ2V0IGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDVcbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgbG9nJDEud2FybignQWRkaW5nIGFuIGFjdGlvbmFibGUgKHVzZXIgY29udHJvbGxhYmxlKSBjaGlsZCB0byBhIEJ1dHRvbiAoJyArIGNsYXNzTmFtZSArICcpIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIENsaWNrYWJsZUNvbXBvbmVudCBpbnN0ZWFkLicpO1xuXG4gICAgLy8gQXZvaWQgdGhlIGVycm9yIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IENsaWNrYWJsZUNvbXBvbmVudCdzIGFkZENoaWxkIG1ldGhvZFxuICAgIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkLmNhbGwodGhpcywgY2hpbGQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGBCdXR0b25gIGVsZW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgYWN0aXZhdGVkIG9yIGNsaWNrZWQuIFVzZSB0aGlzIHdpdGhcbiAgICoge0BsaW5rIEJ1dHRvbiNkaXNhYmxlfS5cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbm5vdCBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxuICAgKiB7QGxpbmsgQnV0dG9uI2VuYWJsZX0uXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQnV0dG9uYCBoYXMgZm9jdXMgYW5kIGBrZXlkb3duYCBpcyB0cmlnZ2VyZWQgdmlhIGEga2V5XG4gICAqIHByZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gSWdub3JlIFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBicm93c2VyIGZvciBhIGJ1dHRvbi5cbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICByZXR1cm4gQnV0dG9uO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0J1dHRvbicsIEJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgYmlnLXBsYXktYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGluaXRpYWwgcGxheSBidXR0b24gdGhhdCBzaG93cyBiZWZvcmUgdGhlIHZpZGVvIGhhcyBwbGF5ZWQuIFRoZSBoaWRpbmcgb2YgdGhlXG4gKiBgQmlnUGxheUJ1dHRvbmAgZ2V0IGRvbmUgdmlhIENTUyBhbmQgYFBsYXllcmAgc3RhdGVzLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBCaWdQbGF5QnV0dG9uID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoQmlnUGxheUJ1dHRvbiwgX0J1dHRvbik7XG5cbiAgZnVuY3Rpb24gQmlnUGxheUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCaWdQbGF5QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubW91c2V1c2VkXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMub24oJ21vdXNlZG93bicsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC4gQWx3YXlzIHJldHVybnMgJ3Zqcy1iaWctcGxheS1idXR0b24nLlxuICAgKi9cblxuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWJpZy1wbGF5LWJ1dHRvbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBCaWdQbGF5QnV0dG9uYCBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgcGxheVByb21pc2UgPSB0aGlzLnBsYXllcl8ucGxheSgpO1xuXG4gICAgLy8gZXhpdCBlYXJseSBpZiBjbGlja2VkIHZpYSB0aGUgbW91c2VcbiAgICBpZiAodGhpcy5tb3VzZXVzZWRfICYmIGV2ZW50LmNsaWVudFggJiYgZXZlbnQuY2xpZW50WSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYiA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgnY29udHJvbEJhcicpO1xuICAgIHZhciBwbGF5VG9nZ2xlID0gY2IgJiYgY2IuZ2V0Q2hpbGQoJ3BsYXlUb2dnbGUnKTtcblxuICAgIGlmICghcGxheVRvZ2dsZSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBsYXlGb2N1cyA9IGZ1bmN0aW9uIHBsYXlGb2N1cygpIHtcbiAgICAgIHJldHVybiBwbGF5VG9nZ2xlLmZvY3VzKCk7XG4gICAgfTtcblxuICAgIGlmIChpc1Byb21pc2UocGxheVByb21pc2UpKSB7XG4gICAgICBwbGF5UHJvbWlzZS50aGVuKHBsYXlGb2N1cywgZnVuY3Rpb24gKCkge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRpbWVvdXQocGxheUZvY3VzLCAxKTtcbiAgICB9XG4gIH07XG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIHRoaXMubW91c2V1c2VkXyA9IGZhbHNlO1xuXG4gICAgX0J1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZXVzZWRfID0gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gQmlnUGxheUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBCaWdQbGF5QnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5CaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheSBWaWRlbyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQmlnUGxheUJ1dHRvbicsIEJpZ1BsYXlCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNsb3NlLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBgQ2xvc2VCdXR0b25gIGlzIGEgYHtAbGluayBCdXR0b259YCB0aGF0IGZpcmVzIGEgYGNsb3NlYCBldmVudCB3aGVuXG4gKiBpdCBnZXRzIGNsaWNrZWQuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIENsb3NlQnV0dG9uID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoQ2xvc2VCdXR0b24sIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDbG9zZUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbG9zZUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmNvbnRyb2xUZXh0KG9wdGlvbnMgJiYgb3B0aW9ucy5jb250cm9sVGV4dCB8fCBfdGhpcy5sb2NhbGl6ZSgnQ2xvc2UnKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDbG9zZUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2xvc2UtYnV0dG9uICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbG9zZUJ1dHRvbmAgZ2V0cyBjbGlja2VkLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2hlbiB0aGlzIHdpbGwgYmVcbiAgICogdHJpZ2dlcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAZmlyZXMgQ2xvc2VCdXR0b24jY2xvc2VcbiAgICovXG5cblxuICBDbG9zZUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGEgYENsb3NlQnV0dG9uYCBpcyBjbGlja2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IENsb3NlQnV0dG9uI2Nsb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnViYmxlcz1mYWxzZV1cbiAgICAgKiAgICAgICAgICAgc2V0IHRvIGZhbHNlIHNvIHRoYXQgdGhlIGNsb3NlIGV2ZW50IGRvZXMgbm90XG4gICAgICogICAgICAgICAgIGJ1YmJsZSB1cCB0byBwYXJlbnRzIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Nsb3NlJywgYnViYmxlczogZmFsc2UgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENsb3NlQnV0dG9uO1xufShCdXR0b24pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Nsb3NlQnV0dG9uJywgQ2xvc2VCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXktdG9nZ2xlLmpzXG4gKi9cbi8qKlxuICogQnV0dG9uIHRvIHRvZ2dsZSBiZXR3ZWVuIHBsYXkgYW5kIHBhdXNlLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBQbGF5VG9nZ2xlID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheVRvZ2dsZSwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5VG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlUb2dnbGUpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdwbGF5JywgX3RoaXMuaGFuZGxlUGxheSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncGF1c2UnLCBfdGhpcy5oYW5kbGVQYXVzZSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5LWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5VG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCBvbmNlIGFmdGVyIHRoZSB2aWRlbyBoYXMgZW5kZWQgYW5kIHRoZSB1c2VyIHNlZWtzIHNvIHRoYXRcbiAgICogd2UgY2FuIGNoYW5nZSB0aGUgcmVwbGF5IGJ1dHRvbiBiYWNrIHRvIGEgcGxheSBidXR0b24uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3NlZWtlZFxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVNlZWtlZCA9IGZ1bmN0aW9uIGhhbmRsZVNlZWtlZChldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5oYW5kbGVQYXVzZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlUGxheShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1wbGF5aW5nIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcGxheVxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVBsYXkgPSBmdW5jdGlvbiBoYW5kbGVQbGF5KGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBhdXNlXCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1wYXVzZWQgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwYXVzZVxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZVBhdXNlID0gZnVuY3Rpb24gaGFuZGxlUGF1c2UoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGxheVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHZqcy1lbmRlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZW5kZWQnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUmVwbGF5XCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdSZXBsYXknKTtcblxuICAgIC8vIG9uIHRoZSBuZXh0IHNlZWsgcmVtb3ZlIHRoZSByZXBsYXkgYnV0dG9uXG4gICAgdGhpcy5vbmUodGhpcy5wbGF5ZXJfLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVTZWVrZWQpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5VG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXlUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5JztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5VG9nZ2xlJywgUGxheVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgZm9ybWF0LXRpbWUuanNcbiAqIEBtb2R1bGUgRm9ybWF0LXRpbWVcbiAqL1xuXG4vKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTUy4gU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpXG4gKiB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAqICAgICAgICBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBndWlkZVxuICogICAgICAgIE51bWJlciAoaW4gc2Vjb25kcykgdG8gbW9kZWwgdGhlIHN0cmluZyBhZnRlclxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRpbWUoc2Vjb25kcykge1xuICB2YXIgZ3VpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHNlY29uZHM7XG5cbiAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICB2YXIgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICB2YXIgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICB2YXIgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XG4gIHZhciBnaCA9IE1hdGguZmxvb3IoZ3VpZGUgLyAzNjAwKTtcblxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyAnLScgaXMgZmFsc2UgZm9yIGFsbCByZWxhdGlvbmFsIG9wZXJhdG9ycyAoZS5nLiA8LCA+PSkgc28gdGhpcyBzZXR0aW5nXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgaCA9IG0gPSBzID0gJy0nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gIGggPSBoID4gMCB8fCBnaCA+IDAgPyBoICsgJzonIDogJyc7XG5cbiAgLy8gSWYgaG91cnMgYXJlIHNob3dpbmcsIHdlIG1heSBuZWVkIHRvIGFkZCBhIGxlYWRpbmcgemVyby5cbiAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gIG0gPSAoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCA/ICcwJyArIG0gOiBtKSArICc6JztcblxuICAvLyBDaGVjayBpZiBsZWFkaW5nIHplcm8gaXMgbmVlZCBmb3Igc2Vjb25kc1xuICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XG5cbiAgcmV0dXJuIGggKyBtICsgcztcbn1cblxuLyoqXG4gKiBAZmlsZSB0aW1lLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZUNvbnRlbnQpLCAyNSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHBsYWluTmFtZSkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKTtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSArICcgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSArICctZGlzcGxheSdcbiAgICB9LCB7XG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSwgY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIHRleHRDb250ZW50OiB0aGlzLmxvY2FsaXplKHRoaXMuY29udHJvbFRleHRfKVxuICAgIH0pKTtcblxuICAgIHRoaXMudXBkYXRlVGV4dE5vZGVfKCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsXyA9IG51bGw7XG4gICAgdGhpcy50ZXh0Tm9kZV8gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBcInJlbWFpbmluZyB0aW1lXCIgdGV4dCBub2RlIHdpdGggbmV3IGNvbnRlbnQgdXNpbmcgdGhlXG4gICAqIGNvbnRlbnRzIG9mIHRoZSBgZm9ybWF0dGVkVGltZV9gIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRFbF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5jb250ZW50RWxfLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuY29udGVudEVsXy5yZW1vdmVDaGlsZCh0aGlzLmNvbnRlbnRFbF8uZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0Tm9kZV8gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLmZvcm1hdHRlZFRpbWVfIHx8ICcwOjAwJyk7XG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgZm9ybWF0dGVkIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHVzZSBpbiBkaXNwbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgICBBIG51bWVyaWMgdGltZSwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEEgZm9ybWF0dGVkIHRpbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8gPSBmdW5jdGlvbiBmb3JtYXRUaW1lXyh0aW1lKSB7XG4gICAgcmV0dXJuIGZvcm1hdFRpbWUodGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRpbWUgZGlzcGxheSB0ZXh0IG5vZGUgaWYgaXQgaGFzIHdoYXQgd2FzIHBhc3NlZCBpbiBjaGFuZ2VkXG4gICAqIHRoZSBmb3JtYXR0ZWQgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHVwZGF0ZSB0b1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JtYXR0ZWRUaW1lXyA9IGZ1bmN0aW9uIHVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRpbWUpIHtcbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9IHRoaXMuZm9ybWF0VGltZV8odGltZSk7XG5cbiAgICBpZiAoZm9ybWF0dGVkVGltZSA9PT0gdGhpcy5mb3JtYXR0ZWRUaW1lXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXR0ZWRUaW1lO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gYmUgZmlsbGVkIG91dCBpbiB0aGUgY2hpbGQgY2xhc3MsIHNob3VsZCB1cGRhdGUgdGhlIGRpc3BsYXllZCB0aW1lXG4gICAqIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgZmFjdCB0aGF0IHRoZSBjdXJyZW50IHRpbWUgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge307XG5cbiAgcmV0dXJuIFRpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFRpbWVEaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1RpbWUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RpbWVEaXNwbGF5JywgVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGN1cnJlbnQtdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIGN1cnJlbnQgdGltZVxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBDdXJyZW50VGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX1RpbWVEaXNwbGF5KSB7XG4gIGluaGVyaXRzKEN1cnJlbnRUaW1lRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEN1cnJlbnRUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGltZURpc3BsYXkuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jdXJyZW50LXRpbWUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY3VycmVudCB0aW1lIGRpc3BsYXlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIHZhciB0aW1lID0gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBmaXJlcyBlbmRlZCB0aGVyZSBzaG91bGQgYmUgbm8gdGltZSBsZWZ0LiBTYWRseVxuICAgKiB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UsIGxldHMgbWFrZSBpdCBzZWVtIGxpa2UgdGhhdCBpcyB0aGUgY2FzZVxuICAgKiBmb3IgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xuICB9O1xuXG4gIHJldHVybiBDdXJyZW50VGltZURpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBDdXJyZW50VGltZURpc3BsYXlgcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0N1cnJlbnQgVGltZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ3VycmVudFRpbWVEaXNwbGF5JywgQ3VycmVudFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBkdXJhdGlvbi1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIGR1cmF0aW9uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIER1cmF0aW9uRGlzcGxheSA9IGZ1bmN0aW9uIChfVGltZURpc3BsYXkpIHtcbiAgaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfVGltZURpc3BsYXkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRHVyYXRpb25EaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIER1cmF0aW9uRGlzcGxheSk7XG5cbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0by9uZWVkIHRvIHRocm90dGxlIGR1cmF0aW9uIGNoYW5nZXMsXG4gICAgLy8gYXMgdGhleSBzaG91bGQgYWx3YXlzIGRpc3BsYXkgdGhlIGNoYW5nZWQgZHVyYXRpb24gYXNcbiAgICAvLyBpdCBoYXMgY2hhbmdlZFxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZUNvbnRlbnQpO1xuXG4gICAgLy8gQWxzbyBsaXN0ZW4gZm9yIHRpbWV1cGRhdGUgKGluIHRoZSBwYXJlbnQpIGFuZCBsb2FkZWRtZXRhZGF0YSBiZWNhdXNlIHJlbW92aW5nIHRob3NlXG4gICAgLy8gbGlzdGVuZXJzIGNvdWxkIGhhdmUgYnJva2VuIGRlcGVuZGVudCBhcHBsaWNhdGlvbnMvbGlicmFyaWVzLiBUaGVzZVxuICAgIC8vIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCBmb3IgNy4wLlxuICAgIF90aGlzLm9uKHBsYXllciwgJ2xvYWRlZG1ldGFkYXRhJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWR1cmF0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGR1cmF0aW9uIHRpbWUgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAsIGB0aW1ldXBkYXRlYCwgb3IgYGxvYWRlZG1ldGFkYXRhYCBldmVudCB0aGF0IGNhdXNlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICBpZiAoZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbl8gIT09IGR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmR1cmF0aW9uXyA9IGR1cmF0aW9uO1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyhkdXJhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEdXJhdGlvbkRpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBEdXJhdGlvbkRpc3BsYXlgcyBjb250cm9scy4gQWRkZWQgdG8gZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkR1cmF0aW9uRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0R1cmF0aW9uIFRpbWUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0R1cmF0aW9uRGlzcGxheScsIER1cmF0aW9uRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgdGltZS1kaXZpZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIHNlcGFyYXRvciBiZXR3ZWVuIHRoZSBjdXJyZW50IHRpbWUgYW5kIGR1cmF0aW9uLlxuICogQ2FuIGJlIGhpZGRlbiBpZiBpdCdzIG5vdCBuZWVkZWQgaW4gdGhlIGRlc2lnbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGltZURpdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaW1lRGl2aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGltZURpdmlkZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZURpdmlkZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBjb21wb25lbnQncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBUaW1lRGl2aWRlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtY29udHJvbCB2anMtdGltZS1kaXZpZGVyJyxcbiAgICAgIGlubmVySFRNTDogJzxkaXY+PHNwYW4+Lzwvc3Bhbj48L2Rpdj4nXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVEaXZpZGVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RpbWVEaXZpZGVyJywgVGltZURpdmlkZXIpO1xuXG4vKipcbiAqIEBmaWxlIHJlbWFpbmluZy10aW1lLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgdGltZSBsZWZ0IGluIHRoZSB2aWRlb1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBSZW1haW5pbmdUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfVGltZURpc3BsYXkpIHtcbiAgaW5oZXJpdHMoUmVtYWluaW5nVGltZURpc3BsYXksIF9UaW1lRGlzcGxheSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBSZW1haW5pbmdUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1haW5pbmdUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW1lRGlzcGxheS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZHVyYXRpb25jaGFuZ2UnLCBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIF90aGlzLmhhbmRsZUVuZGVkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1yZW1haW5pbmctdGltZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByZW1haW5pbmcgdGltZSBkaXNwbGF5IHByZWZpeGVzIG51bWJlcnMgd2l0aCBhIFwibWludXNcIiBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZVxuICAgKiAgICAgICAgIEEgbnVtZXJpYyB0aW1lLCBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQSBmb3JtYXR0ZWQgdGltZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5mb3JtYXRUaW1lXyA9IGZ1bmN0aW9uIGZvcm1hdFRpbWVfKHRpbWUpIHtcbiAgICByZXR1cm4gJy0nICsgX1RpbWVEaXNwbGF5LnByb3RvdHlwZS5mb3JtYXRUaW1lXy5jYWxsKHRoaXMsIHRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmVtYWluaW5nIHRpbWUgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQGRlcHJlY2F0ZWQgV2Ugc2hvdWxkIG9ubHkgdXNlIHJlbWFpbmluZ1RpbWVEaXNwbGF5XG4gICAgLy8gYXMgb2YgdmlkZW8uanMgN1xuICAgIGlmICh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZURpc3BsYXkpIHtcbiAgICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8odGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWVEaXNwbGF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgcGxheWVyIGZpcmVzIGVuZGVkIHRoZXJlIHNob3VsZCBiZSBubyB0aW1lIGxlZnQuIFNhZGx5XG4gICAqIHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZSwgbGV0cyBtYWtlIGl0IHNlZW0gbGlrZSB0aGF0IGlzIHRoZSBjYXNlXG4gICAqIGZvciB1c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKDApO1xuICB9O1xuXG4gIHJldHVybiBSZW1haW5pbmdUaW1lRGlzcGxheTtcbn0oVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFJlbWFpbmluZ1RpbWVEaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5SZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1JlbWFpbmluZyBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdSZW1haW5pbmdUaW1lRGlzcGxheScsIFJlbWFpbmluZ1RpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBsaXZlLWRpc3BsYXkuanNcbiAqL1xuLy8gVE9ETyAtIEZ1dHVyZSBtYWtlIGl0IGNsaWNrIHRvIHNuYXAgdG8gbGl2ZVxuXG4vKipcbiAqIERpc3BsYXlzIHRoZSBsaXZlIGluZGljYXRvciB3aGVuIGR1cmF0aW9uIGlzIEluZmluaXR5LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMaXZlRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKExpdmVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIExpdmVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExpdmVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlU2hvd2luZygpO1xuICAgIF90aGlzLm9uKF90aGlzLnBsYXllcigpLCAnZHVyYXRpb25jaGFuZ2UnLCBfdGhpcy51cGRhdGVTaG93aW5nKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWRpc3BsYXknLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUoJ1N0cmVhbSBUeXBlJykgKyAnPC9zcGFuPicgKyB0aGlzLmxvY2FsaXplKCdMSVZFJylcbiAgICB9LCB7XG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgZHVyYXRpb24gdG8gc2VlIGlmIHRoZSBMaXZlRGlzcGxheSBzaG91bGQgYmUgc2hvd2luZyBvciBub3QuIFRoZW4gc2hvdy9oaWRlXG4gICAqIGl0IGFjY29yZGluZ2x5XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2R1cmF0aW9uY2hhbmdlfSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVNob3dpbmcgPSBmdW5jdGlvbiB1cGRhdGVTaG93aW5nKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyKCkuZHVyYXRpb24oKSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIExpdmVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xpdmVEaXNwbGF5JywgTGl2ZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHNsaWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIGEgc2xpZGVyLiBDYW4gYmUgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cbiAqIEZvciBpbnN0YW5jZSB0aGUgdm9sdW1lIGJhciBvciB0aGUgc2VlayBiYXIgb24gYSB2aWRlbyBpcyBhIHNsaWRlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgU2xpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU2xpZGVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBTbGlkZXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIC8vIFNldCBwcm9wZXJ0eSBuYW1lcyB0byBiYXIgdG8gbWF0Y2ggd2l0aCB0aGUgY2hpbGQgU2xpZGVyIGNsYXNzIGlzIGxvb2tpbmcgZm9yXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5iYXIgPSBfdGhpcy5nZXRDaGlsZChfdGhpcy5vcHRpb25zXy5iYXJOYW1lKTtcblxuICAgIC8vIFNldCBhIGhvcml6b250YWwgb3IgdmVydGljYWwgY2xhc3Mgb24gdGhlIHNsaWRlciBkZXBlbmRpbmcgb24gdGhlIHNsaWRlciB0eXBlXG4gICAgX3RoaXMudmVydGljYWwoISFfdGhpcy5vcHRpb25zXy52ZXJ0aWNhbCk7XG5cbiAgICBfdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQXJlIGNvbnRyb2xzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBmb3IgdGhpcyBzbGlkZXIgb3Igbm90LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRydWUgaWYgY29udHJvbHMgYXJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBjb250cm9scyBmb3IgdGhpcyBzbGlkZXIgaWYgdGhleSBhcmUgZGlzYWJsZWRcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayk7XG5cbiAgICB0aGlzLm9uKHRoaXMucGxheWVyXywgJ2NvbnRyb2xzdmlzaWJsZScsIHRoaXMudXBkYXRlKTtcblxuICAgIGlmICh0aGlzLnBsYXllckV2ZW50KSB7XG4gICAgICB0aGlzLm9uKHRoaXMucGxheWVyXywgdGhpcy5wbGF5ZXJFdmVudCwgdGhpcy51cGRhdGUpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSBjb250cm9scyBmb3IgdGhpcyBzbGlkZXIgaWYgdGhleSBhcmUgZW5hYmxlZFxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZG9jID0gdGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9mZignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgIHRoaXMub2ZmKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9mZignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZih0aGlzLnBsYXllcl8sICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG5cbiAgICB0aGlzLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgaWYgKHRoaXMucGxheWVyRXZlbnQpIHtcbiAgICAgIHRoaXMub2ZmKHRoaXMucGxheWVyXywgdGhpcy5wbGF5ZXJFdmVudCwgdGhpcy51cGRhdGUpO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEJ1dHRvbmBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVHlwZSBvZiBlbGVtZW50IHRvIGNyZWF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIExpc3Qgb2YgcHJvcGVydGllcyBpbiBPYmplY3QgZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgbGlzdCBvZiBhdHRyaWJ1dGVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSh0eXBlKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICAvLyBBZGQgdGhlIHNsaWRlciBlbGVtZW50IGNsYXNzIHRvIGFsbCBzdWIgY2xhc3Nlc1xuICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArICcgdmpzLXNsaWRlcic7XG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcbiAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IDEwMCxcbiAgICAgICd0YWJJbmRleCc6IDBcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHR5cGUsIHByb3BzLCBhdHRyaWJ1dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJhY3RpdmVcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgYmxvY2tUZXh0U2VsZWN0aW9uKCk7XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGluZycpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgaW4gYW4gYWN0aXZlIHN0YXRlXG4gICAgICpcbiAgICAgKiBAZXZlbnQgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmFjdGl2ZScpO1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBgbW91c2Vtb3ZlYCwgYHRvdWNobW92ZWAsIGFuZCBgbW91c2Vkb3duYCBldmVudHMgb24gdGhpcyBgU2xpZGVyYC5cbiAgICogVGhlIGBtb3VzZW1vdmVgIGFuZCBgdG91Y2htb3ZlYCBldmVudHMgd2lsbCBvbmx5IG9ubHkgdHJpZ2dlciB0aGlzIGZ1bmN0aW9uIGR1cmluZ1xuICAgKiBgbW91c2Vkb3duYCBhbmQgYHRvdWNoc3RhcnRgLiBUaGlzIGlzIGR1ZSB0byB7QGxpbmsgU2xpZGVyI2hhbmRsZU1vdXNlRG93bn0gYW5kXG4gICAqIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VVcH0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCwgYG1vdXNlbW92ZWAsIGB0b3VjaHN0YXJ0YCwgb3IgYHRvdWNobW92ZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXG4gICAqIEBsaXN0ZW5zIHRvdWNobW92ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7fTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqIEBmaXJlcyBTbGlkZXIjc2xpZGVyaW5hY3RpdmVcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHVuYmxvY2tUZXh0U2VsZWN0aW9uKCk7XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGluZycpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgbm8gbG9uZ2VyIGluIGFuIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyaW5hY3RpdmVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzbGlkZXJpbmFjdGl2ZScpO1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHByb2dyZXNzIGJhciBvZiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqICAgICAgICAgIFRoZSBwZXJjZW50YWdlIG9mIHByb2dyZXNzIHRoZSBwcm9ncmVzcyBiYXIgcmVwcmVzZW50cyBhcyBhXG4gICAqICAgICAgICAgIG51bWJlciBmcm9tIDAgdG8gMS5cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIC8vIEluIFZvbHVtZUJhciBpbml0IHdlIGhhdmUgYSBzZXRUaW1lb3V0IGZvciB1cGRhdGUgdGhhdCBwb3BzIGFuZCB1cGRhdGVcbiAgICAvLyB0byB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gc3RhY2suIFRoZSBwbGF5ZXIgaXMgZGVzdHJveWVkIGJlZm9yZSB0aGVuXG4gICAgLy8gdXBkYXRlIHdpbGwgY2F1c2UgYW4gZXJyb3JcbiAgICBpZiAoIXRoaXMuZWxfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgc2NydWJiaW5nLCB3ZSBjb3VsZCB1c2UgYSBjYWNoZWQgdmFsdWUgdG8gbWFrZSB0aGUgaGFuZGxlIGtlZXAgdXBcbiAgICAvLyB3aXRoIHRoZSB1c2VyJ3MgbW91c2UuIE9uIEhUTUw1IGJyb3dzZXJzIHNjcnViYmluZyBpcyByZWFsbHkgc21vb3RoLCBidXRcbiAgICAvLyBzb21lIGZsYXNoIHBsYXllcnMgYXJlIHNsb3csIHNvIHdlIG1pZ2h0IHdhbnQgdG8gdXRpbGl6ZSB0aGlzIGxhdGVyLlxuICAgIC8vIHZhciBwcm9ncmVzcyA9ICAodGhpcy5wbGF5ZXJfLnNjcnViYmluZygpKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuZ2V0UGVyY2VudCgpO1xuICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gYmFyLi4uXG4gICAgaWYgKCFiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm8gZHVyYXRpb24gYW5kIG90aGVyIGRpdmlzaW9uIGlzc3Vlc1xuICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgIT09ICdudW1iZXInIHx8IHByb2dyZXNzICE9PSBwcm9ncmVzcyB8fCBwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPT09IEluZmluaXR5KSB7XG4gICAgICBwcm9ncmVzcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCB0byBhIHBlcmNlbnRhZ2UgZm9yIHNldHRpbmdcbiAgICB2YXIgcGVyY2VudGFnZSA9IChwcm9ncmVzcyAqIDEwMCkudG9GaXhlZCgyKSArICclJztcbiAgICB2YXIgc3R5bGUgPSBiYXIuZWwoKS5zdHlsZTtcblxuICAgIC8vIFNldCB0aGUgbmV3IGJhciB3aWR0aCBvciBoZWlnaHRcbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBwZXJjZW50YWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS53aWR0aCA9IHBlcmNlbnRhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZGlzdGFuY2UgZm9yIHNsaWRlclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIFNsaWRlci5cbiAgICogICAgICAgICAtIHBvc3RpdGlvbi54IGZvciB2ZXJ0aWNhbCBgU2xpZGVyYHNcbiAgICogICAgICAgICAtIHBvc3RpdGlvbi55IGZvciBob3Jpem9udGFsIGBTbGlkZXJgc1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuY2FsY3VsYXRlRGlzdGFuY2UgPSBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbih0aGlzLmVsXywgZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMudmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uLnk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbi54O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBgZm9jdXNgIGV2ZW50IG9uIHRoaXMgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGZvY3VzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgZm9jdXNcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5vbih0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoZSBgU2xpZGVyYC4gV2F0Y2hlcyBmb3IgbGVmdCwgcmlndGgsIHVwLCBhbmQgZG93blxuICAgKiBhcnJvdyBrZXlzLiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgc2xpZGVyIGhhcyBmb2N1cy4gU2VlXG4gICAqIHtAbGluayBTbGlkZXIjaGFuZGxlRm9jdXN9IGFuZCB7QGxpbmsgU2xpZGVyI2hhbmRsZUJsdXJ9LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG5cbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBgYmx1cmAgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLm9mZih0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuZXIgZm9yIGNsaWNrIGV2ZW50cyBvbiBzbGlkZXIsIHVzZWQgdG8gcHJldmVudCBjbGlja3NcbiAgICogICBmcm9tIGJ1YmJsaW5nIHVwIHRvIHBhcmVudCBlbGVtZW50cyBsaWtlIGJ1dHRvbiBtZW51cy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICBFdmVudCB0aGF0IGNhdXNlZCB0aGlzIG9iamVjdCB0byBydW5cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHNsaWRlciBpcyBob3Jpem9udGFsIGZvciB2ZXJ0aWNhbFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCxcbiAgICogICAgICAgIC0gZmFsc2UgaXMgaG9yaXpvbnRhbFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBzbGlkZXIgaXMgdmVydGljYWwsIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiB0aGUgc2xpZGVyIGlzIGhvcml6b250YWwsIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS52ZXJ0aWNhbCA9IGZ1bmN0aW9uIHZlcnRpY2FsKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbF8gfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy52ZXJ0aWNhbF8gPSAhIWJvb2w7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbF8pIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItdmVydGljYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci1ob3Jpem9udGFsJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTbGlkZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2xpZGVyJywgU2xpZGVyKTtcblxuLyoqXG4gKiBAZmlsZSBsb2FkLXByb2dyZXNzLWJhci5qc1xuICovXG4vKipcbiAqIFNob3dzIGxvYWRpbmcgcHJvZ3Jlc3NcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZFByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTG9hZFByb2dyZXNzQmFyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIExvYWRQcm9ncmVzc0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5wYXJ0RWxzXyA9IFtdO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3Byb2dyZXNzJywgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBMb2FkUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1sb2FkLXByb2dyZXNzJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdMb2FkZWQnKSArICc8L3NwYW4+OiAwJTwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLnBhcnRFbHNfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHByb2dyZXNzIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHByb2dyZXNzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICB2YXIgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnRFbHNfO1xuXG4gICAgLy8gZ2V0IHRoZSBwZXJjZW50IHdpZHRoIG9mIGEgdGltZSBjb21wYXJlZCB0byB0aGUgdG90YWwgZW5kXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xuICAgICAgLy8gbm8gTmFOXG4gICAgICB2YXIgcGVyY2VudCA9IHRpbWUgLyBlbmQgfHwgMDtcblxuICAgICAgcmV0dXJuIChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDAgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIHZhciBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoY3JlYXRlRWwoKSk7XG4gICAgICAgIGNoaWxkcmVuW2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcbiAgICAgIHBhcnQuc3R5bGUubGVmdCA9IHBlcmNlbnRpZnkoc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICAgIHBhcnQuc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGVuZCAtIHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVudXNlZCBidWZmZXJlZCByYW5nZSBlbGVtZW50c1xuICAgIGZvciAodmFyIF9pID0gY2hpbGRyZW4ubGVuZ3RoOyBfaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgX2ktLSkge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bX2kgLSAxXSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgdGltZS10b29sdGlwLmpzXG4gKi9cbi8qKlxuICogVGltZSB0b29sdGlwcyBkaXNwbGF5IGEgdGltZSBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lVG9vbHRpcCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVUb29sdGlwLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lVG9vbHRpcCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lVG9vbHRpcCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRpbWUgdG9vbHRpcCBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBUaW1lVG9vbHRpcC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtdG9vbHRpcCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgYFNlZWtCYXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCkge1xuICAgIHZhciB0b29sdGlwUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsXyk7XG4gICAgdmFyIHBsYXllclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5wbGF5ZXJfLmVsKCkpO1xuICAgIHZhciBzZWVrQmFyUG9pbnRQeCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50O1xuXG4gICAgLy8gZG8gbm90aGluZyBpZiBlaXRoZXIgcmVjdCBpc24ndCBhdmFpbGFibGVcbiAgICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHBsYXllciBpc24ndCBpbiB0aGUgRE9NIGZvciB0ZXN0aW5nXG4gICAgaWYgKCFwbGF5ZXJSZWN0IHx8ICF0b29sdGlwUmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIGxlZnQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSBhbnkgZ2FwIGJldHdlZW4gdGhlIGxlZnQgZWRnZSBvZiB0aGUgcGxheWVyXG4gICAgLy8gYW5kIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgYWRkIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZVxuICAgIC8vIGBTZWVrQmFyYCBiZWZvcmUgaGl0dGluZyB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICB2YXIgc3BhY2VMZWZ0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LmxlZnQgLSBwbGF5ZXJSZWN0LmxlZnQgKyBzZWVrQmFyUG9pbnRQeDtcblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIHJpZ2h0IG9mIHRoZSBgc2Vla0JhclBvaW50YCBhdmFpbGFibGUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAvLyBvZiB0aGUgcGxheWVyLiBXZSBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBwaXhlbHMgZnJvbSB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICAvLyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdG8gdGhhdCBhbnkgZ2FwIGJldHdlZW4gdGhlXG4gICAgLy8gcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCB0aGUgcGxheWVyLlxuICAgIHZhciBzcGFjZVJpZ2h0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LndpZHRoIC0gc2Vla0JhclBvaW50UHggKyAocGxheWVyUmVjdC5yaWdodCAtIHNlZWtCYXJSZWN0LnJpZ2h0KTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIHRvb2x0aXAgd2lsbCBuZWVkIHRvIGJlIHB1bGxlZFxuICAgIC8vIGZ1cnRoZXIgdG8gdGhlIHJpZ2h0IHRvIGNlbnRlciBpdCBvdmVyIHRoZSBgc2Vla0JhclBvaW50YC5cbiAgICB2YXIgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoIC8gMjtcblxuICAgIC8vIEFkanVzdCB0aGUgYHB1bGxUb29sdGlwQnlgIGRpc3RhbmNlIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGRlcGVuZGluZyBvblxuICAgIC8vIHRoZSByZXN1bHRzIG9mIHRoZSBzcGFjZSBjYWxjdWxhdGlvbnMgYWJvdmUuXG4gICAgaWYgKHNwYWNlTGVmdE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ICs9IHB1bGxUb29sdGlwQnkgLSBzcGFjZUxlZnRPZlBvaW50O1xuICAgIH0gZWxzZSBpZiAoc3BhY2VSaWdodE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gc3BhY2VSaWdodE9mUG9pbnQ7XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIHRoZSBpbXByZWNpc2lvbiBvZiBkZWNpbWFsL3JhdGlvIGJhc2VkIGNhbGN1bGF0aW9ucyBhbmQgdmFyeWluZ1xuICAgIC8vIHJvdW5kaW5nIGJlaGF2aW9ycywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBzcGFjaW5nIGFkanVzdG1lbnQgaXMgb2ZmXG4gICAgLy8gYnkgYSBwaXhlbCBvciB0d28uIFRoaXMgYWRkcyBpbnN1cmFuY2UgdG8gdGhlc2UgY2FsY3VsYXRpb25zLlxuICAgIGlmIChwdWxsVG9vbHRpcEJ5IDwgMCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IDA7XG4gICAgfSBlbHNlIGlmIChwdWxsVG9vbHRpcEJ5ID4gdG9vbHRpcFJlY3Qud2lkdGgpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aDtcbiAgICB9XG5cbiAgICB0aGlzLmVsXy5zdHlsZS5yaWdodCA9ICctJyArIHB1bGxUb29sdGlwQnkgKyAncHgnO1xuICAgIHRleHRDb250ZW50KHRoaXMuZWxfLCBjb250ZW50KTtcbiAgfTtcblxuICByZXR1cm4gVGltZVRvb2x0aXA7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZVRvb2x0aXAnLCBUaW1lVG9vbHRpcCk7XG5cbi8qKlxuICogQGZpbGUgcGxheS1wcm9ncmVzcy1iYXIuanNcbiAqL1xuLyoqXG4gKiBVc2VkIGJ5IHtAbGluayBTZWVrQmFyfSB0byBkaXNwbGF5IG1lZGlhIHBsYXliYWNrIHByb2dyZXNzIGFzIHBhcnQgb2YgdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheVByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheVByb2dyZXNzQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQbGF5UHJvZ3Jlc3NCYXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheVByb2dyZXNzQmFyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5LXByb2dyZXNzIHZqcy1zbGlkZXItYmFyJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgdXBkYXRlcyB0byBpdHMgb3duIERPTSBhcyB3ZWxsIGFzIHRoZSBET00gb2YgaXRzXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgckFGIElELCBjYW5jZWwgaXQgc28gd2UgZG9uJ3Qgb3Zlci1xdWV1ZS5cbiAgICBpZiAodGhpcy5yYWZJZF8pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZF8pO1xuICAgIH1cblxuICAgIHRoaXMucmFmSWRfID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRpbWUgPSBfdGhpczIucGxheWVyXy5zY3J1YmJpbmcoKSA/IF90aGlzMi5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiBfdGhpczIucGxheWVyXy5jdXJyZW50VGltZSgpO1xuXG4gICAgICB2YXIgY29udGVudCA9IGZvcm1hdFRpbWUodGltZSwgX3RoaXMyLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgICB2YXIgdGltZVRvb2x0aXAgPSBfdGhpczIuZ2V0Q2hpbGQoJ3RpbWVUb29sdGlwJyk7XG5cbiAgICAgIGlmICh0aW1lVG9vbHRpcCkge1xuICAgICAgICB0aW1lVG9vbHRpcC51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXlQcm9ncmVzc0Jhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHtAbGluayBQbGF5UHJvZ3Jlc3NCYXJ9LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFtdXG59O1xuXG4vLyBUaW1lIHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18uY2hpbGRyZW4ucHVzaCgndGltZVRvb2x0aXAnKTtcbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5UHJvZ3Jlc3NCYXInLCBQbGF5UHJvZ3Jlc3NCYXIpO1xuXG4vKipcbiAqIEBmaWxlIG1vdXNlLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTW91c2VUaW1lRGlzcGxheX0gY29tcG9uZW50IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uIEl0IGRpc3BsYXlzIGFuIGluZGljYXRvciBhbmQgYSB7QGxpbmsgVGltZVRvb2x0aXB9XG4gKiBpbmRpY2F0aW5nIHRoZSB0aW1lIHdoaWNoIGlzIHJlcHJlc2VudGVkIGJ5IGEgZ2l2ZW4gcG9pbnQgaW4gdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW91c2VUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vdXNlVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTW91c2VUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgMjUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHNlZWtCYXJQb2ludCAqIGR1cmF0aW9uLCBkdXJhdGlvbik7XG5cbiAgICAgIF90aGlzMi5lbF8uc3R5bGUubGVmdCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50ICsgJ3B4JztcbiAgICAgIF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlVGltZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW91c2VUaW1lRGlzcGxheWBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd0aW1lVG9vbHRpcCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01vdXNlVGltZURpc3BsYXknLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzZWVrLWJhci5qc1xuICovXG4vLyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGBzdGVwKmAgZnVuY3Rpb25zIG1vdmUgdGhlIHRpbWVsaW5lLlxudmFyIFNURVBfU0VDT05EUyA9IDU7XG5cbi8vIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0aGUgYmFyIHNob3VsZCB1cGRhdGUgYXMgaXQgcHJvZ3Jlc3Nlcy5cbnZhciBVUERBVEVfUkVGUkVTSF9JTlRFUlZBTCA9IDMwO1xuXG4vKipcbiAqIFNlZWsgYmFyIGFuZCBjb250YWluZXIgZm9yIHRoZSBwcm9ncmVzcyBiYXJzLiBVc2VzIHtAbGluayBQbGF5UHJvZ3Jlc3NCYXJ9XG4gKiBhcyBpdHMgYGJhcmAuXG4gKlxuICogQGV4dGVuZHMgU2xpZGVyXG4gKi9cblxudmFyIFNlZWtCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhTZWVrQmFyLCBfU2xpZGVyKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFNlZWtCYXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Vla0Jhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSksIFVQREFURV9SRUZSRVNIX0lOVEVSVkFMKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCBfdGhpcy51cGRhdGUpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuXG4gICAgLy8gd2hlbiBwbGF5aW5nLCBsZXQncyBlbnN1cmUgd2Ugc21vb3RobHkgdXBkYXRlIHRoZSBwbGF5IHByb2dyZXNzIGJhclxuICAgIC8vIHZpYSBhbiBpbnRlcnZhbFxuICAgIF90aGlzLnVwZGF0ZUludGVydmFsID0gbnVsbDtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydwbGF5aW5nJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNsZWFySW50ZXJ2YWwoX3RoaXMudXBkYXRlSW50ZXJ2YWwpO1xuXG4gICAgICBfdGhpcy51cGRhdGVJbnRlcnZhbCA9IF90aGlzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBVUERBVEVfUkVGUkVTSF9JTlRFUlZBTCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnZW5kZWQnLCAncGF1c2UnLCAnd2FpdGluZyddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbGVhckludGVydmFsKF90aGlzLnVwZGF0ZUludGVydmFsKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWyd0aW1ldXBkYXRlJywgJ2VuZGVkJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX1NsaWRlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWhvbGRlcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzIEJhcicpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgcGxheSBwcm9ncmVzcyBiYXIgYW5kIGFjY2Vzc2libGl0eVxuICAgKiBhdHRyaWJ1dGVzIHRvIHdoYXRldmVyIGlzIHBhc3NlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lXG4gICAqICAgICAgICBUaGUgY3VycmVudFRpbWUgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50XG4gICAqICAgICAgICBUaGUgcGVyY2VudGFnZSBhcyBhIGRlY2ltYWwgdGhhdCB0aGUgYmFyIHNob3VsZCBiZSBmaWxsZWQgZnJvbSAwLTEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlXyA9IGZ1bmN0aW9uIHVwZGF0ZV8oY3VycmVudFRpbWUsIHBlcmNlbnQpIHtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIG1hY2hpbmUgcmVhZGFibGUgdmFsdWUgb2YgcHJvZ3Jlc3MgYmFyIChwZXJjZW50YWdlIGNvbXBsZXRlKVxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIChwZXJjZW50ICogMTAwKS50b0ZpeGVkKDIpKTtcblxuICAgIC8vIGh1bWFuIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAodGltZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfScsIFtmb3JtYXRUaW1lKGN1cnJlbnRUaW1lLCBkdXJhdGlvbiksIGZvcm1hdFRpbWUoZHVyYXRpb24sIGR1cmF0aW9uKV0sICd7MX0gb2YgezJ9JykpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBgUGxheVByb2dyZXNzQmFyYC5cbiAgICB0aGlzLmJhci51cGRhdGUoZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKSwgcGVyY2VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VlayBiYXIncyBVSS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiAgICAgICAgICBUaGUgY3VycmVudCBwZXJjZW50IGF0IGEgbnVtYmVyIGZyb20gMC0xXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHBlcmNlbnQgPSBfU2xpZGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudXBkYXRlXyh0aGlzLmdldEN1cnJlbnRUaW1lXygpLCBwZXJjZW50KTtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBjdXJyZW50IHRpbWUgYnV0IGFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZyxcbiAgICogd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRpbWUgdmFsdWUgdG8gZGlzcGxheVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldEN1cnJlbnRUaW1lXyA9IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lXygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogV2Ugd2FudCB0aGUgc2VlayBiYXIgdG8gYmUgZnVsbCBvbiBlbmRlZFxuICAgKiBubyBtYXR0ZXIgd2hhdCB0aGUgYWN0dWFsIGludGVybmFsIHZhbHVlcyBhcmUuIHNvIHdlIGZvcmNlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIG9yIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZV8odGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCksIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnRhZ2Ugb2YgbWVkaWEgcGxheWVkIHNvIGZhci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIgKDAgdG8gMSkuXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgdmFyIHBlcmNlbnQgPSB0aGlzLmdldEN1cnJlbnRUaW1lXygpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICByZXR1cm4gcGVyY2VudCA+PSAxID8gMSA6IHBlcmNlbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIG9uIHNlZWsgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyh0cnVlKTtcblxuICAgIHRoaXMudmlkZW9XYXNQbGF5aW5nID0gIXRoaXMucGxheWVyXy5wYXVzZWQoKTtcbiAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcblxuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vtb3ZlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpICogdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBEb24ndCBsZXQgdmlkZW8gZW5kIHdoaWxlIHNjcnViYmluZy5cbiAgICBpZiAobmV3VGltZSA9PT0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xO1xuICAgIH1cblxuICAgIC8vIFNldCBuZXcgdGltZSAodGVsbCBwbGF5ZXIgdG8gc2VlayB0byBuZXcgdGltZSlcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUobmV3VGltZSk7XG4gIH07XG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgIHZhciBtb3VzZVRpbWVEaXNwbGF5ID0gdGhpcy5nZXRDaGlsZCgnbW91c2VUaW1lRGlzcGxheScpO1xuXG4gICAgaWYgKCFtb3VzZVRpbWVEaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW91c2VUaW1lRGlzcGxheS5zaG93KCk7XG4gIH07XG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgIHZhciBtb3VzZVRpbWVEaXNwbGF5ID0gdGhpcy5nZXRDaGlsZCgnbW91c2VUaW1lRGlzcGxheScpO1xuXG4gICAgaWYgKCFtb3VzZVRpbWVEaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW91c2VUaW1lRGlzcGxheS5oaWRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZXVwYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciB0aW1ldXBkYXRlIGJlY2F1c2Ugd2UncmUgZG9uZSBzZWVraW5nIGFuZCB0aGUgdGltZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGlmIHRoZSBwbGF5ZXIgaXMgcGF1c2VkIHRvIHRpbWUgdGhlIHRpbWUgZGlzcGxheXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMucGxheWVyXy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgcGxheWVyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBlbnRlciBvciBzcGFjZSBpcyB1c2VkIG9uIHRoZSBzZWVrYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIFNlZWtCYXIgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQWN0aW9uYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Vla0Jhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgU2Vla0JhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXG4gIGJhck5hbWU6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG4vLyBNb3VzZVRpbWVEaXNwbGF5IHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xufVxuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5cbi8qKlxuICogQGZpbGUgcHJvZ3Jlc3MtY29udHJvbC5qc1xuICovXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VTZWVrKSwgMjUpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICB2YXIgc2Vla0JhckVsID0gc2Vla0Jhci5lbCgpO1xuICAgIHZhciBzZWVrQmFyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzZWVrQmFyRWwpO1xuICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNraW4gaGFzIGEgZ2FwIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBgU2Vla0JhcmAuIFRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IGl0J3MgcG9zc2libGUgdG8gdHJpZ2dlciB0aGlzIGJlaGF2aW9yIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMgb2ZcbiAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgIGlmIChzZWVrQmFyUG9pbnQgPiAxKSB7XG4gICAgICBzZWVrQmFyUG9pbnQgPSAxO1xuICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgc2Vla0JhclBvaW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgbW91c2VUaW1lRGlzcGxheS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHRocm90dGxlZCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sI2hhbmRsZU1vdXNlU2Vla30gbGlzdGVuZXIuXG4gICAqXG4gICAqIEBtZXRob2QgUHJvZ3Jlc3NDb250cm9sI3Rocm90dGxlZEhhbmRsZU1vdXNlU2Vla1xuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVuIHRvdWNobW92ZVxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZW1vdmVgIG9yIGB0b3VjaG1vdmVgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVNlZWsgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVNlZWsoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQXJlIGNvbnRyb2xzIGFyZSBjdXJyZW50bHkgZW5hYmxlZCBmb3IgdGhpcyBwcm9ncmVzcyBjb250cm9sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRydWUgaWYgY29udHJvbHMgYXJlIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgYWxsIGNvbnRyb2xzIG9uIHRoZSBwcm9ncmVzcyBjb250cm9sIGFuZCBpdHMgY2hpbGRyZW5cbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmRpc2FibGUgJiYgY2hpbGQuZGlzYWJsZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub2ZmKFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSwgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub2ZmKHRoaXMuZWxfLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMuaGFuZGxlTW91c2VVcCgpO1xuXG4gICAgdGhpcy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIGFsbCBjb250cm9scyBvbiB0aGUgcHJvZ3Jlc3MgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQuZW5hYmxlICYmIGNoaWxkLmVuYWJsZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKHRoaXMuZWxfLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEZ1bGxzY3JlZW5Ub2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bGxzY3JlZW5Ub2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIHBsYXllciBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdGdWxsc2NyZWVuJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxuICogYENvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkICB1c2luZyB0aGUgYHZqcy1oaWRkZW5gIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBoaWRkZW4gaWYgdm9sdW1lIGlzIHVuc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2hlY2tWb2x1bWVTdXBwb3J0ID0gZnVuY3Rpb24gY2hlY2tWb2x1bWVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gIGlmIChwbGF5ZXIudGVjaF8gJiYgIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH1cblxuICBzZWxmLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xuICovXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVMZXZlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUxldmVsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBWb2x1bWVMZXZlbCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVMZXZlbCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVm9sdW1lTGV2ZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lTGV2ZWw7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTGV2ZWwnLCBWb2x1bWVMZXZlbCk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWJhci5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKCdzbGlkZXJhY3RpdmUnLCBfdGhpcy51cGRhdGVMYXN0Vm9sdW1lXyk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyIHZqcy1zbGlkZXItYmFyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gb24gdm9sdW1lIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW92ZW1lbnQgZXZlbnRzIG9uIHRoZSB7QGxpbmsgVm9sdW1lTWVudUJ1dHRvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgdGhlIHBsYXllciBpcyBtdXRlZCB1bm11dGUgaXQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jaGVja011dGVkID0gZnVuY3Rpb24gY2hlY2tNdXRlZCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcGVyY2VudCBvZiB2b2x1bWUgbGV2ZWxcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFZvbHVtZSBsZXZlbCBwZXJjZW50IGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5nZXRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0UGVyY2VudCgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICsgMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjcmVhc2Ugdm9sdW1lIGxldmVsIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSAtIDAuMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoZXZlbnQpIHtcbiAgICB2YXIgYXJpYVZhbHVlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAwIDogdGhpcy52b2x1bWVBc1BlcmNlbnRhZ2VfKCk7XG5cbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBhcmlhVmFsdWUpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBhcmlhVmFsdWUgKyAnJScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwbGF5ZXIgdm9sdW1lIGFzIGEgcGVyY2VudGFnZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudm9sdW1lQXNQZXJjZW50YWdlXyA9IGZ1bmN0aW9uIHZvbHVtZUFzUGVyY2VudGFnZV8oKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICogMTAwKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgVm9sdW1lQmFyLCBzdG9yZSB0aGUgdm9sdW1lIGFuZCBsaXN0ZW4gZm9yXG4gICAqIHRoZSBlbmQgb2YgdGhlIGRyYWcuIFdoZW4gdGhlIGRyYWcgZW5kcywgaWYgdGhlIHZvbHVtZSB3YXMgc2V0IHRvIHplcm8sXG4gICAqIHNldCBsYXN0Vm9sdW1lIHRvIHRoZSBzdG9yZWQgdm9sdW1lLlxuICAgKlxuICAgKiBAbGlzdGVucyBzbGlkZXJhY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUxhc3RWb2x1bWVfID0gZnVuY3Rpb24gdXBkYXRlTGFzdFZvbHVtZV8oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdm9sdW1lQmVmb3JlRHJhZyA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcblxuICAgIHRoaXMub25lKCdzbGlkZXJpbmFjdGl2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIucGxheWVyXy52b2x1bWUoKSA9PT0gMCkge1xuICAgICAgICBfdGhpczIucGxheWVyXy5sYXN0Vm9sdW1lXyh2b2x1bWVCZWZvcmVEcmFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lQmFyO1xufShTbGlkZXIpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVMZXZlbCddLFxuICBiYXJOYW1lOiAndm9sdW1lTGV2ZWwnXG59O1xuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQmFyJywgVm9sdW1lQmFyKTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtY29udHJvbC5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdm9sdW1lIGxldmVsXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFZvbHVtZUNvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZUNvbnRyb2wocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUNvbnRyb2wpO1xuXG4gICAgb3B0aW9ucy52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWwgfHwgZmFsc2U7XG5cbiAgICAvLyBQYXNzIHRoZSB2ZXJ0aWNhbCBvcHRpb24gZG93biB0byB0aGUgVm9sdW1lQmFyIGlmXG4gICAgLy8gdGhlIFZvbHVtZUJhciBpcyB0dXJuZWQgb24uXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZvbHVtZUJhciA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUJhcikpIHtcbiAgICAgIG9wdGlvbnMudm9sdW1lQmFyID0gb3B0aW9ucy52b2x1bWVCYXIgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUJhci52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWw7XG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgX3RoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKSwgMjUpO1xuXG4gICAgX3RoaXMub24oJ21vdXNlZG93bicsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgX3RoaXMub24oJ3RvdWNoc3RhcnQnLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuXG4gICAgLy8gd2hpbGUgdGhlIHNsaWRlciBpcyBhY3RpdmUgKHRoZSBtb3VzZSBoYXMgYmVlbiBwcmVzc2VkIGRvd24gYW5kXG4gICAgLy8gaXMgZHJhZ2dpbmcpIG9yIGluIGZvY3VzIHdlIGRvIG5vdCB3YW50IHRvIGhpZGUgdGhlIFZvbHVtZUJhclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydmb2N1cycsICdzbGlkZXJhY3RpdmUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudm9sdW1lQmFyLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdzbGlkZXJhY3RpdmUnKTtcbiAgICB9KTtcblxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydibHVyJywgJ3NsaWRlcmluYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZvbHVtZUJhci5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtaG9yaXpvbnRhbCc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zXy52ZXJ0aWNhbCkge1xuICAgICAgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLXZlcnRpY2FsJztcbiAgICB9XG5cbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1jb250cm9sIHZqcy1jb250cm9sICcgKyBvcmllbnRhdGlvbkNsYXNzXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdGhpcy52b2x1bWVCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQ29udHJvbGBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblZvbHVtZUNvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd2b2x1bWVCYXInXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVDb250cm9sJywgVm9sdW1lQ29udHJvbCk7XG5cbi8qKlxuICogQGZpbGUgbXV0ZS10b2dnbGUuanNcbiAqL1xuLyoqXG4gKiBBIGJ1dHRvbiBjb21wb25lbnQgZm9yIG11dGluZyB0aGUgYXVkaW8uXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIE11dGVUb2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhNdXRlVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE11dGVUb2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTXV0ZVRvZ2dsZSk7XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnbG9hZHN0YXJ0JywgJ3ZvbHVtZWNoYW5nZSddLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtbXV0ZS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgTXV0ZVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICAgIHZhciBsYXN0Vm9sdW1lID0gdGhpcy5wbGF5ZXJfLmxhc3RWb2x1bWVfKCk7XG5cbiAgICBpZiAodm9sID09PSAwKSB7XG4gICAgICB2YXIgdm9sdW1lVG9TZXQgPSBsYXN0Vm9sdW1lIDwgMC4xID8gMC4xIDogbGFzdFZvbHVtZTtcblxuICAgICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh2b2x1bWVUb1NldCk7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQodGhpcy5wbGF5ZXJfLm11dGVkKCkgPyBmYWxzZSA6IHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBgTXV0ZVRvZ2dsZWAgYnV0dG9uIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiBgdm9sdW1lYCBhbmQgYG11dGVkYFxuICAgKiBvbiB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNsb2Fkc3RhcnR9IGV2ZW50IGlmIHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZFxuICAgKiAgICAgICAgdGhyb3VnaCBhbiBldmVudC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVJY29uXygpO1xuICAgIHRoaXMudXBkYXRlQ29udHJvbFRleHRfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgYE11dGVUb2dnbGVgIGljb24uXG4gICAqXG4gICAqIFBvc3NpYmxlIHN0YXRlcyAoZ2l2ZW4gYGxldmVsYCB2YXJpYWJsZSBiZWxvdyk6XG4gICAqIC0gMDogY3Jvc3NlZCBvdXRcbiAgICogLSAxOiB6ZXJvIGJhcnMgb2Ygdm9sdW1lXG4gICAqIC0gMjogb25lIGJhciBvZiB2b2x1bWVcbiAgICogLSAzOiB0d28gYmFycyBvZiB2b2x1bWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGVJY29uXyA9IGZ1bmN0aW9uIHVwZGF0ZUljb25fKCkge1xuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgdmFyIGxldmVsID0gMztcblxuICAgIGlmICh2b2wgPT09IDAgfHwgdGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcbiAgICAgIGxldmVsID0gMDtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuMzMpIHtcbiAgICAgIGxldmVsID0gMTtcbiAgICB9IGVsc2UgaWYgKHZvbCA8IDAuNjcpIHtcbiAgICAgIGxldmVsID0gMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIGltcHJvdmUgbXV0ZWQgaWNvbiBjbGFzc2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgaSk7XG4gICAgfVxuICAgIGFkZENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgbGV2ZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiBgbXV0ZWRgIGhhcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIsIHVwZGF0ZSB0aGUgY29udHJvbCB0ZXh0XG4gICAqIChgdGl0bGVgIGF0dHJpYnV0ZSBvbiBgdmpzLW11dGUtY29udHJvbGAgZWxlbWVudCBhbmQgY29udGVudCBvZlxuICAgKiBgdmpzLWNvbnRyb2wtdGV4dGAgZWxlbWVudCkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlQ29udHJvbFRleHRfID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbFRleHRfKCkge1xuICAgIHZhciBzb3VuZE9mZiA9IHRoaXMucGxheWVyXy5tdXRlZCgpIHx8IHRoaXMucGxheWVyXy52b2x1bWUoKSA9PT0gMDtcbiAgICB2YXIgdGV4dCA9IHNvdW5kT2ZmID8gJ1VubXV0ZScgOiAnTXV0ZSc7XG5cbiAgICBpZiAodGhpcy5jb250cm9sVGV4dCgpICE9PSB0ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRyb2xUZXh0KHRleHQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTXV0ZVRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBNdXRlVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5NdXRlVG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnTXV0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTXV0ZVRvZ2dsZScsIE11dGVUb2dnbGUpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIEEgQ29tcG9uZW50IHRvIGNvbnRhaW4gdGhlIE11dGVUb2dnbGUgYW5kIFZvbHVtZUNvbnRyb2wgc28gdGhhdFxuICogdGhleSBjYW4gd29yayB0b2dldGhlci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lUGFuZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVQYW5lbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVQYW5lbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lUGFuZWwpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gb3B0aW9ucy5pbmxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIHRoZSBpbmxpbmUgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUNvbnRyb2wgYXMgdmVydGljYWwgaWZcbiAgICAvLyB0aGUgVm9sdW1lQ29udHJvbCBpcyBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNQbGFpbihvcHRpb25zLnZvbHVtZUNvbnRyb2wpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPSBvcHRpb25zLnZvbHVtZUNvbnRyb2wgfHwge307XG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wudmVydGljYWwgPSAhb3B0aW9ucy5pbmxpbmU7XG4gICAgfVxuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgLy8gd2hpbGUgdGhlIHNsaWRlciBpcyBhY3RpdmUgKHRoZSBtb3VzZSBoYXMgYmVlbiBwcmVzc2VkIGRvd24gYW5kXG4gICAgLy8gaXMgZHJhZ2dpbmcpIG9yIGluIGZvY3VzIHdlIGRvIG5vdCB3YW50IHRvIGhpZGUgdGhlIFZvbHVtZUJhclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyYWN0aXZlJ10sIF90aGlzLnNsaWRlckFjdGl2ZV8pO1xuICAgIF90aGlzLm9uKF90aGlzLm11dGVUb2dnbGUsICdmb2N1cycsIF90aGlzLnNsaWRlckFjdGl2ZV8pO1xuXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQ29udHJvbCwgWydzbGlkZXJpbmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJJbmFjdGl2ZV8pO1xuICAgIF90aGlzLm9uKF90aGlzLm11dGVUb2dnbGUsICdibHVyJywgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5zbGlkZXJBY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVyQWN0aXZlXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHZqcy1zbGlkZXItYWN0aXZlIGNsYXNzIHRvIHRoZSBWb2x1bWVQYW5lbFxuICAgKlxuICAgKiBAbGlzdGVucyBWb2x1bWVDb250cm9sI3NsaWRlcmluYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckluYWN0aXZlXyA9IGZ1bmN0aW9uIHNsaWRlckluYWN0aXZlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHZhciBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtcGFuZWwtaG9yaXpvbnRhbCc7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9uc18uaW5saW5lKSB7XG4gICAgICBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtcGFuZWwtdmVydGljYWwnO1xuICAgIH1cblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLXBhbmVsIHZqcy1jb250cm9sICcgKyBvcmllbnRhdGlvbkNsYXNzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZVBhbmVsO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVDb250cm9sYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVm9sdW1lUGFuZWwucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydtdXRlVG9nZ2xlJywgJ3ZvbHVtZUNvbnRyb2wnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVQYW5lbCcsIFZvbHVtZVBhbmVsKTtcblxuLyoqXG4gKiBAZmlsZSBtZW51LmpzXG4gKi9cbi8qKlxuICogVGhlIE1lbnUgY29tcG9uZW50IGlzIHVzZWQgdG8gYnVpbGQgcG9wdXAgbWVudXMsIGluY2x1ZGluZyBzdWJ0aXRsZSBhbmRcbiAqIGNhcHRpb25zIHNlbGVjdGlvbiBtZW51cy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTWVudSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnUsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgdGhlIHBsYXllciB0aGF0IHRoaXMgY29tcG9uZW50IHNob3VsZCBhdHRhY2ggdG9cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBNZW51KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnUpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgX3RoaXMubWVudUJ1dHRvbl8gPSBvcHRpb25zLm1lbnVCdXR0b247XG4gICAgfVxuXG4gICAgX3RoaXMuZm9jdXNlZENoaWxkXyA9IC0xO1xuXG4gICAgX3RoaXMub24oJ2tleWRvd24nLCBfdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBNZW51SXRlbX0gdG8gdGhlIG1lbnUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiB0aGUgYE1lbnVJdGVtYCB0byBhZGQuXG4gICAqXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uIGFkZEl0ZW0oY29tcG9uZW50KSB7XG4gICAgdGhpcy5hZGRDaGlsZChjb21wb25lbnQpO1xuICAgIGNvbXBvbmVudC5vbignY2xpY2snLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gVW5wcmVzcyB0aGUgYXNzb2NpYXRlZCBNZW51QnV0dG9uLCBhbmQgbW92ZSBmb2N1cyBiYWNrIHRvIGl0XG4gICAgICBpZiAodGhpcy5tZW51QnV0dG9uXykge1xuICAgICAgICB0aGlzLm1lbnVCdXR0b25fLnVucHJlc3NCdXR0b24oKTtcblxuICAgICAgICAvLyBkb24ndCBmb2N1cyBtZW51IGJ1dHRvbiBpZiBpdGVtIGlzIGEgY2FwdGlvbiBzZXR0aW5ncyBpdGVtXG4gICAgICAgIC8vIGJlY2F1c2UgZm9jdXMgd2lsbCBtb3ZlIGVsc2V3aGVyZSBhbmQgaXQgbG9ncyBhbiBlcnJvciBvbiBJRThcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lKCkgIT09ICdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbScpIHtcbiAgICAgICAgICB0aGlzLm1lbnVCdXR0b25fLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICB0aGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgY29udGVudEVsVHlwZSA9IHRoaXMub3B0aW9uc18uY29udGVudEVsVHlwZSB8fCAndWwnO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoY29udGVudEVsVHlwZSwge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtY29udGVudCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudScpO1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgYXBwZW5kOiB0aGlzLmNvbnRlbnRFbF8sXG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudSdcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBmcm9tIGJ1YmJsaW5nIHVwLiBOZWVkZWQgZm9yIE1lbnUgQnV0dG9ucyxcbiAgICAvLyB3aGVyZSBhIGNsaWNrIG9uIHRoZSBwYXJlbnQgaXMgc2lnbmlmaWNhbnRcbiAgICBvbihlbCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgTWVudS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoaXMgbWVudS4gVGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBBIGBrZXlkb3duYCBldmVudCB0aGF0IGhhcHBlbmVkIG9uIHRoZSBtZW51LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG5cbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIG5leHQgKGxvd2VyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyArIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0byBwcmV2aW91cyAoaGlnaGVyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyAtIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGZvY3VzIG9uIGEge0BsaW5rIE1lbnVJdGVtfSBpbiB0aGUgYE1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtpdGVtPTBdXG4gICAqICAgICAgICBJbmRleCBvZiBjaGlsZCBpdGVtIHNldCBmb2N1cyBvbi5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpLnNsaWNlKCk7XG4gICAgdmFyIGhhdmVUaXRsZSA9IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlblswXS5jbGFzc05hbWUgJiYgL3Zqcy1tZW51LXRpdGxlLy50ZXN0KGNoaWxkcmVuWzBdLmNsYXNzTmFtZSk7XG5cbiAgICBpZiAoaGF2ZVRpdGxlKSB7XG4gICAgICBjaGlsZHJlbi5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXRlbSA8IDApIHtcbiAgICAgICAgaXRlbSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gPj0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZF8gPSBpdGVtO1xuXG4gICAgICBjaGlsZHJlbltpdGVtXS5lbF8uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnU7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQSBgTWVudUJ1dHRvbmAgY2xhc3MgZm9yIGFueSBwb3B1cCB7QGxpbmsgTWVudX0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51QnV0dG9uLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE1lbnVCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG5ldyBCdXR0b24ocGxheWVyLCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KF90aGlzLmNvbnRyb2xUZXh0Xyk7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG5cbiAgICAvLyBBZGQgYnVpbGRDU1NDbGFzcyB2YWx1ZXMgdG8gdGhlIGJ1dHRvbiwgbm90IHRoZSB3cmFwcGVyXG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uY2xhc3NOYW1lID0gX3RoaXMuYnVpbGRDU1NDbGFzcygpICsgJyAnICsgYnV0dG9uQ2xhc3M7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8ucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9sJyk7XG5cbiAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5tZW51QnV0dG9uXyk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcblxuICAgIF90aGlzLmVuYWJsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAndGFwJywgX3RoaXMuaGFuZGxlQ2xpY2spO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdmb2N1cycsIF90aGlzLmhhbmRsZUZvY3VzKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2JsdXInLCBfdGhpcy5oYW5kbGVCbHVyKTtcblxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlU3VibWVudUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIGl0cyBpdGVtcy5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG1lbnUgPSB0aGlzLmNyZWF0ZU1lbnUoKTtcblxuICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgIHRoaXMubWVudS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMubWVudSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZW51ID0gbWVudTtcbiAgICB0aGlzLmFkZENoaWxkKG1lbnUpO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBtZW51IGJ1dHRvblxuICAgICAqXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA8PSB0aGlzLmhpZGVUaHJlc2hvbGRfKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIG1lbnUgYW5kIGFkZCBhbGwgaXRlbXMgdG8gaXQuXG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIG1lbnVcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXywgeyBtZW51QnV0dG9uOiB0aGlzIH0pO1xuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgbWVudSBpZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGlzIHRocmVzaG9sZC4gVGhpcyBkZWZhdWx0c1xuICAgICAqIHRvIDAgYW5kIHdoZW5ldmVyIHdlIGFkZCBpdGVtcyB3aGljaCBjYW4gYmUgaGlkZGVuIHRvIHRoZSBtZW51IHdlJ2xsIGluY3JlbWVudCBpdC4gV2UgbGlzdFxuICAgICAqIGl0IGhlcmUgYmVjYXVzZSBldmVyeSB0aW1lIHdlIHJ1biBgY3JlYXRlTWVudWAgd2UgbmVlZCB0byByZXNldCB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfID0gMDtcblxuICAgIC8vIEFkZCBhIHRpdGxlIGxpc3QgaXRlbSB0byB0aGUgdG9wXG4gICAgaWYgKHRoaXMub3B0aW9uc18udGl0bGUpIHtcbiAgICAgIHZhciB0aXRsZSA9IGNyZWF0ZUVsKCdsaScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtdGl0bGUnLFxuICAgICAgICBpbm5lckhUTUw6IHRvVGl0bGVDYXNlKHRoaXMub3B0aW9uc18udGl0bGUpLFxuICAgICAgICB0YWJJbmRleDogLTFcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG5cbiAgICAgIG1lbnUuY2hpbGRyZW5fLnVuc2hpZnQodGl0bGUpO1xuICAgICAgcHJlcGVuZFRvKHRpdGxlLCBtZW51LmNvbnRlbnRFbCgpKTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZW1zID0gdGhpcy5jcmVhdGVJdGVtcygpO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIC8vIEFkZCBtZW51IGl0ZW1zIHRvIHRoZSBtZW51XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVudS5hZGRJdGVtKHRoaXMuaXRlbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZW51O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGxpc3Qgb2YgbWVudSBpdGVtcy4gU3BlY2lmaWMgdG8gZWFjaCBzdWJjbGFzcy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHt9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51QnV0dG9uc2BzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZFdyYXBwZXJDU1NDbGFzcygpXG4gICAgfSwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvdyBzdWIgY29tcG9uZW50cyB0byBzdGFjayBDU1MgY2xhc3MgbmFtZXMgZm9yIHRoZSB3cmFwcGVyIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjb25zdHJ1Y3RlZCB3cmFwcGVyIERPTSBgY2xhc3NOYW1lYFxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgdmFyIG1lbnVCdXR0b25DbGFzcyA9ICd2anMtbWVudS1idXR0b24nO1xuXG4gICAgLy8gSWYgdGhlIGlubGluZSBvcHRpb24gaXMgcGFzc2VkLCB3ZSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgc3R5bGVzIGFsdG9nZXRoZXIuXG4gICAgaWYgKHRoaXMub3B0aW9uc18uaW5saW5lID09PSB0cnVlKSB7XG4gICAgICBtZW51QnV0dG9uQ2xhc3MgKz0gJy1pbmxpbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZW51QnV0dG9uQ2xhc3MgKz0gJy1wb3B1cCc7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRml4IHRoZSBDU1Mgc28gdGhhdCB0aGlzIGlzbid0IG5lY2Vzc2FyeVxuICAgIHZhciBidXR0b25DbGFzcyA9IEJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcygpO1xuXG4gICAgcmV0dXJuICd2anMtbWVudS1idXR0b24gJyArIG1lbnVCdXR0b25DbGFzcyArICcgJyArIGJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgdmFyIG1lbnVCdXR0b25DbGFzcyA9ICd2anMtbWVudS1idXR0b24nO1xuXG4gICAgLy8gSWYgdGhlIGlubGluZSBvcHRpb24gaXMgcGFzc2VkLCB3ZSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgc3R5bGVzIGFsdG9nZXRoZXIuXG4gICAgaWYgKHRoaXMub3B0aW9uc18uaW5saW5lID09PSB0cnVlKSB7XG4gICAgICBtZW51QnV0dG9uQ2xhc3MgKz0gJy1pbmxpbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZW51QnV0dG9uQ2xhc3MgKz0gJy1wb3B1cCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICd2anMtbWVudS1idXR0b24gJyArIG1lbnVCdXR0b25DbGFzcyArICcgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9jYWxpemVkIGNvbnRyb2wgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogPiBOT1RFOiBUaGlzIHdpbGwgY29tZSBmcm9tIHRoZSBpbnRlcm5hbCBgbWVudUJ1dHRvbl9gIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF1cbiAgICogICAgICAgIENvbnRyb2wgdGV4dCBmb3IgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWw9dGhpcy5tZW51QnV0dG9uXy5lbCgpXVxuICAgKiAgICAgICAgRWxlbWVudCB0byBzZXQgdGhlIHRpdGxlIG9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgLSBUaGUgY29udHJvbCB0ZXh0IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0ID0gZnVuY3Rpb24gY29udHJvbFRleHQodGV4dCkge1xuICAgIHZhciBlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5tZW51QnV0dG9uXy5lbCgpO1xuXG4gICAgcmV0dXJuIHRoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQodGV4dCwgZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiBhIGBNZW51QnV0dG9uYC5cbiAgICogU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAvLyBXaGVuIHlvdSBjbGljayB0aGUgYnV0dG9uIGl0IGFkZHMgZm9jdXMsIHdoaWNoIHdpbGwgc2hvdyB0aGUgbWVudS5cbiAgICAvLyBTbyB3ZSdsbCByZW1vdmUgZm9jdXMgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBidXR0b24uIEZvY3VzIGlzIG5lZWRlZFxuICAgIC8vIGZvciB0YWIgbmF2aWdhdGlvbi5cblxuICAgIHRoaXMub25lKHRoaXMubWVudS5jb250ZW50RWwoKSwgJ21vdXNlbGVhdmUnLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIHRoaXMuZWxfLmJsdXIoKTtcbiAgICB9KSk7XG4gICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXNzQnV0dG9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvY3VzIHRvIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdG8gdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmZvY3VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGUgYWN0dWFsIGJ1dHRvbiwgbm90IHRoaXMgZWxlbWVudFxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiBibHVyKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uYmx1cigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgZ2FpbnMgZm9jdXMgdmlhIGEgYGZvY3VzYCBldmVudC5cbiAgICogVHVybnMgb24gbGlzdGVuaW5nIGZvciBga2V5ZG93bmAgZXZlbnRzLiBXaGVuIHRoZXkgaGFwcGVuIGl0XG4gICAqIGNhbGxzIGB0aGlzLmhhbmRsZUtleVByZXNzYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoKSB7XG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgYE1lbnVCdXR0b25gIGxvc2VzIGZvY3VzLiBUdXJucyBvZmYgdGhlIGxpc3RlbmVyIGZvclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0YWIsIGVzY2FwZSwgZG93biBhcnJvdywgYW5kIHVwIGFycm93IGtleXMgZm9yIGBNZW51QnV0dG9uYC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gRXNjYXBlICgyNykga2V5IG9yIFRhYiAoOSkga2V5IHVucHJlc3MgdGhlICdidXR0b24nXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAyNyB8fCBldmVudC53aGljaCA9PT0gOSkge1xuICAgICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pIHtcbiAgICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBwcmV2ZW50RGVmYXVsdCBmb3IgVGFiIGtleSAtIHdlIHN0aWxsIHdhbnQgdG8gbG9zZSBmb2N1c1xuICAgICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIFNldCBmb2N1cyBiYWNrIHRvIHRoZSBtZW51IGJ1dHRvbidzIGJ1dHRvblxuICAgICAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5mb2N1cygpO1xuICAgICAgfVxuICAgICAgLy8gVXAgKDM4KSBrZXkgb3IgRG93biAoNDApIGtleSBwcmVzcyB0aGUgJ2J1dHRvbidcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGlmICghdGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnByZXNzQnV0dG9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gYSBzdWItbWVudS4gVGhlIGxpc3RlbmVyIGZvciB0aGlzIGlzIGFkZGVkIGluXG4gICAqIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIEtleSBwcmVzcyBldmVudFxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlU3VibWVudUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlU3VibWVudUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQdXQgdGhlIGN1cnJlbnQgYE1lbnVCdXR0b25gIGludG8gYSBwcmVzc2VkIHN0YXRlLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnByZXNzQnV0dG9uID0gZnVuY3Rpb24gcHJlc3NCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZF8pIHtcbiAgICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5tZW51LmxvY2tTaG93aW5nKCk7XG4gICAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuXG4gICAgICAvLyBzZXQgdGhlIGZvY3VzIGludG8gdGhlIHN1Ym1lbnUsIGV4Y2VwdCBvbiBpT1Mgd2hlcmUgaXQgaXMgcmVzdWx0aW5nIGluXG4gICAgICAvLyB1bmRlc2lyZWQgc2Nyb2xsaW5nIGJlaGF2aW9yIHdoZW4gdGhlIHBsYXllciBpcyBpbiBhbiBpZnJhbWVcbiAgICAgIGlmIChJU19JT1MgJiYgaXNJbkZyYW1lKCkpIHtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IHNvIHRoYXQgdGhlIG1lbnUgaXNuJ3QgZm9jdXNlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVudS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGFrZSB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgb3V0IG9mIGEgcHJlc3NlZCBzdGF0ZS5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51bnByZXNzQnV0dG9uID0gZnVuY3Rpb24gdW5wcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuICAgICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBEb24ndCBhbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBBbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcblxuICAgIHRoaXMubWVudUJ1dHRvbl8uZW5hYmxlKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVCdXR0b247XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUJ1dHRvbicsIE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljICB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpLlxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoVHJhY2tCdXR0b24sIF9NZW51QnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrQnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrQnV0dG9uKTtcblxuICAgIHZhciB0cmFja3MgPSBvcHRpb25zLnRyYWNrcztcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChfdGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgX3RoaXMucGxheWVyXy5vbigncmVhZHknLCB1cGRhdGVIYW5kbGVyKTtcblxuICAgIF90aGlzLnBsYXllcl8ub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUcmFja0J1dHRvbjtcbn0oTWVudUJ1dHRvbik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVHJhY2tCdXR0b24nLCBUcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgYSBtZW51IGl0ZW0uIGA8bGk+YFxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51SXRlbSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnNlbGVjdGFibGUgPSBvcHRpb25zLnNlbGVjdGFibGU7XG5cbiAgICBfdGhpcy5zZWxlY3RlZChvcHRpb25zLnNlbGVjdGVkKTtcblxuICAgIGlmIChfdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAvLyBUT0RPOiBNYXkgbmVlZCB0byBiZSBlaXRoZXIgbWVudWl0ZW1jaGVja2JveCBvciBtZW51aXRlbXJhZGlvLFxuICAgICAgLy8gICAgICAgYW5kIG1heSBuZWVkIGxvZ2ljYWwgZ3JvdXBpbmcgb2YgbWVudSBpdGVtcy5cbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1jaGVja2JveCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtJyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51SXRlbSdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1saV1cbiAgICogICAgICAgIEVsZW1lbnQncyBub2RlIHR5cGUsIG5vdCBhY3R1YWxseSB1c2VkLCBhbHdheXMgc2V0IHRvIGBsaWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRycz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIC8vIFRoZSBjb250cm9sIGlzIHRleHR1YWwsIG5vdCBqdXN0IGFuIGljb25cbiAgICB0aGlzLm5vbkljb25Db250cm9sID0gdHJ1ZTtcblxuICAgIHJldHVybiBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdsaScsIGFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1pdGVtJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCkgKyAnPC9zcGFuPicsXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQW55IGNsaWNrIG9uIGEgYE1lbnVJdGVtYCBwdXRzIGludCBpbnRvIHRoZSBzZWxlY3RlZCBzdGF0ZS5cbiAgICogU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBmb3IgdGhpcyBtZW51IGl0ZW0gYXMgc2VsZWN0ZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqICAgICAgICBpZiB0aGUgbWVudSBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKF9zZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIGlmIChfc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgICAgICAgLy8gYXJpYS1jaGVja2VkIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBieSBicm93c2Vycy9zY3JlZW4gcmVhZGVycyxcbiAgICAgICAgLy8gc28gaW5kaWNhdGUgc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlciBpbiB0aGUgY29udHJvbCB0ZXh0LlxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcsIHNlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gSW5kaWNhdGUgdW4tc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlclxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVJdGVtO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiBjaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHZhciBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5oYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcGxheWVyLm9uKFsnbG9hZHN0YXJ0JywgJ3RleHR0cmFja2NoYW5nZSddLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwbGF5ZXIub2ZmKFsnbG9hZHN0YXJ0JywgJ3RleHR0cmFja2NoYW5nZSddLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RlZGxhbmd1YWdlY2hhbmdlJywgc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gaU9TNyBkb2Vzbid0IGRpc3BhdGNoIGNoYW5nZSBldmVudHMgdG8gVGV4dFRyYWNrTGlzdHMgd2hlbiBhblxuICAgIC8vIGFzc29jaWF0ZWQgdHJhY2sncyBtb2RlIGNoYW5nZXMuIFdpdGhvdXQgc29tZXRoaW5nIGxpa2VcbiAgICAvLyBPYmplY3Qub2JzZXJ2ZSgpIChhbHNvIG5vdCBwcmVzZW50IG9uIGlPUzcpLCBpdCdzIG5vdFxuICAgIC8vIHBvc3NpYmxlIHRvIGRldGVjdCBjaGFuZ2VzIHRvIHRoZSBtb2RlIGF0dHJpYnV0ZSBhbmQgcG9seWZpbGxcbiAgICAvLyB0aGUgY2hhbmdlIGV2ZW50LiBBcyBhIHBvb3Igc3Vic3RpdHV0ZSwgd2UgbWFudWFsbHkgZGlzcGF0Y2hcbiAgICAvLyBjaGFuZ2UgZXZlbnRzIHdoZW5ldmVyIHRoZSBjb250cm9scyBtb2RpZnkgdGhlIG1vZGUuXG4gICAgaWYgKHRyYWNrcy5vbmNoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZXZlbnQgPSB2b2lkIDA7XG5cbiAgICAgIF90aGlzLm9uKFsndGFwJywgJ2NsaWNrJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90eXBlb2Yod2luZG93LkV2ZW50KSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBBbmRyb2lkIDIuMyB0aHJvd3MgYW4gSWxsZWdhbCBDb25zdHJ1Y3RvciBlcnJvciBmb3Igd2luZG93LkV2ZW50XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IHdpbmRvdy5FdmVudCgnY2hhbmdlJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgZGVmYXVsdCBzdGF0ZSBiYXNlZCBvbiBjdXJyZW50IHRyYWNrc1xuICAgIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFRleHRUcmFja01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIGtpbmQgPSB0aGlzLnRyYWNrLmtpbmQ7XG4gICAgdmFyIGtpbmRzID0gdGhpcy50cmFjay5raW5kcztcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICgha2luZHMpIHtcbiAgICAgIGtpbmRzID0gW2tpbmRdO1xuICAgIH1cblxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjayA9PT0gdGhpcy50cmFjayAmJiBraW5kcy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEpIHtcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgIT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhY2subW9kZSAhPT0gJ2Rpc2FibGVkJykge1xuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGxpc3QgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5tb2RlID09PSAnc2hvd2luZycpO1xuICB9O1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZShldmVudCkge1xuICAgIGlmICh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG5cbiAgICAgIC8vIERvbid0IHJlcGxhY2UgdGhlIGtpbmQgb2YgdHJhY2sgYWNyb3NzIHRoZSBzYW1lIGxhbmd1YWdlXG4gICAgICBpZiAoc2VsZWN0ZWRMYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmVuYWJsZWQgJiYgc2VsZWN0ZWRMYW5ndWFnZS5sYW5ndWFnZSA9PT0gdGhpcy50cmFjay5sYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmtpbmQgIT09IHRoaXMudHJhY2sua2luZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZSA9IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbGFuZ3VhZ2U6IHRoaXMudHJhY2subGFuZ3VhZ2UsXG4gICAgICAgIGtpbmQ6IHRoaXMudHJhY2sua2luZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gdHJhY2sgb2JqZWN0IG9uIGRpc3Bvc2VcbiAgICB0aGlzLnRyYWNrID0gbnVsbDtcblxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RleHRUcmFja01lbnVJdGVtJywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIG9mZi10ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIEEgc3BlY2lhbCBtZW51IGl0ZW0gZm9yIHR1cm5pbmcgb2YgYSBzcGVjaWZpYyB0eXBlIG9mIHRleHQgdHJhY2tcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBPZmZUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoT2ZmVGV4dFRyYWNrTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBPZmZUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICAvLyBDcmVhdGUgcHNldWRvIHRyYWNrIGluZm9cbiAgICAvLyBSZXF1aXJlcyBvcHRpb25zWydraW5kJ11cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBraW5kczogb3B0aW9ucy5raW5kcyxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICBtb2RlOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5raW5kcykge1xuICAgICAgb3B0aW9ucy5raW5kcyA9IFtvcHRpb25zLmtpbmRdO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxhYmVsKSB7XG4gICAgICBvcHRpb25zLnRyYWNrLmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMua2luZHMuam9pbignIGFuZCAnKSArICcgb2ZmJztcbiAgICB9XG5cbiAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqL1xuXG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH07XG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBhbGxIaWRkZW4gPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmIChbJ2NhcHRpb25zJywgJ2Rlc2NyaXB0aW9ucycsICdzdWJ0aXRsZXMnXS5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGFsbEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdPZmZUZXh0VHJhY2tNZW51SXRlbScsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVGV4dFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEV4aXN0aW5nIGFycmF5IG9mIGl0ZW1zIHRvIHVzZSBkdXJpbmcgY3JlYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIFRyYWNrTWVudUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRleHRUcmFja01lbnVJdGVtO1xuXG5cbiAgICAvLyBMYWJlbCBpcyBhbiBvdmVyaWRlIGZvciB0aGUgW3RyYWNrXSBvZmYgbGFiZWxcbiAgICAvLyBVU2VkIHRvIGxvY2FsaXNlIGNhcHRpb25zL3N1YnRpdGxlc1xuICAgIHZhciBsYWJlbCA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgbGFiZWwgPSB0aGlzLmxhYmVsXyArICcgb2ZmJztcbiAgICB9XG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxuICAgIGl0ZW1zLnB1c2gobmV3IE9mZlRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAga2luZHM6IHRoaXMua2luZHNfLFxuICAgICAga2luZDogdGhpcy5raW5kXyxcbiAgICAgIGxhYmVsOiBsYWJlbFxuICAgIH0pKTtcblxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMua2luZHNfKSkge1xuICAgICAgdGhpcy5raW5kc18gPSBbdGhpcy5raW5kX107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIGFuIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRoaXMua2luZHNfLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuXG4gICAgICAgIHZhciBpdGVtID0gbmV3IFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3Zqcy0nICsgdHJhY2sua2luZCArICctbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tCdXR0b24nLCBUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBjaGFwdGVyIHRyYWNrIG1lbnUgaXRlbVxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIENoYXB0ZXJzVHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2hhcHRlcnNUcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciBjdWUgPSBvcHRpb25zLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGN1ZS50ZXh0O1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSBjdWUuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlLmVuZFRpbWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICBfdGhpcy5jdWUgPSBjdWU7XG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2hhcHRlcnNUcmFja01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjaGFwdGVyIG1lbnUgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGN1ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFjayNjdWVjaGFuZ2VcbiAgICovXG5cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBjdWUgPSB0aGlzLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMuc2VsZWN0ZWQoY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lKTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNUcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBjaGFwdGVycy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICogQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuICogQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBDaGFwdGVyc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKENoYXB0ZXJzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBBbiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy50cmFja18gfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdhZGR0cmFjaycgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbW92ZXRyYWNrJykpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodGhpcy5maW5kQ2hhcHRlcnNUcmFjaygpKTtcbiAgICB9XG4gICAgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrIGZvciB0aGUgY2hhcHRlcnMgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBuZXcgdHJhY2sgdG8gc2VsZWN0LiBOb3RoaW5nIHdpbGwgY2hhbmdlIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiAgICAgICAgdHJhY2suXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnNldFRyYWNrID0gZnVuY3Rpb24gc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFja18gPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVwZGF0ZUhhbmRsZXJfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgb2xkIHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB2YXIgcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAocmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgcmVtb3RlVGV4dFRyYWNrRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWNrXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja18gPSB0cmFjaztcblxuICAgIC8vIGhlcmUgdGhpcy50cmFja18gcmVmZXJzIHRvIHRoZSBuZXcgdHJhY2sgaW5zdGFuY2VcbiAgICBpZiAodGhpcy50cmFja18pIHtcbiAgICAgIHRoaXMudHJhY2tfLm1vZGUgPSAnaGlkZGVuJztcblxuICAgICAgdmFyIF9yZW1vdGVUZXh0VHJhY2tFbCA9IHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0aGlzLnRyYWNrXyk7XG5cbiAgICAgIGlmIChfcmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgX3JlbW90ZVRleHRUcmFja0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHRyYWNrIG9iamVjdCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhpcyBDaGFwdGVyc0J1dHRvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRyYWNrIG9yIHVuZGVmaW5lZCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZmluZENoYXB0ZXJzVHJhY2sgPSBmdW5jdGlvbiBmaW5kQ2hhcHRlcnNUcmFjaygpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIFdlIHdpbGwgYWx3YXlzIGNob29zZSB0aGUgbGFzdCB0cmFjayBhcyBvdXIgY2hhcHRlcnNUcmFja1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhcHRpb24gZm9yIHRoZSBDaGFwdGVyc0J1dHRvbiBiYXNlZCBvbiB0aGUgdHJhY2sgbGFiZWwuIFRoaXMgd2lsbCBhbHNvXG4gICAqIHVzZSB0aGUgY3VycmVudCB0cmFja3MgbG9jYWxpemVkIGtpbmQgYXMgYSBmYWxsYmFjayBpZiBhIGxhYmVsIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHRyYWNrcyBjdXJyZW50IGxhYmVsIG9yIHRoZSBsb2NhbGl6ZWQgdHJhY2sga2luZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZ2V0TWVudUNhcHRpb24gPSBmdW5jdGlvbiBnZXRNZW51Q2FwdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmFja18gJiYgdGhpcy50cmFja18ubGFiZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrXy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodG9UaXRsZUNhc2UodGhpcy5raW5kXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgbWVudSBmcm9tIGNoYXB0ZXIgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBOZXcgbWVudSBmb3IgdGhlIGNoYXB0ZXIgYnV0dG9uc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLnRpdGxlID0gdGhpcy5nZXRNZW51Q2FwdGlvbigpO1xuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnRyYWNrXykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIHZhciBjdWVzID0gdGhpcy50cmFja18uY3VlcztcblxuICAgIGlmICghY3Vlcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgdmFyIG1pID0gbmV3IENoYXB0ZXJzVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgdHJhY2s6IHRoaXMudHJhY2tfLCBjdWU6IGN1ZSB9KTtcblxuICAgICAgaXRlbXMucHVzaChtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBDaGFwdGVyc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjaGFwdGVycyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2hhcHRlcnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDaGFwdGVycyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNCdXR0b24nLCBDaGFwdGVyc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgZGVzY3JpcHRpb25zLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGRlc2NyaXB0aW9uc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBEZXNjcmlwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhEZXNjcmlwdGlvbnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gRGVzY3JpcHRpb25zQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGV4dCB0cmFjayBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1blxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBhIHRyYWNrIG9mIGEgZGlmZmVyZW50IGtpbmQgaXMgc2hvd2luZ1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCAhPT0gdGhpcy5raW5kXyAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBhbm90aGVyIHRyYWNrIGlzIHNob3dpbmcsIGRpc2FibGUgdGhpcyBtZW51IGJ1dHRvblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kZXNjcmlwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIERlc2NyaXB0aW9uc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkRlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnZGVzY3JpcHRpb25zJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBEZXNjcmlwdGlvbnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRGVzY3JpcHRpb25zJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEZXNjcmlwdGlvbnNCdXR0b24nLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnRpdGxlcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBzdWJ0aXRsZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgU3VidGl0bGVzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3VidGl0bGVzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFN1YnRpdGxlc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3VidGl0bGVzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gU3VidGl0bGVzQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdzdWJ0aXRsZXMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnRpdGxlc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnRpdGxlc0J1dHRvbicsIFN1YnRpdGxlc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbi1zZXR0aW5ncy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgbWVudSBpdGVtIGZvciBjYXB0aW9uIHRyYWNrIHNldHRpbmdzIG1lbnVcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBsYWJlbDogb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncycsXG4gICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICBtb2RlOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIC8vIENhcHRpb25TZXR0aW5nc01lbnVJdGVtIGhhcyBubyBjb25jZXB0IG9mICdzZWxlY3RlZCdcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSBmYWxzZTtcblxuICAgIG9wdGlvbnMubmFtZSA9ICdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgICBfdGhpcy5jb250cm9sVGV4dCgnLCBvcGVucyAnICsgb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncyBkaWFsb2cnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENhcHRpb25TZXR0aW5nc01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKS5vcGVuKCk7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2FwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDYXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvbnNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcy5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENhcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2FwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25zQnV0dG9uJywgQ2FwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnMtY2Fwcy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBTdWJzQ2Fwc01lbnVJdGVtIGhhcyBhbiBbY2NdIGljb24gdG8gZGlzdGluZ3Vpc2ggY2FwdGlvbnMgZnJvbSBzdWJ0aXRsZXNcbiAqIGluIHRoZSBTdWJzQ2Fwc01lbnUuXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgU3Vic0NhcHNNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc01lbnVJdGVtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN1YnNDYXBzTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgaW5uZXJIVE1MICs9ICdcXG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4gJyArIHRoaXMubG9jYWxpemUoJ0NhcHRpb25zJykgKyAnPC9zcGFuPlxcbiAgICAgICc7XG4gICAgfVxuXG4gICAgaW5uZXJIVE1MICs9ICc8L3NwYW4+JztcblxuICAgIHZhciBlbCA9IF9UZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUxcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzTWVudUl0ZW0nLCBTdWJzQ2Fwc01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBzdWItY2Fwcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9ucyBhbmQvb3Igc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnNDYXBzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFN1YnNDYXBzQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbiAgICAvLyBBbHRob3VnaCBOb3J0aCBBbWVyaWNhIHVzZXMgXCJjYXB0aW9uc1wiIGluIG1vc3QgY2FzZXMgZm9yXG4gICAgLy8gXCJjYXB0aW9ucyBhbmQgc3VidGl0bGVzXCIgb3RoZXIgbG9jYWxlcyB1c2UgXCJzdWJ0aXRsZXNcIlxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWxfID0gJ3N1YnRpdGxlcyc7XG4gICAgaWYgKFsnZW4nLCAnZW4tdXMnLCAnZW4tY2EnLCAnZnItY2EnXS5pbmRleE9mKF90aGlzLnBsYXllcl8ubGFuZ3VhZ2VfKSA+IC0xKSB7XG4gICAgICBfdGhpcy5sYWJlbF8gPSAnY2FwdGlvbnMnO1xuICAgIH1cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0b1RpdGxlQ2FzZShfdGhpcy5sYWJlbF8pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJzLWNhcHMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNhcHRpb24vc3VidGl0bGVzIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmxhYmVsXyB9KSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgcyBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUua2luZHNfID0gWydjYXB0aW9ucycsICdzdWJ0aXRsZXMnXTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJzQ2Fwc0J1dHRvbmBzIGNvbnRyb2xzLlxuICpcbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzQnV0dG9uJywgU3Vic0NhcHNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIEFuIHtAbGluayBBdWRpb1RyYWNrfSB7QGxpbmsgTWVudUl0ZW19XG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQXVkaW9UcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2suZW5hYmxlZDtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xuXG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYEF1ZGlvVHJhY2tNZW51SXRlbSBpcyBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5lbmFibGVkKTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB7QGxpbmsgQXVkaW9UcmFja30gdHlwZXMuXG4gKlxuICogQGV4dGVuZHMgVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja0J1dHRvbiwgX1RyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIuYXVkaW9UcmFja3MoKTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYXVkaW8tYnV0dG9uICcgKyBfVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCBhdWRpbyB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tNZW51SXRlbVtdfSBbaXRlbXM9W11dXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBleGlzdGluZyBtZW51IGl0ZW1zIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7QXVkaW9UcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBvbmUgYXVkaW8gdHJhY2ssIHRoZXJlIG5vIHBvaW50IGluIHNob3dpbmcgaXRcbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfID0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGl0ZW1zLnB1c2gobmV3IEF1ZGlvVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBBdWRpb1RyYWNrQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5BdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQXVkaW8gVHJhY2snO1xuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrQnV0dG9uJywgQXVkaW9UcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIHBsYXliYWNrIHJhdGUuXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgUGxheWJhY2tSYXRlTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4gICAgdmFyIGxhYmVsID0gb3B0aW9ucy5yYXRlO1xuICAgIHZhciByYXRlID0gcGFyc2VGbG9hdChsYWJlbCwgMTApO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSByYXRlID09PSAxO1xuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBfdGhpcy5yYXRlID0gcmF0ZTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBQbGF5YmFja1JhdGVNZW51SXRlbSB3aGVuIHRoZSBwbGF5YmFja3JhdGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXliYWNrUmF0ZU1lbnVJdGVtYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuY29udGVudEVsVHlwZSA9ICdidXR0b24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVJdGVtJywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUJ1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9NZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheWJhY2stcmF0ZS12YWx1ZScsXG4gICAgICBpbm5lckhUTUw6ICcxeCdcbiAgICB9KTtcblxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxFbF8pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMubGFiZWxFbF8gPSBudWxsO1xuXG4gICAgX01lbnVCdXR0b24ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXBsYXliYWNrLXJhdGUgJyArIF9NZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBwbGF5YmFjayByYXRlIG1lbnVcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBNZW51IG9iamVjdCBwb3B1bGF0ZWQgd2l0aCB7QGxpbmsgUGxheWJhY2tSYXRlTWVudUl0ZW19c1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XG4gICAgdmFyIHJhdGVzID0gdGhpcy5wbGF5YmFja1JhdGVzKCk7XG5cbiAgICBpZiAocmF0ZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSByYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZW51LmFkZENoaWxkKG5ldyBQbGF5YmFja1JhdGVNZW51SXRlbSh0aGlzLnBsYXllcigpLCB7IHJhdGU6IHJhdGVzW2ldICsgJ3gnIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVudTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBBUklBIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gdXBkYXRlQVJJQUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gQ3VycmVudCBwbGF5YmFjayByYXRlXG4gICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVCdXR0b25gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cbiAgICB2YXIgY3VycmVudFJhdGUgPSB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgLy8gdGhpcyB3aWxsIHNlbGVjdCBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgIHZhciBuZXdSYXRlID0gcmF0ZXNbMF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmF0ZXNbaV0gPiBjdXJyZW50UmF0ZSkge1xuICAgICAgICBuZXdSYXRlID0gcmF0ZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZShuZXdSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBvc3NpYmxlIHBsYXliYWNrIHJhdGVzXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFsbCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZXMgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLnBsYXliYWNrUmF0ZXMgfHwgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zICYmIHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy5wbGF5YmFja1JhdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBwbGF5YmFjayByYXRlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHRlY2hcbiAgICogYW5kIGFuIGFycmF5IG9mIHBsYXliYWNrIHJhdGVzIGV4aXN0c1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFdoZXRoZXIgY2hhbmdpbmcgcGxheWJhY2sgcmF0ZSBpcyBzdXBwb3J0ZWRcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKSAmJiB0aGlzLnBsYXliYWNrUmF0ZXMoKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHBsYXliYWNrIHJhdGUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vIHBsYXliYWNrIHJhdGUgb3B0aW9ucyB0byBzZWxlY3RcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgYnV0dG9uIGxhYmVsIHdoZW4gcmF0ZSBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMubGFiZWxFbF8uaW5uZXJIVE1MID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSArICd4JztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XG59KE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5YmFjayBSYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51QnV0dG9uJywgUGxheWJhY2tSYXRlTWVudUJ1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgc3BhY2VyLmpzXG4gKi9cbi8qKlxuICogSnVzdCBhbiBlbXB0eSBzcGFjZXIgZWxlbWVudCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFwcGVuZCBwb2ludCBmb3IgcGx1Z2lucywgZXRjLlxuICogQWxzbyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgU3BhY2VyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoU3BhY2VyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTcGFjZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3BhY2VyICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNwYWNlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTcGFjZXInLCBTcGFjZXIpO1xuXG4vKipcbiAqIEBmaWxlIGN1c3RvbS1jb250cm9sLXNwYWNlci5qc1xuICovXG4vKipcbiAqIFNwYWNlciBzcGVjaWZpY2FsbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhbiBpbnNlcnRpb24gcG9pbnQgZm9yIG5ldyBwbHVnaW5zLCBldGMuXG4gKlxuICogQGV4dGVuZHMgU3BhY2VyXG4gKi9cblxudmFyIEN1c3RvbUNvbnRyb2xTcGFjZXIgPSBmdW5jdGlvbiAoX1NwYWNlcikge1xuICBpbmhlcml0cyhDdXN0b21Db250cm9sU3BhY2VyLCBfU3BhY2VyKTtcblxuICBmdW5jdGlvbiBDdXN0b21Db250cm9sU3BhY2VyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUNvbnRyb2xTcGFjZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TcGFjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgQ3VzdG9tQ29udHJvbFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY3VzdG9tLWNvbnRyb2wtc3BhY2VyICcgKyBfU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ3VzdG9tQ29udHJvbFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgZWwgPSBfU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9KTtcblxuICAgIC8vIE5vLWZsZXgvdGFibGUtY2VsbCBtb2RlIHJlcXVpcmVzIHRoZXJlIGJlIHNvbWUgY29udGVudFxuICAgIC8vIGluIHRoZSBjZWxsIHRvIGZpbGwgdGhlIHJlbWFpbmluZyBzcGFjZSBvZiB0aGUgdGFibGUuXG4gICAgZWwuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIHJldHVybiBDdXN0b21Db250cm9sU3BhY2VyO1xufShTcGFjZXIpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0N1c3RvbUNvbnRyb2xTcGFjZXInLCBDdXN0b21Db250cm9sU3BhY2VyKTtcblxuLyoqXG4gKiBAZmlsZSBjb250cm9sLWJhci5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBDb250YWluZXIgb2YgbWFpbiBjb250cm9scy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ29udHJvbEJhciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKENvbnRyb2xCYXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2xCYXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbEJhcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgQ29udHJvbEJhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtYmFyJyxcbiAgICAgIGRpcjogJ2x0cidcbiAgICB9LCB7XG4gICAgICAvLyBUaGUgY29udHJvbCBiYXIgaXMgYSBncm91cCwgYnV0IHdlIGRvbid0IGFyaWEtbGFiZWwgaXQgdG8gYXZvaWRcbiAgICAgIC8vICBvdmVyLWFubm91bmNpbmcgYnkgSkFXU1xuICAgICAgcm9sZTogJ2dyb3VwJ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sQmFyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbnRyb2xCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Db250cm9sQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsncGxheVRvZ2dsZScsICd2b2x1bWVQYW5lbCcsICdjdXJyZW50VGltZURpc3BsYXknLCAndGltZURpdmlkZXInLCAnZHVyYXRpb25EaXNwbGF5JywgJ3Byb2dyZXNzQ29udHJvbCcsICdsaXZlRGlzcGxheScsICdyZW1haW5pbmdUaW1lRGlzcGxheScsICdjdXN0b21Db250cm9sU3BhY2VyJywgJ3BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCAnY2hhcHRlcnNCdXR0b24nLCAnZGVzY3JpcHRpb25zQnV0dG9uJywgJ3N1YnNDYXBzQnV0dG9uJywgJ2F1ZGlvVHJhY2tCdXR0b24nLCAnZnVsbHNjcmVlblRvZ2dsZSddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NvbnRyb2xCYXInLCBDb250cm9sQmFyKTtcblxuLyoqXG4gKiBAZmlsZSBlcnJvci1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogQSBkaXNwbGF5IHRoYXQgaW5kaWNhdGVzIGFuIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBtZWFucyB0aGF0IHRoZSB2aWRlb1xuICogaXMgdW5wbGF5YWJsZS5cbiAqXG4gKiBAZXh0ZW5kcyBNb2RhbERpYWxvZ1xuICovXG5cbnZhciBFcnJvckRpc3BsYXkgPSBmdW5jdGlvbiAoX01vZGFsRGlhbG9nKSB7XG4gIGluaGVyaXRzKEVycm9yRGlzcGxheSwgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBFcnJvckRpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlcnJvcicsIF90aGlzLm9wZW4pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFNpbmNlIHZlcnNpb24gNS5cbiAgICovXG5cblxuICBFcnJvckRpc3BsYXkucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWVycm9yLWRpc3BsYXkgJyArIF9Nb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbGl6ZWQgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgYFBsYXllcmBzIGVycm9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgcyBlcnJvciBtZXNzYWdlIGxvY2FsaXplZCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnBsYXllcigpLmVycm9yKCk7XG5cbiAgICByZXR1cm4gZXJyb3IgPyB0aGlzLmxvY2FsaXplKGVycm9yLm1lc3NhZ2UpIDogJyc7XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yRGlzcGxheTtcbn0oTW9kYWxEaWFsb2cpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFuIGBFcnJvckRpc3BsYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5FcnJvckRpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXywge1xuICBwYXVzZU9uT3BlbjogZmFsc2UsXG4gIGZpbGxBbHdheXM6IHRydWUsXG4gIHRlbXBvcmFyeTogZmFsc2UsXG4gIHVuY2xvc2VhYmxlOiB0cnVlXG59KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdFcnJvckRpc3BsYXknLCBFcnJvckRpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stc2V0dGluZ3MuanNcbiAqL1xudmFyIExPQ0FMX1NUT1JBR0VfS0VZID0gJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcblxudmFyIENPTE9SX0JMQUNLID0gWycjMDAwJywgJ0JsYWNrJ107XG52YXIgQ09MT1JfQkxVRSA9IFsnIzAwRicsICdCbHVlJ107XG52YXIgQ09MT1JfQ1lBTiA9IFsnIzBGRicsICdDeWFuJ107XG52YXIgQ09MT1JfR1JFRU4gPSBbJyMwRjAnLCAnR3JlZW4nXTtcbnZhciBDT0xPUl9NQUdFTlRBID0gWycjRjBGJywgJ01hZ2VudGEnXTtcbnZhciBDT0xPUl9SRUQgPSBbJyNGMDAnLCAnUmVkJ107XG52YXIgQ09MT1JfV0hJVEUgPSBbJyNGRkYnLCAnV2hpdGUnXTtcbnZhciBDT0xPUl9ZRUxMT1cgPSBbJyNGRjAnLCAnWWVsbG93J107XG5cbnZhciBPUEFDSVRZX09QQVFVRSA9IFsnMScsICdPcGFxdWUnXTtcbnZhciBPUEFDSVRZX1NFTUkgPSBbJzAuNScsICdTZW1pLVRyYW5zcGFyZW50J107XG52YXIgT1BBQ0lUWV9UUkFOUyA9IFsnMCcsICdUcmFuc3BhcmVudCddO1xuXG4vLyBDb25maWd1cmF0aW9uIGZvciB0aGUgdmFyaW91cyA8c2VsZWN0PiBlbGVtZW50cyBpbiB0aGUgRE9NIG9mIHRoaXMgY29tcG9uZW50LlxuLy9cbi8vIFBvc3NpYmxlIGtleXMgaW5jbHVkZTpcbi8vXG4vLyBgZGVmYXVsdGA6XG4vLyAgIFRoZSBkZWZhdWx0IG9wdGlvbiBpbmRleC4gT25seSBuZWVkcyB0byBiZSBwcm92aWRlZCBpZiBub3QgemVyby5cbi8vIGBwYXJzZXJgOlxuLy8gICBBIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gcGFyc2UgdGhlIHZhbHVlIGZyb20gdGhlIHNlbGVjdGVkIG9wdGlvbiBpblxuLy8gICBhIGN1c3RvbWl6ZWQgd2F5LlxuLy8gYHNlbGVjdG9yYDpcbi8vICAgVGhlIHNlbGVjdG9yIHVzZWQgdG8gZmluZCB0aGUgYXNzb2NpYXRlZCA8c2VsZWN0PiBlbGVtZW50LlxudmFyIHNlbGVjdENvbmZpZ3MgPSB7XG4gIGJhY2tncm91bmRDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1iZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfQkxBQ0ssIENPTE9SX1dISVRFLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgYmFja2dyb3VuZE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctb3BhY2l0eSA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLW9wYWNpdHktJXMnLFxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcbiAgICBvcHRpb25zOiBbT1BBQ0lUWV9PUEFRVUUsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9UUkFOU11cbiAgfSxcblxuICBjb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1mZy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb3JlZ3JvdW5kLWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJyxcbiAgICBvcHRpb25zOiBbQ09MT1JfV0hJVEUsIENPTE9SX0JMQUNLLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXG4gIH0sXG5cbiAgZWRnZVN0eWxlOiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWVkZ2Utc3R5bGUgPiBzZWxlY3QnLFxuICAgIGlkOiAnJXMnLFxuICAgIGxhYmVsOiAnVGV4dCBFZGdlIFN0eWxlJyxcbiAgICBvcHRpb25zOiBbWydub25lJywgJ05vbmUnXSwgWydyYWlzZWQnLCAnUmFpc2VkJ10sIFsnZGVwcmVzc2VkJywgJ0RlcHJlc3NlZCddLCBbJ3VuaWZvcm0nLCAnVW5pZm9ybSddLCBbJ2Ryb3BzaGFkb3cnLCAnRHJvcHNoYWRvdyddXVxuICB9LFxuXG4gIGZvbnRGYW1pbHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1mYW1pbHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9udC1mYW1pbHktJXMnLFxuICAgIGxhYmVsOiAnRm9udCBGYW1pbHknLFxuICAgIG9wdGlvbnM6IFtbJ3Byb3BvcnRpb25hbFNhbnNTZXJpZicsICdQcm9wb3J0aW9uYWwgU2Fucy1TZXJpZiddLCBbJ21vbm9zcGFjZVNhbnNTZXJpZicsICdNb25vc3BhY2UgU2Fucy1TZXJpZiddLCBbJ3Byb3BvcnRpb25hbFNlcmlmJywgJ1Byb3BvcnRpb25hbCBTZXJpZiddLCBbJ21vbm9zcGFjZVNlcmlmJywgJ01vbm9zcGFjZSBTZXJpZiddLCBbJ2Nhc3VhbCcsICdDYXN1YWwnXSwgWydzY3JpcHQnLCAnU2NyaXB0J10sIFsnc21hbGwtY2FwcycsICdTbWFsbCBDYXBzJ11dXG4gIH0sXG5cbiAgZm9udFBlcmNlbnQ6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtc2l6ZS0lcycsXG4gICAgbGFiZWw6ICdGb250IFNpemUnLFxuICAgIG9wdGlvbnM6IFtbJzAuNTAnLCAnNTAlJ10sIFsnMC43NScsICc3NSUnXSwgWycxLjAwJywgJzEwMCUnXSwgWycxLjI1JywgJzEyNSUnXSwgWycxLjUwJywgJzE1MCUnXSwgWycxLjc1JywgJzE3NSUnXSwgWycyLjAwJywgJzIwMCUnXSwgWyczLjAwJywgJzMwMCUnXSwgWyc0LjAwJywgJzQwMCUnXV0sXG4gICAgJ2RlZmF1bHQnOiAyLFxuICAgIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSAnMS4wMCcgPyBudWxsIDogTnVtYmVyKHYpO1xuICAgIH1cbiAgfSxcblxuICB0ZXh0T3BhY2l0eToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy10ZXh0LW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUldXG4gIH0sXG5cbiAgLy8gT3B0aW9ucyBmb3IgdGhpcyBvYmplY3QgYXJlIGRlZmluZWQgYmVsb3cuXG4gIHdpbmRvd0NvbG9yOiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1jb2xvciA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy13aW5kb3ctY29sb3ItJXMnLFxuICAgIGxhYmVsOiAnQ29sb3InXG4gIH0sXG5cbiAgLy8gT3B0aW9ucyBmb3IgdGhpcyBvYmplY3QgYXJlIGRlZmluZWQgYmVsb3cuXG4gIHdpbmRvd09wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtd2luZG93LW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LW9wYWNpdHktJXMnLFxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcbiAgICBvcHRpb25zOiBbT1BBQ0lUWV9UUkFOUywgT1BBQ0lUWV9TRU1JLCBPUEFDSVRZX09QQVFVRV1cbiAgfVxufTtcblxuc2VsZWN0Q29uZmlncy53aW5kb3dDb2xvci5vcHRpb25zID0gc2VsZWN0Q29uZmlncy5iYWNrZ3JvdW5kQ29sb3Iub3B0aW9ucztcblxuLyoqXG4gKiBHZXQgdGhlIGFjdHVhbCB2YWx1ZSBvZiBhbiBvcHRpb24uXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgICBUaGUgdmFsdWUgdG8gZ2V0XG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcikge1xuICBpZiAocGFyc2VyKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgIHRoZSBlbGVtZW50IHRvIGxvb2sgaW5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gW3BhcnNlcl1cbiAqICAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vIHZhbHVlIGV4aXN0c1xuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwibm9uZVwiLlxuICogICAgICAgICAtIFdpbGwgYmUgdGhlIGFjdHVhbCB2YWx1ZSBvdGhlcndpc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShlbCwgcGFyc2VyKSB7XG4gIHZhciB2YWx1ZSA9IGVsLm9wdGlvbnNbZWwub3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcblxuICByZXR1cm4gcGFyc2VPcHRpb25WYWx1ZSh2YWx1ZSwgcGFyc2VyKTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzZWxlY3RlZCA8b3B0aW9uPiBlbGVtZW50IHdpdGhpbiBhIDxzZWxlY3Q+IGVsZW1lbnQgYmFzZWQgb24gYVxuICogZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHRvIGxvb2sgaW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgdGhlIHByb3BlcnR5IHRvIGxvb2sgb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcnNlcl1cbiAqICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlIGJlZm9yZSBjb21wYXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWRPcHRpb24oZWwsIHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWwub3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZU9wdGlvblZhbHVlKGVsLm9wdGlvbnNbaV0udmFsdWUsIHBhcnNlcikgPT09IHZhbHVlKSB7XG4gICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hbmlwdWxhdGUgVGV4dCBUcmFja3Mgc2V0dGluZ3MuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgVGV4dFRyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoX01vZGFsRGlhbG9nKSB7XG4gIGluaGVyaXRzKFRleHRUcmFja1NldHRpbmdzLCBfTW9kYWxEaWFsb2cpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tTZXR0aW5ncyhwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbiAgICBvcHRpb25zLnRlbXBvcmFyeSA9IGZhbHNlO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTW9kYWxEaWFsb2cuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZURpc3BsYXkgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcblxuICAgIC8vIGZpbGwgdGhlIG1vZGFsIGFuZCBwcmV0ZW5kIHdlIGhhdmUgb3BlbmVkIGl0XG4gICAgX3RoaXMuZmlsbCgpO1xuICAgIF90aGlzLmhhc0JlZW5PcGVuZWRfID0gX3RoaXMuaGFzQmVlbkZpbGxlZF8gPSB0cnVlO1xuXG4gICAgX3RoaXMuZW5kRGlhbG9nID0gY3JlYXRlRWwoJ3AnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIHRleHRDb250ZW50OiBfdGhpcy5sb2NhbGl6ZSgnRW5kIG9mIGRpYWxvZyB3aW5kb3cuJylcbiAgICB9KTtcbiAgICBfdGhpcy5lbCgpLmFwcGVuZENoaWxkKF90aGlzLmVuZERpYWxvZyk7XG5cbiAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuXG4gICAgLy8gR3JhYiBgcGVyc2lzdFRleHRUcmFja1NldHRpbmdzYCBmcm9tIHRoZSBwbGF5ZXIgb3B0aW9ucyBpZiBub3QgcGFzc2VkIGluIGNoaWxkIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX3RoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kb25lLWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy4kKCcudmpzLWRlZmF1bHQtYnV0dG9uJyksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNldERlZmF1bHRzKCk7XG4gICAgICBfdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfSk7XG5cbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIF90aGlzLm9uKF90aGlzLiQoY29uZmlnLnNlbGVjdG9yKSwgJ2NoYW5nZScsIF90aGlzLnVwZGF0ZURpc3BsYXkpO1xuICAgIH0pO1xuXG4gICAgaWYgKF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xuICAgICAgX3RoaXMucmVzdG9yZVNldHRpbmdzKCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVuZERpYWxvZyA9IG51bGw7XG5cbiAgICBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgPHNlbGVjdD4gZWxlbWVudCB3aXRoIGNvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiAgICAgICAgQ29uZmlndXJhdGlvbiBrZXkgdG8gdXNlIGR1cmluZyBjcmVhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFNlbGVjdF8gPSBmdW5jdGlvbiBjcmVhdGVFbFNlbGVjdF8oa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbGFiZWwnO1xuXG4gICAgdmFyIGNvbmZpZyA9IHNlbGVjdENvbmZpZ3Nba2V5XTtcbiAgICB2YXIgaWQgPSBjb25maWcuaWQucmVwbGFjZSgnJXMnLCB0aGlzLmlkXyk7XG5cbiAgICByZXR1cm4gWyc8JyArIHR5cGUgKyAnIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArICh0eXBlID09PSAnbGFiZWwnID8gJ3Zqcy1sYWJlbCcgOiAnJykgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZShjb25maWcubGFiZWwpLCAnPC8nICsgdHlwZSArICc+JywgJzxzZWxlY3QgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIChsZWdlbmRJZCAhPT0gJycgPyBsZWdlbmRJZCArICcgJyA6ICcnKSArIGlkICsgJ1wiPiddLmNvbmNhdChjb25maWcub3B0aW9ucy5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBvcHRpb25JZCA9IGlkICsgJy0nICsgb1sxXTtcblxuICAgICAgcmV0dXJuIFsnPG9wdGlvbiBpZD1cIicgKyBvcHRpb25JZCArICdcIiB2YWx1ZT1cIicgKyBvWzBdICsgJ1wiICcsICdhcmlhLWxhYmVsbGVkYnk9XCInICsgKGxlZ2VuZElkICE9PSAnJyA/IGxlZ2VuZElkICsgJyAnIDogJycpICsgaWQgKyAnICcgKyBvcHRpb25JZCArICdcIj4nLCBfdGhpczIubG9jYWxpemUob1sxXSksICc8L29wdGlvbj4nXS5qb2luKCcnKTtcbiAgICB9KSkuY29uY2F0KCc8L3NlbGVjdD4nKS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGZvcmVncm91bmQgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsRmdDb2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbEZnQ29sb3JfKCkge1xuICAgIHZhciBsZWdlbmRJZCA9ICdjYXB0aW9ucy10ZXh0LWxlZ2VuZC0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZmctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdUZXh0JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnY29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy10ZXh0LW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygndGV4dE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBiYWNrZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEJnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxCZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtYmFja2dyb3VuZC0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtYmctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdCYWNrZ3JvdW5kJyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZENvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtYmctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdiYWNrZ3JvdW5kT3BhY2l0eScsIGxlZ2VuZElkKSwgJzwvc3Bhbj4nLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHdpbmRvdyBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxXaW5Db2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbFdpbkNvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtd2luZG93LScgKyB0aGlzLmlkXztcblxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy13aW5kb3ctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdXaW5kb3cnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3dpbmRvd09wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb2xvciBlbGVtZW50cyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxDb2xvcnNfID0gZnVuY3Rpb24gY3JlYXRlRWxDb2xvcnNfKCkge1xuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbG9ycycsXG4gICAgICBpbm5lckhUTUw6IFt0aGlzLmNyZWF0ZUVsRmdDb2xvcl8oKSwgdGhpcy5jcmVhdGVFbEJnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxXaW5Db2xvcl8oKV0uam9pbignJylcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGZvbnQgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZvbnRfID0gZnVuY3Rpb24gY3JlYXRlRWxGb250XygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1mb250XCI+JyxcbiAgICAgIGlubmVySFRNTDogWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1wZXJjZW50IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRQZXJjZW50JywgJycsICdsZWdlbmQnKSwgJzwvZmllbGRzZXQ+JywgJzxmaWVsZHNldCBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2VkZ2VTdHlsZScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1mYW1pbHkgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnZm9udEZhbWlseScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjb250cm9scyBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29udHJvbHNfID0gZnVuY3Rpb24gY3JlYXRlRWxDb250cm9sc18oKSB7XG4gICAgdmFyIGRlZmF1bHRzRGVzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXplKCdyZXN0b3JlIGFsbCBzZXR0aW5ncyB0byB0aGUgZGVmYXVsdCB2YWx1ZXMnKTtcblxuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xzJyxcbiAgICAgIGlubmVySFRNTDogWyc8YnV0dG9uIGNsYXNzPVwidmpzLWRlZmF1bHQtYnV0dG9uXCIgdGl0bGU9XCInICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdSZXNldCcpLCAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyBkZWZhdWx0c0Rlc2NyaXB0aW9uICsgJzwvc3Bhbj4nLCAnPC9idXR0b24+JywgJzxidXR0b24gY2xhc3M9XCJ2anMtZG9uZS1idXR0b25cIj4nICsgdGhpcy5sb2NhbGl6ZSgnRG9uZScpICsgJzwvYnV0dG9uPiddLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgIHJldHVybiBbdGhpcy5jcmVhdGVFbENvbG9yc18oKSwgdGhpcy5jcmVhdGVFbEZvbnRfKCksIHRoaXMuY3JlYXRlRWxDb250cm9sc18oKV07XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUoJ0NhcHRpb24gU2V0dGluZ3MgRGlhbG9nJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUoJ0JlZ2lubmluZyBvZiBkaWFsb2cgd2luZG93LiBFc2NhcGUgd2lsbCBjYW5jZWwgYW5kIGNsb3NlIHRoZSB3aW5kb3cuJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKSArICcgdmpzLXRleHQtdHJhY2stc2V0dGluZ3MnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzIChvciBudWxsKS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIGNvbmZpZyB2YWx1ZXMgcGFyc2VkIGZyb20gdGhlIERPTSBvciBsb2NhbFN0b3JhZ2UuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIGdldFZhbHVlcygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHJldHVybiByZWR1Y2Uoc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGFjY3VtLCBjb25maWcsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShfdGhpczMuJChjb25maWcuc2VsZWN0b3IpLCBjb25maWcucGFyc2VyKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRleHQgdHJhY2sgc2V0dGluZ3MgZnJvbSBhbiBvYmplY3Qgb2YgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzXG4gICAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcsIGtleSkge1xuICAgICAgc2V0U2VsZWN0ZWRPcHRpb24oX3RoaXM0LiQoY29uZmlnLnNlbGVjdG9yKSwgdmFsdWVzW2tleV0sIGNvbmZpZy5wYXJzZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGFsbCBgPHNlbGVjdD5gIGVsZW1lbnRzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIHNldERlZmF1bHRzKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICB2YXIgaW5kZXggPSBjb25maWcuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IGNvbmZpZ1snZGVmYXVsdCddIDogMDtcblxuICAgICAgX3RoaXM1LiQoY29uZmlnLnNlbGVjdG9yKS5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGV4dHRyYWNrIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnJlc3RvcmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHJlc3RvcmVTZXR0aW5ncygpIHtcbiAgICB2YXIgdmFsdWVzID0gdm9pZCAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlcyA9IEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2ckMS53YXJuKGVycik7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgdGhpcy5zZXRWYWx1ZXModmFsdWVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhdmUgdGV4dCB0cmFjayBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2F2ZVNldHRpbmdzID0gZnVuY3Rpb24gc2F2ZVNldHRpbmdzKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGgpIHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh2YWx1ZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTF9TVE9SQUdFX0tFWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2ckMS53YXJuKGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGlzcGxheSBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0dERpc3BsYXkgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ3RleHRUcmFja0Rpc3BsYXknKTtcblxuICAgIGlmICh0dERpc3BsYXkpIHtcbiAgICAgIHR0RGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBjb25kaXRpb25hbGx5IGJsdXIgdGhlIGVsZW1lbnQgYW5kIHJlZm9jdXMgdGhlIGNhcHRpb25zIGJ1dHRvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xuICAgIHRoaXMub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uY29udHJvbEJhcjtcbiAgICB2YXIgc3Vic0NhcHNCdG4gPSBjYiAmJiBjYi5zdWJzQ2Fwc0J1dHRvbjtcbiAgICB2YXIgY2NCdG4gPSBjYiAmJiBjYi5jYXB0aW9uc0J1dHRvbjtcblxuICAgIGlmIChzdWJzQ2Fwc0J0bikge1xuICAgICAgc3Vic0NhcHNCdG4uZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKGNjQnRuKSB7XG4gICAgICBjY0J0bi5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrU2V0dGluZ3M7XG59KE1vZGFsRGlhbG9nKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tTZXR0aW5ncycsIFRleHRUcmFja1NldHRpbmdzKTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQyID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddLCBbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuXFxuICAgICAgICAgICAgVGhpcyBtYXkgcHJldmVudCB0ZXh0IHRyYWNrcyBmcm9tIGxvYWRpbmcuJ10pO1xuXG4vKipcbiAqIEBmaWxlIGh0bWw1LmpzXG4gKi9cbi8qKlxuICogSFRNTDUgTWVkaWEgQ29udHJvbGxlciAtIFdyYXBwZXIgZm9yIEhUTUw1IE1lZGlhIEFQSVxuICpcbiAqIEBtaXhlcyBUZWNoflNvdWNlSGFuZGxlckFkZGl0aW9uc1xuICogQGV4dGVuZHMgVGVjaFxuICovXG5cbnZhciBIdG1sNSA9IGZ1bmN0aW9uIChfVGVjaCkge1xuICBpbmhlcml0cyhIdG1sNSwgX1RlY2gpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSByZWFkeVxuICAgKiAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBgSFRNTDVgIFRlY2ggaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBIdG1sNShvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWw1KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RlY2guY2FsbCh0aGlzLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgIHZhciBjcm9zc29yaWdpblRyYWNrcyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IHRoZSBzb3VyY2UgaWYgb25lIGlzIHByb3ZpZGVkXG4gICAgLy8gMSkgQ2hlY2sgaWYgdGhlIHNvdXJjZSBpcyBuZXcgKGlmIG5vdCwgd2Ugd2FudCB0byBrZWVwIHRoZSBvcmlnaW5hbCBzbyBwbGF5YmFjayBpc24ndCBpbnRlcnJ1cHRlZClcbiAgICAvLyAyKSBDaGVjayB0byBzZWUgaWYgdGhlIG5ldHdvcmsgc3RhdGUgb2YgdGhlIHRhZyB3YXMgZmFpbGVkIGF0IGluaXQsIGFuZCBpZiBzbywgcmVzZXQgdGhlIHNvdXJjZVxuICAgIC8vIGFueXdheSBzbyB0aGUgZXJyb3IgZ2V0cyBmaXJlZC5cbiAgICBpZiAoc291cmNlICYmIChfdGhpcy5lbF8uY3VycmVudFNyYyAhPT0gc291cmNlLnNyYyB8fCBvcHRpb25zLnRhZyAmJiBvcHRpb25zLnRhZy5pbml0TmV0d29ya1N0YXRlXyA9PT0gMykpIHtcbiAgICAgIF90aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5oYW5kbGVMYXRlSW5pdF8oX3RoaXMuZWxfKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuZWxfLmhhc0NoaWxkTm9kZXMoKSkge1xuXG4gICAgICB2YXIgbm9kZXMgPSBfdGhpcy5lbF8uY2hpbGROb2RlcztcbiAgICAgIHZhciBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciByZW1vdmVOb2RlcyA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZXNMZW5ndGgtLSkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW25vZGVzTGVuZ3RoXTtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICAgICAgICAvLyBFbXB0eSB2aWRlbyB0YWcgdHJhY2tzIHNvIHRoZSBidWlsdC1pbiBwbGF5ZXIgZG9lc24ndCB1c2UgdGhlbSBhbHNvLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbm90IGJlIGZhc3QgZW5vdWdoIHRvIHN0b3AgSFRNTDUgYnJvd3NlcnMgZnJvbSByZWFkaW5nIHRoZSB0YWdzXG4gICAgICAgICAgICAvLyBzbyB3ZSdsbCBuZWVkIHRvIHR1cm4gb2ZmIGFueSBkZWZhdWx0IHRyYWNrcyBpZiB3ZSdyZSBtYW51YWxseSBkb2luZ1xuICAgICAgICAgICAgLy8gY2FwdGlvbnMgYW5kIHN1YnRpdGxlcy4gdmlkZW9FbGVtZW50LnRleHRUcmFja3NcbiAgICAgICAgICAgIHJlbW92ZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgICAgICAgICAgX3RoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuYWRkVHJhY2tFbGVtZW50Xyhub2RlKTtcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhub2RlLnRyYWNrKTtcbiAgICAgICAgICAgIF90aGlzLnRleHRUcmFja3MoKS5hZGRUcmFjayhub2RlLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICghY3Jvc3NvcmlnaW5UcmFja3MgJiYgIV90aGlzLmVsXy5oYXNBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJykgJiYgaXNDcm9zc09yaWdpbihub2RlLnNyYykpIHtcbiAgICAgICAgICAgICAgY3Jvc3NvcmlnaW5UcmFja3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF90aGlzLmVsXy5yZW1vdmVDaGlsZChyZW1vdmVOb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMucHJveHlOYXRpdmVUcmFja3NfKCk7XG4gICAgaWYgKF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyAmJiBjcm9zc29yaWdpblRyYWNrcykge1xuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCQyKSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBpT1MgU2FmYXJpIGZyb20gZGlzYWJsaW5nIG1ldGFkYXRhIHRleHQgdHJhY2tzIGR1cmluZyBuYXRpdmUgcGxheWJhY2tcbiAgICBfdGhpcy5yZXN0b3JlTWV0YWRhdGFUcmFja3NJbklPU05hdGl2ZVBsYXllcl8oKTtcblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoKFRPVUNIX0VOQUJMRUQgfHwgSVNfSVBIT05FIHx8IElTX05BVElWRV9BTkRST0lEKSAmJiBvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggPT09IHRydWUpIHtcbiAgICAgIF90aGlzLnNldENvbnRyb2xzKHRydWUpO1xuICAgIH1cblxuICAgIC8vIG9uIGlPUywgd2Ugd2FudCB0byBwcm94eSBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gXG4gICAgLy8gaW50byBhIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudFxuICAgIF90aGlzLnByb3h5V2Via2l0RnVsbHNjcmVlbl8oKTtcblxuICAgIF90aGlzLnRyaWdnZXJSZWFkeSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIGBIVE1MNWAgbWVkaWEgZWxlbWVudCBhbmQgcmVtb3ZlIGFsbCB0cmFja3MuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICAgIHRoaXMub3B0aW9uc18gPSBudWxsO1xuXG4gICAgLy8gdGVjaCB3aWxsIGhhbmRsZSBjbGVhcmluZyBvZiB0aGUgZW11bGF0ZWQgdHJhY2sgbGlzdFxuICAgIF9UZWNoLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjYXB0aW9ucyB0cmFjayBpcyBlbmFibGVkIGluIHRoZSBpT1MgU2FmYXJpIG5hdGl2ZSBwbGF5ZXIsIGFsbCBvdGhlclxuICAgKiB0cmFja3MgYXJlIGRpc2FibGVkIChpbmNsdWRpbmcgbWV0YWRhdGEgdHJhY2tzKSwgd2hpY2ggbnVsbHMgYWxsIG9mIHRoZWlyXG4gICAqIGFzc29jaWF0ZWQgY3VlIHBvaW50cy4gVGhpcyB3aWxsIHJlc3RvcmUgbWV0YWRhdGEgdHJhY2tzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuXG4gICAqIHN0YXRlIGluIHRob3NlIGNhc2VzIHNvIHRoYXQgY3VlIHBvaW50cyBhcmUgbm90IG5lZWRsZXNzbHkgbG9zdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfID0gZnVuY3Rpb24gcmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCkge1xuICAgIHZhciB0ZXh0VHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlID0gdm9pZCAwO1xuXG4gICAgLy8gY2FwdHVyZXMgYSBzbmFwc2hvdCBvZiBldmVyeSBtZXRhZGF0YSB0cmFjaydzIGN1cnJlbnQgc3RhdGVcbiAgICB2YXIgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCA9IGZ1bmN0aW9uIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKSB7XG4gICAgICBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdGV4dFRyYWNrc1tpXTtcblxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJykge1xuICAgICAgICAgIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLnB1c2goe1xuICAgICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgICAgc3RvcmVkTW9kZTogdHJhY2subW9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHNuYXBzaG90IGVhY2ggbWV0YWRhdGEgdHJhY2sncyBpbml0aWFsIHN0YXRlLCBhbmQgdXBkYXRlIHRoZSBzbmFwc2hvdFxuICAgIC8vIGVhY2ggdGltZSB0aGVyZSBpcyBhIHRyYWNrICdjaGFuZ2UnIGV2ZW50XG4gICAgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCgpO1xuICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdG9yZVRyYWNrTW9kZSA9IGZ1bmN0aW9uIHJlc3RvcmVUcmFja01vZGUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdG9yZWRUcmFjayA9IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlW2ldO1xuXG4gICAgICAgIGlmIChzdG9yZWRUcmFjay50cmFjay5tb2RlID09PSAnZGlzYWJsZWQnICYmIHN0b3JlZFRyYWNrLnRyYWNrLm1vZGUgIT09IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGUpIHtcbiAgICAgICAgICBzdG9yZWRUcmFjay50cmFjay5tb2RlID0gc3RvcmVkVHJhY2suc3RvcmVkTW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gd2Ugb25seSB3YW50IHRoaXMgaGFuZGxlciB0byBiZSBleGVjdXRlZCBvbiB0aGUgZmlyc3QgJ2NoYW5nZScgZXZlbnRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfTtcblxuICAgIC8vIHdoZW4gd2UgZW50ZXIgZnVsbHNjcmVlbiBwbGF5YmFjaywgc3RvcCB1cGRhdGluZyB0aGUgc25hcHNob3QgYW5kXG4gICAgLy8gcmVzdG9yZSBhbGwgdHJhY2sgbW9kZXMgdG8gdGhlaXIgcHJlLWZ1bGxzY3JlZW4gc3RhdGVcbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFnYWluIGFmdGVyIGxlYXZpbmcgZnVsbHNjcmVlblxuICAgIHRoaXMub24oJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyIGJlZm9yZSBhZGRpbmcgaXQganVzdCBpbiBjYXNlIGl0IHdhc24ndCBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHJlc3RvcmVUcmFja01vZGUgaGFuZGxlciBpbiBjYXNlIGl0IHdhc24ndCB0cmlnZ2VyZWQgZHVyaW5nIGZ1bGxzY3JlZW4gcGxheWJhY2tcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcmVzdG9yZVRyYWNrTW9kZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGFsbCBuYXRpdmUgdHJhY2sgbGlzdCBldmVudHMgdG8gb3VyIHRyYWNrIGxpc3RzIGlmIHRoZSBicm93c2VyIHdlIGFyZSBwbGF5aW5nXG4gICAqIGluIHN1cHBvcnRzIHRoYXQgdHlwZSBvZiB0cmFjayBsaXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5wcm94eU5hdGl2ZVRyYWNrc18gPSBmdW5jdGlvbiBwcm94eU5hdGl2ZVRyYWNrc18oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBOT1JNQUwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gTk9STUFMW25hbWVdO1xuICAgICAgdmFyIGVsVHJhY2tzID0gX3RoaXMyLmVsKClbcHJvcHMuZ2V0dGVyTmFtZV07XG4gICAgICB2YXIgdGVjaFRyYWNrcyA9IF90aGlzMltwcm9wcy5nZXR0ZXJOYW1lXSgpO1xuXG4gICAgICBpZiAoIV90aGlzMlsnZmVhdHVyZXNOYXRpdmUnICsgcHJvcHMuY2FwaXRhbE5hbWUgKyAnVHJhY2tzJ10gfHwgIWVsVHJhY2tzIHx8ICFlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XG4gICAgICAgIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLnRyaWdnZXIoe1xuICAgICAgICAgICAgdHlwZTogJ2NoYW5nZScsXG4gICAgICAgICAgICB0YXJnZXQ6IHRlY2hUcmFja3MsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgc3JjRWxlbWVudDogdGVjaFRyYWNrc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGR0cmFjazogZnVuY3Rpb24gYWRkdHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZXRyYWNrOiBmdW5jdGlvbiByZW1vdmV0cmFjayhlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhlLnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciByZW1vdmVPbGRUcmFja3MgPSBmdW5jdGlvbiByZW1vdmVPbGRUcmFja3MoKSB7XG4gICAgICAgIHZhciByZW1vdmVUcmFja3MgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlY2hUcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxUcmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChlbFRyYWNrc1tqXSA9PT0gdGVjaFRyYWNrc1tpXSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYWNrcy5wdXNoKHRlY2hUcmFja3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZW1vdmVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy5yZW1vdmVUcmFjayhyZW1vdmVUcmFja3Muc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGVsVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsVHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSAobmF0aXZlKSB0cmFja3MgdGhhdCBhcmUgbm90IHVzZWQgYW55bW9yZVxuICAgICAgX3RoaXMyLm9uKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgX3RoaXMyLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5vZmYoJ2xvYWRzdGFydCcsIHJlbW92ZU9sZFRyYWNrcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgSHRtbDVgIFRlY2gncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLm9wdGlvbnNfLnRhZztcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBtb3ZpbmcgdGhlIGVsZW1lbnQgaW50byB0aGUgYm94LlxuICAgIC8vIE9uIHRoZSBpUGhvbmUgdmlkZW8gd2lsbCBicmVhayBpZiB5b3UgbW92ZSB0aGUgZWxlbWVudCxcbiAgICAvLyBTbyB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGJyYW5kIG5ldyBlbGVtZW50LlxuICAgIC8vIElmIHdlIGluZ2VzdGVkIHRoZSBwbGF5ZXIgZGl2LCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIHRoZSBtZWRpYSBlbGVtZW50LlxuICAgIGlmICghZWwgfHwgISh0aGlzLm9wdGlvbnNfLnBsYXllckVsSW5nZXN0IHx8IHRoaXMubW92aW5nTWVkaWFFbGVtZW50SW5ET00pKSB7XG5cbiAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0YWcgaXMgc3RpbGwgdGhlcmUsIGNsb25lIGFuZCByZW1vdmUgaXQuXG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KGVsKTtcbiAgICAgICAgZWwgPSBjbG9uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIHZhciB0YWdBdHRyaWJ1dGVzID0gdGhpcy5vcHRpb25zXy50YWcgJiYgZ2V0QXR0cmlidXRlcyh0aGlzLm9wdGlvbnNfLnRhZyk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbWVyZ2VPcHRpb25zKHt9LCB0YWdBdHRyaWJ1dGVzKTtcblxuICAgICAgICBpZiAoIVRPVUNIX0VOQUJMRUQgfHwgdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoICE9PSB0cnVlKSB7XG4gICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuY29udHJvbHM7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGVsLCBhc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgIGlkOiB0aGlzLm9wdGlvbnNfLnRlY2hJZCxcbiAgICAgICAgICAnY2xhc3MnOiAndmpzLXRlY2gnXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgZWwucGxheWVySWQgPSB0aGlzLm9wdGlvbnNfLnBsYXllcklkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zXy5wcmVsb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2V0QXR0cmlidXRlKGVsLCAncHJlbG9hZCcsIHRoaXMub3B0aW9uc18ucHJlbG9hZCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNwZWNpZmljIHRhZyBzZXR0aW5ncywgaW4gY2FzZSB0aGV5IHdlcmUgb3ZlcnJpZGRlblxuICAgIC8vIGBhdXRvcGxheWAgaGFzIHRvIGJlICpsYXN0KiBzbyB0aGF0IGBtdXRlZGAgYW5kIGBwbGF5c2lubGluZWAgYXJlIHByZXNlbnRcbiAgICAvLyB3aGVuIGlPUy9TYWZhcmkgb3Igb3RoZXIgYnJvd3NlcnMgYXR0ZW1wdCB0byBhdXRvcGxheS5cbiAgICB2YXIgc2V0dGluZ3NBdHRycyA9IFsnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZScsICdhdXRvcGxheSddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXR0aW5nc0F0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnNfW2F0dHJdO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWwsIGF0dHIsIGF0dHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZShlbCwgYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxbYXR0cl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCwgYmVmb3JlIHZpZGVvanMgd2FzXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxuICAgKiAxLiBJZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZ1xuICAgKiAyLiBUaGUgbWVkaWEgaXMgYWxyZWFkeSBwbGF5aW5nIHRoZSAob2Z0ZW4gd2l0aCBhdXRvcGxheSBvbikgdGhlblxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZmlyZSBhbm90aGVyIGxvYWRzdGFydCBzbyB0aGF0IHZpZGVvanMgY2FuIGNhdGNodXAuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVMYXRlSW5pdF8gPSBmdW5jdGlvbiBoYW5kbGVMYXRlSW5pdF8oZWwpIHtcbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXG4gICAgICAvLyBlbmQgb2YgdGhlIGN1cnJlbnQgc3RhY2ssIHVzdWFsbHkgYmVmb3JlIHNldEludGVydmFsKGZuLCAwKS5cbiAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGZpcmUgbG9hZHN0YXJ0IHByZW1hdHVyZWx5IGhlcmUgYW5kIGNhdXNlIGFcbiAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXG4gICAgICAvLyBIT1dFVkVSLCB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGZpcmVzIGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxuICAgICAgdmFyIGxvYWRzdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICB2YXIgdHJpZ2dlckxvYWRzdGFydCA9IGZ1bmN0aW9uIHRyaWdnZXJMb2Fkc3RhcnQoKSB7XG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXG4gICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdsb2Fkc3RhcnQnLCBzZXRMb2Fkc3RhcnRGaXJlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbmF0aXZlIGxvYWRzdGFydC4gRmlyZSBpdCBub3cuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcm9tIGhlcmUgb24gd2Uga25vdyB0aGF0IGxvYWRzdGFydCBhbHJlYWR5IGZpcmVkIGFuZCB3ZSBtaXNzZWQgaXQuXG4gICAgLy8gVGhlIG90aGVyIHJlYWR5U3RhdGUgZXZlbnRzIGFyZW4ndCBhcyBtdWNoIG9mIGEgcHJvYmxlbSBpZiB3ZSBkb3VibGVcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XG4gICAgLy8gdGhhdCB1bmxlc3Mgd2UgZmluZCByZWFzb24gdG8uXG4gICAgdmFyIGV2ZW50c1RvVHJpZ2dlciA9IFsnbG9hZHN0YXJ0J107XG5cbiAgICAvLyBsb2FkZWRtZXRhZGF0YTogbmV3bHkgZXF1YWwgdG8gSEFWRV9NRVRBREFUQSAoMSkgb3IgZ3JlYXRlclxuICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRtZXRhZGF0YScpO1xuXG4gICAgLy8gbG9hZGVkZGF0YTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfQ1VSUkVOVF9EQVRBICgyKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDMpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheXRocm91Z2g6IG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEgKDQpXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnaXZlIHRoZSBwbGF5ZXIgdGltZSB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZSBmb3IgdGhlIGBIVE1MNWAgdGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAgICogICAgICAgIFNldCB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBtZWRpYSB0byB0aGlzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbF8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyQxKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcbiAgICAgIC8vIHRoaXMud2FybmluZyhWaWRlb0pTLndhcm5pbmdzLnZpZGVvTm90UmVhZHkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBvciAwIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gQW5kcm9pZCBDaHJvbWUgd2lsbCByZXBvcnQgZHVyYXRpb24gYXMgSW5maW5pdHkgZm9yIFZPRCBITFMgdW50aWwgYWZ0ZXJcbiAgICAvLyBwbGF5YmFjayBoYXMgc3RhcnRlZCwgd2hpY2ggdHJpZ2dlcnMgdGhlIGxpdmUgZGlzcGxheSBlcnJvbmVvdXNseS5cbiAgICAvLyBSZXR1cm4gTmFOIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhbmQgdHJpZ2dlciBhIGR1cmF0aW9udXBkYXRlIG9uY2VcbiAgICAvLyB0aGUgZHVyYXRpb24gY2FuIGJlIHJlbGlhYmx5IGtub3duLlxuICAgIGlmICh0aGlzLmVsXy5kdXJhdGlvbiA9PT0gSW5maW5pdHkgJiYgSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgdGhpcy5lbF8uY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaXJzdCBgdGltZXVwZGF0ZWAgd2l0aCBjdXJyZW50VGltZSA+IDAgLSB0aGVyZSBtYXkgYmVcbiAgICAgIC8vIHNldmVyYWwgd2l0aCAwXG4gICAgICB2YXIgY2hlY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIGNoZWNrUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmIChfdGhpczMuZWxfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgICAgIC8vIFRyaWdnZXIgZHVyYXRpb25jaGFuZ2UgZm9yIGdlbnVpbmVseSBsaXZlIHZpZGVvXG4gICAgICAgICAgaWYgKF90aGlzMy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBfdGhpczMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLm9mZigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgY2hlY2tQcm9ncmVzcyk7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldFdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGhlaWd0aCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGlPUyBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gIGludG9cbiAgICogYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAbGlzdGVucyB3ZWJraXRlbmRmdWxsc2NyZWVuXG4gICAqIEBsaXN0ZW5zIHdlYmtpdGJlZ2luZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlXZWJraXRGdWxsc2NyZWVuXyA9IGZ1bmN0aW9uIHByb3h5V2Via2l0RnVsbHNjcmVlbl8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoISgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHRoaXMuZWxfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmRGbiA9IGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJywgeyBpc0Z1bGxzY3JlZW46IGZhbHNlIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYmVnaW5GbiA9IGZ1bmN0aW9uIGJlZ2luRm4oKSB7XG4gICAgICBpZiAoJ3dlYmtpdFByZXNlbnRhdGlvbk1vZGUnIGluIHRoaXMuZWxfICYmIHRoaXMuZWxfLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgIT09ICdwaWN0dXJlLWluLXBpY3R1cmUnKSB7XG4gICAgICAgIHRoaXMub25lKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBiZWdpbkZuKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgICBfdGhpczQub2ZmKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBwbGF5YmFjayBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsXy53ZWJraXRFbnRlckZ1bGxTY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuXG4gICAgICAvLyBTZWVtcyB0byBiZSBicm9rZW4gaW4gQ2hyb21pdW0vQ2hyb21lICYmIFNhZmFyaSBpbiBMZW9wYXJkXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZW50ZXIgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZW50ZXJGdWxsU2NyZWVuID0gZnVuY3Rpb24gZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHZhciB2aWRlbyA9IHRoaXMuZWxfO1xuXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBwcmltZSB0aGUgdmlkZW8gZWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljIGFjY2Vzc1xuICAgICAgLy8gdGhpcyBpc24ndCBuZWNlc3Nhcnkgb24gdGhlIGRlc2t0b3AgYnV0IHNob3VsZG4ndCBodXJ0XG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAgIC8vIHBsYXlpbmcgYW5kIHBhdXNpbmcgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIHRyYW5zaXRpb24gdG8gZnVsbHNjcmVlblxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZXhpdCBmdWxsc2NyZWVuLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGV4aXRGdWxsU2NyZWVuKCkge1xuICAgIHRoaXMuZWxfLndlYmtpdEV4aXRGdWxsU2NyZWVuKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBIdG1sNWAgVGVjaCdzIHNvdXJjZSBvYmplY3QuXG4gICAqID4gTm90ZTogUGxlYXNlIHVzZSB7QGxpbmsgSHRtbDUjc2V0U291cmNlfVxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBbc3JjXVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgeW91IHdhbnQgdG8gc2V0IG9uIHRoZSBgSFRNTDVgIHRlY2hzIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgd2hlbiBhIHNvdXJjZSBpcyBub3QgcGFzc2VkIGluLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhfc3JjKSB7XG4gICAgaWYgKF9zcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxfLnNyYztcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgdGhpcy5zZXRTcmMoX3NyYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoIGJ5IHJlbW92aW5nIGFsbCBzb3VyY2VzIGFuZCB0aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIEh0bWw1LnJlc2V0TWVkaWFFbGVtZW50fS5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBIdG1sNS5yZXNldE1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2Ugb24gdGhlIGBIVE1MNWAgVGVjaC4gRmFsbHMgYmFjayB0byByZXR1cm5pbmcgdGhlIHNvdXJjZSBmcm9tXG4gICAqIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IGZyb20gdGhlIEhUTUw1IHRlY2guIFdpdGggYSBmYWxsYmFjayB0byB0aGVcbiAgICogICAgICAgICBlbGVtZW50cyBzb3VyY2UuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlXy5zcmM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsXy5jdXJyZW50U3JjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY29udHJvbHMgYXR0cmlidXRlIGZvciB0aGUgSFRNTDUgbWVkaWEgRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBjb250cm9scyBhdHRyaWJ1dGUgdG9cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q29udHJvbHMgPSBmdW5jdGlvbiBzZXRDb250cm9scyh2YWwpIHtcbiAgICB0aGlzLmVsXy5jb250cm9scyA9ICEhdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICByZXR1cm4gX1RlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjay5jYWxsKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGVpdGhlciBuYXRpdmUgVGV4dFRyYWNrIG9yIGFuIGVtdWxhdGVkIFRleHRUcmFjayBkZXBlbmRpbmdcbiAgICogb24gdGhlIHZhbHVlIG9mIGBmZWF0dXJlc05hdGl2ZVRleHRUcmFja3NgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGludGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIERlZmF1bHQgdGhpcyB0cmFjayB0byBvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXVxuICAgKiAgICAgICAgVGhlIGludGVybmFsIGlkIHRvIGFzc2lnbiB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSBzb3VyY2UgdXJsIGZvciB0aGUgdHJhY2suXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gICAgaWYgKG9wdGlvbnMua2luZCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5raW5kID0gb3B0aW9ucy5raW5kO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZykge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5zcmNsYW5nID0gb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjID0gb3B0aW9ucy5zcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW1vdGUgdGV4dCB0cmFjayBvYmplY3QgYW5kIHJldHVybnMgYW4gaHRtbCB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHZhbHVlcyBmb3JcbiAgICoga2luZCwgbGFuZ3VhZ2UsIGxhYmVsLCBhbmQgc3JjIChsb2NhdGlvbiBvZiB0aGUgV2ViVlRUIGZpbGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9IEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB3aWxsIGRlZmF1bHRcbiAgICogdG8gXCJmYWxzZVwiIGluIHVwY29taW5nIHZlcnNpb25zIG9mIFZpZGVvLmpzXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBfVGVjaC5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucywgbWFudWFsQ2xlYW51cCk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuZWwoKS5hcHBlbmRDaGlsZChodG1sVHJhY2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHJlbW90ZSBgVGV4dFRyYWNrYCBmcm9tIGBUZXh0VHJhY2tMaXN0YCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBvYmplY3QgdG8gcmVtb3ZlXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIF9UZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLiQkKCd0cmFjaycpO1xuXG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRyYWNrID09PSB0cmFja3NbaV0gfHwgdHJhY2sgPT09IHRyYWNrc1tpXS50cmFjaykge1xuICAgICAgICAgIHRoaXMuZWwoKS5yZW1vdmVDaGlsZCh0cmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0ge307XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuZWwoKS53ZWJraXREZWNvZGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyA9IHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudDtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAod2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LkRhdGUubm93KCkgLSB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9QbGF5YmFja1F1YWxpdHk7XG4gIH07XG5cbiAgcmV0dXJuIEh0bWw1O1xufShUZWNoKTtcblxuLyogSFRNTDUgU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuaWYgKGlzUmVhbCgpKSB7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgZm9yIHRlc3RpbmcgYnJvd3NlciBIVE1MNSBtZWRpYSBjYXBhYmlsaXRpZXNcbiAgICpcbiAgICogQHR5cGUge0VsZW1lbnR9XG4gICAqIEBjb25zdGFudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSHRtbDUuVEVTVF9WSUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gIHRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xuICB0cmFjay5zcmNsYW5nID0gJ2VuJztcbiAgdHJhY2subGFiZWwgPSAnRW5nbGlzaCc7XG4gIEh0bWw1LlRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBIVE1MNSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkLlxuICogICAgICAgICAtIEZhbHNlIGlmIEhUTUw1IG1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbkh0bWw1LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSAwLjU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBIdG1sNS5jYW5QbGF5VHlwZShzcmNPYmoudHlwZSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqIFZvbHVtZSBjYW5ub3QgYmUgY2hhbmdlZCBpbiBhIGxvdCBvZiBtb2JpbGUgZGV2aWNlcy5cbiAqIFNwZWNpZmljYWxseSwgaXQgY2FuJ3QgYmUgY2hhbmdlZCBmcm9tIDEgb24gaU9TLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB2b2x1bWUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHZvbHVtZSA9IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcblxuICAgIEh0bWw1LlRFU1RfVklELnZvbHVtZSA9IHZvbHVtZSAvIDIgKyAwLjE7XG4gICAgcmV0dXJuIHZvbHVtZSAhPT0gSHRtbDUuVEVTVF9WSUQudm9sdW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwbGF5YmFjayByYXRlIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGxheWJhY2sgcmF0ZSBBUEkgaXMgaW1wbGVtZW50ZWQgaW4gQW5kcm9pZCBDaHJvbWUsIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8zMTgwXG4gIGlmIChJU19BTkRST0lEICYmIElTX0NIUk9NRSAmJiBDSFJPTUVfVkVSU0lPTiA8IDU4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciBwbGF5YmFja1JhdGUgPSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGUgLyAyICsgMC4xO1xuICAgIHJldHVybiBwbGF5YmFja1JhdGUgIT09IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSVNfQU5ZX1NBRkFSSTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELnZpZGVvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmF1ZGlvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgZXZlbnRzIGF2YWlsYWJsZSBvbiB0aGUgSHRtbDUgdGVjaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0FycmF5fVxuICovXG5IdG1sNS5FdmVudHMgPSBbJ2xvYWRzdGFydCcsICdzdXNwZW5kJywgJ2Fib3J0JywgJ2Vycm9yJywgJ2VtcHRpZWQnLCAnc3RhbGxlZCcsICdsb2FkZWRtZXRhZGF0YScsICdsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NlZWtpbmcnLCAnc2Vla2VkJywgJ2VuZGVkJywgJ2R1cmF0aW9uY2hhbmdlJywgJ3RpbWV1cGRhdGUnLCAncHJvZ3Jlc3MnLCAncGxheScsICdwYXVzZScsICdyYXRlY2hhbmdlJywgJ3Jlc2l6ZScsICd2b2x1bWVjaGFuZ2UnXTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHZvbHVtZSBjb250cm9sLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xWb2x1bWV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSBIdG1sNS5jYW5Db250cm9sVm9sdW1lKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIG1lZGlhXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZX1cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBtb3ZpbmcgaW4gdGhlIERPTS4gaU9TIGJyZWFrcyBpZiB5b3UgbW92ZSB0aGUgbWVkaWEgZWxlbWVudCwgc28gdGhpcyBpcyBzZXQgdGhpcyB0b1xuICogZmFsc2UgdGhlcmUuIEV2ZXJ5d2hlcmUgZWxzZSB0aGlzIHNob3VsZCBiZSB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLm1vdmluZ01lZGlhRWxlbWVudEluRE9NID0gIUlTX0lPUztcblxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4vLyAgICAgICBJcyB0aGlzIHRydWU/XG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcbiAqIHdoZW4gZ29pbmcgaW50byBmdWxsc2NyZWVuLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGBwcm9ncmVzc2AgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgdGltZXVwZGF0ZSBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFRleHRUcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgVmlkZW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgQXVkaW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZUF1ZGlvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcygpO1xuXG4vLyBIVE1MNSBGZWF0dXJlIGRldGVjdGlvbiBhbmQgRGV2aWNlIEZpeGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xudmFyIGNhblBsYXlUeXBlID0gSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xudmFyIG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XG52YXIgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgaWYgKEFORFJPSURfVkVSU0lPTiA+PSA0LjAgJiYgIUlTX0ZJUkVGT1gpIHtcbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgbXBlZ3VybFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgQW5kcm9pZCAyLjIgYW5kIGxlc3MgY2FuUGxheVR5cGUgbWV0aG9kIHdoaWNoIGlzIGJyb2tlblxuICB9IGVsc2UgaWYgKElTX09MRF9BTkRST0lEKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wNFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuICB9XG59O1xuXG5IdG1sNS51bnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xuXG4gIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIGJ5IGRlZmF1bHQsIHBhdGNoIHRoZSBtZWRpYSBlbGVtZW50XG5IdG1sNS5wYXRjaENhblBsYXlUeXBlKCk7XG5cbkh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IGNoaWxkIHRyYWNrIG9yIHNvdXJjZSBub2RlcyB0byBwcmV2ZW50IHRoZWlyIGxvYWRpbmdcbiAgd2hpbGUgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbkh0bWw1LnJlc2V0TWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc291cmNlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xuICB2YXIgaSA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbC5yZW1vdmVDaGlsZChzb3VyY2VzW2ldKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS5cbiAgLy8gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IHRocm93cyBhbiBlcnJvclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNhdGlzZnkgbGludGVyXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuLyogTmF0aXZlIEhUTUw1IGVsZW1lbnQgcHJvcGVydHkgd3JhcHBpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbi8vIFdyYXAgbmF0aXZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIGdldHRlcnMgdGhhdCBjaGVjayBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd2VkOlxuLy8gbXV0ZWQsIGRlZmF1bHRNdXRlZCwgYXV0b3BsYXksIGNvbnRyb2xzLCBsb29wLCBwbGF5c2lubGluZVxuW1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBtdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIHZvbHVtZSBmb3IgdGhlIG1lZGlhIHNob3VsZCBiZSBzZXQgdG8gc2lsZW50LiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZVxuICogdGhlIGB2b2x1bWVgIGF0dHJpYnV0ZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I211dGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIHNob3VsZCBiZSBpZ25vcmVkIGFuZCB0aGUgYXVkaW8gc2V0IHRvIHNpbGVudC5cbiAqICAgICAgICAgLSBGYWxzZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIHVzZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0TXV0ZWRgIGluZGljYXRlc1xuICogd2hldGhlciB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IG11dGVkIG9yIG5vdC4gT25seSBjaGFuZ2VzIHRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZVxuICogbWVkaWEuIGBtdXRlZGAgYW5kIGBkZWZhdWx0TXV0ZWRgIGNhbiBoYXZlIGRpZmZlcmVudCB2YWx1ZXMuIHtAbGluayBIdG1sNSNtdXRlZH0gaW5kaWNhdGVzIHRoZVxuICogY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2RlZmF1bHRNdXRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgbXV0ZWRcbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRtdXRlZH1cbiAqL1xuJ2RlZmF1bHRNdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYXV0b3BsYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY29udHJvbHNgIGluZGljYXRlc1xuICogd2hldGhlciB0aGUgbmF0aXZlIG1lZGlhIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNjb250cm9sc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93aW5nLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgaGlkZGVuLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWNvbnRyb2xzfVxuICovXG4nY29udHJvbHMnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBsb29wYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXG4gKiBpdCByZWFjaGVzIHRoZSBlbmQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb29wXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBzZWVrIGJhY2sgdG8gc3RhcnQgb25jZVxuICogICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBub3QgbG9vcCBiYWNrIHRvIHRoZSBzdGFydCB3aGVuIHRoZVxuICogICAgICAgICAgIGVuZCBvZiB0aGUgbWVkaWEgaXMgcmVhY2hlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1sb29wfVxuICovXG4nbG9vcCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5c2lubGluZWAgaW5kaWNhdGVzXG4gKiB0byB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZCB3aGVuIGZ1bGxzY3JlZW5cbiAqIHBsYXliYWNrIGlzIHRoZSBuYXRpdmUgZGVmYXVsdCwgc3VjaCBhcyBpbiBpT1MgU2FmYXJpLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheXNpbmxpbmVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBwbGF5c2lubGluZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3QgcGxheSBpbmxpbmUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAqL1xuJ3BsYXlzaW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdIHx8IHRoaXMuZWxfLmhhc0F0dHJpYnV0ZShwcm9wKTtcbiAgfTtcbn0pO1xuXG4vLyBXcmFwIG5hdGl2ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBzZXR0ZXJzIHRoYXQgc2V0IGJvdGggcHJvcGVydHkgYW5kIGF0dHJpYnV0ZVxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWQ6XG4vLyBzZXRNdXRlZCwgc2V0RGVmYXVsdE11dGVkLCBzZXRBdXRvcGxheSwgc2V0TG9vcCwgc2V0UGxheXNpbmxpbmVcbi8vIHNldENvbnRyb2xzIGlzIHNwZWNpYWwtY2FzZWQgYWJvdmVcbltcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgbXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgbXV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBzaG91bGQgYmUgc2lsZW50LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0TXV0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZWRcbiAqICAgICAgICAtIFRydWUgaWYgdGhlIGF1ZGlvIHNob3VsZCBiZSBzZXQgdG8gc2lsZW50XG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW11dGVkfVxuICovXG4nbXV0ZWQnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0TXV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBzaG91bGQgYmUgc2lsZW50LCBidXQgd2lsbCBvbmx5IGVmZmVjdCB0aGUgbXV0ZWQgbGV2ZWwgb24gaW50aWFsIHBsYXliYWNrLi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5zZXREZWZhdWx0TXV0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmYXVsdE11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0bXV0ZWR9XG4gKi9cbidkZWZhdWx0TXV0ZWQnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGF1dG9wbGF5YCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCB0byBwbGF5IGFzIHNvb24gYXMgdGhlIHBhZ2UgaXMgcmVhZHkuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRBdXRvcGxheVxuICogQHBhcmFtIHtib29sZWFufSBhdXRvcGxheVxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtYXV0b3BsYXl9XG4gKi9cbidhdXRvcGxheScsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgbG9vcGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBsb29wYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXG4gKiBpdCByZWFjaGVzIHRoZSBlbmQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRMb29wXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBzZWVrIGJhY2sgdG8gc3RhcnQgb25jZVxuICogICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBub3QgbG9vcCBiYWNrIHRvIHRoZSBzdGFydCB3aGVuIHRoZVxuICogICAgICAgICAgIGVuZCBvZiB0aGUgbWVkaWEgaXMgcmVhY2hlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1sb29wfVxuICovXG4nbG9vcCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5c2lubGluZWAgaW5kaWNhdGVzXG4gKiB0byB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZCB3aGVuIGZ1bGxzY3JlZW5cbiAqIHBsYXliYWNrIGlzIHRoZSBuYXRpdmUgZGVmYXVsdCwgc3VjaCBhcyBpbiBpT1MgU2FmYXJpLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UGxheXNpbmxpbmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGxheXNpbmxpbmVcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3QgcGxheSBpbmxpbmUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAqL1xuJ3BsYXlzaW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xuICAgIHRoaXMuZWxfW3Byb3BdID0gdjtcblxuICAgIGlmICh2KSB7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUocHJvcCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgcHJvcGVydGllcyB3aXRoIGEgZ2V0dGVyXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZFxuLy8gcGF1c2VkLCBjdXJyZW50VGltZSwgYnVmZmVyZWQsIHZvbHVtZSwgcG9zdGVyLCBwcmVsb2FkLCBlcnJvciwgc2Vla2luZ1xuLy8gc2Vla2FibGUsIGVuZGVkLCBwbGF5YmFja1JhdGUsIGRlZmF1bHRQbGF5YmFja1JhdGUsIHBsYXllZCwgbmV0d29ya1N0YXRlXG4vLyByZWFkeVN0YXRlLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodFxuW1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwYXVzZWRgIGluZGljYXRlcyB3aGV0aGVyIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BhdXNlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZWR9XG4gKi9cbidwYXVzZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGN1cnJlbnRUaW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY3VycmVudFRpbWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc2Vjb25kIHRoYXQgdGhlIG1lZGlhIGlzIGF0IGluIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY3VycmVudFRpbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWN1cnJlbnR0aW1lfVxuICovXG4nY3VycmVudFRpbWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGJ1ZmZlcmVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYnVmZmVyZWRgIGlzIGEgYFRpbWVSYW5nZWBcbiAqIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBhbHJlYWR5IGRvd25sb2FkZWQgYW5kXG4gKiBhdmFpbGFibGUgZm9yIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYnVmZmVyZWRcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkfVxuICovXG4nYnVmZmVyZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBwbGF5YmFjayB2b2x1bWUgb2YgYXVkaW8gZm9yIGEgbWVkaWEuIGB2b2x1bWVgIHdpbGwgYmUgYSB2YWx1ZSBmcm9tIDBcbiAqIChzaWxlbnQpIHRvIDEgKGxvdWRlc3QgYW5kIGRlZmF1bHQpLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdm9sdW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGJldHdlZW4gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBvc3RlcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBvc3RlcmAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB1cmwgb2YgYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwb3N0ZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwb3N0ZXJgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFZhbHVlIHdpbGwgYmUgYSB1cmwgdG8gYW5cbiAqICAgICAgICAgaW1hZ2UuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItdmlkZW8tcG9zdGVyfVxuICovXG4ncG9zdGVyJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcHJlbG9hZGAgaW5kaWNhdGVzXG4gKiB3aGF0IHNob3VsZCBkb3dubG9hZCBiZWZvcmUgdGhlIG1lZGlhIGlzIGludGVyYWN0ZWQgd2l0aC4gSXQgY2FuIGhhdmUgdGhlIGZvbGxvd2luZ1xuICogdmFsdWVzOlxuICogLSBub25lOiBub3RoaW5nIHNob3VsZCBiZSBkb3dubG9hZGVkXG4gKiAtIG1ldGFkYXRhOiBwb3N0ZXIgYW5kIHRoZSBmaXJzdCBmZXcgZnJhbWVzIG9mIHRoZSBtZWRpYSBtYXkgYmUgZG93bmxvYWRlZCB0byBnZXRcbiAqICAgbWVkaWEgZGltZW5zaW9ucyBhbmQgb3RoZXIgbWV0YWRhdGFcbiAqIC0gYXV0bzogYWxsb3cgdGhlIG1lZGlhIGFuZCBtZXRhZGF0YSBmb3IgdGhlIG1lZGlhIHRvIGJlIGRvd25sb2FkZWQgYmVmb3JlXG4gKiAgICBpbnRlcmFjdGlvblxuICpcbiAqIEBtZXRob2QgSHRtbDUjcHJlbG9hZFxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFdpbGwgYmUgJ25vbmUnLCAnbWV0YWRhdGEnLFxuICogICAgICAgICBvciAnYXV0bycuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtcHJlbG9hZH1cbiAqL1xuJ3ByZWxvYWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGVycm9yYCBpbmRpY2F0ZXMgYW55XG4gKiBNZWRpYUVycm9yIHRoYXQgbWF5IGhhdmUgb2NjdXJlZCBkdXJpbmcgcGxheWJhY2suIElmIGVycm9yIHJldHVybnMgbnVsbCB0aGVyZSBpcyBub1xuICogY3VycmVudCBlcnJvci5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2Vycm9yXG4gKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgZXJyb3JgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFdpbGwgYmUgYE1lZGlhRXJyb3JgIGlmIHRoZXJlXG4gKiAgICAgICAgIGlzIGEgY3VycmVudCBlcnJvciBhbmQgbnVsbCBvdGhlcndpc2UuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1lcnJvcn1cbiAqL1xuJ2Vycm9yJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgc2Vla2luZ2AgaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG4gKiBtZWRpYSBpcyBjdXJyZW50bHkgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZWVraW5nXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgc2Vla2luZ2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbi5cbiAqICAgICAgICAgLSBGbGFzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaXMgbm90IHNlZWtpbmcgdG8gYSBuZXcgcG9zaXRpb24gYXQgdGhpcyB0aW1lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc2Vla2luZ31cbiAqL1xuJ3NlZWtpbmcnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgc2Vla2FibGVgIHJldHVybnMgYVxuICogYFRpbWVSYW5nZWAgb2JqZWN0IGluZGljYXRpbmcgcmFuZ2VzIG9mIHRpbWUgdGhhdCBjYW4gY3VycmVudGx5IGJlIGBzZWVrZWRgIHRvLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2Vla2FibGVcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBzZWVrYWJsZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBgVGltZVJhbmdlYCBvYmplY3RcbiAqICAgICAgICAgaW5kaWNhdGluZyB0aGUgY3VycmVudCByYW5nZXMgb2YgdGltZSB0aGF0IGNhbiBiZSBzZWVrZWQgdG8uXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zZWVrYWJsZX1cbiAqL1xuJ3NlZWthYmxlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBlbmRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGVuZGVkYCBpbmRpY2F0ZXMgd2hldGhlclxuICogdGhlIG1lZGlhIGhhcyByZWFjaGVkIHRoZSBlbmQgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZW5kZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBlbmRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBoYXMgZW5kZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGhhcyBub3QgZW5kZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1lbmRlZH1cbiAqL1xuJ2VuZGVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIEV4YW1wbGVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ3BsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIFRoaXMgdmFsdWUgd2lsbCBub3QgaW5kaWNhdGUgdGhlIGN1cnJlbnRcbiAqIGBwbGF5YmFja1JhdGVgIGFmdGVyIHBsYXliYWNrIGhhcyBzdGFydGVkLCB1c2Uge0BsaW5rIEh0bWw1I3BsYXliYWNrUmF0ZX0gZm9yIHRoYXQuXG4gKlxuICogRXhhbXBsZXM6XG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLmRlZmF1bHRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5ZWRgIHJldHVybnMgYSBgVGltZVJhbmdlYFxuICogb2JqZWN0IHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIG1lZGlhIHRpbWVsaW5lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXllZFxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXllZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgcmFuZ2VzIG9mIHRpbWUgdGhhdCBoYXZlIGJlZW4gcGxheWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWVkfVxuICovXG4ncGxheWVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBuZXR3b3JrU3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgbmV0d29yayBzdGF0ZS4gSXQgcmV0dXJucyBhbiBlbnVtZXJhdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAqIC0gMDogTkVUV09SS19FTVBUWVxuICogLSAxOiBORVdPUktfSURMRVxuICogLSAyOiBORVRXT1JLX0xPQURJTkdcbiAqIC0gMzogTkVUV09SS19OT19TT1VSQ0VcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I25ldHdvcmtTdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW5ldHdvcmtzdGF0ZX1cbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNyZWFkeS1zdGF0ZXN9XG4gKi9cbidyZWFkeVN0YXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9XaWR0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdmlkZW8gaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvV2lkdGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9XaWR0aCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9IZWlnaHRgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIGB2aWRlb0hlaWd0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb0hlaWdodFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9IZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF07XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgcHJvcGVydGllcyB3aXRoIGEgc2V0dGVyIGluIHRoaXMgZm9ybWF0OlxuLy8gc2V0ICsgdG9UaXRsZUNhc2UobmFtZSlcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd3M6XG4vLyBzZXRWb2x1bWUsIHNldFNyYywgc2V0UG9zdGVyLCBzZXRQcmVsb2FkLCBzZXRQbGF5YmFja1JhdGUsIHNldERlZmF1bHRQbGF5YmFja1JhdGVcbltcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcbiAqIHNvIG9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudEFzRGVjaW1hbFxuICogICAgICAgIFRoZSB2b2x1bWUgcGVyY2VudCBhcyBhIGRlY2ltYWwuIFZhbGlkIHJhbmdlIGlzIGZyb20gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHNyY2Agb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBzcmNgIGluZGljYXRlcyB0aGUgY3VycmVudFxuICoge0BsaW5rIFRlY2h+U291cmNlT2JqZWN0fSBmb3IgdGhlIG1lZGlhLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0U3JjXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdCB0byBzZXQgYXMgdGhlIGN1cnJlbnQgc291cmNlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc3JjfVxuICovXG4nc3JjJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpcyB0aGUgdXJsIHRvXG4gKiBhbiBpbWFnZSBmaWxlIHRoYXQgY2FuL3dpbGwgYmUgc2hvd24gd2hlbiBubyBtZWRpYSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBvc3RlclxuICogQHBhcmFtIHtzdHJpbmd9IHBvc3RlclxuICogICAgICAgIFRoZSB1cmwgdG8gYW4gaW1hZ2UgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgYHBvc3RlcmAgZm9yIHRoZSBtZWRpYVxuICogICAgICAgIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtcG9zdGVyfVxuICovXG4ncG9zdGVyJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFByZWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVsb2FkXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgdG8gc2V0IG9uIHRoZSBtZWRpYSBlbGVtZW50LiBNdXN0IGJlICdub25lJywgJ21ldGFkYXRhJyxcbiAqICAgICAgICAgb3IgJ2F1dG8nLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XG4gKi9cbidwcmVsb2FkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjayB1cG9uIGluaXRpYWwgc3RhcnR1cC4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxuICogYWZ0ZXIgYSB2aWRlbyBoYXMgc3RhcnRlZCB3aWxsIGRvIG5vdGhpbmcuIEluc3RlYWQgeW91IHNob3VsZCB1c2VkIHtAbGluayBIdG1sNSNzZXRQbGF5YmFja1JhdGV9LlxuICpcbiAqIEV4YW1wbGUgVmFsdWVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xuICAgIHRoaXMuZWxfW3Byb3BdID0gdjtcbiAgfTtcbn0pO1xuXG4vLyB3cmFwIG5hdGl2ZSBmdW5jdGlvbnMgd2l0aCBhIGZ1bmN0aW9uXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dzOlxuLy8gcGF1c2UsIGxvYWQgcGxheVxuW1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgcGF1c2VgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YFxuICogbWVkaWEgZWxlbWVudHMgYHBhdXNlYCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BhdXNlXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBhdXNlfVxuICovXG4ncGF1c2UnLFxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBsb2FkYCBmdW5jdGlvbi4gVGhpcyB3aWxsIGNhbGwgdGhlIGBIVE1MNWBzXG4gKiBtZWRpYSBlbGVtZW50IGBsb2FkYCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2xvYWRcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbG9hZH1cbiAqL1xuJ2xvYWQnLFxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBwbGF5YCBmdW5jdGlvbi4gVGhpcyB3aWxsIGNhbGwgdGhlIGBIVE1MNWBzXG4gKiBtZWRpYSBlbGVtZW50IGBwbGF5YCBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXlcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheX1cbiAqL1xuJ3BsYXknXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF0oKTtcbiAgfTtcbn0pO1xuXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyhIdG1sNSk7XG5cbi8qKlxuICogTmF0aXZlIHNvdXJjZSBoYW5kbGVyIGZvciBIdG1sNSwgc2ltcGx5IHBhc3NlcyB0aGUgc291cmNlIHRvIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBwcm9wcmV0eSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHByb3ByZXR5IHtIdG1sNX0gdGVjaFxuICogICAgICAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgSFRNTDUgdGVjaC5cbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBwbGF5IHRoZSBnaXZlbiBtaW1lIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAvLyBJRTkgb24gV2luZG93cyA3IHdpdGhvdXQgTWVkaWFQbGF5ZXIgdGhyb3dzIGFuIGVycm9yIGhlcmVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzUxOVxuICB0cnkge1xuICAgIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbWVkaWEgZWxlbWVudCBjYW4gaGFuZGxlIGEgc291cmNlIG5hdGl2ZWx5LlxuICpcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICogICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICAgT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHRlY2guXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKS5cbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG5cbiAgLy8gSWYgYSB0eXBlIHdhcyBwcm92aWRlZCB3ZSBzaG91bGQgcmVseSBvbiB0aGF0XG4gIGlmIChzb3VyY2UudHlwZSkge1xuICAgIHJldHVybiBIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKHNvdXJjZS50eXBlKTtcblxuICAgIC8vIElmIG5vIHR5cGUsIGZhbGwgYmFjayB0byBjaGVja2luZyAndmlkZW8vW0VYVEVOU0lPTl0nXG4gIH0gZWxzZSBpZiAoc291cmNlLnNyYykge1xuICAgIHZhciBleHQgPSBnZXRGaWxlRXh0ZW5zaW9uKHNvdXJjZS5zcmMpO1xuXG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoJ3ZpZGVvLycgKyBleHQpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBQYXNzIHRoZSBzb3VyY2UgdG8gdGhlIG5hdGl2ZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtIdG1sNX0gdGVjaFxuICogICAgICAgIFRoZSBpbnN0YW5jZSBvZiB0aGUgSHRtbDUgdGVjaFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2VcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5oYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCB0ZWNoLCBvcHRpb25zKSB7XG4gIHRlY2guc2V0U3JjKHNvdXJjZS5zcmMpO1xufTtcblxuLyoqXG4gKiBBIG5vb3AgZm9yIHRoZSBuYXRpdmUgZGlzcG9zZSBmdW5jdGlvbiwgYXMgY2xlYW51cCBpcyBub3QgbmVlZGVkLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gUmVnaXN0ZXIgdGhlIG5hdGl2ZSBzb3VyY2UgaGFuZGxlclxuSHRtbDUucmVnaXN0ZXJTb3VyY2VIYW5kbGVyKEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIpO1xuXG5UZWNoLnJlZ2lzdGVyVGVjaCgnSHRtbDUnLCBIdG1sNSk7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMSA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddLCBbJ1xcbiAgICAgICAgVXNpbmcgdGhlIHRlY2ggZGlyZWN0bHkgY2FuIGJlIGRhbmdlcm91cy4gSSBob3BlIHlvdSBrbm93IHdoYXQgeW91XFwncmUgZG9pbmcuXFxuICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzI2MTcgZm9yIG1vcmUgaW5mby5cXG4gICAgICAnXSk7XG5cbi8qKlxuICogQGZpbGUgcGxheWVyLmpzXG4gKi9cbi8vIFN1YmNsYXNzZXMgQ29tcG9uZW50XG4vLyBUaGUgZm9sbG93aW5nIGltcG9ydHMgYXJlIHVzZWQgb25seSB0byBlbnN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBtb2R1bGVzXG4vLyBhcmUgYWx3YXlzIGluY2x1ZGVkIGluIHRoZSB2aWRlby5qcyBwYWNrYWdlLiBJbXBvcnRpbmcgdGhlIG1vZHVsZXMgd2lsbFxuLy8gZXhlY3V0ZSB0aGVtIGFuZCB0aGV5IHdpbGwgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIHZpZGVvLmpzLlxuLy8gSW1wb3J0IEh0bWw1IHRlY2gsIGF0IGxlYXN0IGZvciBkaXNwb3NpbmcgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZy5cbi8vIFRoZSBmb2xsb3dpbmcgdGVjaCBldmVudHMgYXJlIHNpbXBseSByZS10cmlnZ2VyZWRcbi8vIG9uIHRoZSBwbGF5ZXIgd2hlbiB0aGV5IGhhcHBlblxudmFyIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUiA9IFtcbi8qKlxuICogRmlyZWQgd2hpbGUgdGhlIHVzZXIgYWdlbnQgaXMgZG93bmxvYWRpbmcgbWVkaWEgZGF0YS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3Byb2dyZXNzXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoUHJvZ3Jlc3NfXG4gKiBAZmlyZXMgUGxheWVyI3Byb2dyZXNzXG4gKiBAbGlzdGVucyBUZWNoI3Byb2dyZXNzXG4gKi9cbidwcm9ncmVzcycsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlbyBpcyBhYm9ydGVkLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjYWJvcnRcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBhYm9ydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hBYm9ydF9cbiAqIEBmaXJlcyBQbGF5ZXIjYWJvcnRcbiAqIEBsaXN0ZW5zIFRlY2gjYWJvcnRcbiAqL1xuJ2Fib3J0JyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGlzIGludGVudGlvbmFsbHkgbm90IGdldHRpbmcgbWVkaWEgZGF0YS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3N1c3BlbmRcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBzdXNwZW5kYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFN1c3BlbmRfXG4gKiBAZmlyZXMgUGxheWVyI3N1c3BlbmRcbiAqIEBsaXN0ZW5zIFRlY2gjc3VzcGVuZFxuICovXG4nc3VzcGVuZCcsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5bGlzdCBpcyBlbXB0eS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2VtcHRpZWRcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBlbXB0aWVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaEVtcHRpZWRfXG4gKiBAZmlyZXMgUGxheWVyI2VtcHRpZWRcbiAqIEBsaXN0ZW5zIFRlY2gjZW1wdGllZFxuICovXG4nZW1wdGllZCcsXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgdHJ5aW5nIHRvIGdldCBtZWRpYSBkYXRhLCBidXQgZGF0YSBpcyBub3QgYXZhaWxhYmxlLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjc3RhbGxlZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN0YWxsZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3RhbGxlZF9cbiAqIEBmaXJlcyBQbGF5ZXIjc3RhbGxlZFxuICogQGxpc3RlbnMgVGVjaCNzdGFsbGVkXG4gKi9cbidzdGFsbGVkJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgbWV0YSBkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN0YWxsZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGVkbWV0YWRhdGFfXG4gKiBAZmlyZXMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAbGlzdGVucyBUZWNoI2xvYWRlZG1ldGFkYXRhXG4gKi9cbidsb2FkZWRtZXRhZGF0YScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIHRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBhdWRpby92aWRlby5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBsb2FkZWRkYXRhYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaExvYWRkZWRkYXRhX1xuICogQGZpcmVzIFBsYXllciNsb2FkZWRkYXRhXG4gKiBAbGlzdGVucyBUZWNoI2xvYWRlZGRhdGFcbiAqL1xuJ2xvYWRlZGRhdGEnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaGFzIGNoYW5nZWQuXG4gKlxuICogQGV2ZW50IFBsYXllciN0aW1ldXBkYXRlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hUaW1lVXBkYXRlX1xuICogQGZpcmVzIFBsYXllciN0aW1ldXBkYXRlXG4gKiBAbGlzdGVucyBUZWNoI3RpbWV1cGRhdGVcbiAqL1xuJ3RpbWV1cGRhdGUnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHBsYXlpbmcgc3BlZWQgb2YgdGhlIGF1ZGlvL3ZpZGVvIGlzIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3JhdGVjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJhdGVjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3JhdGVjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjcmF0ZWNoYW5nZVxuICovXG4ncmF0ZWNoYW5nZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdmlkZW8ncyBpbnRyaW5zaWMgZGltZW5zaW9ucyBjaGFuZ2VcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3Jlc2l6ZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHJlc2l6ZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSZXNpemVfXG4gKiBAZmlyZXMgUGxheWVyI3Jlc2l6ZVxuICogQGxpc3RlbnMgVGVjaCNyZXNpemVcbiAqL1xuJ3Jlc2l6ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdm9sdW1lIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHZvbHVtZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hWb2x1bWVjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQGxpc3RlbnMgVGVjaCN2b2x1bWVjaGFuZ2VcbiAqL1xuJ3ZvbHVtZWNoYW5nZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0ZXh0dHJhY2tjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGV4dHRyYWNrY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gKi9cbid0ZXh0dHJhY2tjaGFuZ2UnXTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgYFBsYXllcmAgY2xhc3MgaXMgY3JlYXRlZCB3aGVuIGFueSBvZiB0aGUgVmlkZW8uanMgc2V0dXAgbWV0aG9kc1xuICogYXJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBhIHZpZGVvLlxuICpcbiAqIEFmdGVyIGFuIGluc3RhbmNlIGhhcyBiZWVuIGNyZWF0ZWQgaXQgY2FuIGJlIGFjY2Vzc2VkIGdsb2JhbGx5IGluIHR3byB3YXlzOlxuICogMS4gQnkgY2FsbGluZyBgdmlkZW9qcygnZXhhbXBsZV92aWRlb18xJyk7YFxuICogMi4gQnkgdXNpbmcgaXQgZGlyZWN0bHkgdmlhICBgdmlkZW9qcy5wbGF5ZXJzLmV4YW1wbGVfdmlkZW9fMTtgXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFBsYXllciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFBsYXllciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICAgKiAgICAgICAgVGhlIG9yaWdpbmFsIHZpZGVvIERPTSBlbGVtZW50IHVzZWQgZm9yIGNvbmZpZ3VyaW5nIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgUmVhZHkgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBQbGF5ZXIodGFnLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGFnIElEIGV4aXN0c1xuICAgIHRhZy5pZCA9IHRhZy5pZCB8fCAndmpzX3ZpZGVvXycgKyBuZXdHVUlEKCk7XG5cbiAgICAvLyBTZXQgT3B0aW9uc1xuICAgIC8vIFRoZSBvcHRpb25zIGFyZ3VtZW50IG92ZXJyaWRlcyBvcHRpb25zIHNldCBpbiB0aGUgdmlkZW8gdGFnXG4gICAgLy8gd2hpY2ggb3ZlcnJpZGVzIGdsb2JhbGx5IHNldCBvcHRpb25zLlxuICAgIC8vIFRoaXMgbGF0dGVyIHBhcnQgY29pbmNpZGVzIHdpdGggdGhlIGxvYWQgb3JkZXJcbiAgICAvLyAodGFnIG11c3QgZXhpc3QgYmVmb3JlIFBsYXllcilcbiAgICBvcHRpb25zID0gYXNzaWduKFBsYXllci5nZXRUYWdTZXR0aW5ncyh0YWcpLCBvcHRpb25zKTtcblxuICAgIC8vIERlbGF5IHRoZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZHJlbiBiZWNhdXNlIHdlIG5lZWQgdG8gc2V0IHVwXG4gICAgLy8gcGxheWVyIHByb3BlcnRpZXMgZmlyc3QsIGFuZCBjYW4ndCB1c2UgYHRoaXNgIGJlZm9yZSBgc3VwZXIoKWBcbiAgICBvcHRpb25zLmluaXRDaGlsZHJlbiA9IGZhbHNlO1xuXG4gICAgLy8gU2FtZSB3aXRoIGNyZWF0aW5nIHRoZSBlbGVtZW50XG4gICAgb3B0aW9ucy5jcmVhdGVFbCA9IGZhbHNlO1xuXG4gICAgLy8gZG9uJ3QgYXV0byBtaXhpbiB0aGUgZXZlbnRlZCBtaXhpblxuICAgIG9wdGlvbnMuZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgcGxheWVyIHRvIHJlcG9ydCB0b3VjaCBhY3Rpdml0eSBvbiBpdHNlbGZcbiAgICAvLyBzZWUgZW5hYmxlVG91Y2hBY3Rpdml0eSBpbiBDb21wb25lbnRcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcblxuICAgIC8vIElmIGxhbmd1YWdlIGlzIG5vdCBzZXQsIGdldCB0aGUgY2xvc2VzdCBsYW5nIGF0dHJpYnV0ZVxuICAgIGlmICghb3B0aW9ucy5sYW5ndWFnZSkge1xuICAgICAgaWYgKHR5cGVvZiB0YWcuY2xvc2VzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2xvc2VzdCA9IHRhZy5jbG9zZXN0KCdbbGFuZ10nKTtcblxuICAgICAgICBpZiAoY2xvc2VzdCAmJiBjbG9zZXN0LmdldEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBjbG9zZXN0LmdldEF0dHJpYnV0ZSgnbGFuZycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRhZztcblxuICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgaWYgKGdldEF0dHJpYnV0ZXMoZWxlbWVudCkuaGFzT3duUHJvcGVydHkoJ2xhbmcnKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBiYXNlIGNvbXBvbmVudCBpbml0aWFsaXppbmcgd2l0aCBuZXcgb3B0aW9uc1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgX3RoaXMuaXNSZWFkeV8gPSBmYWxzZTtcblxuICAgIC8vIEluaXQgc3RhdGUgaGFzU3RhcnRlZF9cbiAgICBfdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdCBzdGF0ZSB1c2VyQWN0aXZlX1xuICAgIF90aGlzLnVzZXJBY3RpdmVfID0gZmFsc2U7XG5cbiAgICAvLyBpZiB0aGUgZ2xvYmFsIG9wdGlvbiBvYmplY3Qgd2FzIGFjY2lkZW50YWxseSBibG93biBhd2F5IGJ5XG4gICAgLy8gc29tZW9uZSwgYmFpbCBlYXJseSB3aXRoIGFuIGluZm9ybWF0aXZlIGVycm9yXG4gICAgaWYgKCFfdGhpcy5vcHRpb25zXyB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyIHx8ICFfdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRlY2hPcmRlciBzcGVjaWZpZWQuIERpZCB5b3Ugb3ZlcndyaXRlICcgKyAndmlkZW9qcy5vcHRpb25zIGluc3RlYWQgb2YganVzdCBjaGFuZ2luZyB0aGUgJyArICdwcm9wZXJ0aWVzIHlvdSB3YW50IHRvIG92ZXJyaWRlPycpO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCB0YWcgdXNlZCB0byBzZXQgb3B0aW9uc1xuICAgIF90aGlzLnRhZyA9IHRhZztcblxuICAgIC8vIFN0b3JlIHRoZSB0YWcgYXR0cmlidXRlcyB1c2VkIHRvIHJlc3RvcmUgaHRtbDUgZWxlbWVudFxuICAgIF90aGlzLnRhZ0F0dHJpYnV0ZXMgPSB0YWcgJiYgZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgLy8gVXBkYXRlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICBfdGhpcy5sYW5ndWFnZShfdGhpcy5vcHRpb25zXy5sYW5ndWFnZSk7XG5cbiAgICAvLyBVcGRhdGUgU3VwcG9ydGVkIExhbmd1YWdlc1xuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlcykge1xuICAgICAgLy8gTm9ybWFsaXNlIHBsYXllciBvcHRpb24gbGFuZ3VhZ2VzIHRvIGxvd2VyY2FzZVxuICAgICAgdmFyIGxhbmd1YWdlc1RvTG93ZXIgPSB7fTtcblxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucy5sYW5ndWFnZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgICAgbGFuZ3VhZ2VzVG9Mb3dlcltuYW1lJCQxLnRvTG93ZXJDYXNlKCldID0gb3B0aW9ucy5sYW5ndWFnZXNbbmFtZSQkMV07XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmxhbmd1YWdlc18gPSBsYW5ndWFnZXNUb0xvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5sYW5ndWFnZXM7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgZm9yIHZpZGVvIHByb3BlcnR5IHZhbHVlcy5cbiAgICBfdGhpcy5jYWNoZV8gPSB7fTtcblxuICAgIC8vIFNldCBwb3N0ZXJcbiAgICBfdGhpcy5wb3N0ZXJfID0gb3B0aW9ucy5wb3N0ZXIgfHwgJyc7XG5cbiAgICAvLyBTZXQgY29udHJvbHNcbiAgICBfdGhpcy5jb250cm9sc18gPSAhIW9wdGlvbnMuY29udHJvbHM7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIGxhc3RWb2x1bWVcbiAgICBfdGhpcy5jYWNoZV8ubGFzdFZvbHVtZSA9IDE7XG5cbiAgICAvLyBPcmlnaW5hbCB0YWcgc2V0dGluZ3Mgc3RvcmVkIGluIG9wdGlvbnNcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cbiAgICAvLyBNYXkgYmUgdHVybmVkIGJhY2sgb24gYnkgSFRNTDUgdGVjaCBpZiBuYXRpdmVDb250cm9sc0ZvclRvdWNoIGlzIHRydWVcbiAgICB0YWcuY29udHJvbHMgPSBmYWxzZTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdjb250cm9scycpO1xuXG4gICAgLypcbiAgICAgKiBTdG9yZSB0aGUgaW50ZXJuYWwgc3RhdGUgb2Ygc2NydWJiaW5nXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHVzZXIgaXMgc2NydWJiaW5nXG4gICAgICovXG4gICAgX3RoaXMuc2NydWJiaW5nXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMuZWxfID0gX3RoaXMuY3JlYXRlRWwoKTtcblxuICAgIC8vIE1ha2UgdGhpcyBhbiBldmVudGVkIG9iamVjdCBhbmQgdXNlIGBlbF9gIGFzIGl0cyBldmVudCBidXMuXG4gICAgZXZlbnRlZChfdGhpcywgeyBldmVudEJ1c0tleTogJ2VsXycgfSk7XG5cbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gcGFzcyB0aGUgb3JpZ2luYWwgcGxheWVyIG9wdGlvbnMgdG8gZWFjaCBjb21wb25lbnQgYW5kIHBsdWdpblxuICAgIC8vIGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvIHJlYWNoIGJhY2sgaW50byB0aGUgcGxheWVyIGZvciBvcHRpb25zIGxhdGVyLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBkbyBhbm90aGVyIGNvcHkgb2YgdGhpcy5vcHRpb25zXyBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aFxuICAgIC8vIGFuIGluZmluaXRlIGxvb3AuXG4gICAgdmFyIHBsYXllck9wdGlvbnNDb3B5ID0gbWVyZ2VPcHRpb25zKF90aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIExvYWQgcGx1Z2luc1xuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zO1xuXG4gICAgICBPYmplY3Qua2V5cyhwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lJCQxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXNbbmFtZSQkMV0ocGx1Z2luc1tuYW1lJCQxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbHVnaW4gXCInICsgbmFtZSQkMSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICB9LCBfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucyA9IHBsYXllck9wdGlvbnNDb3B5O1xuXG4gICAgX3RoaXMubWlkZGxld2FyZV8gPSBbXTtcblxuICAgIF90aGlzLmluaXRDaGlsZHJlbigpO1xuXG4gICAgLy8gU2V0IGlzQXVkaW8gYmFzZWQgb24gd2hldGhlciBvciBub3QgYW4gYXVkaW8gdGFnIHdhcyB1c2VkXG4gICAgX3RoaXMuaXNBdWRpbyh0YWcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1ZGlvJyk7XG5cbiAgICAvLyBVcGRhdGUgY29udHJvbHMgY2xhc3NOYW1lLiBDYW4ndCBkbyB0aGlzIHdoZW4gdGhlIGNvbnRyb2xzIGFyZSBpbml0aWFsbHlcbiAgICAvLyBzZXQgYmVjYXVzZSB0aGUgZWxlbWVudCBkb2Vzbid0IGV4aXN0IHlldC5cbiAgICBpZiAoX3RoaXMuY29udHJvbHMoKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgQVJJQSBsYWJlbCBhbmQgcmVnaW9uIHJvbGUgZGVwZW5kaW5nIG9uIHBsYXllciB0eXBlXG4gICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdyZWdpb24nKTtcbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgX3RoaXMubG9jYWxpemUoJ0F1ZGlvIFBsYXllcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF90aGlzLmxvY2FsaXplKCdWaWRlbyBQbGF5ZXInKSk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmlzQXVkaW8oKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1hdWRpbycpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5mbGV4Tm90U3VwcG9ydGVkXygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLW5vLWZsZXgnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgc21hcnRlci4gVG9nZ2xlIHVzZXIgc3RhdGUgYmV0d2VlbiB0b3VjaGluZy9tb3VzaW5nXG4gICAgLy8gdXNpbmcgZXZlbnRzLCBzaW5jZSBkZXZpY2VzIGNhbiBoYXZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cy5cbiAgICAvLyBpZiAoYnJvd3Nlci5UT1VDSF9FTkFCTEVEKSB7XG4gICAgLy8gICB0aGlzLmFkZENsYXNzKCd2anMtdG91Y2gtZW5hYmxlZCcpO1xuICAgIC8vIH1cblxuICAgIC8vIGlPUyBTYWZhcmkgaGFzIGJyb2tlbiBob3ZlciBoYW5kbGluZ1xuICAgIGlmICghSVNfSU9TKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLXdvcmtpbmdob3ZlcicpO1xuICAgIH1cblxuICAgIC8vIE1ha2UgcGxheWVyIGVhc2lseSBmaW5kYWJsZSBieSBJRFxuICAgIFBsYXllci5wbGF5ZXJzW190aGlzLmlkX10gPSBfdGhpcztcblxuICAgIC8vIEFkZCBhIG1ham9yIHZlcnNpb24gY2xhc3MgdG8gYWlkIGNzcyBpbiBwbHVnaW5zXG4gICAgdmFyIG1ham9yVmVyc2lvbiA9IHZlcnNpb24uc3BsaXQoJy4nKVswXTtcblxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdicgKyBtYWpvclZlcnNpb24pO1xuXG4gICAgLy8gV2hlbiB0aGUgcGxheWVyIGlzIGZpcnN0IGluaXRpYWxpemVkLCB0cmlnZ2VyIGFjdGl2aXR5IHNvIGNvbXBvbmVudHNcbiAgICAvLyBsaWtlIHRoZSBjb250cm9sIGJhciBzaG93IHRoZW1zZWx2ZXMgaWYgbmVlZGVkXG4gICAgX3RoaXMudXNlckFjdGl2ZSh0cnVlKTtcbiAgICBfdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICBfdGhpcy5saXN0ZW5Gb3JVc2VyQWN0aXZpdHlfKCk7XG5cbiAgICBfdGhpcy5vbignZnVsbHNjcmVlbmNoYW5nZScsIF90aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfKTtcbiAgICBfdGhpcy5vbignc3RhZ2VjbGljaycsIF90aGlzLmhhbmRsZVN0YWdlQ2xpY2tfKTtcblxuICAgIF90aGlzLmNoYW5naW5nU3JjXyA9IGZhbHNlO1xuICAgIF90aGlzLnBsYXlXYWl0aW5nRm9yUmVhZHlfID0gZmFsc2U7XG4gICAgX3RoaXMucGxheU9uTG9hZHN0YXJ0XyA9IG51bGw7XG5cbiAgICBfdGhpcy5mb3JjZUF1dG9wbGF5SW5DaHJvbWVfKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSB2aWRlbyBwbGF5ZXIgYW5kIGRvZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwLlxuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXG4gICAqIHRvL2Zyb20gdGhlIERPTS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIGlzIGJlaW5nIGRpc3Bvc2VkIG9mLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNkaXNwb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIC8vIHByZXZlbnQgZGlzcG9zZSBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJyk7XG5cbiAgICBpZiAodGhpcy5zdHlsZUVsXyAmJiB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0eWxlRWxfKTtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEtpbGwgcmVmZXJlbmNlIHRvIHRoaXMgcGxheWVyXG4gICAgUGxheWVyLnBsYXllcnNbdGhpcy5pZF9dID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnRhZyAmJiB0aGlzLnRhZy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxfICYmIHRoaXMuZWxfLnBsYXllcikge1xuICAgICAgdGhpcy5lbF8ucGxheWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyRWxJbmdlc3RfKSB7XG4gICAgICB0aGlzLnBsYXllckVsSW5nZXN0XyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gdGhlIGFjdHVhbCAuZWxfIGlzIHJlbW92ZWQgaGVyZVxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgUGxheWVyYCdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnO1xuICAgIHZhciBlbCA9IHZvaWQgMDtcbiAgICB2YXIgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmpzLXBsYXllcicpO1xuICAgIHZhciBkaXZFbWJlZCA9IHRoaXMudGFnLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvLWpzJztcblxuICAgIGlmIChwbGF5ZXJFbEluZ2VzdCkge1xuICAgICAgZWwgPSB0aGlzLmVsXyA9IHRhZy5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoIWRpdkVtYmVkKSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jyk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBvdmVyIGFsbCB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSB0YWcsIGluY2x1ZGluZyBJRCBhbmQgY2xhc3NcbiAgICAvLyBJRCB3aWxsIG5vdyByZWZlcmVuY2UgcGxheWVyIGJveCwgbm90IHRoZSB2aWRlbyB0YWdcbiAgICB2YXIgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzKHRhZyk7XG5cbiAgICBpZiAoZGl2RW1iZWQpIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSB0YWc7XG4gICAgICB0YWcgPSB0aGlzLnRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICB3aGlsZSAoZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRhZy5hcHBlbmRDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNDbGFzcyhlbCwgJ3ZpZGVvLWpzJykpIHtcbiAgICAgICAgYWRkQ2xhc3MoZWwsICd2aWRlby1qcycpO1xuICAgICAgfVxuXG4gICAgICBlbC5hcHBlbmRDaGlsZCh0YWcpO1xuXG4gICAgICBwbGF5ZXJFbEluZ2VzdCA9IHRoaXMucGxheWVyRWxJbmdlc3RfID0gZWw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRhYmluZGV4IHRvIC0xIHNvIHdlIGNvdWxkIGZvY3VzIG9uIHRoZSBwbGF5ZXIgZWxlbWVudFxuICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG5cbiAgICAvLyBSZW1vdmUgd2lkdGgvaGVpZ2h0IGF0dHJzIGZyb20gdGFnIHNvIENTUyBjYW4gbWFrZSBpdCAxMDAlIHdpZHRoL2hlaWdodFxuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gd29ya2Fyb3VuZCBzbyB3ZSBkb24ndCB0b3RhbGx5IGJyZWFrIElFN1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjUzNDQ0L2Nzcy1zdHlsZXMtbm90LWFwcGxpZWQtb24tZHluYW1pYy1lbGVtZW50cy1pbi1pbnRlcm5ldC1leHBsb3Jlci03XG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICBlbC5jbGFzc05hbWUgKz0gJyAnICsgYXR0cnNbYXR0cl07XG5cbiAgICAgICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICAgICAgdGFnLmNsYXNzTmFtZSArPSAnICcgKyBhdHRyc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcblxuICAgICAgICBpZiAoZGl2RW1iZWQpIHtcbiAgICAgICAgICB0YWcuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRhZyBpZC9jbGFzcyBmb3IgdXNlIGFzIEhUTUw1IHBsYXliYWNrIHRlY2hcbiAgICAvLyBNaWdodCB0aGluayB3ZSBzaG91bGQgZG8gdGhpcyBhZnRlciBlbWJlZGRpbmcgaW4gY29udGFpbmVyIHNvIC52anMtdGVjaCBjbGFzc1xuICAgIC8vIGRvZXNuJ3QgZmxhc2ggMTAwJSB3aWR0aC9oZWlnaHQsIGJ1dCBjbGFzcyBvbmx5IGFwcGxpZXMgd2l0aCAudmlkZW8tanMgcGFyZW50XG4gICAgdGFnLnBsYXllcklkID0gdGFnLmlkO1xuICAgIHRhZy5pZCArPSAnX2h0bWw1X2FwaSc7XG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XG5cbiAgICAvLyBNYWtlIHBsYXllciBmaW5kYWJsZSBvbiBlbGVtZW50c1xuICAgIHRhZy5wbGF5ZXIgPSBlbC5wbGF5ZXIgPSB0aGlzO1xuICAgIC8vIERlZmF1bHQgc3RhdGUgb2YgdmlkZW8gaXMgcGF1c2VkXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuXG4gICAgLy8gQWRkIGEgc3R5bGUgZWxlbWVudCBpbiB0aGUgcGxheWVyIHRoYXQgd2UnbGwgdXNlIHRvIHNldCB0aGUgd2lkdGgvaGVpZ2h0XG4gICAgLy8gb2YgdGhlIHBsYXllciBpbiBhIHdheSB0aGF0J3Mgc3RpbGwgb3ZlcnJpZGVhYmxlIGJ5IENTUywganVzdCBsaWtlIHRoZVxuICAgIC8vIHZpZGVvIGVsZW1lbnRcbiAgICBpZiAod2luZG93LlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zdHlsZUVsXyA9IGNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZGVmYXVsdHNTdHlsZUVsID0gJCgnLnZqcy1zdHlsZXMtZGVmYXVsdHMnKTtcbiAgICAgIHZhciBoZWFkID0gJCgnaGVhZCcpO1xuXG4gICAgICBoZWFkLmluc2VydEJlZm9yZSh0aGlzLnN0eWxlRWxfLCBkZWZhdWx0c1N0eWxlRWwgPyBkZWZhdWx0c1N0eWxlRWwubmV4dFNpYmxpbmcgOiBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIC8vIFBhc3MgaW4gdGhlIHdpZHRoL2hlaWdodC9hc3BlY3RSYXRpbyBvcHRpb25zIHdoaWNoIHdpbGwgdXBkYXRlIHRoZSBzdHlsZSBlbFxuICAgIHRoaXMud2lkdGgodGhpcy5vcHRpb25zXy53aWR0aCk7XG4gICAgdGhpcy5oZWlnaHQodGhpcy5vcHRpb25zXy5oZWlnaHQpO1xuICAgIHRoaXMuZmx1aWQodGhpcy5vcHRpb25zXy5mbHVpZCk7XG4gICAgdGhpcy5hc3BlY3RSYXRpbyh0aGlzLm9wdGlvbnNfLmFzcGVjdFJhdGlvKTtcblxuICAgIC8vIEhpZGUgYW55IGxpbmtzIHdpdGhpbiB0aGUgdmlkZW8vYXVkaW8gdGFnLCBiZWNhdXNlIElFIGRvZXNuJ3QgaGlkZSB0aGVtIGNvbXBsZXRlbHkuXG4gICAgdmFyIGxpbmtzID0gdGFnLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlua0VsID0gbGlua3MuaXRlbShpKTtcblxuICAgICAgYWRkQ2xhc3MobGlua0VsLCAndmpzLWhpZGRlbicpO1xuICAgICAgbGlua0VsLnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ2hpZGRlbicpO1xuICAgIH1cblxuICAgIC8vIGluc2VydEVsRmlyc3Qgc2VlbXMgdG8gY2F1c2UgdGhlIG5ldHdvcmtTdGF0ZSB0byBmbGlja2VyIGZyb20gMyB0byAyLCBzb1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGZvciBsYXRlciBzbyB3ZSBjYW4ga25vdyBpZiB0aGUgc291cmNlIG9yaWdpbmFsbHkgZmFpbGVkXG4gICAgdGFnLmluaXROZXR3b3JrU3RhdGVfID0gdGFnLm5ldHdvcmtTdGF0ZTtcblxuICAgIC8vIFdyYXAgdmlkZW8gdGFnIGluIGRpdiAoZWwvYm94KSBjb250YWluZXJcbiAgICBpZiAodGFnLnBhcmVudE5vZGUgJiYgIXBsYXllckVsSW5nZXN0KSB7XG4gICAgICB0YWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhZyk7XG4gICAgfVxuXG4gICAgLy8gaW5zZXJ0IHRoZSB0YWcgYXMgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBwbGF5ZXIgZWxlbWVudFxuICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIGl0IHRvIHRoZSBjaGlsZHJlbiBhcnJheSBzbyB0aGF0IHRoaXMuYWRkQ2hpbGRcbiAgICAvLyB3aWxsIHdvcmsgcHJvcGVybHkgZm9yIG90aGVyIGNvbXBvbmVudHNcbiAgICAvL1xuICAgIC8vIEJyZWFrcyBpUGhvbmUsIGZpeGVkIGluIEhUTUw1IHNldHVwLlxuICAgIHByZXBlbmRUbyh0YWcsIGVsKTtcbiAgICB0aGlzLmNoaWxkcmVuXy51bnNoaWZ0KHRhZyk7XG5cbiAgICAvLyBTZXQgbGFuZyBhdHRyIG9uIHBsYXllciB0byBlbnN1cmUgQ1NTIDpsYW5nKCkgaW4gY29uc2lzdGVudCB3aXRoIHBsYXllclxuICAgIC8vIGlmIGl0J3MgYmVlbiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0byB0aGUgZG9jXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdsYW5nJywgdGhpcy5sYW5ndWFnZV8pO1xuXG4gICAgdGhpcy5lbF8gPSBlbDtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYFBsYXllcmAncyB3aWR0aC4gUmV0dXJucyB0aGUgcGxheWVyJ3MgY29uZmlndXJlZCB2YWx1ZS5cbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IHdpZHRoIHVzZSBgY3VycmVudFdpZHRoKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcmAncyB3aWR0aCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIHBsYXllcnJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiB3aWR0aCh2YWx1ZSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCB2YWx1ZSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3MgaGVpZ2h0LiBSZXR1cm5zIHRoZSBwbGF5ZXIncyBjb25maWd1cmVkIHZhbHVlLlxuICAgKiBUbyBnZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IHVzZSBgY3VycmVudGhlaWdodCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXJgJ3MgaGVpZ3RoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgcGxheWVycmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KHZhbHVlLCBza2lwTGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheWVycmVzaXplXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcbiAgICogICAgICAgIC0gJ3dpZHRoJ1xuICAgKiAgICAgICAgLSAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVmFsdWUgZm9yIGRpbWVuc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgcGxheWVycmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gYXJndW1lbnRzIHZhbHVlIHdoZW4gZ2V0dGluZyAod2lkdGgvaGVpZ2h0KS5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmRpbWVuc2lvbiA9IGZ1bmN0aW9uIGRpbWVuc2lvbihfZGltZW5zaW9uLCB2YWx1ZSwgc2tpcExpc3RlbmVycykge1xuICAgIHZhciBwcml2RGltZW5zaW9uID0gX2RpbWVuc2lvbiArICdfJztcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpc1twcml2RGltZW5zaW9uXSB8fCAwO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgIC8vIElmIGFuIGVtcHR5IHN0cmluZyBpcyBnaXZlbiwgcmVzZXQgdGhlIGRpbWVuc2lvbiB0byBiZSBhdXRvbWF0aWNcbiAgICAgIHRoaXNbcHJpdkRpbWVuc2lvbl0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKHBhcnNlZFZhbCkpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdJbXByb3BlciB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBzdXBwbGllZCBmb3IgZm9yICcgKyBfZGltZW5zaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW3ByaXZEaW1lbnNpb25dID0gcGFyc2VkVmFsO1xuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcblxuICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgaWYgKHRoaXMuaXNSZWFkeV8gJiYgIXNraXBMaXN0ZW5lcnMpIHtcbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHBsYXllciBpcyByZXNpemVkLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWVycmVzaXplXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigncGxheWVycmVzaXplJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIvdG9nZ2xlciBmb3IgdGhlIHZqcy1mbHVpZCBgY2xhc3NOYW1lYCBvbiB0aGUgYFBsYXllcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgdHJ1ZSBhZGRzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiBmYWxzZSByZW1vdmVzIHRoZSBjbGFzcy5cbiAgICogICAgICAgIC0gTm8gdmFsdWUgd2lsbCB0b2dnbGUgdGhlIGZsdWlkIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBmbHVpZCB3aGVuIGdldHRpbmcuXG4gICAqICAgICAgICAgLSBgdW5kZWZpbmVkYCB3aGVuIHNldHRpbmcuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5mbHVpZCA9IGZ1bmN0aW9uIGZsdWlkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmZsdWlkXztcbiAgICB9XG5cbiAgICB0aGlzLmZsdWlkXyA9ICEhYm9vbDtcblxuICAgIGlmIChib29sKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvU2V0IHRoZSBhc3BlY3QgcmF0aW9cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyYXRpb11cbiAgICogICAgICAgIEFzcGVjdCByYXRpbyBmb3IgcGxheWVyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyB0aGUgY3VycmVudCBhc3BlY3QgcmF0aW8gd2hlbiBnZXR0aW5nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGFzcGVjdCByYXRpby5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtyYXRpb11cbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXIncyBhc3BlY3QgcmF0aW8gdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBhc3BlY3QgcmF0aW8gb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFzcGVjdFJhdGlvID0gZnVuY3Rpb24gYXNwZWN0UmF0aW8ocmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNwZWN0UmF0aW9fO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB3aWR0aDpoZWlnaHQgZm9ybWF0XG4gICAgaWYgKCEvXlxcZCtcXDpcXGQrJC8udGVzdChyYXRpbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wcm9wZXIgdmFsdWUgc3VwcGxpZWQgZm9yIGFzcGVjdCByYXRpby4gVGhlIGZvcm1hdCBzaG91bGQgYmUgd2lkdGg6aGVpZ2h0LCBmb3IgZXhhbXBsZSAxNjo5LicpO1xuICAgIH1cbiAgICB0aGlzLmFzcGVjdFJhdGlvXyA9IHJhdGlvO1xuXG4gICAgLy8gV2UncmUgYXNzdW1pbmcgaWYgeW91IHNldCBhbiBhc3BlY3QgcmF0aW8geW91IHdhbnQgZmx1aWQgbW9kZSxcbiAgICAvLyBiZWNhdXNlIGluIGZpeGVkIG1vZGUgeW91IGNvdWxkIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IHlvdXJzZWxmLlxuICAgIHRoaXMuZmx1aWQodHJ1ZSk7XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdHlsZXMgb2YgdGhlIGBQbGF5ZXJgIGVsZW1lbnQgKGhlaWdodCwgd2lkdGggYW5kIGFzcGVjdCByYXRpbykuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVwZGF0ZVN0eWxlRWxfID0gZnVuY3Rpb24gdXBkYXRlU3R5bGVFbF8oKSB7XG4gICAgaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgPT09IHRydWUpIHtcbiAgICAgIHZhciBfd2lkdGggPSB0eXBlb2YgdGhpcy53aWR0aF8gPT09ICdudW1iZXInID8gdGhpcy53aWR0aF8gOiB0aGlzLm9wdGlvbnNfLndpZHRoO1xuICAgICAgdmFyIF9oZWlnaHQgPSB0eXBlb2YgdGhpcy5oZWlnaHRfID09PSAnbnVtYmVyJyA/IHRoaXMuaGVpZ2h0XyA6IHRoaXMub3B0aW9uc18uaGVpZ2h0O1xuICAgICAgdmFyIHRlY2hFbCA9IHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5lbCgpO1xuXG4gICAgICBpZiAodGVjaEVsKSB7XG4gICAgICAgIGlmIChfd2lkdGggPj0gMCkge1xuICAgICAgICAgIHRlY2hFbC53aWR0aCA9IF93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2hlaWdodCA+PSAwKSB7XG4gICAgICAgICAgdGVjaEVsLmhlaWdodCA9IF9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IHZvaWQgMDtcbiAgICB2YXIgaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHZhciBhc3BlY3RSYXRpbyA9IHZvaWQgMDtcbiAgICB2YXIgaWRDbGFzcyA9IHZvaWQgMDtcblxuICAgIC8vIFRoZSBhc3BlY3QgcmF0aW8gaXMgZWl0aGVyIHVzZWQgZGlyZWN0bHkgb3IgdG8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgaWYgKHRoaXMuYXNwZWN0UmF0aW9fICE9PSB1bmRlZmluZWQgJiYgdGhpcy5hc3BlY3RSYXRpb18gIT09ICdhdXRvJykge1xuICAgICAgLy8gVXNlIGFueSBhc3BlY3RSYXRpbyB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICBhc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW9fO1xuICAgIH0gZWxzZSBpZiAodGhpcy52aWRlb1dpZHRoKCkgPiAwKSB7XG4gICAgICAvLyBPdGhlcndpc2UgdHJ5IHRvIGdldCB0aGUgYXNwZWN0IHJhdGlvIGZyb20gdGhlIHZpZGVvIG1ldGFkYXRhXG4gICAgICBhc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9XaWR0aCgpICsgJzonICsgdGhpcy52aWRlb0hlaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPciB1c2UgYSBkZWZhdWx0LiBUaGUgdmlkZW8gZWxlbWVudCdzIGlzIDI6MSwgYnV0IDE2OjkgaXMgbW9yZSBjb21tb24uXG4gICAgICBhc3BlY3RSYXRpbyA9ICcxNjo5JztcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHJhdGlvIGFzIGEgZGVjaW1hbCB3ZSBjYW4gdXNlIHRvIGNhbGN1bGF0ZSBkaW1lbnNpb25zXG4gICAgdmFyIHJhdGlvUGFydHMgPSBhc3BlY3RSYXRpby5zcGxpdCgnOicpO1xuICAgIHZhciByYXRpb011bHRpcGxpZXIgPSByYXRpb1BhcnRzWzFdIC8gcmF0aW9QYXJ0c1swXTtcblxuICAgIGlmICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBVc2UgYW55IHdpZHRoIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aF87XG4gICAgfSBlbHNlIGlmICh0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT3IgY2FsdWxhdGUgdGhlIHdpZHRoIGZyb20gdGhlIGFzcGVjdCByYXRpbyBpZiBhIGhlaWdodCBoYXMgYmVlbiBzZXRcbiAgICAgIHdpZHRoID0gdGhpcy5oZWlnaHRfIC8gcmF0aW9NdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPciB1c2UgdGhlIHZpZGVvJ3MgbWV0YWRhdGEsIG9yIHVzZSB0aGUgdmlkZW8gZWwncyBkZWZhdWx0IG9mIDMwMFxuICAgICAgd2lkdGggPSB0aGlzLnZpZGVvV2lkdGgoKSB8fCAzMDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBVc2UgYW55IGhlaWdodCB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodF87XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIGhlaWdodCBmcm9tIHRoZSByYXRpbyBhbmQgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB3aWR0aCAqIHJhdGlvTXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIENTUyBjbGFzcyBpcyB2YWxpZCBieSBzdGFydGluZyB3aXRoIGFuIGFscGhhIGNoYXJhY3RlclxuICAgIGlmICgvXlteYS16QS1aXS8udGVzdCh0aGlzLmlkKCkpKSB7XG4gICAgICBpZENsYXNzID0gJ2RpbWVuc2lvbnMtJyArIHRoaXMuaWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWRDbGFzcyA9IHRoaXMuaWQoKSArICctZGltZW5zaW9ucyc7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSByaWdodCBjbGFzcyBpcyBzdGlsbCBvbiB0aGUgcGxheWVyIGZvciB0aGUgc3R5bGUgZWxlbWVudFxuICAgIHRoaXMuYWRkQ2xhc3MoaWRDbGFzcyk7XG5cbiAgICBzZXRUZXh0Q29udGVudCh0aGlzLnN0eWxlRWxfLCAnXFxuICAgICAgLicgKyBpZENsYXNzICsgJyB7XFxuICAgICAgICB3aWR0aDogJyArIHdpZHRoICsgJ3B4O1xcbiAgICAgICAgaGVpZ2h0OiAnICsgaGVpZ2h0ICsgJ3B4O1xcbiAgICAgIH1cXG5cXG4gICAgICAuJyArIGlkQ2xhc3MgKyAnLnZqcy1mbHVpZCB7XFxuICAgICAgICBwYWRkaW5nLXRvcDogJyArIHJhdGlvTXVsdGlwbGllciAqIDEwMCArICclO1xcbiAgICAgIH1cXG4gICAgJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQvQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHBsYXliYWNrIHtAbGluayBUZWNofSBpbmNsdWRpbmcgZWxlbWVudFxuICAgKiBhbmQgQVBJIG1ldGhvZHMuIFRoZW4gYXBwZW5kIHRoZSBgVGVjaGAgZWxlbWVudCBpbiBgUGxheWVyYCBhcyBhIGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGVjaE5hbWVcbiAgICogICAgICAgIG5hbWUgb2YgdGhlIHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgKiAgICAgICAgdmlkZW8gc291cmNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb2FkVGVjaF8gPSBmdW5jdGlvbiBsb2FkVGVjaF8odGVjaE5hbWUsIHNvdXJjZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gUGF1c2UgYW5kIHJlbW92ZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3lcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgdGhpcy51bmxvYWRUZWNoXygpO1xuICAgIH1cblxuICAgIHZhciB0aXRsZVRlY2hOYW1lID0gdG9UaXRsZUNhc2UodGVjaE5hbWUpO1xuICAgIHZhciBjYW1lbFRlY2hOYW1lID0gdGVjaE5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB0ZWNoTmFtZS5zbGljZSgxKTtcblxuICAgIC8vIGdldCByaWQgb2YgdGhlIEhUTUw1IHZpZGVvIHRhZyBhcyBzb29uIGFzIHdlIGFyZSB1c2luZyBhbm90aGVyIHRlY2hcbiAgICBpZiAodGl0bGVUZWNoTmFtZSAhPT0gJ0h0bWw1JyAmJiB0aGlzLnRhZykge1xuICAgICAgVGVjaC5nZXRUZWNoKCdIdG1sNScpLmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy50YWcpO1xuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnRlY2hOYW1lXyA9IHRpdGxlVGVjaE5hbWU7XG5cbiAgICAvLyBUdXJuIG9mZiBBUEkgYWNjZXNzIGJlY2F1c2Ugd2UncmUgbG9hZGluZyBhIG5ldyB0ZWNoIHRoYXQgbWlnaHQgbG9hZCBhc3luY2hyb25vdXNseVxuICAgIHRoaXMuaXNSZWFkeV8gPSBmYWxzZTtcblxuICAgIC8vIEdyYWIgdGVjaC1zcGVjaWZpYyBvcHRpb25zIGZyb20gcGxheWVyIG9wdGlvbnMgYW5kIGFkZCBzb3VyY2UgYW5kIHBhcmVudCBlbGVtZW50IHRvIHVzZS5cbiAgICB2YXIgdGVjaE9wdGlvbnMgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICduYXRpdmVDb250cm9sc0ZvclRvdWNoJzogdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoLFxuICAgICAgJ3BsYXllcklkJzogdGhpcy5pZCgpLFxuICAgICAgJ3RlY2hJZCc6IHRoaXMuaWQoKSArICdfJyArIHRpdGxlVGVjaE5hbWUgKyAnX2FwaScsXG4gICAgICAnYXV0b3BsYXknOiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5LFxuICAgICAgJ3BsYXlzaW5saW5lJzogdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSxcbiAgICAgICdwcmVsb2FkJzogdGhpcy5vcHRpb25zXy5wcmVsb2FkLFxuICAgICAgJ2xvb3AnOiB0aGlzLm9wdGlvbnNfLmxvb3AsXG4gICAgICAnbXV0ZWQnOiB0aGlzLm9wdGlvbnNfLm11dGVkLFxuICAgICAgJ3Bvc3Rlcic6IHRoaXMucG9zdGVyKCksXG4gICAgICAnbGFuZ3VhZ2UnOiB0aGlzLmxhbmd1YWdlKCksXG4gICAgICAncGxheWVyRWxJbmdlc3QnOiB0aGlzLnBsYXllckVsSW5nZXN0XyB8fCBmYWxzZSxcbiAgICAgICd2dHQuanMnOiB0aGlzLm9wdGlvbnNfWyd2dHQuanMnXVxuICAgIH07XG5cbiAgICBBTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICAgICAgdmFyIHByb3BzID0gQUxMW25hbWUkJDFdO1xuXG4gICAgICB0ZWNoT3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXSA9IF90aGlzMltwcm9wcy5wcml2YXRlTmFtZV07XG4gICAgfSk7XG5cbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bdGl0bGVUZWNoTmFtZV0pO1xuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1tjYW1lbFRlY2hOYW1lXSk7XG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKTtcblxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGVjaE9wdGlvbnMudGFnID0gdGhpcy50YWc7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2Uuc3JjID09PSB0aGlzLmNhY2hlXy5zcmMgJiYgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPiAwKSB7XG4gICAgICB0ZWNoT3B0aW9ucy5zdGFydFRpbWUgPSB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRlY2ggaW5zdGFuY2VcbiAgICB2YXIgVGVjaENsYXNzID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgIGlmICghVGVjaENsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFRlY2ggbmFtZWQgXFwnJyArIHRpdGxlVGVjaE5hbWUgKyAnXFwnIGV4aXN0cyEgXFwnJyArIHRpdGxlVGVjaE5hbWUgKyAnXFwnIHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKClcXCcnKTtcbiAgICB9XG5cbiAgICB0aGlzLnRlY2hfID0gbmV3IFRlY2hDbGFzcyh0ZWNoT3B0aW9ucyk7XG5cbiAgICAvLyBwbGF5ZXIudHJpZ2dlclJlYWR5IGlzIGFsd2F5cyBhc3luYywgc28gZG9uJ3QgbmVlZCB0aGlzIHRvIGJlIGFzeW5jXG4gICAgdGhpcy50ZWNoXy5yZWFkeShiaW5kKHRoaXMsIHRoaXMuaGFuZGxlVGVjaFJlYWR5XyksIHRydWUpO1xuXG4gICAgdGV4dFRyYWNrQ29udmVydGVyLmpzb25Ub1RleHRUcmFja3ModGhpcy50ZXh0VHJhY2tzSnNvbl8gfHwgW10sIHRoaXMudGVjaF8pO1xuXG4gICAgLy8gTGlzdGVuIHRvIGFsbCBIVE1MNS1kZWZpbmVkIGV2ZW50cyBhbmQgdHJpZ2dlciB0aGVtIG9uIHRoZSBwbGF5ZXJcbiAgICBURUNIX0VWRU5UU19SRVRSSUdHRVIuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIF90aGlzMi5vbihfdGhpczIudGVjaF8sIGV2ZW50LCBfdGhpczJbJ2hhbmRsZVRlY2gnICsgdG9UaXRsZUNhc2UoZXZlbnQpICsgJ18nXSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnbG9hZHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoTG9hZFN0YXJ0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnd2FpdGluZycsIHRoaXMuaGFuZGxlVGVjaFdhaXRpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdjYW5wbGF5JywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwbGF5aW5nJywgdGhpcy5oYW5kbGVUZWNoUGxheWluZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVraW5nJywgdGhpcy5oYW5kbGVUZWNoU2Vla2luZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtlZCcsIHRoaXMuaGFuZGxlVGVjaFNlZWtlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZmlyc3RwbGF5JywgdGhpcy5oYW5kbGVUZWNoRmlyc3RQbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGF1c2UnLCB0aGlzLmhhbmRsZVRlY2hQYXVzZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Vycm9yJywgdGhpcy5oYW5kbGVUZWNoRXJyb3JfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2FkZWRtZXRhZGF0YScsIHRoaXMudXBkYXRlU3R5bGVFbF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3Bvc3RlcmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RleHRkYXRhJywgdGhpcy5oYW5kbGVUZWNoVGV4dERhdGFfKTtcblxuICAgIHRoaXMudXNpbmdOYXRpdmVDb250cm9scyh0aGlzLnRlY2hHZXRfKCdjb250cm9scycpKTtcblxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkgJiYgIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHRlY2ggZWxlbWVudCBpbiB0aGUgRE9NIGlmIGl0IHdhcyBub3QgYWxyZWFkeSB0aGVyZVxuICAgIC8vIE1ha2Ugc3VyZSB0byBub3QgaW5zZXJ0IHRoZSBvcmlnaW5hbCB2aWRlbyBlbGVtZW50IGlmIHVzaW5nIEh0bWw1XG4gICAgaWYgKHRoaXMudGVjaF8uZWwoKS5wYXJlbnROb2RlICE9PSB0aGlzLmVsKCkgJiYgKHRpdGxlVGVjaE5hbWUgIT09ICdIdG1sNScgfHwgIXRoaXMudGFnKSkge1xuICAgICAgcHJlcGVuZFRvKHRoaXMudGVjaF8uZWwoKSwgdGhpcy5lbCgpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcmlkIG9mIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcgcmVmZXJlbmNlIGFmdGVyIHRoZSBmaXJzdCB0ZWNoIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVubG9hZCBhbmQgZGlzcG9zZSBvZiB0aGUgY3VycmVudCBwbGF5YmFjayB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51bmxvYWRUZWNoXyA9IGZ1bmN0aW9uIHVubG9hZFRlY2hfKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCB0ZXh0IHRyYWNrcyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0ZXh0IHRyYWNrcyB3aXRoIHRoZSBuZXh0IHRlY2hcbiAgICBBTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICAgICAgdmFyIHByb3BzID0gQUxMW25hbWUkJDFdO1xuXG4gICAgICBfdGhpczNbcHJvcHMucHJpdmF0ZU5hbWVdID0gX3RoaXMzW3Byb3BzLmdldHRlck5hbWVdKCk7XG4gICAgfSk7XG4gICAgdGhpcy50ZXh0VHJhY2tzSnNvbl8gPSB0ZXh0VHJhY2tDb252ZXJ0ZXIudGV4dFRyYWNrc1RvSnNvbih0aGlzLnRlY2hfKTtcblxuICAgIHRoaXMuaXNSZWFkeV8gPSBmYWxzZTtcblxuICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuXG4gICAgdGhpcy50ZWNoXyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQge0BsaW5rIFRlY2h9LlxuICAgKiBJdCB3aWxsIHByaW50IGEgd2FybmluZyBieSBkZWZhdWx0IGFib3V0IHRoZSBkYW5nZXIgb2YgdXNpbmcgdGhlIHRlY2ggZGlyZWN0bHlcbiAgICogYnV0IGFueSBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCBpbiB3aWxsIHNpbGVuY2UgdGhlIHdhcm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW3NhZmV0eV1cbiAgICogICAgICAgIEFueXRoaW5nIHBhc3NlZCBpbiB0byBzaWxlbmNlIHRoZSB3YXJuaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h9XG4gICAqICAgICAgICAgVGhlIFRlY2hcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2ggPSBmdW5jdGlvbiB0ZWNoKHNhZmV0eSkge1xuICAgIGlmIChzYWZldHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCQxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGVjaF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCBjbGljayBhbmQgdG91Y2ggbGlzdGVuZXJzIGZvciB0aGUgcGxheWJhY2sgZWxlbWVudFxuICAgKlxuICAgKiAtIE9uIGRlc2t0b3BzOiBhIGNsaWNrIG9uIHRoZSB2aWRlbyBpdHNlbGYgd2lsbCB0b2dnbGUgcGxheWJhY2tcbiAgICogLSBPbiBtb2JpbGUgZGV2aWNlczogYSBjbGljayBvbiB0aGUgdmlkZW8gdG9nZ2xlcyBjb250cm9sc1xuICAgKiAgIHdoaWNoIGlzIGRvbmUgYnkgdG9nZ2xpbmcgdGhlIHVzZXIgc3RhdGUgYmV0d2VlbiBhY3RpdmUgYW5kXG4gICAqICAgaW5hY3RpdmVcbiAgICogLSBBIHRhcCBjYW4gc2lnbmFsIHRoYXQgYSB1c2VyIGhhcyBiZWNvbWUgYWN0aXZlIG9yIGhhcyBiZWNvbWUgaW5hY3RpdmVcbiAgICogICBlLmcuIGEgcXVpY2sgdGFwIG9uIGFuIGlQaG9uZSBtb3ZpZSBzaG91bGQgcmV2ZWFsIHRoZSBjb250cm9scy4gQW5vdGhlclxuICAgKiAgIHF1aWNrIHRhcCBzaG91bGQgaGlkZSB0aGVtIGFnYWluIChzaWduYWxpbmcgdGhlIHVzZXIgaXMgaW4gYW4gaW5hY3RpdmVcbiAgICogICB2aWV3aW5nIHN0YXRlKVxuICAgKiAtIEluIGFkZGl0aW9uIHRvIHRoaXMsIHdlIHN0aWxsIHdhbnQgdGhlIHVzZXIgdG8gYmUgY29uc2lkZXJlZCBpbmFjdGl2ZSBhZnRlclxuICAgKiAgIGEgZmV3IHNlY29uZHMgb2YgaW5hY3Rpdml0eS5cbiAgICpcbiAgICogPiBOb3RlOiB0aGUgb25seSBwYXJ0IG9mIGlPUyBpbnRlcmFjdGlvbiB3ZSBjYW4ndCBtaW1pYyB3aXRoIHRoaXMgc2V0dXBcbiAgICogaXMgYSB0b3VjaCBhbmQgaG9sZCBvbiB0aGUgdmlkZW8gZWxlbWVudCBjb3VudGluZyBhcyBhY3Rpdml0eSBpbiBvcmRlciB0b1xuICAgKiBrZWVwIHRoZSBjb250cm9scyBzaG93aW5nLCBidXQgdGhhdCBzaG91bGRuJ3QgYmUgYW4gaXNzdWUuIEEgdG91Y2ggYW5kIGhvbGRcbiAgICogb24gYW55IGNvbnRyb2xzIHdpbGwgc3RpbGwga2VlcCB0aGUgdXNlciBhY3RpdmVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18gPSBmdW5jdGlvbiBhZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0byByZW1vdmUgYWxsIHRoZSBwcmV2aW91cyBsaXN0ZW5lcnMgaW4gY2FzZSB3ZSBhcmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICAgIHRoaXMucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuXG4gICAgLy8gU29tZSBicm93c2VycyAoQ2hyb21lICYgSUUpIGRvbid0IHRyaWdnZXIgYSBjbGljayBvbiBhIGZsYXNoIHN3ZiwgYnV0IGRvXG4gICAgLy8gdHJpZ2dlciBtb3VzZWRvd24vdXAuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDQ0NTYyL2phdmFzY3JpcHQtb25jbGljay1ldmVudC1vdmVyLWZsYXNoLW9iamVjdFxuICAgIC8vIEFueSB0b3VjaCBldmVudHMgYXJlIHNldCB0byBibG9jayB0aGUgbW91c2Vkb3duIGV2ZW50IGZyb20gaGFwcGVuaW5nXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVUZWNoQ2xpY2tfKTtcblxuICAgIC8vIElmIHRoZSBjb250cm9scyB3ZXJlIGhpZGRlbiB3ZSBkb24ndCB3YW50IHRoYXQgdG8gY2hhbmdlIHdpdGhvdXQgYSB0YXAgZXZlbnRcbiAgICAvLyBzbyB3ZSdsbCBjaGVjayBpZiB0aGUgY29udHJvbHMgd2VyZSBhbHJlYWR5IHNob3dpbmcgYmVmb3JlIHJlcG9ydGluZyB1c2VyXG4gICAgLy8gYWN0aXZpdHlcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVGVjaFRvdWNoTW92ZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hFbmRfKTtcblxuICAgIC8vIFRoZSB0YXAgbGlzdGVuZXIgbmVlZHMgdG8gY29tZSBhZnRlciB0aGUgdG91Y2hlbmQgbGlzdGVuZXIgYmVjYXVzZSB0aGUgdGFwXG4gICAgLy8gbGlzdGVuZXIgY2FuY2VscyBvdXQgYW55IHJlcG9ydGVkVXNlckFjdGl2aXR5IHdoZW4gc2V0dGluZyB1c2VyQWN0aXZlKGZhbHNlKVxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyB1c2VkIGZvciBjbGljayBhbmQgdGFwIGNvbnRyb2xzLiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAgICogdG9nZ2xpbmcgdG8gY29udHJvbHMgZGlzYWJsZWQsIHdoZXJlIGEgdGFwL3RvdWNoIHNob3VsZCBkbyBub3RoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXyA9IGZ1bmN0aW9uIHJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBqdXN0IHVzZSBgdGhpcy5vZmYoKWAgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBvdGhlciBuZWVkZWRcbiAgICAvLyBsaXN0ZW5lcnMgYWRkZWQgYnkgdGVjaHMgdGhhdCBleHRlbmQgdGhpcy5cbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVGVjaFRvdWNoTW92ZV8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBsYXllciB3YWl0cyBmb3IgdGhlIHRlY2ggdG8gYmUgcmVhZHlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hSZWFkeV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUmVhZHlfKCkge1xuICAgIHRoaXMudHJpZ2dlclJlYWR5KCk7XG5cbiAgICAvLyBLZWVwIHRoZSBzYW1lIHZvbHVtZSBhcyBiZWZvcmVcbiAgICBpZiAodGhpcy5jYWNoZV8udm9sdW1lKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdGhpcy5jYWNoZV8udm9sdW1lKTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGlmIHRoZSB0ZWNoIGZvdW5kIGEgaGlnaGVyIHJlc29sdXRpb24gcG9zdGVyIHdoaWxlIGxvYWRpbmdcbiAgICB0aGlzLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfKCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGR1cmF0aW9uIGlmIGF2YWlsYWJsZVxuICAgIHRoaXMuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXygpO1xuXG4gICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgYm90aCBoYXZlIGlzc3VlcyB3aXRoIGF1dG9wbGF5LlxuICAgIC8vIEluIFNhZmFyaSAoNS4xLjEpLCB3aGVuIHdlIG1vdmUgdGhlIHZpZGVvIGVsZW1lbnQgaW50byB0aGUgY29udGFpbmVyIGRpdiwgYXV0b3BsYXkgZG9lc24ndCB3b3JrLlxuICAgIC8vIEluIENocm9tZSAoMTUpLCBpZiB5b3UgaGF2ZSBhdXRvcGxheSArIGEgcG9zdGVyICsgbm8gY29udHJvbHMsIHRoZSB2aWRlbyBnZXRzIGhpZGRlbiAoYnV0IGF1ZGlvIHBsYXlzKVxuICAgIC8vIFRoaXMgZml4ZXMgYm90aCBpc3N1ZXMuIE5lZWQgdG8gd2FpdCBmb3IgQVBJLCBzbyBpdCB1cGRhdGVzIGRpc3BsYXlzIGNvcnJlY3RseVxuICAgIGlmICgodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkgJiYgdGhpcy50YWcgJiYgdGhpcy5vcHRpb25zXy5hdXRvcGxheSAmJiB0aGlzLnBhdXNlZCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaHJvbWUgRml4LiBGaXhlZCBpbiBDaHJvbWUgdjE2LlxuICAgICAgICBkZWxldGUgdGhpcy50YWcucG9zdGVyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2ckMSgnZGVsZXRpbmcgdGFnLnBvc3RlciB0aHJvd3MgaW4gc29tZSBicm93c2VycycsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgbG9hZHN0YXJ0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS4gVGhpc1xuICAgKiBmdW5jdGlvbiB3aWxsIGFsc28gdHJpZ2dlciB7QGxpbmsgUGxheWVyI2ZpcnN0cGxheX0gaWYgaXQgaXMgdGhlIGZpcnN0IGxvYWRzdGFydFxuICAgKiBmb3IgYSB2aWRlby5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQGZpcmVzIFBsYXllciNmaXJzdHBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNsb2Fkc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hMb2FkU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaExvYWRTdGFydF8oKSB7XG4gICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBgZW1wdGllZGAgZXZlbnQgaW5zdGVhZC4gU2VlICMxMjc3LlxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlZWtpbmcnKTtcblxuICAgIC8vIHJlc2V0IHRoZSBlcnJvciBzdGF0ZVxuICAgIHRoaXMuZXJyb3IobnVsbCk7XG5cbiAgICAvLyBJZiBpdCdzIGFscmVhZHkgcGxheWluZyB3ZSB3YW50IHRvIHRyaWdnZXIgYSBmaXJzdHBsYXkgZXZlbnQgbm93LlxuICAgIC8vIFRoZSBmaXJzdHBsYXkgZXZlbnQgcmVsaWVzIG9uIGJvdGggdGhlIHBsYXkgYW5kIGxvYWRzdGFydCBldmVudHNcbiAgICAvLyB3aGljaCBjYW4gaGFwcGVuIGluIGFueSBvcmRlciBmb3IgYSBuZXcgc291cmNlXG4gICAgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgYWdlbnQgYmVnaW5zIGxvb2tpbmcgZm9yIG1lZGlhIGRhdGFcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2xvYWRzdGFydFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgdGhlIGhhc1N0YXJ0ZWQgc3RhdGVcbiAgICAgIHRoaXMuaGFzU3RhcnRlZChmYWxzZSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkL3JlbW92ZSB0aGUgdmpzLWhhcy1zdGFydGVkIGNsYXNzXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWVzdFxuICAgKiAgICAgICAgLSB0cnVlOiBhZGRzIHRoZSBjbGFzc1xuICAgKiAgICAgICAgLSBmYWxzZTogcmVtb3ZlIHRoZSBjbGFzc1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRoZSBib29sZWFuIHZhbHVlIG9mIGhhc1N0YXJ0ZWRfXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChyZXF1ZXN0KSB7XG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWN0IGFzIGdldHRlciwgaWYgd2UgaGF2ZSBubyByZXF1ZXN0IHRvIGNoYW5nZVxuICAgICAgcmV0dXJuIHRoaXMuaGFzU3RhcnRlZF87XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QgPT09IHRoaXMuaGFzU3RhcnRlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gcmVxdWVzdDtcblxuICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGJlZ2lucyBvciByZXN1bWVzIHBsYXliYWNrXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheX1cbiAgICogQGZpcmVzIFBsYXllciNwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBsYXlfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGxheWluZycpO1xuXG4gICAgLy8gaGlkZSB0aGUgcG9zdGVyIHdoZW4gdGhlIHVzZXIgaGl0cyBwbGF5XG4gICAgdGhpcy5oYXNTdGFydGVkKHRydWUpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuZXZlciBhbiB7QGxpbmsgVGVjaCNwbGF5fSBldmVudCBoYXBwZW5zLiBJbmRpY2F0ZXMgdGhhdFxuICAgICAqIHBsYXliYWNrIGhhcyBzdGFydGVkIG9yIHJlc3VtZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHdhaXRpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3dhaXRpbmdcbiAgICogQGxpc3RlbnMgVGVjaCN3YWl0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoV2FpdGluZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoV2FpdGluZ18oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIEEgcmVhZHlTdGF0ZSBjaGFuZ2Ugb24gdGhlIERPTSBlbGVtZW50IGhhcyBjYXVzZWQgcGxheWJhY2sgdG8gc3RvcC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjd2FpdGluZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3dhaXRpbmcnKTtcbiAgICB0aGlzLm9uZSgndGltZXVwZGF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczQucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXlgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IGNvbnNpc3RlbnQgYmV0d2VlbiBicm93c2Vycy4gU2VlICMxMzUxXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY2FucGxheVxuICAgKiBAbGlzdGVucyBUZWNoI2NhbnBsYXlcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDYW5QbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5XygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRlVUVVJFX0RBVEEgb3IgZ3JlYXRlci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjY2FucGxheVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgY2FucGxheXRocm91Z2hgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NhbnBsYXl0aHJvdWdoXG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheXRocm91Z2hcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGhhcyBhIHJlYWR5U3RhdGUgb2YgSEFWRV9FTk9VR0hfREFUQSBvciBncmVhdGVyLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG4gICAgICogZW50aXJlIG1lZGlhIGZpbGUgY2FuIGJlIHBsYXllZCB3aXRob3V0IGJ1ZmZlcmluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjY2FucGxheXRocm91Z2hcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5dGhyb3VnaCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBwbGF5aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwbGF5aW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheWluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBsYXlpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBsYXlpbmdfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGlzIG5vIGxvbmdlciBibG9ja2VkIGZyb20gcGxheWJhY2ssIGFuZCBoYXMgc3RhcnRlZCBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNwbGF5aW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGxheWluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBzZWVraW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNzZWVraW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjc2Vla2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNlZWtpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtpbmdfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIHBsYXllciBpcyBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2luZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZWtpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2VkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNzZWVrZWRcbiAgICogQGxpc3RlbnMgVGVjaCNzZWVrZWRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVrZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtlZF8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlZWtpbmcnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGZpbmlzaGVkIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNzZWVrZWRcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzZWVrZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgZmlyc3RwbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNmaXJzdHBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNmaXJzdHBsYXlcbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIGZpcnN0cGxheSBldmVudCBpcyBkZXByZWNhdGVkLlxuICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgcGFzc2luZyB0aGUgYHN0YXJ0dGltZWAgb3B0aW9uIHRvIHRoZSBwbGF5ZXIgYW5kIHRoZSBmaXJzdHBsYXkgZXZlbnQgYXJlIGRlcHJlY2F0ZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRmlyc3RQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGaXJzdFBsYXlfKCkge1xuICAgIC8vIElmIHRoZSBmaXJzdCBzdGFydHRpbWUgYXR0cmlidXRlIGlzIHNwZWNpZmllZFxuICAgIC8vIHRoZW4gd2Ugd2lsbCBzdGFydCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHNlY29uZHNcbiAgICBpZiAodGhpcy5vcHRpb25zXy5zdGFydHRpbWUpIHtcbiAgICAgIGxvZyQxLndhcm4oJ1Bhc3NpbmcgdGhlIGBzdGFydHRpbWVgIG9wdGlvbiB0byB0aGUgcGxheWVyIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiA2LjAnKTtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUodGhpcy5vcHRpb25zXy5zdGFydHRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHRoZSBmaXJzdCB0aW1lIGEgdmlkZW8gaXMgcGxheWVkLiBOb3QgcGFydCBvZiB0aGUgSExTIHNwZWMsIGFuZCB0aGlzIGlzXG4gICAgICogcHJvYmFibHkgbm90IHRoZSBiZXN0IGltcGxlbWVudGF0aW9uIHlldCwgc28gdXNlIHNwYXJpbmdseS4gSWYgeW91IGRvbid0IGhhdmUgYVxuICAgICAqIHJlYXNvbiB0byBwcmV2ZW50IHBsYXliYWNrLCB1c2UgYG15UGxheWVyLm9uZSgncGxheScpO2AgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZmlyc3RwbGF5XG4gICAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIGZpcnN0cGxheSBldmVudCBpcyBkZXByZWNhdGVkLlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBwYXVzZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGF1c2VcbiAgICogQGxpc3RlbnMgVGVjaCNwYXVzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBhdXNlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQYXVzZV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbmV2ZXIgdGhlIG1lZGlhIGhhcyBiZWVuIHBhdXNlZFxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNwYXVzZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGVuZGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNlbmRlZFxuICAgKiBAbGlzdGVucyBUZWNoI2VuZGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRW5kZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVuZGVkXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZW5kZWQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zXy5sb29wKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKDApO1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVuZCBvZiB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgcmVhY2hlZCAoY3VycmVudFRpbWUgPT0gZHVyYXRpb24pXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2VuZGVkXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZW5kZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgZHVyYXRpb24gb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIGZpcnN0IGtub3duIG9yIGNoYW5nZWRcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNkdXJhdGlvbmNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKSB7XG4gICAgdGhpcy5kdXJhdGlvbih0aGlzLnRlY2hHZXRfKCdkdXJhdGlvbicpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgY2xpY2sgb24gdGhlIG1lZGlhIGVsZW1lbnQgdG8gcGxheS9wYXVzZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gdHJpZ2dlclxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI21vdXNlZG93blxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDbGlja18oZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxuICAgIC8vIHRoZSBjbGljayBpcyBjb25zaWRlcmVkIGEgY29udHJvbFxuICAgIGlmICghdGhpcy5jb250cm9sc18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHRhcCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gSXQgd2lsbCB0b2dnbGUgdGhlIHVzZXJcbiAgICogYWN0aXZpdHkgc3RhdGUsIHdoaWNoIGhpZGVzIGFuZCBzaG93cyB0aGUgY29udHJvbHMuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdGFwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGFwXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUYXBfKCkge1xuICAgIHRoaXMudXNlckFjdGl2ZSghdGhpcy51c2VyQWN0aXZlKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gc3RhcnRcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hTdGFydF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hTdGFydF8oKSB7XG4gICAgdGhpcy51c2VyV2FzQWN0aXZlID0gdGhpcy51c2VyQWN0aXZlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBtb3ZlXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2htb3ZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaE1vdmVfKCkge1xuICAgIGlmICh0aGlzLnVzZXJXYXNBY3RpdmUpIHtcbiAgICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gZW5kXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgdG91Y2hlbmQgZXZlbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaGVuZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoRW5kXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaEVuZF8oZXZlbnQpIHtcbiAgICAvLyBTdG9wIHRoZSBtb3VzZSBldmVudHMgZnJvbSBhbHNvIGhhcHBlbmluZ1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBzd2l0Y2hlcyBpbiBvciBvdXQgb2YgZnVsbHNjcmVlbiBtb2RlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfKCkge1xuICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZnVsbHNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogbmF0aXZlIGNsaWNrIGV2ZW50cyBvbiB0aGUgU1dGIGFyZW4ndCB0cmlnZ2VyZWQgb24gSUUxMSwgV2luOC4xUlRcbiAgICogdXNlIHN0YWdlY2xpY2sgZXZlbnRzIHRyaWdnZXJlZCBmcm9tIGluc2lkZSB0aGUgU1dGIGluc3RlYWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgc3RhZ2VjbGlja1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlU3RhZ2VDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVTdGFnZUNsaWNrXygpIHtcbiAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgVGVjaCBGdWxsc2NyZWVuIENoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiAgICAgICAgdGhlIGRhdGEgdGhhdCB3YXMgc2VudCB3aXRoIHRoZSBldmVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICogQGZpcmVzIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRnVsbHNjcmVlbkNoYW5nZV8oZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4oZGF0YS5pc0Z1bGxzY3JlZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGdvaW5nIGluIGFuZCBvdXQgb2YgZnVsbHNjcmVlbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGxvYWRpbmcgb2YgYW4gYXVkaW8vdmlkZW8uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjZXJyb3JcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFcnJvcl8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRXJyb3JfKCkge1xuICAgIHZhciBlcnJvciA9IHRoaXMudGVjaF8uZXJyb3IoKTtcblxuICAgIHRoaXMuZXJyb3IoZXJyb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGB0ZXh0ZGF0YWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdGV4dGRhdGFcbiAgICogQGxpc3RlbnMgVGVjaCN0ZXh0ZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRleHREYXRhXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUZXh0RGF0YV8oKSB7XG4gICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBkYXRhID0gYXJndW1lbnRzWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gd2UgZ2V0IGEgdGV4dGRhdGEgZXZlbnQgZnJvbSB0ZWNoXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3RleHRkYXRhXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigndGV4dGRhdGEnLCBkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9iamVjdCBmb3IgY2FjaGVkIHZhbHVlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIGdldCB0aGUgY3VycmVudCBvYmplY3QgY2FjaGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmdldENhY2hlID0gZnVuY3Rpb24gZ2V0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXNzIHZhbHVlcyB0byB0aGUgcGxheWJhY2sgdGVjaFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZF1cbiAgICogICAgICAgIHRoZSBtZXRob2QgdG8gY2FsbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gICAqICAgICAgICB0aGUgYXJndW1lbnQgdG8gcGFzc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudGVjaENhbGxfID0gZnVuY3Rpb24gdGVjaENhbGxfKG1ldGhvZCwgYXJnKSB7XG4gICAgLy8gSWYgaXQncyBub3QgcmVhZHkgeWV0LCBjYWxsIG1ldGhvZCB3aGVuIGl0IGlzXG5cbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZXRob2QgaW4gYWxsb3dlZFNldHRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHNldCQxKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCwgYXJnKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgICAgICB0aGlzLnRlY2hfW21ldGhvZF0oYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2ckMShlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGNhbGxzIGNhbid0IHdhaXQgZm9yIHRoZSB0ZWNoLCBhbmQgc29tZXRpbWVzIGRvbid0IG5lZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAgICogICAgICAgIFRlY2ggbWV0aG9kXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICogICAgICAgICB0aGUgbWV0aG9kIG9yIHVuZGVmaW5lZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudGVjaEdldF8gPSBmdW5jdGlvbiB0ZWNoR2V0XyhtZXRob2QpIHtcbiAgICBpZiAoIXRoaXMudGVjaF8gfHwgIXRoaXMudGVjaF8uaXNSZWFkeV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kIGluIGFsbG93ZWRHZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kKTtcbiAgICB9XG5cbiAgICAvLyBGbGFzaCBsaWtlcyB0byBkaWUgYW5kIHJlbG9hZCB3aGVuIHlvdSBoaWRlIG9yIHJlcG9zaXRpb24gaXQuXG4gICAgLy8gSW4gdGhlc2UgY2FzZXMgdGhlIG9iamVjdCBtZXRob2RzIGdvIGF3YXkgYW5kIHdlIGdldCBlcnJvcnMuXG4gICAgLy8gV2hlbiB0aGF0IGhhcHBlbnMgd2UnbGwgY2F0Y2ggdGhlIGVycm9ycyBhbmQgaW5mb3JtIHRlY2ggdGhhdCBpdCdzIG5vdCByZWFkeSBhbnkgbW9yZS5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF9bbWV0aG9kXSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgLy8gV2hlbiBidWlsZGluZyBhZGRpdGlvbmFsIHRlY2ggbGlicywgYW4gZXhwZWN0ZWQgbWV0aG9kIG1heSBub3QgYmUgZGVmaW5lZCB5ZXRcbiAgICAgIGlmICh0aGlzLnRlY2hfW21ldGhvZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2ckMSgnVmlkZW8uanM6ICcgKyBtZXRob2QgKyAnIG1ldGhvZCBub3QgZGVmaW5lZCBmb3IgJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5LicsIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIGEgbWV0aG9kIGlzbid0IGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0IGl0IHRocm93cyBhIFR5cGVFcnJvclxuICAgICAgaWYgKGUubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyB1bmF2YWlsYWJsZSBvbiAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kgZWxlbWVudC4nLCBlKTtcbiAgICAgICAgdGhpcy50ZWNoXy5pc1JlYWR5XyA9IGZhbHNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBlcnJvciB1bmtub3duLCBqdXN0IGxvZyBhbmQgdGhyb3dcbiAgICAgIGxvZyQxKGUpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gYmVnaW4gcGxheWJhY2sgYXQgdGhlIGZpcnN0IG9wcG9ydHVuaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBSZXR1cm5zIGEgYFByb21pc2VgIG9ubHkgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmUgYW5kIHRoZSBwbGF5ZXJcbiAgICogICAgICAgICBpcyByZWFkeSB0byBiZWdpbiBwbGF5YmFjay4gRm9yIHNvbWUgYnJvd3NlcnMgYW5kIGFsbCBub24tcmVhZHlcbiAgICogICAgICAgICBzaXR1YXRpb25zLCB0aGlzIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGNhbGxlZCB3aGlsZSB3ZSBoYXZlIGEgcGxheSBxdWV1ZWQgdXAgb24gYSBsb2Fkc3RhcnQsIHJlbW92ZVxuICAgIC8vIHRoYXQgbGlzdGVuZXIgdG8gYXZvaWQgZ2V0dGluZyBpbiBhIHBvdGVudGlhbGx5IGJhZCBzdGF0ZS5cbiAgICBpZiAodGhpcy5wbGF5T25Mb2Fkc3RhcnRfKSB7XG4gICAgICB0aGlzLm9mZignbG9hZHN0YXJ0JywgdGhpcy5wbGF5T25Mb2Fkc3RhcnRfKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyL3RlY2ggaXMgbm90IHJlYWR5LCBxdWV1ZSB1cCBhbm90aGVyIGNhbGwgdG8gYHBsYXkoKWAgZm9yXG4gICAgLy8gd2hlbiBpdCBpcy4gVGhpcyB3aWxsIGxvb3AgYmFjayBpbnRvIHRoaXMgbWV0aG9kIGZvciBhbm90aGVyIGF0dGVtcHQgYXRcbiAgICAvLyBwbGF5YmFjayB3aGVuIHRoZSB0ZWNoIGlzIHJlYWR5LlxuICAgIGlmICghdGhpcy5pc1JlYWR5Xykge1xuXG4gICAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBhbHJlYWR5IHdhaXRpbmcgZm9yIGByZWFkeWAhXG4gICAgICBpZiAodGhpcy5wbGF5V2FpdGluZ0ZvclJlYWR5Xykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGxheVdhaXRpbmdGb3JSZWFkeV8gPSB0cnVlO1xuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5wbGF5V2FpdGluZ0ZvclJlYWR5XyA9IGZhbHNlO1xuICAgICAgICBzaWxlbmNlUHJvbWlzZShfdGhpczUucGxheSgpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGUgcGxheWVyL3RlY2ggaXMgcmVhZHkgYW5kIHdlIGhhdmUgYSBzb3VyY2UsIHdlIGNhbiBhdHRlbXB0IHBsYXliYWNrLlxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY2hhbmdpbmdTcmNfICYmICh0aGlzLnNyYygpIHx8IHRoaXMuY3VycmVudFNyYygpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXknKTtcblxuICAgICAgLy8gSWYgdGhlIHRlY2ggaXMgcmVhZHksIGJ1dCB3ZSBkbyBub3QgaGF2ZSBhIHNvdXJjZSwgd2UnbGwgbmVlZCB0byB3YWl0XG4gICAgICAvLyBmb3IgYm90aCB0aGUgYHJlYWR5YCBhbmQgYSBgbG9hZHN0YXJ0YCB3aGVuIHRoZSBzb3VyY2UgaXMgZmluYWxseVxuICAgICAgLy8gcmVzb2x2ZWQgYnkgbWlkZGxld2FyZSBhbmQgc2V0IG9uIHRoZSBwbGF5ZXIuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGBwbGF5KClgIGlzIGNhbGxlZCB3aGlsZSBjaGFuZ2luZyBzb3VyY2VzIG9yIGJlZm9yZVxuICAgICAgLy8gb25lIGhhcyBiZWVuIHNldCBvbiB0aGUgcGxheWVyLlxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMucGxheU9uTG9hZHN0YXJ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LnBsYXlPbkxvYWRzdGFydF8gPSBudWxsO1xuICAgICAgICBzaWxlbmNlUHJvbWlzZShfdGhpczUucGxheSgpKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub25lKCdsb2Fkc3RhcnQnLCB0aGlzLnBsYXlPbkxvYWRzdGFydF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUGF1c2UgdGhlIHZpZGVvIHBsYXliYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICogICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIG9iamVjdCB0aGlzIGZ1bmN0aW9uIHdhcyBjYWxsZWQgb25cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBwbGF5ZXIgaXMgcGF1c2VkIG9yIGhhcyB5ZXQgdG8gcGxheVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gZmFsc2U6IGlmIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZ1xuICAgKiAgICAgICAgIC0gdHJ1ZTogaWYgbWVkaWEgaXMgbm90IGN1cnJlbnRseSBwbGF5aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQoKSB7XG4gICAgLy8gVGhlIGluaXRpYWwgc3RhdGUgb2YgcGF1c2VkIHNob3VsZCBiZSB0cnVlIChpbiBTYWZhcmkgaXQncyBhY3R1YWxseSBmYWxzZSlcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGF1c2VkJykgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBUaW1lUmFuZ2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCByYW5nZXMgb2YgdGltZSB0aGF0IHRoZSB1c2VyXG4gICAqIGhhcyBwbGF5ZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAgICogICAgICAgICBBIHRpbWUgcmFuZ2Ugb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhbGwgdGhlIGluY3JlbWVudHMgb2YgdGltZSB0aGF0IGhhdmVcbiAgICogICAgICAgICBiZWVuIHBsYXllZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGxheWVkJykgfHwgY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBcInNjcnViYmluZ1wiLiBTY3J1YmJpbmcgaXNcbiAgICogd2hlbiB0aGUgdXNlciBoYXMgY2xpY2tlZCB0aGUgcHJvZ3Jlc3MgYmFyIGhhbmRsZSBhbmQgaXNcbiAgICogZHJhZ2dpbmcgaXQgYWxvbmcgdGhlIHByb2dyZXNzIGJhci5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXNTY3J1YmJpbmddXG4gICAqICAgICAgICB3ZXRoZXIgdGhlIHVzZXIgaXMgb3IgaXMgbm90IHNjcnViYmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBzY3J1YmJpbmcgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zY3J1YmJpbmcgPSBmdW5jdGlvbiBzY3J1YmJpbmcoaXNTY3J1YmJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGlzU2NydWJiaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuc2NydWJiaW5nXztcbiAgICB9XG4gICAgdGhpcy5zY3J1YmJpbmdfID0gISFpc1NjcnViYmluZztcblxuICAgIGlmIChpc1NjcnViYmluZykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHRpbWUgKGluIHNlY29uZHMpXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3NlY29uZHNdXG4gICAqICAgICAgICBUaGUgdGltZSB0byBzZWVrIHRvIGluIHNlY29uZHNcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIC0gdGhlIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFRpbWUgPSBmdW5jdGlvbiBjdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgaWYgKHR5cGVvZiBzZWNvbmRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICAgIHNlY29uZHMgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldEN1cnJlbnRUaW1lJywgc2Vjb25kcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgbGFzdCBjdXJyZW50VGltZSBhbmQgcmV0dXJuLiBkZWZhdWx0IHRvIDAgc2Vjb25kc1xuICAgIC8vXG4gICAgLy8gQ2FjaGluZyB0aGUgY3VycmVudFRpbWUgaXMgbWVhbnQgdG8gcHJldmVudCBhIG1hc3NpdmUgYW1vdW50IG9mIHJlYWRzIG9uIHRoZSB0ZWNoJ3NcbiAgICAvLyBjdXJyZW50VGltZSB3aGVuIHNjcnViYmluZywgYnV0IG1heSBub3QgcHJvdmlkZSBtdWNoIHBlcmZvcm1hbmNlIGJlbmVmaXQgYWZ0ZXJhbGwuXG4gICAgLy8gU2hvdWxkIGJlIHRlc3RlZC4gQWxzbyBzb21ldGhpbmcgaGFzIHRvIHJlYWQgdGhlIGFjdHVhbCBjdXJyZW50IHRpbWUgb3IgdGhlIGNhY2hlIHdpbGxcbiAgICAvLyBuZXZlciBnZXQgdXBkYXRlZC5cbiAgICB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA9IHRoaXMudGVjaEdldF8oJ2N1cnJlbnRUaW1lJykgfHwgMDtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uY3VycmVudFRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vcm1hbGx5IGdldHMgdGhlIGxlbmd0aCBpbiB0aW1lIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzO1xuICAgKiBpbiBhbGwgYnV0IHRoZSByYXJlc3QgdXNlIGNhc2VzIGFuIGFyZ3VtZW50IHdpbGwgTk9UIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqXG4gICAqID4gKipOT1RFKio6IFRoZSB2aWRlbyBtdXN0IGhhdmUgc3RhcnRlZCBsb2FkaW5nIGJlZm9yZSB0aGUgZHVyYXRpb24gY2FuIGJlXG4gICAqIGtub3duLCBhbmQgaW4gdGhlIGNhc2Ugb2YgRmxhc2gsIG1heSBub3QgYmUga25vd24gdW50aWwgdGhlIHZpZGVvIHN0YXJ0c1xuICAgKiBwbGF5aW5nLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kc11cbiAgICogICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gdG8gc2V0IGluIHNlY29uZHNcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIE5hTiBpZiB0aGUgZHVyYXRpb24gaXMgbm90IGtub3duXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZV8uZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMuY2FjaGVfLmR1cmF0aW9uIDogTmFOO1xuICAgIH1cblxuICAgIHNlY29uZHMgPSBwYXJzZUZsb2F0KHNlY29uZHMpO1xuXG4gICAgLy8gU3RhbmRhcmRpemUgb24gSW5pZml0eSBmb3Igc2lnbmFsaW5nIHZpZGVvIGlzIGxpdmVcbiAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgIHNlY29uZHMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoc2Vjb25kcyAhPT0gdGhpcy5jYWNoZV8uZHVyYXRpb24pIHtcbiAgICAgIC8vIENhY2hlIHRoZSBsYXN0IHNldCB2YWx1ZSBmb3Igb3B0aW1pemVkIHNjcnViYmluZyAoZXNwLiBGbGFzaClcbiAgICAgIHRoaXMuY2FjaGVfLmR1cmF0aW9uID0gc2Vjb25kcztcblxuICAgICAgaWYgKHNlY29uZHMgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1saXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgaG93IG11Y2ggdGltZSBpcyBsZWZ0IGluIHRoZSB2aWRlby4gTm90IHBhcnRcbiAgICogb2YgdGhlIG5hdGl2ZSB2aWRlbyBBUEkuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZSA9IGZ1bmN0aW9uIHJlbWFpbmluZ1RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHVyYXRpb24oKSAtIHRoaXMuY3VycmVudFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQSByZW1haW5pbmcgdGltZSBmdW5jdGlvbiB0aGF0IGlzIGludGVudGVkIHRvIGJlIHVzZWQgd2hlblxuICAgKiB0aGUgdGltZSBpcyB0byBiZSBkaXNwbGF5ZWQgZGlyZWN0bHkgdG8gdGhlIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcm91bmRlZCB0aW1lIHJlbWFpbmluZyBpbiBzZWNvbmRzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1haW5pbmdUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIHJlbWFpbmluZ1RpbWVEaXNwbGF5KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZHVyYXRpb24oKSkgLSBNYXRoLmZsb29yKHRoaXMuY3VycmVudFRpbWUoKSk7XG4gIH07XG5cbiAgLy9cbiAgLy8gS2luZCBvZiBsaWtlIGFuIGFycmF5IG9mIHBvcnRpb25zIG9mIHRoZSB2aWRlbyB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkLlxuXG4gIC8qKlxuICAgKiBHZXQgYSBUaW1lUmFuZ2Ugb2JqZWN0IHdpdGggYW4gYXJyYXkgb2YgdGhlIHRpbWVzIG9mIHRoZSB2aWRlb1xuICAgKiB0aGF0IGhhdmUgYmVlbiBkb3dubG9hZGVkLiBJZiB5b3UganVzdCB3YW50IHRoZSBwZXJjZW50IG9mIHRoZVxuICAgKiB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkLCB1c2UgYnVmZmVyZWRQZXJjZW50LlxuICAgKlxuICAgKiBAc2VlIFtCdWZmZXJlZCBTcGVjXXtAbGluayBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL3ZpZGVvLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkfVxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSBtb2NrIFRpbWVSYW5nZSBvYmplY3QgKGZvbGxvd2luZyBIVE1MIHNwZWMpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMudGVjaEdldF8oJ2J1ZmZlcmVkJyk7XG5cbiAgICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudCAoYXMgYSBkZWNpbWFsKSBvZiB0aGUgdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGEgcGFydCBvZiB0aGUgbmF0aXZlIEhUTUwgdmlkZW8gQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgQSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHBlcmNlbnRcbiAgICogICAgICAgICB0aGF0IGlzIGJ1ZmZlcnJlZCAwIGJlaW5nIDAlIGFuZCAxIGJlaW5nIDEwMCVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkUGVyY2VudCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudCQkMSgpIHtcbiAgICByZXR1cm4gYnVmZmVyZWRQZXJjZW50KHRoaXMuYnVmZmVyZWQoKSwgdGhpcy5kdXJhdGlvbigpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbmRpbmcgdGltZSBvZiB0aGUgbGFzdCBidWZmZXJlZCB0aW1lIHJhbmdlXG4gICAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgcHJvZ3Jlc3MgYmFyIHRvIGVuY2Fwc3VsYXRlIGFsbCB0aW1lIHJhbmdlcy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBlbmQgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWRFbmQgPSBmdW5jdGlvbiBidWZmZXJlZEVuZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLmJ1ZmZlcmVkKCk7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpO1xuICAgIHZhciBlbmQgPSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSk7XG5cbiAgICBpZiAoZW5kID4gZHVyYXRpb24pIHtcbiAgICAgIGVuZCA9IGR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBlbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdm9sdW1lIG9mIHRoZSBtZWRpYVxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgdm9sdW1lIGFzIGEgZGVjaW1hbCBwZXJjZW50OlxuICAgKiAgICAgICAgIC0gMCBpcyBtdXRlZC8wJS9vZmZcbiAgICogICAgICAgICAtIDEuMCBpcyAxMDAlL2Z1bGxcbiAgICogICAgICAgICAtIDAuNSBpcyBoYWxmIHZvbHVtZSBvciA1MCVcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiB2b2x1bWUocGVyY2VudEFzRGVjaW1hbCkge1xuICAgIHZhciB2b2wgPSB2b2lkIDA7XG5cbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBGb3JjZSB2YWx1ZSB0byBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIHZvbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHBhcnNlRmxvYXQocGVyY2VudEFzRGVjaW1hbCkpKTtcbiAgICAgIHRoaXMuY2FjaGVfLnZvbHVtZSA9IHZvbDtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRWb2x1bWUnLCB2b2wpO1xuXG4gICAgICBpZiAodm9sID4gMCkge1xuICAgICAgICB0aGlzLmxhc3RWb2x1bWVfKHZvbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIDEgd2hlbiByZXR1cm5pbmcgY3VycmVudCB2b2x1bWUuXG4gICAgdm9sID0gcGFyc2VGbG9hdCh0aGlzLnRlY2hHZXRfKCd2b2x1bWUnKSk7XG4gICAgcmV0dXJuIGlzTmFOKHZvbCkgPyAxIDogdm9sO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbXV0ZWQgc3RhdGUsIG9yIHR1cm4gbXV0ZSBvbiBvciBvZmZcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgbXV0ZSBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgbXV0ZSBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLm11dGVkID0gZnVuY3Rpb24gbXV0ZWQoX211dGVkKSB7XG4gICAgaWYgKF9tdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TXV0ZWQnLCBfbXV0ZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbXV0ZWQnKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGRlZmF1bHRNdXRlZCBzdGF0ZSwgb3IgdHVybiBkZWZhdWx0TXV0ZWQgb24gb3Igb2ZmLiBkZWZhdWx0TXV0ZWRcbiAgICogaW5kaWNhdGVzIHRoZSBzdGF0ZSBvZiBtdXRlZCBvbiBpbnRpYWwgcGxheWJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqICAgdmFyIG15UGxheWVyID0gdmlkZW9qcygnc29tZS1wbGF5ZXItaWQnKTtcbiAgICpcbiAgICogICBteVBsYXllci5zcmMoXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIpO1xuICAgKlxuICAgKiAgIC8vIGdldCwgc2hvdWxkIGJlIGZhbHNlXG4gICAqICAgY29uc29sZS5sb2cobXlQbGF5ZXIuZGVmYXVsdE11dGVkKCkpO1xuICAgKiAgIC8vIHNldCB0byB0cnVlXG4gICAqICAgbXlQbGF5ZXIuZGVmYXVsdE11dGVkKHRydWUpO1xuICAgKiAgIC8vIGdldCBzaG91bGQgYmUgdHJ1ZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRNdXRlZF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byBtdXRlXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHVubXV0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufFBsYXllcn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZGVmYXVsdE11dGVkIGlzIG9uIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBkZWZhdWx0TXV0ZWQgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kZWZhdWx0TXV0ZWQgPSBmdW5jdGlvbiBkZWZhdWx0TXV0ZWQoX2RlZmF1bHRNdXRlZCkge1xuICAgIGlmIChfZGVmYXVsdE11dGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hDYWxsXygnc2V0RGVmYXVsdE11dGVkJywgX2RlZmF1bHRNdXRlZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0TXV0ZWQnKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IHZvbHVtZSwgb3Igc2V0IGl0XG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gW3BlcmNlbnRBc0RlY2ltYWxdXG4gICAqICAgICAgICAgVGhlIG5ldyBsYXN0IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICB0aGUgY3VycmVudCB2YWx1ZSBvZiBsYXN0Vm9sdW1lIGFzIGEgcGVyY2VudCB3aGVuIGdldHRpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhc3RWb2x1bWVfID0gZnVuY3Rpb24gbGFzdFZvbHVtZV8ocGVyY2VudEFzRGVjaW1hbCkge1xuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQgJiYgcGVyY2VudEFzRGVjaW1hbCAhPT0gMCkge1xuICAgICAgdGhpcy5jYWNoZV8ubGFzdFZvbHVtZSA9IHBlcmNlbnRBc0RlY2ltYWw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5sYXN0Vm9sdW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50IHRlY2ggY2FuIHN1cHBvcnQgbmF0aXZlIGZ1bGxzY3JlZW5cbiAgICogKGUuZy4gd2l0aCBidWlsdCBpbiBjb250cm9scyBsaWtlIGlPUywgc28gbm90IG91ciBmbGFzaCBzd2YpXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgaWYgbmF0aXZlIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3N1cHBvcnRzRnVsbFNjcmVlbicpIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSBvciB0ZWxsIHRoZSBwbGF5ZXIgdGhhdCBpdFxuICAgKiBpcyBvciBpcyBub3QgaW4gZnVsbHNjcmVlbiBtb2RlLlxuICAgKlxuICAgKiA+IE5PVEU6IEFzIG9mIHRoZSBsYXRlc3QgSFRNTDUgc3BlYywgaXNGdWxsc2NyZWVuIGlzIG5vIGxvbmdlciBhbiBvZmZpY2lhbFxuICAgKiBwcm9wZXJ0eSBhbmQgaW5zdGVhZCBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCBpcyB1c2VkLiBCdXQgaXNGdWxsc2NyZWVuIGlzXG4gICAqIHN0aWxsIGEgdmFsdWFibGUgcHJvcGVydHkgZm9yIGludGVybmFsIHBsYXllciB3b3JraW5ncy5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2lzRlNdXG4gICAqICAgICAgICAgU2V0IHRoZSBwbGF5ZXJzIGN1cnJlbnQgZnVsbHNjcmVlbiBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBmdWxsc2NyZWVuIGlzIG9uIGFuZCBnZXR0aW5nXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBmdWxsc2NyZWVuIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaXNGdWxsc2NyZWVuID0gZnVuY3Rpb24gaXNGdWxsc2NyZWVuKGlzRlMpIHtcbiAgICBpZiAoaXNGUyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbl8gPSAhIWlzRlM7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuaXNGdWxsc2NyZWVuXztcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVhc2UgdGhlIHNpemUgb2YgdGhlIHZpZGVvIHRvIGZ1bGwgc2NyZWVuXG4gICAqIEluIHNvbWUgYnJvd3NlcnMsIGZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHksIHNvIGl0IGVudGVyc1xuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgICogSW4gYnJvd3NlcnMgYW5kIGRldmljZXMgdGhhdCBzdXBwb3J0IG5hdGl2ZSBmdWxsIHNjcmVlbiwgc29tZXRpbWVzIHRoZVxuICAgKiBicm93c2VyJ3MgZGVmYXVsdCBjb250cm9scyB3aWxsIGJlIHNob3duLCBhbmQgbm90IHRoZSBWaWRlby5qcyBjdXN0b20gc2tpbi5cbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxuICAgKiBTYWZhcmkuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiByZXF1ZXN0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuXG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4odHJ1ZSk7XG5cbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIC8vIHRoZSBicm93c2VyIHN1cHBvcnRzIGdvaW5nIGZ1bGxzY3JlZW4gYXQgdGhlIGVsZW1lbnQgbGV2ZWwgc28gd2UgY2FuXG4gICAgICAvLyB0YWtlIHRoZSBjb250cm9scyBmdWxsc2NyZWVuIGFzIHdlbGwgYXMgdGhlIHZpZGVvXG5cbiAgICAgIC8vIFRyaWdnZXIgZnVsbHNjcmVlbmNoYW5nZSBldmVudCBhZnRlciBjaGFuZ2VcbiAgICAgIC8vIFdlIGhhdmUgdG8gc3BlY2lmaWNhbGx5IGFkZCB0aGlzIGVhY2ggdGltZSwgYW5kIHJlbW92ZVxuICAgICAgLy8gd2hlbiBjYW5jZWxpbmcgZnVsbHNjcmVlbi4gT3RoZXJ3aXNlIGlmIHRoZXJlJ3MgbXVsdGlwbGVcbiAgICAgIC8vIHBsYXllcnMgb24gYSBwYWdlLCB0aGV5IHdvdWxkIGFsbCBiZSByZWFjdGluZyB0byB0aGUgc2FtZSBmdWxsc2NyZWVuXG4gICAgICAvLyBldmVudHNcbiAgICAgIG9uKGRvY3VtZW50LCBmc0FwaS5mdWxsc2NyZWVuY2hhbmdlLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZShlKSB7XG4gICAgICAgIHRoaXMuaXNGdWxsc2NyZWVuKGRvY3VtZW50W2ZzQXBpLmZ1bGxzY3JlZW5FbGVtZW50XSk7XG5cbiAgICAgICAgLy8gSWYgY2FuY2VsbGluZyBmdWxsc2NyZWVuLCByZW1vdmUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSBmYWxzZSkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgICAgfSkpO1xuXG4gICAgICB0aGlzLmVsX1tmc0FwaS5yZXF1ZXN0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIC8vIHdlIGNhbid0IHRha2UgdGhlIHZpZGVvLmpzIGNvbnRyb2xzIGZ1bGxzY3JlZW4gYnV0IHdlIGNhbiBnbyBmdWxsc2NyZWVuXG4gICAgICAvLyB3aXRoIG5hdGl2ZSBjb250cm9sc1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2VudGVyRnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCBzbyB3ZSdsbCBqdXN0IHN0cmV0Y2ggdGhlIHZpZGVvIGVsZW1lbnQgdG9cbiAgICAgIC8vIGZpbGwgdGhlIHZpZXdwb3J0XG4gICAgICB0aGlzLmVudGVyRnVsbFdpbmRvdygpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZpZGVvIHRvIGl0cyBub3JtYWwgc2l6ZSBhZnRlciBoYXZpbmcgYmVlbiBpbiBmdWxsIHNjcmVlbiBtb2RlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZXhpdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbHNjcmVlbigpIHtcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xuXG4gICAgdGhpcy5pc0Z1bGxzY3JlZW4oZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGJyb3dzZXIgZWxlbWVudCBmdWxsc2NyZWVuIHN1cHBvcnRcbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIGRvY3VtZW50W2ZzQXBpLmV4aXRGdWxsc2NyZWVuXSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50ZWNoXy5zdXBwb3J0c0Z1bGxTY3JlZW4oKSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2V4aXRGdWxsU2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhpdEZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hlbiBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCB3ZSBjYW4gc3RyZXRjaCB0aGVcbiAgICogdmlkZW8gY29udGFpbmVyIHRvIGFzIHdpZGUgYXMgdGhlIGJyb3dzZXIgd2lsbCBsZXQgdXMuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW50ZXJGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5lbnRlckZ1bGxXaW5kb3cgPSBmdW5jdGlvbiBlbnRlckZ1bGxXaW5kb3coKSB7XG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSB0cnVlO1xuXG4gICAgLy8gU3RvcmluZyBvcmlnaW5hbCBkb2Mgb3ZlcmZsb3cgdmFsdWUgdG8gcmV0dXJuIHRvIHdoZW4gZnVsbHNjcmVlbiBpcyBvZmZcbiAgICB0aGlzLmRvY09yaWdPdmVyZmxvdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblxuICAgIC8vIEFkZCBsaXN0ZW5lciBmb3IgZXNjIGtleSB0byBleGl0IGZ1bGxzY3JlZW5cbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KSk7XG5cbiAgICAvLyBIaWRlIGFueSBzY3JvbGwgYmFyc1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgLy8gQXBwbHkgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgY2FsbCB0byBlaXRoZXIgZXhpdCBmdWxsIHdpbmRvdyBvclxuICAgKiBmdWxsIHNjcmVlbiBvbiBFU0Mga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgdG8gY2hlY2sgZm9yIGtleSBwcmVzc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZnVsbFdpbmRvd09uRXNjS2V5ID0gZnVuY3Rpb24gZnVsbFdpbmRvd09uRXNjS2V5KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFeGl0IGZ1bGwgd2luZG93XG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsV2luZG93ID0gZnVuY3Rpb24gZXhpdEZ1bGxXaW5kb3coKSB7XG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSBmYWxzZTtcbiAgICBvZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpO1xuXG4gICAgLy8gVW5oaWRlIHNjcm9sbCBiYXJzLlxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IHRoaXMuZG9jT3JpZ092ZXJmbG93O1xuXG4gICAgLy8gUmVtb3ZlIGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLy8gUmVzaXplIHRoZSBib3gsIGNvbnRyb2xsZXIsIGFuZCBwb3N0ZXIgdG8gb3JpZ2luYWwgc2l6ZXNcbiAgICAvLyB0aGlzLnBvc2l0aW9uQWxsKCk7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNleGl0RnVsbFdpbmRvd1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2V4aXRGdWxsV2luZG93Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHBsYXllciBjYW4gcGxheSBhIGdpdmVuIG1pbWV0eXBlXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvdmlkZW8uaHRtbCNkb20tbmF2aWdhdG9yLWNhbnBsYXl0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKHR5cGUpIHtcbiAgICB2YXIgY2FuID0gdm9pZCAwO1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggcGxheWJhY2sgdGVjaG5vbG9neSBpbiB0aGUgb3B0aW9ucyBvcmRlclxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXI7IGkgPCBqLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBqW2ldO1xuICAgICAgdmFyIHRlY2ggPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgICAvLyBSZW1vdmUgb25jZSB0aGF0IGRlcHJlY2F0ZWQgYmVoYXZpb3IgaXMgcmVtb3ZlZC5cbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgaWYgKCF0ZWNoKSB7XG4gICAgICAgIGxvZyQxLmVycm9yKCdUaGUgXCInICsgdGVjaE5hbWUgKyAnXCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guJyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0ZWNoLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgY2FuID0gdGVjaC5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IHNvdXJjZSBiYXNlZCBvbiB0ZWNoLW9yZGVyIG9yIHNvdXJjZS1vcmRlclxuICAgKiBVc2VzIHNvdXJjZS1vcmRlciBzZWxlY3Rpb24gaWYgYG9wdGlvbnMuc291cmNlT3JkZXJgIGlzIHRydXRoeS4gT3RoZXJ3aXNlLFxuICAgKiBkZWZhdWx0cyB0byB0ZWNoLW9yZGVyIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzXG4gICAqICAgICAgICBUaGUgc291cmNlcyBmb3IgYSBtZWRpYSBhc3NldFxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Ym9vbGVhbn1cbiAgICogICAgICAgICBPYmplY3Qgb2Ygc291cmNlIGFuZCB0ZWNoIG9yZGVyIG9yIGZhbHNlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zZWxlY3RTb3VyY2UgPSBmdW5jdGlvbiBzZWxlY3RTb3VyY2Uoc291cmNlcykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gR2V0IG9ubHkgdGhlIHRlY2hzIHNwZWNpZmllZCBpbiBgdGVjaE9yZGVyYCB0aGF0IGV4aXN0IGFuZCBhcmUgc3VwcG9ydGVkIGJ5IHRoZVxuICAgIC8vIGN1cnJlbnQgcGxhdGZvcm1cbiAgICB2YXIgdGVjaHMgPSB0aGlzLm9wdGlvbnNfLnRlY2hPcmRlci5tYXAoZnVuY3Rpb24gKHRlY2hOYW1lKSB7XG4gICAgICByZXR1cm4gW3RlY2hOYW1lLCBUZWNoLmdldFRlY2godGVjaE5hbWUpXTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWZbMF0sXG4gICAgICAgICAgdGVjaCA9IF9yZWZbMV07XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xuICAgICAgaWYgKHRlY2gpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIHJldHVybiB0ZWNoLmlzU3VwcG9ydGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGxvZyQxLmVycm9yKCdUaGUgXCInICsgdGVjaE5hbWUgKyAnXCIgdGVjaCBpcyB1bmRlZmluZWQuIFNraXBwZWQgYnJvd3NlciBzdXBwb3J0IGNoZWNrIGZvciB0aGF0IHRlY2guJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBgaW5uZXJBcnJheWAgZWxlbWVudCBvbmNlIHBlciBgb3V0ZXJBcnJheWAgZWxlbWVudCBhbmQgZXhlY3V0ZVxuICAgIC8vIGB0ZXN0ZXJgIHdpdGggYm90aC4gSWYgYHRlc3RlcmAgcmV0dXJucyBhIG5vbi1mYWxzeSB2YWx1ZSwgZXhpdCBlYXJseSBhbmQgcmV0dXJuXG4gICAgLy8gdGhhdCB2YWx1ZS5cbiAgICB2YXIgZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyID0gZnVuY3Rpb24gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKG91dGVyQXJyYXksIGlubmVyQXJyYXksIHRlc3Rlcikge1xuICAgICAgdmFyIGZvdW5kID0gdm9pZCAwO1xuXG4gICAgICBvdXRlckFycmF5LnNvbWUoZnVuY3Rpb24gKG91dGVyQ2hvaWNlKSB7XG4gICAgICAgIHJldHVybiBpbm5lckFycmF5LnNvbWUoZnVuY3Rpb24gKGlubmVyQ2hvaWNlKSB7XG4gICAgICAgICAgZm91bmQgPSB0ZXN0ZXIob3V0ZXJDaG9pY2UsIGlubmVyQ2hvaWNlKTtcblxuICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIHZhciBmb3VuZFNvdXJjZUFuZFRlY2ggPSB2b2lkIDA7XG4gICAgdmFyIGZsaXAgPSBmdW5jdGlvbiBmbGlwKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuKGIsIGEpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBmaW5kZXIgPSBmdW5jdGlvbiBmaW5kZXIoX3JlZjIsIHNvdXJjZSkge1xuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZjJbMF0sXG4gICAgICAgICAgdGVjaCA9IF9yZWYyWzFdO1xuXG4gICAgICBpZiAodGVjaC5jYW5QbGF5U291cmNlKHNvdXJjZSwgX3RoaXM2Lm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICByZXR1cm4geyBzb3VyY2U6IHNvdXJjZSwgdGVjaDogdGVjaE5hbWUgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB0cnV0aGluZXNzIG9mIGBvcHRpb25zLnNvdXJjZU9yZGVyYCwgd2Ugc3dhcCB0aGUgb3JkZXIgb2YgdGVjaHMgYW5kIHNvdXJjZXNcbiAgICAvLyB0byBzZWxlY3QgZnJvbSB0aGVtIGJhc2VkIG9uIHRoZWlyIHByaW9yaXR5LlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnNvdXJjZU9yZGVyKSB7XG4gICAgICAvLyBTb3VyY2UtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihzb3VyY2VzLCB0ZWNocywgZmxpcChmaW5kZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGVjaC1maXJzdCBvcmRlcmluZ1xuICAgICAgZm91bmRTb3VyY2VBbmRUZWNoID0gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKHRlY2hzLCBzb3VyY2VzLCBmaW5kZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZFNvdXJjZUFuZFRlY2ggfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHZpZGVvIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdHxUZWNoflNvdXJjZU9iamVjdFtdfHN0cmluZ30gW3NvdXJjZV1cbiAgICogICAgICAgIEEgU291cmNlT2JqZWN0LCBhbiBhcnJheSBvZiBTb3VyY2VPYmplY3RzLCBvciBhIHN0cmluZyByZWZlcmVuY2luZ1xuICAgKiAgICAgICAgYSBVUkwgdG8gYSBtZWRpYSBzb3VyY2UuIEl0IGlzIF9oaWdobHkgcmVjb21tZW5kZWRfIHRoYXQgYW4gb2JqZWN0XG4gICAqICAgICAgICBvciBhcnJheSBvZiBvYmplY3RzIGlzIHVzZWQgaGVyZSwgc28gdGhhdCBzb3VyY2Ugc2VsZWN0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG1zIGNhbiB0YWtlIHRoZSBgdHlwZWAgaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgICAgSWYgbm90IHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBhY3RzIGFzIGEgZ2V0dGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIElmIHRoZSBgc291cmNlYCBhcmd1bWVudCBpcyBtaXNzaW5nLCByZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZVxuICAgKiAgICAgICAgIFVSTC4gT3RoZXJ3aXNlLCByZXR1cm5zIG5vdGhpbmcvdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKHNvdXJjZSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgLy8gZ2V0dGVyIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZV8uc3JjIHx8ICcnO1xuICAgIH1cbiAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgc291cmNlcyBhbmQgdHVybiBvdXIgc291cmNlIGludG9cbiAgICAvLyBhbiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0c1xuICAgIHZhciBzb3VyY2VzID0gZmlsdGVyU291cmNlKHNvdXJjZSk7XG5cbiAgICAvLyBpZiBhIHNvdXJjZSB3YXMgcGFzc2VkIGluIHRoZW4gaXQgaXMgaW52YWxpZCBiZWNhdXNlXG4gICAgLy8gaXQgd2FzIGZpbHRlcmVkIHRvIGEgemVybyBsZW5ndGggQXJyYXkuIFNvIHdlIGhhdmUgdG9cbiAgICAvLyBzaG93IGFuIGVycm9yXG4gICAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5ub3RTdXBwb3J0ZWRNZXNzYWdlKSB9KTtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGludGlhbCBzb3VyY2VzXG4gICAgdGhpcy5jYWNoZV8uc291cmNlcyA9IHNvdXJjZXM7XG4gICAgdGhpcy5jaGFuZ2luZ1NyY18gPSB0cnVlO1xuXG4gICAgLy8gaW50aWFsIHNvdXJjZVxuICAgIHRoaXMuY2FjaGVfLnNvdXJjZSA9IHNvdXJjZXNbMF07XG5cbiAgICAvLyBtaWRkbGV3YXJlU291cmNlIGlzIHRoZSBzb3VyY2UgYWZ0ZXIgaXQgaGFzIGJlZW4gY2hhbmdlZCBieSBtaWRkbGV3YXJlXG4gICAgc2V0U291cmNlKHRoaXMsIHNvdXJjZXNbMF0sIGZ1bmN0aW9uIChtaWRkbGV3YXJlU291cmNlLCBtd3MpIHtcbiAgICAgIF90aGlzNy5taWRkbGV3YXJlXyA9IG13cztcblxuICAgICAgdmFyIGVyciA9IF90aGlzNy5zcmNfKG1pZGRsZXdhcmVTb3VyY2UpO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChzb3VyY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LnNyYyhzb3VyY2VzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCB0byBnaXZlIGZvbGtzIGEgY2hhbmNlIHRvIGFkZCBlcnJvciBldmVudCBoYW5kbGVyc1xuICAgICAgICBfdGhpczcuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcih7IGNvZGU6IDQsIG1lc3NhZ2U6IHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5ub3RTdXBwb3J0ZWRNZXNzYWdlKSB9KTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgLy8gd2UgY291bGQgbm90IGZpbmQgYW4gYXBwcm9wcmlhdGUgdGVjaCwgYnV0IGxldCdzIHN0aWxsIG5vdGlmeSB0aGUgZGVsZWdhdGUgdGhhdCB0aGlzIGlzIGl0XG4gICAgICAgIC8vIHRoaXMgbmVlZHMgYSBiZXR0ZXIgY29tbWVudCBhYm91dCB3aHkgdGhpcyBpcyBuZWVkZWRcbiAgICAgICAgX3RoaXM3LnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXM3LmNoYW5naW5nU3JjXyA9IGZhbHNlO1xuICAgICAgLy8gdmlkZW8gZWxlbWVudCBsaXN0ZWQgc291cmNlXG4gICAgICBfdGhpczcuY2FjaGVfLnNyYyA9IG1pZGRsZXdhcmVTb3VyY2Uuc3JjO1xuXG4gICAgICBzZXRUZWNoKG13cywgX3RoaXM3LnRlY2hfKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2JqZWN0IG9uIHRoZSB0ZWNoLCByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IGluZGljYXRlcyB3ZXRoZXJcbiAgICogdGhlcmUgaXMgYSB0ZWNoIHRoYXQgY2FuIHBsYXkgdGhlIHNvdXJjZSBvciBub3RcbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdCB0byBzZXQgb24gdGhlIFRlY2hcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogICAgICAgICAtIFRydWUgaWYgdGhlcmUgaXMgbm8gVGVjaCB0byBwbGF5YmFjayB0aGlzIHNvdXJjZVxuICAgKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5zcmNfID0gZnVuY3Rpb24gc3JjXyhzb3VyY2UpIHtcbiAgICB2YXIgc291cmNlVGVjaCA9IHRoaXMuc2VsZWN0U291cmNlKFtzb3VyY2VdKTtcblxuICAgIGlmICghc291cmNlVGVjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aXRsZUNhc2VFcXVhbHMoc291cmNlVGVjaC50ZWNoLCB0aGlzLnRlY2hOYW1lXykpIHtcbiAgICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxuICAgICAgdGhpcy5sb2FkVGVjaF8oc291cmNlVGVjaC50ZWNoLCBzb3VyY2VUZWNoLnNvdXJjZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgdGVjaCBpcyByZWFkeSB0byBzZXQgdGhlIHNvdXJjZVxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBUaGUgc2V0U291cmNlIHRlY2ggbWV0aG9kIHdhcyBhZGRlZCB3aXRoIHNvdXJjZSBoYW5kbGVyc1xuICAgICAgLy8gc28gb2xkZXIgdGVjaHMgd29uJ3Qgc3VwcG9ydCBpdFxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGUgZGlyZWN0IHByb3RvdHlwZSBmb3IgdGhlIGNhc2Ugd2hlcmUgc3ViY2xhc3Nlc1xuICAgICAgLy8gb2YgdGhlIHRlY2ggZG8gbm90IHN1cHBvcnQgc291cmNlIGhhbmRsZXJzXG4gICAgICBpZiAodGhpcy50ZWNoXy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NldFNvdXJjZScpKSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRTb3VyY2UnLCBzb3VyY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NyYycsIHNvdXJjZS5zcmMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5wcmVsb2FkID09PSAnYXV0bycpIHtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgc291cmNlIHN5bmNocm9ub3VzbHkgaWYgcG9zc2libGUgKCMyMzI2KVxuICAgIH0sIHRydWUpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCZWdpbiBsb2FkaW5nIHRoZSBzcmMgZGF0YS5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdsb2FkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBwbGF5ZXIuIExvYWRzIHRoZSBmaXJzdCB0ZWNoIGluIHRoZSB0ZWNoT3JkZXIsXG4gICAqIGFuZCBjYWxscyBgcmVzZXRgIG9uIHRoZSB0ZWNoYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5sb2FkVGVjaF8odGhpcy5vcHRpb25zXy50ZWNoT3JkZXJbMF0sIG51bGwpO1xuICAgIHRoaXMudGVjaENhbGxfKCdyZXNldCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBvZiB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0cy5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3RbXX1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0c1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNvdXJjZXMgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlcygpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5jdXJyZW50U291cmNlKCk7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcblxuICAgIC8vIGFzc3VtZSBge31gIG9yIGB7IHNyYyB9YFxuICAgIGlmIChPYmplY3Qua2V5cyhzb3VyY2UpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNvdXJjZXMgfHwgc291cmNlcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U291cmNlID0gZnVuY3Rpb24gY3VycmVudFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uc291cmNlIHx8IHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIG9mIHRoZSBjdXJyZW50IHNvdXJjZSB2YWx1ZSBlLmcuIGh0dHA6Ly9teXNpdGUuY29tL3ZpZGVvLm1wNFxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggYGN1cnJlbnRUeXBlYCB0byBhc3Npc3QgaW4gcmVidWlsZGluZyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlKCkgJiYgdGhpcy5jdXJyZW50U291cmNlKCkuc3JjIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIHR5cGUgZS5nLiB2aWRlby9tcDRcbiAgICogVGhpcyBjYW4gYWxsb3cgeW91IHJlYnVpbGQgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBzbyB0aGF0IHlvdSBjb3VsZCBsb2FkIHRoZSBzYW1lXG4gICAqIHNvdXJjZSBhbmQgdGVjaCBsYXRlclxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHNvdXJjZSBNSU1FIHR5cGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRUeXBlID0gZnVuY3Rpb24gY3VycmVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZSgpICYmIHRoaXMuY3VycmVudFNvdXJjZSgpLnR5cGUgfHwgJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIHByZWxvYWQgYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgLSB0cnVlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIHByZWxvYWRcbiAgICogICAgICAgIC0gZmFsc2UgbWFlbnMgdGhhdCB3ZSBzaG91bGQgbm90IHByZWxvYWRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBwcmVsb2FkIGF0dHJpYnV0ZSB2YWx1ZSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnByZWxvYWQgPSBmdW5jdGlvbiBwcmVsb2FkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRQcmVsb2FkJywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zXy5wcmVsb2FkID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwcmVsb2FkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYXV0b3BsYXlcbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGF1dG9wbGF5XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBhdXRvcGxheSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmF1dG9wbGF5ID0gZnVuY3Rpb24gYXV0b3BsYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldEF1dG9wbGF5JywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zXy5hdXRvcGxheSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZWFkeSh0aGlzLmZvcmNlQXV0b3BsYXlJbkNocm9tZV8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnYXV0b3BsYXknLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGNocm9tZSBzdGFydGVkIHBhdXNpbmcgdGhlIHZpZGVvIHdoZW4gbW92aW5nIGluIHRoZSBET01cbiAgICogY2F1c2luZyBhdXRvcGxheSB0byBub3QgY29udGludWUgZHVlIHRvIGhvdyBWaWRlby5qcyBmdW5jdGlvbnMuXG4gICAqIFNlZSAjNDcyMCBmb3IgbW9yZSBpbmZvLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZm9yY2VBdXRvcGxheUluQ2hyb21lXyA9IGZ1bmN0aW9uIGZvcmNlQXV0b3BsYXlJbkNocm9tZV8oKSB7XG4gICAgaWYgKHRoaXMucGF1c2VkKCkgJiYgKFxuICAgIC8vIHJlYWQgZnJvbSB0aGUgdmlkZW8gZWxlbWVudCBvciBvcHRpb25zXG4gICAgdGhpcy5hdXRvcGxheSgpIHx8IHRoaXMub3B0aW9uc18uYXV0b3BsYXkpICYmXG4gICAgLy8gb25seSB0YXJnZXQgZGVza3RvcCBjaHJvbWVcbiAgICBJU19DSFJPTUUgJiYgIUlTX0FORFJPSUQpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIHVuc2V0IHRoZSBwbGF5c2lubGluZSBhdHRyaWJ1dGUuXG4gICAqIFBsYXlzaW5saW5lIHRlbGxzIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCB0cnkgdG8gcGxheSBpbmxpbmUgYnkgZGVmYXVsdFxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCB1c2UgdGhlIGJyb3dzZXIncyBkZWZhdWx0IHBsYXliYWNrIG1vZGUsXG4gICAqICAgICAgICAgIHdoaWNoIGluIG1vc3QgY2FzZXMgaXMgaW5saW5lLiBpT1MgU2FmYXJpIGlzIGEgbm90YWJsZSBleGNlcHRpb25cbiAgICogICAgICAgICAgYW5kIHBsYXlzIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfFBsYXllcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHZhbHVlIG9mIHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheXNpbmxpbmUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXlzaW5saW5lJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvb3AgYXR0cmlidXRlIG9uIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBsb29wIHRoZSB2aWRlb1xuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbG9vcCB0aGUgdmlkZW9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGxvb3Agd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ubG9vcCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbG9vcCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY11cbiAgICogICAgICAgIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBwb3N0ZXIgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wb3N0ZXIgPSBmdW5jdGlvbiBwb3N0ZXIoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3N0ZXJfO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byByZW1vdmUgYSBwb3N0ZXIgaXMgdG8gc2V0IGFzIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIG90aGVyIGZhbHNleSB2YWx1ZXMgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICBpZiAoIXNyYykge1xuICAgICAgc3JjID0gJyc7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBwb3N0ZXIgdmFyaWFibGVcbiAgICB0aGlzLnBvc3Rlcl8gPSBzcmM7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2gncyBwb3N0ZXJcbiAgICB0aGlzLnRlY2hDYWxsXygnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9zdGVyIGltYWdlIGlzIGNoYW5nZWQgb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgdGVjaHMgKGUuZy4gWW91VHViZSkgY2FuIHByb3ZpZGUgYSBwb3N0ZXIgc291cmNlIGluIGFuXG4gICAqIGFzeW5jaHJvbm91cyB3YXkuIFdlIHdhbnQgdGhlIHBvc3RlciBjb21wb25lbnQgdG8gdXNlIHRoaXNcbiAgICogcG9zdGVyIHNvdXJjZSBzbyB0aGF0IGl0IGNvdmVycyB1cCB0aGUgdGVjaCdzIGNvbnRyb2xzLlxuICAgKiAoWW91VHViZSdzIHBsYXkgYnV0dG9uKS4gSG93ZXZlciB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICogc291cmNlIGlmIHRoZSBwbGF5ZXIgdXNlciBoYXNuJ3Qgc2V0IGEgcG9zdGVyIHRocm91Z2hcbiAgICogdGhlIG5vcm1hbCBBUElzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKiBAbGlzdGVucyBUZWNoI3Bvc3RlcmNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpIHtcbiAgICBpZiAoIXRoaXMucG9zdGVyXyAmJiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8ucG9zdGVyKSB7XG4gICAgICB0aGlzLnBvc3Rlcl8gPSB0aGlzLnRlY2hfLnBvc3RlcigpIHx8ICcnO1xuXG4gICAgICAvLyBMZXQgY29tcG9uZW50cyBrbm93IHRoZSBwb3N0ZXIgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjb250cm9sc2VuYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLmNvbnRyb2xzXztcbiAgICB9XG5cbiAgICBib29sID0gISFib29sO1xuXG4gICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGlmICh0aGlzLmNvbnRyb2xzXyA9PT0gYm9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbHNfID0gYm9vbDtcblxuICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldENvbnRyb2xzJywgYm9vbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udHJvbHNfKSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1lbmFibGVkJyk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG4gICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNkaXNhYmxlZFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZGlzYWJsZWQnKTtcbiAgICAgIGlmICghdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgbmF0aXZlIGNvbnRyb2xzIG9uL29mZi4gTmF0aXZlIGNvbnRyb2xzIGFyZSB0aGUgY29udHJvbHMgYnVpbHQgaW50b1xuICAgKiBkZXZpY2VzIChlLmcuIGRlZmF1bHQgaVBob25lIGNvbnRyb2xzKSwgRmxhc2gsIG9yIG90aGVyIHRlY2hzXG4gICAqIChlLmcuIFZpbWVvIENvbnRyb2xzKVxuICAgKiAqKlRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IGJ5IHRoZSBjdXJyZW50IHRlY2gsIGJlY2F1c2Ugb25seSB0aGUgdGVjaCBrbm93c1xuICAgKiBpZiBpdCBjYW4gc3VwcG9ydCBuYXRpdmUgY29udHJvbHMqKlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICogQGZpcmVzIFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgdG8gdHVybiBuYXRpdmUgY29udHJvbHMgb25cbiAgICogICAgICAgIC0gZmFsc2UgdG8gdHVybiBuYXRpdmUgY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgbmF0aXZlIGNvbnRyb2xzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXNpbmdOYXRpdmVDb250cm9scyA9IGZ1bmN0aW9uIHVzaW5nTmF0aXZlQ29udHJvbHMoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIC8vIERvbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgdW5sZXNzIGl0IGFjdHVhbGx5IGNoYW5nZWRcbiAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9PT0gYm9vbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gPSBib29sO1xuXG4gICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18pIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIG5hdGl2ZSBkZXZpY2UgY29udHJvbHNcbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIGN1c3RvbSBIVE1MIGNvbnRyb2xzXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNpbmdjdXN0b21jb250cm9scycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIGdldCB0aGUgY3VycmVudCBNZWRpYUVycm9yXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZXJyb3JcbiAgICpcbiAgICogQHBhcmFtICB7TWVkaWFFcnJvcnxzdHJpbmd8bnVtYmVyfSBbZXJyXVxuICAgKiAgICAgICAgIEEgTWVkaWFFcnJvciBvciBhIHN0cmluZy9udW1iZXIgdG8gYmUgdHVybmVkXG4gICAqICAgICAgICAgaW50byBhIE1lZGlhRXJyb3JcbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IE1lZGlhRXJyb3Igd2hlbiBnZXR0aW5nIChvciBudWxsKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yXyB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmluZyB0byBkZWZhdWx0XG4gICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZXJyb3InKTtcbiAgICAgIGlmICh0aGlzLmVycm9yRGlzcGxheSkge1xuICAgICAgICB0aGlzLmVycm9yRGlzcGxheS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcblxuICAgIC8vIGFkZCB0aGUgdmpzLWVycm9yIGNsYXNzbmFtZSB0byB0aGUgcGxheWVyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVycm9yJyk7XG5cbiAgICAvLyBsb2cgdGhlIG5hbWUgb2YgdGhlIGVycm9yIHR5cGUgYW5kIGFueSBtZXNzYWdlXG4gICAgLy8gaWU4IGp1c3QgbG9ncyBcIltvYmplY3Qgb2JqZWN0XVwiIGlmIHlvdSBqdXN0IGxvZyB0aGUgZXJyb3Igb2JqZWN0XG4gICAgbG9nJDEuZXJyb3IoJyhDT0RFOicgKyB0aGlzLmVycm9yXy5jb2RlICsgJyAnICsgTWVkaWFFcnJvci5lcnJvclR5cGVzW3RoaXMuZXJyb3JfLmNvZGVdICsgJyknLCB0aGlzLmVycm9yXy5tZXNzYWdlLCB0aGlzLmVycm9yXyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI2Vycm9yXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcblxuICAgIHJldHVybjtcbiAgfTtcblxuICAvKipcbiAgICogUmVwb3J0IHVzZXIgYWN0aXZpdHlcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICBFdmVudCBvYmplY3RcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcG9ydFVzZXJBY3Rpdml0eSA9IGZ1bmN0aW9uIHJlcG9ydFVzZXJBY3Rpdml0eShldmVudCkge1xuICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgdXNlciBpcyBhY3RpdmVcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN1c2VyYWN0aXZlXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmluYWN0aXZlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgaWYgdGhlIHVzZXIgaXMgYWN0aXZlXG4gICAqICAgICAgICAtIGZhbHNlIGlmIHRoZSB1c2VyIGlzIGluYWN0aXZlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdXNlckFjdGl2ZSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVzZXJBY3RpdmUgPSBmdW5jdGlvbiB1c2VyQWN0aXZlKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy51c2VyQWN0aXZlXztcbiAgICB9XG5cbiAgICBib29sID0gISFib29sO1xuXG4gICAgaWYgKGJvb2wgPT09IHRoaXMudXNlckFjdGl2ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVzZXJBY3RpdmVfID0gYm9vbDtcblxuICAgIGlmICh0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3VzZXJhY3RpdmVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyYWN0aXZlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hyb21lL1NhZmFyaS9JRSBoYXZlIGJ1Z3Mgd2hlcmUgd2hlbiB5b3UgY2hhbmdlIHRoZSBjdXJzb3IgaXQgY2FuXG4gICAgLy8gdHJpZ2dlciBhIG1vdXNlbW92ZSBldmVudC4gVGhpcyBjYXVzZXMgYW4gaXNzdWUgd2hlbiB5b3UncmUgaGlkaW5nXG4gICAgLy8gdGhlIGN1cnNvciB3aGVuIHRoZSB1c2VyIGlzIGluYWN0aXZlLCBhbmQgYSBtb3VzZW1vdmUgc2lnbmFscyB1c2VyXG4gICAgLy8gYWN0aXZpdHkuIE1ha2luZyBpdCBpbXBvc3NpYmxlIHRvIGdvIGludG8gaW5hY3RpdmUgbW9kZS4gU3BlY2lmaWNhbGx5XG4gICAgLy8gdGhpcyBoYXBwZW5zIGluIGZ1bGxzY3JlZW4gd2hlbiB3ZSByZWFsbHkgbmVlZCB0byBoaWRlIHRoZSBjdXJzb3IuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoaXMgZ2V0cyByZXNvbHZlZCBpbiBBTEwgYnJvd3NlcnMgaXQgY2FuIGJlIHJlbW92ZWRcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAzMDQxXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8ub25lKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1pbmFjdGl2ZScpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjdXNlcmluYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigndXNlcmluYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgdXNlciBhY3Rpdml0eSBiYXNlZCBvbiB0aW1lb3V0IHZhbHVlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5saXN0ZW5Gb3JVc2VyQWN0aXZpdHlfID0gZnVuY3Rpb24gbGlzdGVuRm9yVXNlckFjdGl2aXR5XygpIHtcbiAgICB2YXIgbW91c2VJblByb2dyZXNzID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TW92ZVggPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RNb3ZlWSA9IHZvaWQgMDtcbiAgICB2YXIgaGFuZGxlQWN0aXZpdHkgPSBiaW5kKHRoaXMsIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KTtcblxuICAgIHZhciBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZSkge1xuICAgICAgLy8gIzEwNjggLSBQcmV2ZW50IG1vdXNlbW92ZSBzcGFtbWluZ1xuICAgICAgLy8gQ2hyb21lIEJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM2Njk3MFxuICAgICAgaWYgKGUuc2NyZWVuWCAhPT0gbGFzdE1vdmVYIHx8IGUuc2NyZWVuWSAhPT0gbGFzdE1vdmVZKSB7XG4gICAgICAgIGxhc3RNb3ZlWCA9IGUuc2NyZWVuWDtcbiAgICAgICAgbGFzdE1vdmVZID0gZS5zY3JlZW5ZO1xuICAgICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKCkge1xuICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIC8vIEZvciBhcyBsb25nIGFzIHRoZSB0aGV5IGFyZSB0b3VjaGluZyB0aGUgZGV2aWNlIG9yIGhhdmUgdGhlaXIgbW91c2UgZG93bixcbiAgICAgIC8vIHdlIGNvbnNpZGVyIHRoZW0gYWN0aXZlIGV2ZW4gaWYgdGhleSdyZSBub3QgbW92aW5nIHRoZWlyIGZpbmdlciBvciBtb3VzZS5cbiAgICAgIC8vIFNvIHdlIHdhbnQgdG8gY29udGludWUgdG8gdXBkYXRlIHRoYXQgdGhleSBhcmUgYWN0aXZlXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwobW91c2VJblByb2dyZXNzKTtcbiAgICAgIC8vIFNldHRpbmcgdXNlckFjdGl2aXR5PXRydWUgbm93IGFuZCBzZXR0aW5nIHRoZSBpbnRlcnZhbCB0byB0aGUgc2FtZSB0aW1lXG4gICAgICAvLyBhcyB0aGUgYWN0aXZpdHlDaGVjayBpbnRlcnZhbCAoMjUwKSBzaG91bGQgZW5zdXJlIHdlIG5ldmVyIG1pc3MgdGhlXG4gICAgICAvLyBuZXh0IGFjdGl2aXR5Q2hlY2tcbiAgICAgIG1vdXNlSW5Qcm9ncmVzcyA9IHRoaXMuc2V0SW50ZXJ2YWwoaGFuZGxlQWN0aXZpdHksIDI1MCk7XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIC8vIFN0b3AgdGhlIGludGVydmFsIHRoYXQgbWFpbnRhaW5zIGFjdGl2aXR5IGlmIHRoZSBtb3VzZS90b3VjaCBpcyBkb3duXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwobW91c2VJblByb2dyZXNzKTtcbiAgICB9O1xuXG4gICAgLy8gQW55IG1vdXNlIG1vdmVtZW50IHdpbGwgYmUgY29uc2lkZXJlZCB1c2VyIGFjdGl2aXR5XG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKTtcblxuICAgIC8vIExpc3RlbiBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgIC8vIFNob3VsZG4ndCBuZWVkIHRvIHVzZSBpblByb2dyZXNzIGludGVydmFsIGJlY2F1c2Ugb2Yga2V5IHJlcGVhdFxuICAgIHRoaXMub24oJ2tleWRvd24nLCBoYW5kbGVBY3Rpdml0eSk7XG4gICAgdGhpcy5vbigna2V5dXAnLCBoYW5kbGVBY3Rpdml0eSk7XG5cbiAgICAvLyBSdW4gYW4gaW50ZXJ2YWwgZXZlcnkgMjUwIG1pbGxpc2Vjb25kcyBpbnN0ZWFkIG9mIHN0dWZmaW5nIGV2ZXJ5dGhpbmcgaW50b1xuICAgIC8vIHRoZSBtb3VzZW1vdmUvdG91Y2htb3ZlIGZ1bmN0aW9uIGl0c2VsZiwgdG8gcHJldmVudCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi5cbiAgICAvLyBgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHlgIHNpbXBseSBzZXRzIHRoaXMudXNlckFjdGl2aXR5XyB0byB0cnVlLCB3aGljaFxuICAgIC8vIHRoZW4gZ2V0cyBwaWNrZWQgdXAgYnkgdGhpcyBsb29wXG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2xlYXJuaW5nLWZyb20tdHdpdHRlci9cbiAgICB2YXIgaW5hY3Rpdml0eVRpbWVvdXQgPSB2b2lkIDA7XG5cbiAgICB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBtb3VzZS90b3VjaCBhY3Rpdml0eSBoYXMgaGFwcGVuZWRcbiAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2aXR5IHRyYWNrZXJcbiAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiB0aGUgdXNlciBzdGF0ZSB3YXMgaW5hY3RpdmUsIHNldCB0aGUgc3RhdGUgdG8gYWN0aXZlXG4gICAgICB0aGlzLnVzZXJBY3RpdmUodHJ1ZSk7XG5cbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbmFjdGl2aXR5IHRpbWVvdXQgdG8gc3RhcnQgdGhlIHRpbWVyIG92ZXJcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KGluYWN0aXZpdHlUaW1lb3V0KTtcblxuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLm9wdGlvbnNfLmluYWN0aXZpdHlUaW1lb3V0O1xuXG4gICAgICBpZiAodGltZW91dCA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSW4gPHRpbWVvdXQ+IG1pbGxpc2Vjb25kcywgaWYgbm8gbW9yZSBhY3Rpdml0eSBoYXMgb2NjdXJyZWQgdGhlXG4gICAgICAvLyB1c2VyIHdpbGwgYmUgY29uc2lkZXJlZCBpbmFjdGl2ZVxuICAgICAgaW5hY3Rpdml0eVRpbWVvdXQgPSB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIGluYWN0aXZpdHlUaW1lb3V0IGNhbiB0cmlnZ2VyIGp1c3RcbiAgICAgICAgLy8gYmVmb3JlIHRoZSBuZXh0IHVzZXIgYWN0aXZpdHkgaXMgcGlja2VkIHVwIGJ5IHRoZSBhY3Rpdml0eSBjaGVjayBsb29wXG4gICAgICAgIC8vIGNhdXNpbmcgYSBmbGlja2VyXG4gICAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGltZW91dCk7XG4gICAgfSwgMjUwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuIEEgcGxheWJhY2sgcmF0ZSBvZlxuICAgKiAxLjAgcmVwcmVzZW50cyBub3JtYWwgc3BlZWQgYW5kIDAuNSB3b3VsZCBpbmRpY2F0ZSBoYWxmLXNwZWVkXG4gICAqIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXRlXVxuICAgKiAgICAgICBOZXcgcGxheWJhY2sgcmF0ZSB0byBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBwbGF5YmFjayByYXRlIHdoZW4gZ2V0dGluZyBvciAxLjBcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBsYXliYWNrUmF0ZScsIHJhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5YmFja1JhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIDEuMDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGRlZmF1bHQgcGxheWJhY2sgcmF0ZS4gQSBkZWZhdWx0IHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZCBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKiBkZWZhdWx0UGxheWJhY2tSYXRlIHdpbGwgb25seSByZXByZXNlbnQgd2hhdCB0aGUgaW50aWFsIHBsYXliYWNrUmF0ZSBvZiBhIHZpZGVvIHdhcywgbm90XG4gICAqIG5vdCB0aGUgY3VycmVudCBwbGF5YmFja1JhdGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0cGxheWJhY2tyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICogICAgICAgTmV3IGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB0byBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSBUaGUgZGVmYXVsdCBwbGF5YmFjayByYXRlIHdoZW4gZ2V0dGluZyBvciAxLjBcbiAgICogICAgICAgICAtIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kZWZhdWx0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gZGVmYXVsdFBsYXliYWNrUmF0ZShyYXRlKSB7XG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaENhbGxfKCdzZXREZWZhdWx0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2RlZmF1bHRQbGF5YmFja1JhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIDEuMDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBhdWRpbyBmbGFnXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYm9vbFxuICAgKiAgICAgICAgLSB0cnVlIHNpZ25hbHMgdGhhdCB0aGlzIGlzIGFuIGF1ZGlvIHBsYXllclxuICAgKiAgICAgICAgLSBmYWxzZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBub3QgYW4gYXVkaW8gcGxheWVyXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgaXNBdWRpbyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzQXVkaW8gPSBmdW5jdGlvbiBpc0F1ZGlvKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmlzQXVkaW9fID0gISFib29sO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuaXNBdWRpb187XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIG1ldGhvZCBmb3IgYWRkaW5nIGEge0BsaW5rIFRleHRUcmFja30gdG8gb3VyXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIFczQyBzZXR0aW5ncyB3ZSBhbGxvdyBhZGRpbmcgYWRkaXRpb25hbCBpbmZvIHRocm91Z2ggb3B0aW9ucy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtYWRkdGV4dHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF1cbiAgICogICAgICAgIHRoZSBraW5kIG9mIFRleHRUcmFjayB5b3UgYXJlIGFkZGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgdGhlIGxhYmVsIHRvIGdpdmUgdGhlIFRleHRUcmFjayBsYWJlbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgdGhlIGxhbmd1YWdlIHRvIHNldCBvbiB0aGUgVGV4dFRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja3x1bmRlZmluZWR9XG4gICAqICAgICAgICAgdGhlIFRleHRUcmFjayB0aGF0IHdhcyBhZGRlZCBvciB1bmRlZmluZWRcbiAgICogICAgICAgICBpZiB0aGVyZSBpcyBubyB0ZWNoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IGFuZCBhbiB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0uIEl0IHdpbGxcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzLCB1bmxlc3NcbiAgICogbWFudWFsQ2xlYW51cCBpcyBzZXQgdG8gZmFsc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBPcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGR1cmluZyBjcmVhdGlvbi4gU2VlXG4gICAqICAgICAgICB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gZm9yIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgeW91IHNob3VsZCB1c2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICB0aGUgSFRNTFRyYWNrRWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhZGRlZFxuICAgKiAgICAgICAgIHRvIHRoZSBIdG1sVHJhY2tFbGVtZW50TGlzdCBhbmQgdGhlIHJlbW90ZVxuICAgKiAgICAgICAgIFRleHRUcmFja0xpc3RcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB3aWxsIGRlZmF1bHRcbiAgICogICAgICAgICAgICAgdG8gXCJmYWxzZVwiIGluIHVwY29taW5nIHZlcnNpb25zIG9mIFZpZGVvLmpzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gZnJvbSB0aGUgcmVzcGVjdGl2ZVxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0gYW5kIHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja1xuICAgKiAgICAgICAgUmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IHRvIHJlbW92ZVxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2soKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZjMkdHJhY2sgPSBfcmVmMy50cmFjayxcbiAgICAgICAgdHJhY2sgPSBfcmVmMyR0cmFjayA9PT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3JlZjMkdHJhY2s7XG5cbiAgICAvLyBkZXN0cnVjdHVyZSB0aGUgaW5wdXQgaW50byBhbiBvYmplY3Qgd2l0aCBhIHRyYWNrIGFyZ3VtZW50LCBkZWZhdWx0aW5nIHRvIGFyZ3VtZW50c1swXVxuICAgIC8vIGRlZmF1bHQgdGhlIHdob2xlIGFyZ3VtZW50IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBub3RoaW5nIHdhcyBwYXNzZWQgaW5cblxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIG9yIHVuZGVmaW5lZCBpZiB0aGVyZVxuICAgKiAgICAgICAgIGlzIG5vIHRlY2ggb3IgdGhlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2dldFZpZGVvUGxheWJhY2tRdWFsaXR5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlbyB3aWR0aFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgY3VycmVudCB2aWRlbyB3aWR0aFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9XaWR0aCA9IGZ1bmN0aW9uIHZpZGVvV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb1dpZHRoICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCgpIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2aWRlbyBoZWlnaHRcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gaGVpZ2h0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS52aWRlb0hlaWdodCA9IGZ1bmN0aW9uIHZpZGVvSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQgJiYgdGhpcy50ZWNoXy52aWRlb0hlaWdodCgpIHx8IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwbGF5ZXIncyBsYW5ndWFnZSBjb2RlXG4gICAqIE5PVEU6IFRoZSBsYW5ndWFnZSBzaG91bGQgYmUgc2V0IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBpZiB5b3Ugd2FudCB0aGVcbiAgICogdGhlIGNvbnRyb2xzIHRvIGJlIGJ1aWx0IHdpdGggYSBzcGVjaWZpYyBsYW5ndWFnZS4gQ2hhbmdpbmcgdGhlIGxhbnVnYWdlXG4gICAqIGxhdGVyIHdpbGwgbm90IHVwZGF0ZSBjb250cm9scyB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgY29kZSB0byBzZXQgdGhlIHBsYXllciB0b1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgbGFuZ3VhZ2UgY29kZSB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlID0gZnVuY3Rpb24gbGFuZ3VhZ2UoY29kZSkge1xuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlXztcbiAgICB9XG5cbiAgICB0aGlzLmxhbmd1YWdlXyA9IFN0cmluZyhjb2RlKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBsYXllcidzIGxhbmd1YWdlIGRpY3Rpb25hcnlcbiAgICogTWVyZ2UgZXZlcnkgdGltZSwgYmVjYXVzZSBhIG5ld2x5IGFkZGVkIHBsdWdpbiBtaWdodCBjYWxsIHZpZGVvanMuYWRkTGFuZ3VhZ2UoKSBhdCBhbnkgdGltZVxuICAgKiBMYW5ndWFnZXMgc3BlY2lmaWVkIGRpcmVjdGx5IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBoYXZlIHByZWNlZGVuY2VcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2Ygb2Ygc3VwcG9ydGVkIGxhbmd1YWdlc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGFuZ3VhZ2VzID0gZnVuY3Rpb24gbGFuZ3VhZ2VzKCkge1xuICAgIHJldHVybiBtZXJnZU9wdGlvbnMoUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXy5sYW5ndWFnZXMsIHRoaXMubGFuZ3VhZ2VzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCByZXBlcmVzZW50aW5nIHRoZSBjdXJyZW50IHRyYWNrXG4gICAqIGluZm9ybWF0aW9uLiAqKkRPRVMgbm90IHJldHVybiBpdCBhcyBKU09OKipcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgb2YgdHJhY2sgaW5mb1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18pO1xuICAgIHZhciB0cmFja3MgPSBvcHRpb25zLnRyYWNrcztcblxuICAgIG9wdGlvbnMudHJhY2tzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAvLyBkZWVwIG1lcmdlIHRyYWNrcyBhbmQgbnVsbCBvdXQgcGxheWVyIHNvIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgIHRyYWNrID0gbWVyZ2VPcHRpb25zKHRyYWNrKTtcbiAgICAgIHRyYWNrLnBsYXllciA9IHVuZGVmaW5lZDtcbiAgICAgIG9wdGlvbnMudHJhY2tzW2ldID0gdHJhY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgbW9kYWwgZGlhbG9nIChhbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfVxuICAgKiBjb21wb25lbnQpIHRoYXQgaW1tZWRpYXRlbHkgb3ZlcmxheXMgdGhlIHBsYXllciB3aXRoIGFyYml0cmFyeVxuICAgKiBjb250ZW50IGFuZCByZW1vdmVzIGl0c2VsZiB3aGVuIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb258RWxlbWVudHxBcnJheXxudWxsfSBjb250ZW50XG4gICAqICAgICAgICBTYW1lIGFzIHtAbGluayBNb2RhbERpYWxvZyNjb250ZW50fSdzIHBhcmFtIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqICAgICAgICBUaGUgbW9zdCBzdHJhaWdodC1mb3J3YXJkIHVzYWdlIGlzIHRvIHByb3ZpZGUgYSBzdHJpbmcgb3IgRE9NXG4gICAqICAgICAgICBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBFeHRyYSBvcHRpb25zIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtNb2RhbERpYWxvZ31cbiAgICogICAgICAgICB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfSB0aGF0IHdhcyBjcmVhdGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVNb2RhbCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGFsKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY29udGVudCA9IGNvbnRlbnQgfHwgJyc7XG5cbiAgICB2YXIgbW9kYWwgPSBuZXcgTW9kYWxEaWFsb2codGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmFkZENoaWxkKG1vZGFsKTtcbiAgICBtb2RhbC5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzOC5yZW1vdmVDaGlsZChtb2RhbCk7XG4gICAgfSk7XG5cbiAgICBtb2RhbC5vcGVuKCk7XG4gICAgcmV0dXJuIG1vZGFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRhZyBzZXR0aW5nc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICAgKiAgICAgICAgVGhlIHBsYXllciB0YWdcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3NcbiAgICogICAgICAgICBmb3IgYSBwbGF5ZXIgdGFnXG4gICAqL1xuXG5cbiAgUGxheWVyLmdldFRhZ1NldHRpbmdzID0gZnVuY3Rpb24gZ2V0VGFnU2V0dGluZ3ModGFnKSB7XG4gICAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgICAgc291cmNlczogW10sXG4gICAgICB0cmFja3M6IFtdXG4gICAgfTtcblxuICAgIHZhciB0YWdPcHRpb25zID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuICAgIHZhciBkYXRhU2V0dXAgPSB0YWdPcHRpb25zWydkYXRhLXNldHVwJ107XG5cbiAgICBpZiAoaGFzQ2xhc3ModGFnLCAndmpzLWZsdWlkJykpIHtcbiAgICAgIHRhZ09wdGlvbnMuZmx1aWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGRhdGEtc2V0dXAgYXR0ciBleGlzdHMuXG4gICAgaWYgKGRhdGFTZXR1cCAhPT0gbnVsbCkge1xuICAgICAgLy8gUGFyc2Ugb3B0aW9ucyBKU09OXG4gICAgICAvLyBJZiBlbXB0eSBzdHJpbmcsIG1ha2UgaXQgYSBwYXJzYWJsZSBqc29uIG9iamVjdC5cbiAgICAgIHZhciBfc2FmZVBhcnNlVHVwbGUgPSBzYWZlUGFyc2VUdXBsZShkYXRhU2V0dXAgfHwgJ3t9JyksXG4gICAgICAgICAgZXJyID0gX3NhZmVQYXJzZVR1cGxlWzBdLFxuICAgICAgICAgIGRhdGEgPSBfc2FmZVBhcnNlVHVwbGVbMV07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nJDEuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbih0YWdPcHRpb25zLCBkYXRhKTtcbiAgICB9XG5cbiAgICBhc3NpZ24oYmFzZU9wdGlvbnMsIHRhZ09wdGlvbnMpO1xuXG4gICAgLy8gR2V0IHRhZyBjaGlsZHJlbiBzZXR0aW5nc1xuICAgIGlmICh0YWcuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0YWcuY2hpbGROb2RlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIC8vIENoYW5nZSBjYXNlIG5lZWRlZDogaHR0cDovL2Vqb2huLm9yZy9ibG9nL25vZGVuYW1lLWNhc2Utc2Vuc2l0aXZpdHkvXG4gICAgICAgIHZhciBjaGlsZE5hbWUgPSBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgYmFzZU9wdGlvbnMuc291cmNlcy5wdXNoKGdldEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy50cmFja3MucHVzaChnZXRBdHRyaWJ1dGVzKGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZU9wdGlvbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3ZXRoZXIgb3Igbm90IGZsZXhib3ggaXMgc3VwcG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGZsZXhib3ggaXMgc3VwcG9ydGVkXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBmbGV4Ym94IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZsZXhOb3RTdXBwb3J0ZWRfID0gZnVuY3Rpb24gZmxleE5vdFN1cHBvcnRlZF8oKSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBhY3R1YWxseSB1c2UgZmxleEJhc2lzIChvciBmbGV4T3JkZXIpLCBidXQgaXQncyBvbmUgb2YgdGhlIG1vcmVcbiAgICAvLyBjb21tb24gZmxleCBmZWF0dXJlcyB0aGF0IHdlIGNhbiByZWx5IG9uIHdoZW4gY2hlY2tpbmcgZm9yIGZsZXggc3VwcG9ydC5cbiAgICByZXR1cm4gISgnZmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICd3ZWJraXRGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21vekZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnbXNGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHxcbiAgICAvLyBJRTEwLXNwZWNpZmljICgyMDEyIGZsZXggc3BlYylcbiAgICAnbXNGbGV4T3JkZXInIGluIGVsZW0uc3R5bGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5ZXI7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3RcbiAqXG4gKiBAcmV0dXJuIHtWaWRlb1RyYWNrTGlzdH1cbiAqICAgICAgICAgdGhlIGN1cnJlbnQgdmlkZW8gdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS52aWRlb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja2xpc3RcbiAqXG4gKiBAcmV0dXJuIHtBdWRpb1RyYWNrTGlzdH1cbiAqICAgICAgICAgdGhlIGN1cnJlbnQgYXVkaW8gdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5hdWRpb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAbGluayBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtdGV4dHRyYWNrc1xuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHRleHQgdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS50ZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxuICogICAgICAgICBUaGUgY3VycmVudCByZW1vdGUgdGV4dCB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH0gdHJhY2tzLlxuICpcbiAqIEByZXR1cm4ge0h0bWxUcmFja0VsZW1lbnRMaXN0fVxuICogICAgICAgICBUaGUgY3VycmVudCByZW1vdGUgdGV4dCB0cmFjayBlbGVtZW50IGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrRWxzXG4gKi9cblxuQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgdmFyIHByb3BzID0gQUxMW25hbWUkJDFdO1xuXG4gIFBsYXllci5wcm90b3R5cGVbcHJvcHMuZ2V0dGVyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfW3Byb3BzLmdldHRlck5hbWVdKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRUZWNoXywgd2UgY3JlYXRlIHt2aWRlbyxhdWRpbyx0ZXh0fVRyYWNrc19cbiAgICAvLyB0aGVzZSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGVjaCBkdXJpbmcgbG9hZGluZ1xuICAgIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gfHwgbmV3IHByb3BzLkxpc3RDbGFzcygpO1xuICAgIHJldHVybiB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEdsb2JhbCBwbGF5ZXIgbGlzdFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblBsYXllci5wbGF5ZXJzID0ge307XG5cbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuXG4vKlxuICogUGxheWVyIGluc3RhbmNlIG9wdGlvbnMsIHN1cmZhY2VkIHVzaW5nIG9wdGlvbnNcbiAqIG9wdGlvbnMgPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfXG4gKiBNYWtlIGNoYW5nZXMgaW4gb3B0aW9ucywgbm90IGhlcmUuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblBsYXllci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIC8vIERlZmF1bHQgb3JkZXIgb2YgZmFsbGJhY2sgdGVjaG5vbG9neVxuICB0ZWNoT3JkZXI6IFRlY2guZGVmYXVsdFRlY2hPcmRlcl8sXG5cbiAgaHRtbDU6IHt9LFxuICBmbGFzaDoge30sXG5cbiAgLy8gZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXRcbiAgaW5hY3Rpdml0eVRpbWVvdXQ6IDIwMDAsXG5cbiAgLy8gZGVmYXVsdCBwbGF5YmFjayByYXRlc1xuICBwbGF5YmFja1JhdGVzOiBbXSxcbiAgLy8gQWRkIHBsYXliYWNrIHJhdGUgc2VsZWN0aW9uIGJ5IGFkZGluZyByYXRlc1xuICAvLyAncGxheWJhY2tSYXRlcyc6IFswLjUsIDEsIDEuNSwgMl0sXG5cbiAgLy8gSW5jbHVkZWQgY29udHJvbCBzZXRzXG4gIGNoaWxkcmVuOiBbJ21lZGlhTG9hZGVyJywgJ3Bvc3RlckltYWdlJywgJ3RleHRUcmFja0Rpc3BsYXknLCAnbG9hZGluZ1NwaW5uZXInLCAnYmlnUGxheUJ1dHRvbicsICdjb250cm9sQmFyJywgJ2Vycm9yRGlzcGxheScsICd0ZXh0VHJhY2tTZXR0aW5ncyddLFxuXG4gIGxhbmd1YWdlOiBuYXZpZ2F0b3IgJiYgKG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8IG5hdmlnYXRvci5sYW5ndWFnZSkgfHwgJ2VuJyxcblxuICAvLyBsb2NhbGVzIGFuZCB0aGVpciBsYW5ndWFnZSB0cmFuc2xhdGlvbnNcbiAgbGFuZ3VhZ2VzOiB7fSxcblxuICAvLyBEZWZhdWx0IG1lc3NhZ2UgdG8gc2hvdyB3aGVuIGEgdmlkZW8gY2Fubm90IGJlIHBsYXllZC5cbiAgbm90U3VwcG9ydGVkTWVzc2FnZTogJ05vIGNvbXBhdGlibGUgc291cmNlIHdhcyBmb3VuZCBmb3IgdGhpcyBtZWRpYS4nXG59O1xuXG5bXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJlbmRlZFwiIHN0YXRlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgZW5kZWQgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgUGxheWVyI2VuZGVkXG4gKi9cbidlbmRlZCcsXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBsYXllciBpcyBpbiB0aGUgXCJzZWVraW5nXCIgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBzZWVraW5nIHN0YXRlLCBmYWxzZSBpZiBub3QuXG4gKiBAbWV0aG9kIFBsYXllciNzZWVraW5nXG4gKi9cbidzZWVraW5nJyxcbi8qKlxuICogUmV0dXJucyB0aGUgVGltZVJhbmdlcyBvZiB0aGUgbWVkaWEgdGhhdCBhcmUgY3VycmVudGx5IGF2YWlsYWJsZVxuICogZm9yIHNlZWtpbmcgdG8uXG4gKlxuICogQHJldHVybiB7VGltZVJhbmdlc30gdGhlIHNlZWthYmxlIGludGVydmFscyBvZiB0aGUgbWVkaWEgdGltZWxpbmVcbiAqIEBtZXRob2QgUGxheWVyI3NlZWthYmxlXG4gKi9cbidzZWVrYWJsZScsXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgbmV0d29yayBhY3Rpdml0eSBmb3IgdGhlIGVsZW1lbnQsIGZyb21cbiAqIHRoZSBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAqIC0gTkVUV09SS19FTVBUWSAobnVtZXJpYyB2YWx1ZSAwKVxuICogICBUaGUgZWxlbWVudCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpc2VkLiBBbGwgYXR0cmlidXRlcyBhcmUgaW5cbiAqICAgdGhlaXIgaW5pdGlhbCBzdGF0ZXMuXG4gKiAtIE5FVFdPUktfSURMRSAobnVtZXJpYyB2YWx1ZSAxKVxuICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlIGFuZCBoYXNcbiAqICAgc2VsZWN0ZWQgYSByZXNvdXJjZSwgYnV0IGl0IGlzIG5vdCBhY3R1YWxseSB1c2luZyB0aGUgbmV0d29yayBhdFxuICogICB0aGlzIHRpbWUuXG4gKiAtIE5FVFdPUktfTE9BRElORyAobnVtZXJpYyB2YWx1ZSAyKVxuICogICBUaGUgdXNlciBhZ2VudCBpcyBhY3RpdmVseSB0cnlpbmcgdG8gZG93bmxvYWQgZGF0YS5cbiAqIC0gTkVUV09SS19OT19TT1VSQ0UgKG51bWVyaWMgdmFsdWUgMylcbiAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSwgYnV0IGl0IGhhc1xuICogICBub3QgeWV0IGZvdW5kIGEgcmVzb3VyY2UgdG8gdXNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI25ldHdvcmstc3RhdGVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IG5ldHdvcmsgYWN0aXZpdHkgc3RhdGVcbiAqIEBtZXRob2QgUGxheWVyI25ldHdvcmtTdGF0ZVxuICovXG4nbmV0d29ya1N0YXRlJyxcbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIHRoYXQgZXhwcmVzc2VzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50XG4gKiB3aXRoIHJlc3BlY3QgdG8gcmVuZGVyaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLCBmcm9tIHRoZVxuICogY29kZXMgaW4gdGhlIGxpc3QgYmVsb3cuXG4gKiAtIEhBVkVfTk9USElORyAobnVtZXJpYyB2YWx1ZSAwKVxuICogICBObyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgdGhlIG1lZGlhIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9NRVRBREFUQSAobnVtZXJpYyB2YWx1ZSAxKVxuICogICBFbm91Z2ggb2YgdGhlIHJlc291cmNlIGhhcyBiZWVuIG9idGFpbmVkIHRoYXQgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICogICByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gKiAtIEhBVkVfQ1VSUkVOVF9EQVRBIChudW1lcmljIHZhbHVlIDIpXG4gKiAgIERhdGEgZm9yIHRoZSBpbW1lZGlhdGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBpcyBhdmFpbGFibGUuXG4gKiAtIEhBVkVfRlVUVVJFX0RBVEEgKG51bWVyaWMgdmFsdWUgMylcbiAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYXNcbiAqICAgd2VsbCBhcyBlbm91Z2ggZGF0YSBmb3IgdGhlIHVzZXIgYWdlbnQgdG8gYWR2YW5jZSB0aGUgY3VycmVudFxuICogICBwbGF5YmFjayBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIG9mIHBsYXliYWNrLlxuICogLSBIQVZFX0VOT1VHSF9EQVRBIChudW1lcmljIHZhbHVlIDQpXG4gKiAgIFRoZSB1c2VyIGFnZW50IGVzdGltYXRlcyB0aGF0IGVub3VnaCBkYXRhIGlzIGF2YWlsYWJsZSBmb3JcbiAqICAgcGxheWJhY2sgdG8gcHJvY2VlZCB1bmludGVycnVwdGVkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1yZWFkeXN0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IHBsYXliYWNrIHJlbmRlcmluZyBzdGF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjcmVhZHlTdGF0ZVxuICovXG4ncmVhZHlTdGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gIFBsYXllci5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKGZuKTtcbiAgfTtcbn0pO1xuXG5URUNIX0VWRU5UU19SRVRSSUdHRVIuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgUGxheWVyLnByb3RvdHlwZVsnaGFuZGxlVGVjaCcgKyB0b1RpdGxlQ2FzZShldmVudCkgKyAnXyddID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXIoZXZlbnQpO1xuICB9O1xufSk7XG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBpbml0aWFsIGR1cmF0aW9uIGFuZCBkaW1lbnNpb24gaW5mb3JtYXRpb25cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGRvd25sb2FkZWQgZGF0YSBhdCB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvblxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZCAqXG4gKiBEdXJpbmcgcGxheWJhY2sgdGhpcyBpcyBmaXJlZCBldmVyeSAxNS0yNTAgbWlsbGlzZWNvbmRzLCBkZXBlbmRpbmcgb24gdGhlXG4gKiBwbGF5YmFjayB0ZWNobm9sb2d5IGluIHVzZS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHZvbHVtZSBjaGFuZ2VzXG4gKlxuICogQGV2ZW50IFBsYXllciN2b2x1bWVjaGFuZ2VcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbGF5ZXIgaGFzIGEgcGx1Z2luIGF2YWlsYWJsZS5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IHJlcG9ydCB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBldmVyIGJlZW4gaW5pdGlhbGl6ZWRcbiAqIG9uIHRoaXMgcGxheWVyLiBGb3IgdGhhdCwgW3VzaW5nUGx1Z2luXXtAbGluayBQbGF5ZXIjdXNpbmdQbHVnaW59LlxuICpcbiAqIEBtZXRob2QgUGxheWVyI2hhc1BsdWdpblxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGlzIHBsYXllciBoYXMgdGhlIHJlcXVlc3RlZCBwbHVnaW4gYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBpcyB1c2luZyBhIHBsdWdpbiBieSBuYW1lLlxuICpcbiAqIEZvciBiYXNpYyBwbHVnaW5zLCB0aGlzIG9ubHkgcmVwb3J0cyB3aGV0aGVyIHRoZSBwbHVnaW4gaGFzIF9ldmVyXyBiZWVuXG4gKiBpbml0aWFsaXplZCBvbiB0aGlzIHBsYXllci5cbiAqXG4gKiBAbWV0aG9kIFBsYXllciN1c2luZ1BsdWdpblxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoaXMgcGxheWVyIGlzIHVzaW5nIHRoZSByZXF1ZXN0ZWQgcGx1Z2luLlxuICovXG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWVyJywgUGxheWVyKTtcblxuLyoqXG4gKiBAZmlsZSBwbHVnaW4uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBwbHVnaW4gbmFtZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgQkFTRV9QTFVHSU5fTkFNRSA9ICdwbHVnaW4nO1xuXG4vKipcbiAqIFRoZSBrZXkgb24gd2hpY2ggYSBwbGF5ZXIncyBhY3RpdmUgcGx1Z2lucyBjYWNoZSBpcyBzdG9yZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUgICAgIHtzdHJpbmd9XG4gKi9cbnZhciBQTFVHSU5fQ0FDSEVfS0VZID0gJ2FjdGl2ZVBsdWdpbnNfJztcblxuLyoqXG4gKiBTdG9yZXMgcmVnaXN0ZXJlZCBwbHVnaW5zIGluIGEgcHJpdmF0ZSBzcGFjZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUgICAge09iamVjdH1cbiAqL1xudmFyIHBsdWdpblN0b3JhZ2UgPSB7fTtcblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICovXG52YXIgcGx1Z2luRXhpc3RzID0gZnVuY3Rpb24gcGx1Z2luRXhpc3RzKG5hbWUpIHtcbiAgcmV0dXJuIHBsdWdpblN0b3JhZ2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG59O1xuXG4vKipcbiAqIEdldCBhIHNpbmdsZSByZWdpc3RlcmVkIHBsdWdpbiBieSBuYW1lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICogICAgICAgICAgVGhlIHBsdWdpbiAob3IgdW5kZWZpbmVkKS5cbiAqL1xudmFyIGdldFBsdWdpbiA9IGZ1bmN0aW9uIGdldFBsdWdpbihuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5FeGlzdHMobmFtZSkgPyBwbHVnaW5TdG9yYWdlW25hbWVdIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBNYXJrcyBhIHBsdWdpbiBhcyBcImFjdGl2ZVwiIG9uIGEgcGxheWVyLlxuICpcbiAqIEFsc28sIGVuc3VyZXMgdGhhdCB0aGUgcGxheWVyIGhhcyBhbiBvYmplY3QgZm9yIHRyYWNraW5nIGFjdGl2ZSBwbHVnaW5zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICovXG52YXIgbWFya1BsdWdpbkFzQWN0aXZlID0gZnVuY3Rpb24gbWFya1BsdWdpbkFzQWN0aXZlKHBsYXllciwgbmFtZSkge1xuICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV0gPSBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV0gfHwge307XG4gIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFRyaWdnZXJzIGEgcGFpciBvZiBwbHVnaW4gc2V0dXAgZXZlbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofSBoYXNoXG4gKiAgICAgICAgIEEgcGx1Z2luIGV2ZW50IGhhc2guXG4gKlxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2JlZm9yZV1cbiAqICAgICAgICAgSWYgdHJ1ZSwgcHJlZml4ZXMgdGhlIGV2ZW50IG5hbWUgd2l0aCBcImJlZm9yZVwiLiBJbiBvdGhlciB3b3JkcyxcbiAqICAgICAgICAgdXNlIHRoaXMgdG8gdHJpZ2dlciBcImJlZm9yZXBsdWdpbnNldHVwXCIgaW5zdGVhZCBvZiBcInBsdWdpbnNldHVwXCIuXG4gKi9cbnZhciB0cmlnZ2VyU2V0dXBFdmVudCA9IGZ1bmN0aW9uIHRyaWdnZXJTZXR1cEV2ZW50KHBsYXllciwgaGFzaCwgYmVmb3JlKSB7XG4gIHZhciBldmVudE5hbWUgPSAoYmVmb3JlID8gJ2JlZm9yZScgOiAnJykgKyAncGx1Z2luc2V0dXAnO1xuXG4gIHBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgaGFzaCk7XG4gIHBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSArICc6JyArIGhhc2gubmFtZSwgaGFzaCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgYmFzaWMgcGx1Z2luIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBtYXJrc1xuICogb24gdGhlIHBsYXllciB0aGF0IHRoZSBwbHVnaW4gaGFzIGJlZW4gYWN0aXZhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luXG4gKiAgICAgICAgICBUaGUgYmFzaWMgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqICAgICAgICAgIEEgd3JhcHBlciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIHBsdWdpbi5cbiAqL1xudmFyIGNyZWF0ZUJhc2ljUGx1Z2luID0gZnVuY3Rpb24gY3JlYXRlQmFzaWNQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIHZhciBiYXNpY1BsdWdpbldyYXBwZXIgPSBmdW5jdGlvbiBiYXNpY1BsdWdpbldyYXBwZXIoKSB7XG5cbiAgICAvLyBXZSB0cmlnZ2VyIHRoZSBcImJlZm9yZXBsdWdpbnNldHVwXCIgYW5kIFwicGx1Z2luc2V0dXBcIiBldmVudHMgb24gdGhlIHBsYXllclxuICAgIC8vIHJlZ2FyZGxlc3MsIGJ1dCB3ZSB3YW50IHRoZSBoYXNoIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGUgaGFzaCBwcm92aWRlZFxuICAgIC8vIGZvciBhZHZhbmNlZCBwbHVnaW5zLlxuICAgIC8vXG4gICAgLy8gVGhlIG9ubHkgcG90ZW50aWFsbHkgY291bnRlci1pbnR1aXRpdmUgdGhpbmcgaGVyZSBpcyB0aGUgYGluc3RhbmNlYCBpblxuICAgIC8vIHRoZSBcInBsdWdpbnNldHVwXCIgZXZlbnQgaXMgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBgcGx1Z2luYCBmdW5jdGlvbi5cbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogcGx1Z2luLCBpbnN0YW5jZTogbnVsbCB9LCB0cnVlKTtcblxuICAgIHZhciBpbnN0YW5jZSA9IHBsdWdpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgbWFya1BsdWdpbkFzQWN0aXZlKHRoaXMsIG5hbWUpO1xuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBpbnN0YW5jZSB9KTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBPYmplY3Qua2V5cyhwbHVnaW4pLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBiYXNpY1BsdWdpbldyYXBwZXJbcHJvcF0gPSBwbHVnaW5bcHJvcF07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNpY1BsdWdpbldyYXBwZXI7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgcGx1Z2luIHN1Yi1jbGFzcyBhbmQgcmV0dXJucyBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmdcbiAqIGluc3RhbmNlcyBvZiBpdC5cbiAqXG4gKiBUaGlzIGZhY3RvcnkgZnVuY3Rpb24gd2lsbCByZXBsYWNlIGl0c2VsZiB3aXRoIGFuIGluc3RhbmNlIG9mIHRoZSByZXF1ZXN0ZWRcbiAqIHN1Yi1jbGFzcyBvZiBQbHVnaW4uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQHBhcmFtICAge1BsdWdpbn0gUGx1Z2luU3ViQ2xhc3NcbiAqICAgICAgICAgIFRoZSBhZHZhbmNlZCBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG52YXIgY3JlYXRlUGx1Z2luRmFjdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgUGx1Z2luU3ViQ2xhc3MpIHtcblxuICAvLyBBZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gdGhlIHBsdWdpbiBwcm90b3R5cGUgc28gdGhhdCBlYWNoIHBsdWdpbiBjYW5cbiAgLy8gcmVmZXIgdG8gaXRzZWxmIGJ5IG5hbWUuXG4gIFBsdWdpblN1YkNsYXNzLnByb3RvdHlwZS5uYW1lID0gbmFtZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBQbHVnaW5TdWJDbGFzcywgaW5zdGFuY2U6IG51bGwgfSwgdHJ1ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KFBsdWdpblN1YkNsYXNzLCBbbnVsbF0uY29uY2F0KFt0aGlzXS5jb25jYXQoYXJncykpKSkoKTtcblxuICAgIC8vIFRoZSBwbHVnaW4gaXMgcmVwbGFjZWQgYnkgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgaW5zdGFuY2UuZ2V0RXZlbnRIYXNoKCkpO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufTtcblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGFsbCBhZHZhbmNlZCBwbHVnaW5zLlxuICpcbiAqIEBtaXhlcyAgIG1vZHVsZTpldmVudGVkfkV2ZW50ZWRNaXhpblxuICogQG1peGVzICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW5cbiAqIEBmaXJlcyAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cFxuICogQGZpcmVzICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwOiRuYW1lXG4gKiBAZmlyZXMgICBQbGF5ZXIjcGx1Z2luc2V0dXBcbiAqIEBmaXJlcyAgIFBsYXllciNwbHVnaW5zZXR1cDokbmFtZVxuICogQGxpc3RlbnMgUGxheWVyI2Rpc3Bvc2VcbiAqIEB0aHJvd3MgIHtFcnJvcn1cbiAqICAgICAgICAgIElmIGF0dGVtcHRpbmcgdG8gaW5zdGFudGlhdGUgdGhlIGJhc2Uge0BsaW5rIFBsdWdpbn0gY2xhc3NcbiAqICAgICAgICAgIGRpcmVjdGx5IGluc3RlYWQgb2YgdmlhIGEgc3ViLWNsYXNzLlxuICovXG5cbnZhciBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogU3ViLWNsYXNzZXMgc2hvdWxkIGNhbGwgYHN1cGVyYCB0byBlbnN1cmUgcGx1Z2lucyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gUGx1Z2luKHBsYXllcikge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsdWdpbik7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gUGx1Z2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbiBtdXN0IGJlIHN1Yi1jbGFzc2VkOyBub3QgZGlyZWN0bHkgaW5zdGFudGlhdGVkLicpO1xuICAgIH1cblxuICAgIHRoaXMucGxheWVyID0gcGxheWVyO1xuXG4gICAgLy8gTWFrZSB0aGlzIG9iamVjdCBldmVudGVkLCBidXQgcmVtb3ZlIHRoZSBhZGRlZCBgdHJpZ2dlcmAgbWV0aG9kIHNvIHdlXG4gICAgLy8gdXNlIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBpbnN0ZWFkLlxuICAgIGV2ZW50ZWQodGhpcyk7XG4gICAgZGVsZXRlIHRoaXMudHJpZ2dlcjtcblxuICAgIHN0YXRlZnVsKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFN0YXRlKTtcbiAgICBtYXJrUGx1Z2luQXNBY3RpdmUocGxheWVyLCB0aGlzLm5hbWUpO1xuXG4gICAgLy8gQXV0by1iaW5kIHRoZSBkaXNwb3NlIG1ldGhvZCBzbyB3ZSBjYW4gdXNlIGl0IGFzIGEgbGlzdGVuZXIgYW5kIHVuYmluZFxuICAgIC8vIGl0IGxhdGVyIGVhc2lseS5cbiAgICB0aGlzLmRpc3Bvc2UgPSBiaW5kKHRoaXMsIHRoaXMuZGlzcG9zZSk7XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyIGlzIGRpc3Bvc2VkLCBkaXNwb3NlIHRoZSBwbHVnaW4uXG4gICAgcGxheWVyLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZlcnNpb24gb2YgdGhlIHBsdWdpbiB0aGF0IHdhcyBzZXQgb24gPHBsdWdpbk5hbWU+LlZFUlNJT05cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLnZlcnNpb24gPSBmdW5jdGlvbiB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLlZFUlNJT047XG4gIH07XG5cbiAgLyoqXG4gICAqIEVhY2ggZXZlbnQgdHJpZ2dlcmVkIGJ5IHBsdWdpbnMgaW5jbHVkZXMgYSBoYXNoIG9mIGFkZGl0aW9uYWwgZGF0YSB3aXRoXG4gICAqIGNvbnZlbnRpb25hbCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgdGhhdCBvYmplY3Qgb3IgbXV0YXRlcyBhbiBleGlzdGluZyBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaD17fV1cbiAgICogICAgICAgICAgQW4gb2JqZWN0IHRvIGJlIHVzZWQgYXMgZXZlbnQgYW4gZXZlbnQgaGFzaC5cbiAgICpcbiAgICogQHJldHVybnMge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gICAqICAgICAgICAgIEFuIGV2ZW50IGhhc2ggb2JqZWN0IHdpdGggcHJvdmlkZWQgcHJvcGVydGllcyBtaXhlZC1pbi5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmdldEV2ZW50SGFzaCA9IGZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBoYXNoLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgaGFzaC5wbHVnaW4gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGhhc2guaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiBldmVudCBvbiB0aGUgcGx1Z2luIG9iamVjdCBhbmQgb3ZlcnJpZGVzXG4gICAqIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW4udHJpZ2dlcnxFdmVudGVkTWl4aW4udHJpZ2dlcn0uXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgICBBbiBldmVudCB0eXBlIG9yIGFuIG9iamVjdCB3aXRoIGEgdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFkZGl0aW9uYWwgZGF0YSBoYXNoIHRvIG1lcmdlIHdpdGggYVxuICAgKiAgICAgICAgICB7QGxpbmsgUGx1Z2luflBsdWdpbkV2ZW50SGFzaHxQbHVnaW5FdmVudEhhc2h9LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgZGVmYXVsdCB3YXMgcHJldmVudGVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIkJDEoZXZlbnQpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICByZXR1cm4gdHJpZ2dlcih0aGlzLmV2ZW50QnVzRWxfLCBldmVudCwgdGhpcy5nZXRFdmVudEhhc2goaGFzaCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnRzIG9uIHRoZSBwbHVnaW4uIE5vLW9wIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGJ5XG4gICAqIHN1YmNsYXNzaW5nLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtICAgIHtFdmVudH0gZVxuICAgKiAgICAgICAgICAgQW4gZXZlbnQgb2JqZWN0IHByb3ZpZGVkIGJ5IGEgXCJzdGF0ZWNoYW5nZWRcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICAgIHtPYmplY3R9IGUuY2hhbmdlc1xuICAgKiAgICAgICAgICAgQW4gb2JqZWN0IGRlc2NyaWJpbmcgY2hhbmdlcyB0aGF0IG9jY3VycmVkIHdpdGggdGhlIFwic3RhdGVjaGFuZ2VkXCJcbiAgICogICAgICAgICAgIGV2ZW50LlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuaGFuZGxlU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gaGFuZGxlU3RhdGVDaGFuZ2VkKGUpIHt9O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyBhIHBsdWdpbi5cbiAgICpcbiAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBpZiB0aGV5IHdhbnQsIGJ1dCBmb3IgdGhlIHNha2Ugb2Ygc2FmZXR5LFxuICAgKiBpdCdzIHByb2JhYmx5IGJlc3QgdG8gc3Vic2NyaWJlIHRoZSBcImRpc3Bvc2VcIiBldmVudC5cbiAgICpcbiAgICogQGZpcmVzIFBsdWdpbiNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoYXQgYSBhZHZhbmNlZCBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2Rpc3Bvc2VcbiAgICAgKiBAdHlwZSAge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkaXNwb3NlJyk7XG4gICAgdGhpcy5vZmYoKTtcbiAgICBwbGF5ZXIub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIEVsaW1pbmF0ZSBhbnkgcG9zc2libGUgc291cmNlcyBvZiBsZWFraW5nIG1lbW9yeSBieSBjbGVhcmluZyB1cFxuICAgIC8vIHJlZmVyZW5jZXMgYmV0d2VlbiB0aGUgcGxheWVyIGFuZCB0aGUgcGx1Z2luIGluc3RhbmNlIGFuZCBudWxsaW5nIG91dFxuICAgIC8vIHRoZSBwbHVnaW4ncyBzdGF0ZSBhbmQgcmVwbGFjaW5nIG1ldGhvZHMgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGhyb3dzLlxuICAgIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9IGZhbHNlO1xuICAgIHRoaXMucGxheWVyID0gdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBGaW5hbGx5LCByZXBsYWNlIHRoZSBwbHVnaW4gbmFtZSBvbiB0aGUgcGxheWVyIHdpdGggYSBuZXcgZmFjdG9yeVxuICAgIC8vIGZ1bmN0aW9uLCBzbyB0aGF0IHRoZSBwbHVnaW4gaXMgcmVhZHkgdG8gYmUgc2V0IHVwIGFnYWluLlxuICAgIHBsYXllcltuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luU3RvcmFnZVtuYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4gKGkuZS4gbm90IGEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gKS5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIElmIGEgc3RyaW5nLCBtYXRjaGVzIHRoZSBuYW1lIG9mIGEgcGx1Z2luLiBJZiBhIGZ1bmN0aW9uLCB3aWxsIGJlXG4gICAqICAgICAgICAgIHRlc3RlZCBkaXJlY3RseS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5pc0Jhc2ljID0gZnVuY3Rpb24gaXNCYXNpYyhwbHVnaW4pIHtcbiAgICB2YXIgcCA9IHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gZ2V0UGx1Z2luKHBsdWdpbikgOiBwbHVnaW47XG5cbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbicgJiYgIVBsdWdpbi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihwLnByb3RvdHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAgICogICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICAgKiAgICAgICAgICBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIEEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gIG9yIGEgZnVuY3Rpb24gZm9yIGJhc2ljIHBsdWdpbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICogICAgICAgICAgRm9yIGFkdmFuY2VkIHBsdWdpbnMsIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhhdCBwbHVnaW4uIEZvclxuICAgKiAgICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwbHVnaW4gbmFtZSwgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIHN0cmluZywgd2FzICcgKyAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSArICcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgbG9nJDEud2FybignQSBwbHVnaW4gbmFtZWQgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSB3YW50IHRvIGF2b2lkIHJlLXJlZ2lzdGVyaW5nIHBsdWdpbnMhJyk7XG4gICAgfSBlbHNlIGlmIChQbGF5ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIGNhbm5vdCBzaGFyZSBhIG5hbWUgd2l0aCBhbiBleGlzdGluZyBwbGF5ZXIgbWV0aG9kIScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIGZvciBcIicgKyBuYW1lICsgJ1wiLCBtdXN0IGJlIGEgZnVuY3Rpb24sIHdhcyAnICsgKHR5cGVvZiBwbHVnaW4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBsdWdpbikpICsgJy4nKTtcbiAgICB9XG5cbiAgICBwbHVnaW5TdG9yYWdlW25hbWVdID0gcGx1Z2luO1xuXG4gICAgLy8gQWRkIGEgcGxheWVyIHByb3RvdHlwZSBtZXRob2QgZm9yIGFsbCBzdWItY2xhc3NlZCBwbHVnaW5zIChidXQgbm90IGZvclxuICAgIC8vIHRoZSBiYXNlIFBsdWdpbiBjbGFzcykuXG4gICAgaWYgKG5hbWUgIT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIGlmIChQbHVnaW4uaXNCYXNpYyhwbHVnaW4pKSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gZGVyZWdpc3RlclBsdWdpbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlLXJlZ2lzdGVyIGJhc2UgcGx1Z2luLicpO1xuICAgIH1cbiAgICBpZiAocGx1Z2luRXhpc3RzKG5hbWUpKSB7XG4gICAgICBkZWxldGUgcGx1Z2luU3RvcmFnZVtuYW1lXTtcbiAgICAgIGRlbGV0ZSBQbGF5ZXIucHJvdG90eXBlW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gICB7QXJyYXl9IFtuYW1lc11cbiAgICogICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gICAqICAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICAgKiAgICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAgICovXG5cblxuICBQbHVnaW4uZ2V0UGx1Z2lucyA9IGZ1bmN0aW9uIGdldFBsdWdpbnMoKSB7XG4gICAgdmFyIG5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3Qua2V5cyhwbHVnaW5TdG9yYWdlKTtcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gcGx1Z2luO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiAgICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpblZlcnNpb24gPSBmdW5jdGlvbiBnZXRQbHVnaW5WZXJzaW9uKG5hbWUpIHtcbiAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgcmV0dXJuIHBsdWdpbiAmJiBwbHVnaW4uVkVSU0lPTiB8fCAnJztcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luO1xufSgpO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCAgIGdldFBsdWdpblxuICogQG1lbWJlck9mIFBsdWdpblxuICogQHBhcmFtICAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyAge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgICBUaGUgcGx1Z2luIChvciBgdW5kZWZpbmVkYCkuXG4gKi9cblxuXG5QbHVnaW4uZ2V0UGx1Z2luID0gZ2V0UGx1Z2luO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBiYXNlIHBsdWdpbiBjbGFzcyBhcyBpdCBpcyByZWdpc3RlcmVkLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblBsdWdpbi5CQVNFX1BMVUdJTl9OQU1FID0gQkFTRV9QTFVHSU5fTkFNRTtcblxuUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKEJBU0VfUExVR0lOX05BTUUsIFBsdWdpbik7XG5cbi8qKlxuICogRG9jdW1lbnRlZCBpbiBwbGF5ZXIuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cblBsYXllci5wcm90b3R5cGUudXNpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISF0aGlzW1BMVUdJTl9DQUNIRV9LRVldICYmIHRoaXNbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPT09IHRydWU7XG59O1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhc1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhIXBsdWdpbkV4aXN0cyhuYW1lKTtcbn07XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgc2V0IHVwIG9uIGEgcGxheWVyIC0gYnkgbmFtZS4gVGhlIG5hbWVcbiAqIGlzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGhhcyBqdXN0IGJlZW4gc2V0IHVwIG9uIGEgcGxheWVyLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXBcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBQbHVnaW5+UGx1Z2luRXZlbnRIYXNoXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGluc3RhbmNlXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yXG4gKiAgICAgICAgICAgYWR2YW5jZWQgcGx1Z2lucywgdGhlIHBsdWdpbiBpbnN0YW5jZSBvbiB3aGljaCB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbHVnaW5cbiAqICAgICAgICAgICBGb3IgYmFzaWMgcGx1Z2lucywgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yIGFkdmFuY2VkIHBsdWdpbnMsIHRoZVxuICogICAgICAgICAgIHBsdWdpbiBjbGFzcy9jb25zdHJ1Y3Rvci5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQG1vZHVsZSBleHRlbmRcbiAqL1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2Ygbm9kZSBpbmhlcml0cyBhbmQgYmFiZWwncyBpbmhlcml0cyAoYWZ0ZXIgdHJhbnNwaWxlKS5cbiAqIEJvdGggd29yayB0aGUgc2FtZSBidXQgbm9kZSBhZGRzIGBzdXBlcl9gIHRvIHRoZSBzdWJDbGFzc1xuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ViQ2xhc3NNZXRob2RzPXt9XVxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgbmV3IG9iamVjdCB3aXRoIHN1YkNsYXNzTWV0aG9kcyB0aGF0IGluaGVyaXRlZCBzdXBlckNsYXNzLlxuICovXG52YXIgZXh0ZW5kRm4gPSBmdW5jdGlvbiBleHRlbmRGbihzdXBlckNsYXNzKSB7XG4gIHZhciBzdWJDbGFzc01ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBzdWJDbGFzcyA9IGZ1bmN0aW9uIHN1YkNsYXNzKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICgodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViQ2xhc3NNZXRob2RzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIG1ldGhvZHMgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9XG5cbiAgX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YkNsYXNzO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby5qc1xuICogQG1vZHVsZSB2aWRlb2pzXG4gKi9cbi8vIEluY2x1ZGUgdGhlIGJ1aWx0LWluIHRlY2hzXG4vLyBIVE1MNSBFbGVtZW50IFNoaW0gZm9yIElFOFxuaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ID09PSAndW5kZWZpbmVkJyAmJiBpc1JlYWwoKSkge1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlby1qcycpO1xufVxuXG4vKipcbiAqIERvdWJsZXMgYXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIHVzZXJzIHRvIGNyZWF0ZSBhIHBsYXllciBpbnN0YW5jZSBhbmQgYWxzb1xuICogdGhlIG1haW4gbGlicmFyeSBvYmplY3QuXG4gKiBUaGUgYHZpZGVvanNgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgb3IgcmV0cmlldmUgYSBwbGF5ZXIuXG4gICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGlkXG4gKiAgICAgICAgVmlkZW8gZWxlbWVudCBvciB2aWRlbyBlbGVtZW50IElEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWcvc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gKiAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gKiAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZpZGVvanMoaWQsIG9wdGlvbnMsIHJlYWR5KSB7XG4gIHZhciB0YWcgPSB2b2lkIDA7XG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXG4gIC8vIFN0cmluZyBJRFxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwbGF5ZXJzID0gdmlkZW9qcy5nZXRQbGF5ZXJzKCk7XG5cbiAgICAvLyBBZGp1c3QgZm9yIGpRdWVyeSBJRCBzeW50YXhcbiAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIElmIGEgcGxheWVyIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhpcyBJRCByZXR1cm4gaXQuXG4gICAgaWYgKHBsYXllcnNbaWRdKSB7XG5cbiAgICAgIC8vIElmIG9wdGlvbnMgb3IgcmVhZHkgZnVuY3Rpb24gYXJlIHBhc3NlZCwgd2FyblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgbG9nJDEud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5KSB7XG4gICAgICAgIHBsYXllcnNbaWRdLnJlYWR5KHJlYWR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYXllcnNbaWRdO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnZXQgZWxlbWVudCBmb3IgSURcbiAgICB0YWcgPSAkKCcjJyArIGlkKTtcblxuICAgIC8vIElEIGlzIGEgbWVkaWEgZWxlbWVudFxuICB9IGVsc2Uge1xuICAgIHRhZyA9IGlkO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XG4gIC8vIHJlOiBub2RlTmFtZSwgY291bGQgYmUgYSBib3ggZGl2IGFsc29cbiAgaWYgKCF0YWcgfHwgIXRhZy5ub2RlTmFtZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7XG4gIH1cblxuICAvLyBFbGVtZW50IG1heSBoYXZlIGEgcGxheWVyIGF0dHIgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBwbGF5ZXIgaW5zdGFuY2UuXG4gIC8vIElmIHNvIHJldHVybiB0aGF0IG90aGVyd2lzZSBzZXQgdXAgYSBuZXcgcGxheWVyIGJlbG93XG4gIGlmICh0YWcucGxheWVyIHx8IFBsYXllci5wbGF5ZXJzW3RhZy5wbGF5ZXJJZF0pIHtcbiAgICByZXR1cm4gdGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgZWxlbWVudCBpcyBpbmNsdWRlZCBpbiB0aGUgRE9NXG4gIGlmIChpc0VsKHRhZykgJiYgIWRvY3VtZW50LmJvZHkuY29udGFpbnModGFnKSkge1xuICAgIGxvZyQxLndhcm4oJ1RoZSBlbGVtZW50IHN1cHBsaWVkIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgRE9NJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2aWRlb2pzLmhvb2tzKCdiZWZvcmVzZXR1cCcpLmZvckVhY2goZnVuY3Rpb24gKGhvb2tGdW5jdGlvbikge1xuICAgIHZhciBvcHRzID0gaG9va0Z1bmN0aW9uKHRhZywgbWVyZ2VPcHRpb25zKG9wdGlvbnMpKTtcblxuICAgIGlmICghaXNPYmplY3Qob3B0cykgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgbG9nJDEuZXJyb3IoJ3BsZWFzZSByZXR1cm4gYW4gb2JqZWN0IGluIGJlZm9yZXNldHVwIGhvb2tzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCBvcHRzKTtcbiAgfSk7XG5cbiAgdmFyIFBsYXllckNvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1BsYXllcicpO1xuICAvLyBJZiBub3QsIHNldCB1cCBhIG5ldyBwbGF5ZXJcbiAgdmFyIHBsYXllciA9IG5ldyBQbGF5ZXJDb21wb25lbnQodGFnLCBvcHRpb25zLCByZWFkeSk7XG5cbiAgdmlkZW9qcy5ob29rcygnc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gaG9va0Z1bmN0aW9uKHBsYXllcik7XG4gIH0pO1xuXG4gIHJldHVybiBwbGF5ZXI7XG59XG5cbi8qKlxuICogQW4gT2JqZWN0IHRoYXQgY29udGFpbnMgbGlmZWN5Y2xlIGhvb2tzIGFzIGtleXMgd2hpY2ggcG9pbnQgdG8gYW4gYXJyYXlcbiAqIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSBydW4gd2hlbiBhIGxpZmVjeWNsZSBpcyB0cmlnZ2VyZWRcbiAqL1xudmlkZW9qcy5ob29rc18gPSB7fTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGhvb2tzIGZvciBhIHNwZWNpZmljIGxpZmVjeWNsZVxuICogQGZ1bmN0aW9uIHZpZGVvanMuaG9va3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3lsZSB0byBnZXQgaG9va3MgZnJvbVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258RnVuY3Rpb25bXX0gW2ZuXVxuICogICAgICAgIE9wdGlvbmFsbHkgYWRkIGEgaG9vayAob3IgaG9va3MpIHRvIHRoZSBsaWZlY3ljbGUgdGhhdCB5b3VyIGFyZSBnZXR0aW5nLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBhbiBhcnJheSBvZiBob29rcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gKi9cbnZpZGVvanMuaG9va3MgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXSB8fCBbXTtcbiAgaWYgKGZuKSB7XG4gICAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5jb25jYXQoZm4pO1xuICB9XG4gIHJldHVybiB2aWRlb2pzLmhvb2tzX1t0eXBlXTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2aWRlb2pzLmhvb2tzKHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0aGF0IHdpbGwgb25seSBydW4gb25jZSB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9va09uY2UgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rcyh0eXBlLCBbXS5jb25jYXQoZm4pLm1hcChmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICB2aWRlb2pzLnJlbW92ZUhvb2sodHlwZSwgd3JhcHBlcik7XG4gICAgICBvcmlnaW5hbC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9KSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGhvb2sgZnJvbSBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0aGF0IHRoZSBmdW5jdGlvbiBob29rZWQgdG9cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgIFRoZSBob29rZWQgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2FzIHJlbW92ZWQgb3IgdW5kZWZcbiAqL1xudmlkZW9qcy5yZW1vdmVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZhciBpbmRleCA9IHZpZGVvanMuaG9va3ModHlwZSkuaW5kZXhPZihmbik7XG5cbiAgaWYgKGluZGV4IDw9IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5zbGljZSgpO1xuICB2aWRlb2pzLmhvb2tzX1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWRkIGRlZmF1bHQgc3R5bGVzXG5pZiAod2luZG93LlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSAhPT0gdHJ1ZSAmJiBpc1JlYWwoKSkge1xuICB2YXIgc3R5bGUgPSAkKCcudmpzLXN0eWxlcy1kZWZhdWx0cycpO1xuXG4gIGlmICghc3R5bGUpIHtcbiAgICBzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kZWZhdWx0cycpO1xuICAgIHZhciBoZWFkID0gJCgnaGVhZCcpO1xuXG4gICAgaWYgKGhlYWQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzZXRUZXh0Q29udGVudChzdHlsZSwgJ1xcbiAgICAgIC52aWRlby1qcyB7XFxuICAgICAgICB3aWR0aDogMzAwcHg7XFxuICAgICAgICBoZWlnaHQ6IDE1MHB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiA1Ni4yNSVcXG4gICAgICB9XFxuICAgICcpO1xuICB9XG59XG5cbi8vIFJ1biBBdXRvLWxvYWQgcGxheWVyc1xuLy8gWW91IGhhdmUgdG8gd2FpdCBhdCBsZWFzdCBvbmNlIGluIGNhc2UgdGhpcyBzY3JpcHQgaXMgbG9hZGVkIGFmdGVyIHlvdXJcbi8vIHZpZGVvIGluIHRoZSBET00gKHdlaXJkIGJlaGF2aW9yIG9ubHkgd2l0aCBtaW5pZmllZCB2ZXJzaW9uKVxuYXV0b1NldHVwVGltZW91dCgxLCB2aWRlb2pzKTtcblxuLyoqXG4gKiBDdXJyZW50IHNvZnR3YXJlIHZlcnNpb24uIEZvbGxvd3Mgc2VtdmVyLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZpZGVvanMuVkVSU0lPTiA9IHZlcnNpb247XG5cbi8qKlxuICogVGhlIGdsb2JhbCBvcHRpb25zIG9iamVjdC4gVGhlc2UgYXJlIHRoZSBzZXR0aW5ncyB0aGF0IHRha2UgZWZmZWN0XG4gKiBpZiBubyBvdmVycmlkZXMgYXJlIHNwZWNpZmllZCB3aGVuIHRoZSBwbGF5ZXIgaXMgY3JlYXRlZC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52aWRlb2pzLm9wdGlvbnMgPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2l0aCB0aGUgY3VycmVudGx5IGNyZWF0ZWQgcGxheWVycywga2V5ZWQgYnkgcGxheWVyIElEXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgY3JlYXRlZCBwbGF5ZXJzXG4gKi9cbnZpZGVvanMuZ2V0UGxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFBsYXllci5wbGF5ZXJzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgcGxheWVycyBvYmplY3QuXG4gKlxuICogQG1lbWJlck9mIHZpZGVvanNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbGF5ZXJzXG4gKi9cbnZpZGVvanMucGxheWVycyA9IFBsYXllci5wbGF5ZXJzO1xuXG4vKipcbiAqIEdldCBhIGNvbXBvbmVudCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIENvbXBvbmVudC5nZXRDb21wb25lbnQgYXMgdmlkZW9qcy5nZXRDb21wb25lbnRcbiAqL1xudmlkZW9qcy5nZXRDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IHNvIGl0IGNhbiByZWZlcnJlZCB0byBieSBuYW1lLiBVc2VkIHdoZW4gYWRkaW5nIHRvIG90aGVyXG4gKiBjb21wb25lbnRzLCBlaXRoZXIgdGhyb3VnaCBhZGRDaGlsZCBgY29tcG9uZW50LmFkZENoaWxkKCdteUNvbXBvbmVudCcpYCBvciB0aHJvdWdoXG4gKiBkZWZhdWx0IGNoaWxkcmVuIG9wdGlvbnMgIGB7IGNoaWxkcmVuOiBbJ215Q29tcG9uZW50J10gfWAuXG4gKlxuICogPiBOT1RFOiBZb3UgY291bGQgYWxzbyBqdXN0IGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWRkaW5nLlxuICogYGNvbXBvbmVudC5hZGRDaGlsZChuZXcgTXlDb21wb25lbnQoKSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgVGhlIGNsYXNzIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCBjbGFzc1xuICpcbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqICAgICAgICAgVGhlIG5ld2x5IHJlZ2lzdGVyZWQgY29tcG9uZW50XG4gKi9cbnZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSQkMSwgY29tcCkge1xuICBpZiAoVGVjaC5pc1RlY2goY29tcCkpIHtcbiAgICBsb2ckMS53YXJuKCdUaGUgJyArIG5hbWUkJDEgKyAnIHRlY2ggd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb25lbnQuIEl0IHNob3VsZCBpbnN0ZWFkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2gobmFtZSwgdGVjaCknKTtcbiAgfVxuXG4gIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudC5jYWxsKENvbXBvbmVudCwgbmFtZSQkMSwgY29tcCk7XG59O1xuXG4vKipcbiAqIEdldCBhIFRlY2ggY2xhc3Mgb2JqZWN0IGJ5IG5hbWVcbiAqXG4gKiBAYm9ycm93cyBUZWNoLmdldFRlY2ggYXMgdmlkZW9qcy5nZXRUZWNoXG4gKi9cbnZpZGVvanMuZ2V0VGVjaCA9IFRlY2guZ2V0VGVjaDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIFRlY2ggc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuXG4gKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHRlY2ggb3JkZXIgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGJvcnJvd3MgVGVjaC5yZWdpc3RlclRlY2ggYXMgdmlkZW9qcy5yZWdpc3RlclRlY2hcbiAqL1xudmlkZW9qcy5yZWdpc3RlclRlY2ggPSBUZWNoLnJlZ2lzdGVyVGVjaDtcblxudmlkZW9qcy51c2UgPSB1c2U7XG5cbi8qKlxuICogQSBzdWl0ZSBvZiBicm93c2VyIGFuZCBkZXZpY2UgdGVzdHMgZnJvbSB7QGxpbmsgYnJvd3Nlcn0uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZpZGVvanMuYnJvd3NlciA9IGJyb3dzZXI7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLiBJbmNsdWRlZCBmb3IgYmFja3dhcmRcbiAqIGNvbXBhdGliaWxpdHkgd2l0aCA0LngsIGJ1dCBkZXByZWNhdGVkLiBVc2UgYHZpZGVvanMuYnJvd3Nlci5UT1VDSF9FTkFCTEVEYFxuICogaW5zdGVhZCBnb2luZyBmb3J3YXJkLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNS4wXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmlkZW9qcy5UT1VDSF9FTkFCTEVEID0gVE9VQ0hfRU5BQkxFRDtcblxuLyoqXG4gKiBTdWJjbGFzcyBhbiBleGlzdGluZyBjbGFzc1xuICogTWltaWNzIEVTNiBzdWJjbGFzc2luZyB3aXRoIHRoZSBgZXh0ZW5kYCBrZXl3b3JkXG4gKlxuICogQGJvcnJvd3MgZXh0ZW5kOmV4dGVuZEZuIGFzIHZpZGVvanMuZXh0ZW5kXG4gKi9cbnZpZGVvanMuZXh0ZW5kID0gZXh0ZW5kRm47XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbnMgb2JqZWN0cyByZWN1cnNpdmVseVxuICogUGVyZm9ybXMgYSBkZWVwIG1lcmdlIGxpa2UgbG9kYXNoLm1lcmdlIGJ1dCAqKm9ubHkgbWVyZ2VzIHBsYWluIG9iamVjdHMqKlxuICogKG5vdCBhcnJheXMsIGVsZW1lbnRzLCBhbnl0aGluZyBlbHNlKVxuICogT3RoZXIgdmFsdWVzIHdpbGwgYmUgY29waWVkIGRpcmVjdGx5IGZyb20gdGhlIHNlY29uZCBvYmplY3QuXG4gKlxuICogQGJvcnJvd3MgbWVyZ2Utb3B0aW9uczptZXJnZU9wdGlvbnMgYXMgdmlkZW9qcy5tZXJnZU9wdGlvbnNcbiAqL1xudmlkZW9qcy5tZXJnZU9wdGlvbnMgPSBtZXJnZU9wdGlvbnM7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBjb250ZXh0ICh0aGlzKSBvZiBhIGZ1bmN0aW9uXG4gKlxuICogPiBOT1RFOiBhcyBvZiB2NS4wIHdlIHJlcXVpcmUgYW4gRVM1IHNoaW0sIHNvIHlvdSBzaG91bGQgdXNlIHRoZSBuYXRpdmVcbiAqIGBmdW5jdGlvbigpIHt9LmJpbmQobmV3Q29udGV4dCk7YCBpbnN0ZWFkIG9mIHRoaXMuXG4gKlxuICogQGJvcnJvd3MgZm46YmluZCBhcyB2aWRlb2pzLmJpbmRcbiAqL1xudmlkZW9qcy5iaW5kID0gYmluZDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAqXG4gKiBAYm9ycm93cyBwbHVnaW46cmVnaXN0ZXJQbHVnaW4gYXMgdmlkZW9qcy5yZWdpc3RlclBsdWdpblxuICogQG1ldGhvZCByZWdpc3RlclBsdWdpblxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHJlZ2lzdGVyZWQuIE11c3QgYmUgYSBzdHJpbmcgYW5kXG4gKiAgICAgICAgIG11c3Qgbm90IG1hdGNoIGFuIGV4aXN0aW5nIHBsdWdpbiBvciBhIG1ldGhvZCBvbiB0aGUgYFBsYXllcmBcbiAqICAgICAgICAgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgQSBzdWItY2xhc3Mgb2YgYFBsdWdpbmAgb3IgYSBmdW5jdGlvbiBmb3IgYmFzaWMgcGx1Z2lucy5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgRm9yIGFkdmFuY2VkIHBsdWdpbnMsIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhhdCBwbHVnaW4uIEZvclxuICogICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxuICovXG52aWRlb2pzLnJlZ2lzdGVyUGx1Z2luID0gUGx1Z2luLnJlZ2lzdGVyUGx1Z2luO1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgbWV0aG9kIHRvIHJlZ2lzdGVyIGEgcGx1Z2luIHdpdGggVmlkZW8uanNcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogICAgICAgIHZpZGVvanMucGx1Z2luKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMucmVnaXN0ZXJQbHVnaW4oKSBpbnN0ZWFkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgcGx1Z2luIG5hbWVcbiAqXG4gKiBAcGFyYW0ge1BsdWdpbnxGdW5jdGlvbn0gcGx1Z2luXG4gKiAgICAgICAgIFRoZSBwbHVnaW4gc3ViLWNsYXNzIG9yIGZ1bmN0aW9uXG4gKi9cbnZpZGVvanMucGx1Z2luID0gZnVuY3Rpb24gKG5hbWUkJDEsIHBsdWdpbikge1xuICBsb2ckMS53YXJuKCd2aWRlb2pzLnBsdWdpbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCkgaW5zdGVhZCcpO1xuICByZXR1cm4gUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKG5hbWUkJDEsIHBsdWdpbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gW25hbWVzXVxuICogICAgICAgICBJZiBwcm92aWRlZCwgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHBsdWdpbiBuYW1lcy4gRGVmYXVsdHMgdG8gX2FsbF9cbiAqICAgICAgICAgcGx1Z2luIG5hbWVzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICogICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW5zID0gUGx1Z2luLmdldFBsdWdpbnM7XG5cbi8qKlxuICogR2V0cyBhIHBsdWdpbiBieSBuYW1lIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICogICAgICAgICBUaGUgcGx1Z2luIChvciBgdW5kZWZpbmVkYCkuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2luID0gUGx1Z2luLmdldFBsdWdpbjtcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luJ3MgdmVyc2lvbiwgaWYgYXZhaWxhYmxlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHBsdWdpbidzIHZlcnNpb24gb3IgYW4gZW1wdHkgc3RyaW5nLlxuICovXG52aWRlb2pzLmdldFBsdWdpblZlcnNpb24gPSBQbHVnaW4uZ2V0UGx1Z2luVmVyc2lvbjtcblxuLyoqXG4gKiBBZGRpbmcgbGFuZ3VhZ2VzIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgdG8gYWxsIHBsYXllcnMuXG4gKiBFeGFtcGxlOiBgdmlkZW9qcy5hZGRMYW5ndWFnZSgnZXMnLCB7ICdIZWxsbyc6ICdIb2xhJyB9KTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqICAgICAgICBUaGUgbGFuZ3VhZ2UgY29kZSBvciBkaWN0aW9uYXJ5IHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqICAgICAgICBUaGUgZGF0YSB2YWx1ZXMgdG8gYmUgdHJhbnNsYXRlZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIHJlc3VsdGluZyBsYW5ndWFnZSBkaWN0aW9uYXJ5IG9iamVjdFxuICovXG52aWRlb2pzLmFkZExhbmd1YWdlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcbiAgdmFyIF9tZXJnZU9wdGlvbnM7XG5cbiAgY29kZSA9ICgnJyArIGNvZGUpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlcyA9IG1lcmdlT3B0aW9ucyh2aWRlb2pzLm9wdGlvbnMubGFuZ3VhZ2VzLCAoX21lcmdlT3B0aW9ucyA9IHt9LCBfbWVyZ2VPcHRpb25zW2NvZGVdID0gZGF0YSwgX21lcmdlT3B0aW9ucykpO1xuXG4gIHJldHVybiB2aWRlb2pzLm9wdGlvbnMubGFuZ3VhZ2VzW2NvZGVdO1xufTtcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXNcbiAqXG4gKiBAYm9ycm93cyBsb2c6bG9nIGFzIHZpZGVvanMubG9nXG4gKi9cbnZpZGVvanMubG9nID0gbG9nJDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXVsYXRlZCBUaW1lUmFuZ2Ugb2JqZWN0LlxuICpcbiAqIEBib3Jyb3dzIHRpbWUtcmFuZ2VzOmNyZWF0ZVRpbWVSYW5nZXMgYXMgdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VcbiAqL1xuLyoqXG4gKiBAYm9ycm93cyB0aW1lLXJhbmdlczpjcmVhdGVUaW1lUmFuZ2VzIGFzIHZpZGVvanMuY3JlYXRlVGltZVJhbmdlc1xuICovXG52aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZSA9IHZpZGVvanMuY3JlYXRlVGltZVJhbmdlcyA9IGNyZWF0ZVRpbWVSYW5nZXM7XG5cbi8qKlxuICogRm9ybWF0IHNlY29uZHMgYXMgYSB0aW1lIHN0cmluZywgSDpNTTpTUyBvciBNOlNTXG4gKiBTdXBwbHlpbmcgYSBndWlkZSAoaW4gc2Vjb25kcykgd2lsbCBmb3JjZSBhIG51bWJlciBvZiBsZWFkaW5nIHplcm9zXG4gKiB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBndWlkZVxuICpcbiAqIEBib3Jyb3dzIGZvcm1hdC10aW1lOmZvcm1hdFRpbWUgYXMgdmlkZW9qcy5mb3JtYXRUaW1lXG4gKi9cbnZpZGVvanMuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG5cbi8qKlxuICogUmVzb2x2ZSBhbmQgcGFyc2UgdGhlIGVsZW1lbnRzIG9mIGEgVVJMXG4gKlxuICogQGJvcnJvd3MgdXJsOnBhcnNlVXJsIGFzIHZpZGVvanMucGFyc2VVcmxcbiAqL1xudmlkZW9qcy5wYXJzZVVybCA9IHBhcnNlVXJsO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAYm9ycm93cyB1cmw6aXNDcm9zc09yaWdpbiBhcyB2aWRlb2pzLmlzQ3Jvc3NPcmlnaW5cbiAqL1xudmlkZW9qcy5pc0Nyb3NzT3JpZ2luID0gaXNDcm9zc09yaWdpbjtcblxuLyoqXG4gKiBFdmVudCB0YXJnZXQgY2xhc3MuXG4gKlxuICogQGJvcnJvd3MgRXZlbnRUYXJnZXQgYXMgdmlkZW9qcy5FdmVudFRhcmdldFxuICovXG52aWRlb2pzLkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQ7XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czpvbiBhcyB2aWRlb2pzLm9uXG4gKi9cbnZpZGVvanMub24gPSBvbjtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czpvbmUgYXMgdmlkZW9qcy5vbmVcbiAqL1xudmlkZW9qcy5vbmUgPSBvbmU7XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9mZiBhcyB2aWRlb2pzLm9mZlxuICovXG52aWRlb2pzLm9mZiA9IG9mZjtcblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IGZvciBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOnRyaWdnZXIgYXMgdmlkZW9qcy50cmlnZ2VyXG4gKi9cbnZpZGVvanMudHJpZ2dlciA9IHRyaWdnZXI7XG5cbi8qKlxuICogQSBjcm9zcy1icm93c2VyIFhNTEh0dHBSZXF1ZXN0IHdyYXBwZXIuIEhlcmUncyBhIHNpbXBsZSBleGFtcGxlOlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgc2V0dGluZ3MgZm9yIHRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fFhEb21haW5SZXF1ZXN0fVxuICogICAgICAgICBUaGUgcmVxdWVzdCBvYmplY3QuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmF5bm9zL3hoclxuICovXG52aWRlb2pzLnhociA9IHhocjtcblxuLyoqXG4gKiBUZXh0VHJhY2sgY2xhc3NcbiAqXG4gKiBAYm9ycm93cyBUZXh0VHJhY2sgYXMgdmlkZW9qcy5UZXh0VHJhY2tcbiAqL1xudmlkZW9qcy5UZXh0VHJhY2sgPSBUZXh0VHJhY2s7XG5cbi8qKlxuICogZXhwb3J0IHRoZSBBdWRpb1RyYWNrIGNsYXNzIHNvIHRoYXQgc291cmNlIGhhbmRsZXJzIGNhbiBjcmVhdGVcbiAqIEF1ZGlvVHJhY2tzIGFuZCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBwbGF5ZXJzIEF1ZGlvVHJhY2tMaXN0XG4gKlxuICogQGJvcnJvd3MgQXVkaW9UcmFjayBhcyB2aWRlb2pzLkF1ZGlvVHJhY2tcbiAqL1xudmlkZW9qcy5BdWRpb1RyYWNrID0gQXVkaW9UcmFjaztcblxuLyoqXG4gKiBleHBvcnQgdGhlIFZpZGVvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxuICogVmlkZW9UcmFja3MgYW5kIHRoZW4gYWRkIHRoZW0gdG8gdGhlIHBsYXllcnMgVmlkZW9UcmFja0xpc3RcbiAqXG4gKiBAYm9ycm93cyBWaWRlb1RyYWNrIGFzIHZpZGVvanMuVmlkZW9UcmFja1xuICovXG52aWRlb2pzLlZpZGVvVHJhY2sgPSBWaWRlb1RyYWNrO1xuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTppc0VsIGFzIHZpZGVvanMuaXNFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmlzRWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQGJvcnJvd3MgZG9tOmlzVGV4dE5vZGUgYXMgdmlkZW9qcy5pc1RleHROb2RlXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNUZXh0Tm9kZSgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBib3Jyb3dzIGRvbTpjcmVhdGVFbCBhcyB2aWRlb2pzLmNyZWF0ZUVsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uY3JlYXRlRWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzc1xuICpcbiAqIEBib3Jyb3dzIGRvbTpoYXNFbENsYXNzIGFzIHZpZGVvanMuaGFzQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5oYXNDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBkb206YWRkRWxDbGFzcyBhcyB2aWRlb2pzLmFkZENsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYWRkQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBkb206cmVtb3ZlRWxDbGFzcyBhcyB2aWRlb2pzLnJlbW92ZUNsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20ucmVtb3ZlQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBDU1MgY2xhc3MgbmFtZSBvbiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiBhbiBvcHRpb25hbFxuICogY29uZGl0aW9uIG9yIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSBjbGFzcyBuYW1lLlxuICpcbiAqIEBib3Jyb3dzIGRvbTp0b2dnbGVFbENsYXNzIGFzIHZpZGVvanMudG9nZ2xlQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS50b2dnbGVDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTpzZXRFbEF0dHJpYnV0ZXMgYXMgdmlkZW9qcy5zZXRBdHRyaWJ1dGVcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5zZXRBdHRyaWJ1dGVzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKlxuICogQGJvcnJvd3MgZG9tOmdldEVsQXR0cmlidXRlcyBhcyB2aWRlb2pzLmdldEF0dHJpYnV0ZXNcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5nZXRBdHRyaWJ1dGVzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogRW1wdGllcyB0aGUgY29udGVudHMgb2YgYW4gZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206ZW1wdHlFbCBhcyB2aWRlb2pzLmVtcHR5RWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5lbXB0eUVsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQGJvcnJvd3MgZG9tOmFwcGVuZENvbnRlbnRzIGFzIHZpZGVvanMuYXBwZW5kQ29udGV0XG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYXBwZW5kQ29udGVudCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGluc2VydHMgY29udGVudCBpbnRvIGFuIGVsZW1lbnQ7IHRoaXMgaXMgaWRlbnRpY2FsIHRvXG4gKiBgYXBwZW5kQ29udGVudCgpYCwgZXhjZXB0IGl0IGVtcHRpZXMgdGhlIGVsZW1lbnQgZmlyc3QuXG4gKlxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcbiAqIGNvbWJpbmF0aW9ucywgd2hvc2UgYmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIFN0cmluZ1xuICogICBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXG4gKlxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxuICogICBQYXNzZWQgdGhyb3VnaC5cbiAqXG4gKiAtIEFycmF5XG4gKiAgIEEgb25lLWRpbWVuc2lvbmFsIGFycmF5IG9mIHN0cmluZ3MsIGVsZW1lbnRzLCBub2Rlcywgb3IgZnVuY3Rpb25zICh3aGljaFxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKlxuICogLSBGdW5jdGlvblxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcbiAqICAgbm9kZSwgb3IgYXJyYXkuXG4gKlxuICogQGJvcnJvd3MgZG9tOmluc2VydENvbnRlbnQgYXMgdmlkZW9qcy5pbnNlcnRDb250ZW50XG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaW5zZXJ0Q29udGVudCgpIGluc3RlYWRcbiAqL1xuWydpc0VsJywgJ2lzVGV4dE5vZGUnLCAnY3JlYXRlRWwnLCAnaGFzQ2xhc3MnLCAnYWRkQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCAnc2V0QXR0cmlidXRlcycsICdnZXRBdHRyaWJ1dGVzJywgJ2VtcHR5RWwnLCAnYXBwZW5kQ29udGVudCcsICdpbnNlcnRDb250ZW50J10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICB2aWRlb2pzW2tdID0gZnVuY3Rpb24gKCkge1xuICAgIGxvZyQxLndhcm4oJ3ZpZGVvanMuJyArIGsgKyAnKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMuZG9tLicgKyBrICsgJygpIGluc3RlYWQnKTtcbiAgICByZXR1cm4gRG9tW2tdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBBIHNhZmUgZ2V0Q29tcHV0ZWRTdHlsZSB3aXRoIGFuIElFOCBmYWxsYmFjay5cbiAqXG4gKiBUaGlzIGlzIGJlY2F1c2UgaW4gRmlyZWZveCwgaWYgdGhlIHBsYXllciBpcyBsb2FkZWQgaW4gYW4gaWZyYW1lIHdpdGggYGRpc3BsYXk6bm9uZWAsXG4gKiB0aGVuIGBnZXRDb21wdXRlZFN0eWxlYCByZXR1cm5zIGBudWxsYCwgc28sIHdlIGRvIGEgbnVsbC1jaGVjayB0byBtYWtlIHN1cmVcbiAqIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IGJyZWFrIGluIHRoZXNlIGNhc2VzLlxuICogU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5NyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBib3Jyb3dzIGNvbXB1dGVkLXN0eWxlOmNvbXB1dGVkU3R5bGUgYXMgdmlkZW9qcy5jb21wdXRlZFN0eWxlXG4gKi9cbnZpZGVvanMuY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBEb20gdXRpbGl0aWVzIGZvciB1c2UgaW4gZXh0ZXJuYWwgcGx1Z2luc1xuICogYW5kIFRlY2gnc1xuICovXG52aWRlb2pzLmRvbSA9IERvbTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIFVybCB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMudXJsID0gVXJsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZpZGVvanM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjYuMEB2aWRlby5qcy9kaXN0L3ZpZGVvLmNqcy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFZQTs7O0FBZUE7Ozs7OztBQVdBO0FBR0E7QUFDQTtBQUNBO0FBZ0JBO0FBQ0E7QUFrQkE7QUFxQkE7OztBQXlIQTs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7O0FBZUE7Ozs7Ozs7OztBQWdDQTs7Ozs7O0FBV0E7OztBQVFBO0FBR0E7QUFHQTs7Ozs7Ozs7Ozs7OztBQWdCQTtBQVNBO0FBSUE7QUFLQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFXQTtBQUNBO0FBS0E7QUFDQTs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7QUFtQkE7OztBQVFBOztBQVNBOztBQVVBOzs7OztBQVlBOzs7OztBQWNBOzs7Ozs7QUFlQTs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7QUFvQkE7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7QUFnQkE7Ozs7QUFTQTtBQUlBO0FBR0E7QUFDQTs7Ozs7Ozs7O0FBY0E7Ozs7O0FBVUE7QUFHQTtBQUNBOzs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7QUFZQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOzs7Ozs7Ozs7OztBQThCQTs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7QUFvQkE7QUFLQTtBQUNBOzs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUdBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7OztBQXdCQTtBQUlBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7QUFhQTs7QUFPQTs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7O0FBbUNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQTBCQTs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7QUFjQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQU1BO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7O0FBd0NBOzs7QUFJQTs7Ozs7QUFRQTs7O0FBUUE7Ozs7Ozs7OztBQVVBOzs7Ozs7QUFTQTs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7O0FBd0JBOzs7OztBQWdCQTtBQVFBO0FBR0E7QUFPQTs7Ozs7OztBQWNBOzs7Ozs7OztBQVNBO0FBSUE7QUFHQTtBQUVBO0FBQ0E7QUFRQTtBQU9BOzs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUdBOzs7Ozs7OztBQWFBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFLQTtBQUtBO0FBWUE7QUFZQTtBQVdBO0FBU0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQU9BOztBQU1BO0FBY0E7O0FBTUE7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBUUE7QUE2QkE7Ozs7Ozs7Ozs7OztBQTRDQTtBQUVBO0FBT0E7QUFTQTtBQU1BO0FBWUE7QUFLQTtBQU1BOzs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBS0E7QUFDQTtBQUlBO0FBSUE7QUFFQTtBQUVBO0FBSUE7QUFLQTs7Ozs7Ozs7Ozs7QUFlQTtBQVVBOzs7OztBQWtCQTs7QUFNQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBd0JBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBRUE7QUFLQTtBQU9BOzs7Ozs7Ozs7QUFlQTs7OztBQWdCQTs7O0FBU0E7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBaUJBOzs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBRUE7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFpQkE7O0FBa0JBOzs7Ozs7O0FBUUE7Ozs7O0FBU0E7Ozs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7O0FBU0E7Ozs7Ozs7OztBQVlBO0FBRUE7QUFDQTs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFhQTs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUFhQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7O0FBc0JBOzs7QUFNQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBZ0JBO0FBR0E7QUFDQTs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUdBO0FBQ0E7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQWdCQTtBQUdBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFnQkE7QUFJQTtBQVdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQUdBO0FBSUE7QUFLQTtBQUtBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFNQTtBQVlBOzs7QUFjQTs7Ozs7QUFNQTs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7O0FBZUE7QUFJQTtBQVNBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFJQTtBQUNBO0FBR0E7OztBQVlBOzs7Ozs7OztBQVNBOzs7Ozs7Ozs7OztBQW9CQTs7O0FBUUE7Ozs7Ozs7OztBQVVBOzs7O0FBa0NBOzs7Ozs7O0FBU0E7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBS0E7QUFFQTtBQUtBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFRQTtBQU9BO0FBRUE7QUFTQTtBQU1BO0FBRUE7Ozs7QUFZQTs7Ozs7Ozs7O0FBWUE7QUFHQTtBQVNBO0FBTUE7QUFTQTs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7O0FBbUJBOzs7OztBQW1CQTs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0E7Ozs7OztBQTBDQTs7Ozs7QUFZQTs7Ozs7O0FBYUE7Ozs7O0FBWUE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBUUE7QUFNQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBV0E7QUFDQTtBQU9BO0FBQ0E7QUFRQTs7Ozs7O0FBWUE7O0FBc0NBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFXQTtBQUZBO0FBeUJBO0FBQ0E7QUFDQTs7Ozs7OztBQWlCQTtBQUVBO0FBQ0E7Ozs7Ozs7QUFhQTtBQWlCQTs7OztBQVdBO0FBSUE7QUFJQTtBQVNBOzs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7OztBQWdCQTs7Ozs7QUFZQTs7Ozs7QUFZQTs7Ozs7Ozs7OztBQWlCQTs7O0FBVUE7OztBQVVBOzs7OztBQVlBOzs7OztBQVlBOzs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7OztBQWVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTtBQUdBO0FBS0E7QUFTQTs7Ozs7QUFPQTtBQU9BO0FBQ0E7QUFLQTtBQUtBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBZ0JBO0FBY0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7QUFTQTs7Ozs7QUFlQTs7Ozs7QUFZQTs7QUFTQTs7QUFTQTs7Ozs7Ozs7Ozs7O0FBbUJBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBRUE7QUFLQTtBQUVBO0FBTUE7QUFJQTtBQUNBO0FBZUE7QUFJQTtBQUNBO0FBR0E7QUFFQTtBQUdBO0FBRUE7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7QUFFQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFNQTs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7Ozs7O0FBbUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0E7QUFrQkE7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFRQTtBQTRCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7OztBQXlCQTs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTs7Ozs7QUFXQTs7Ozs7Ozs7OztBQThCQTs7O0FBYUE7Ozs7Ozs7Ozs7O0FBWUE7QUFrQkE7Ozs7QUFlQTs7Ozs7O0FBT0E7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBTUE7QUFFQTtBQU9BOztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBR0E7QUFDQTtBQVFBO0FBSUE7QUFDQTs7OztBQWlCQTs7Ozs7QUFRQTs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7O0FBUUE7QUFTQTtBQUNBO0FBR0E7Ozs7Ozs7O0FBWUE7Ozs7Ozs7O0FBYUE7Ozs7O0FBYUE7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7Ozs7QUFnQ0E7O0FBbUJBOzs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUNBO0FBV0E7QUFDQTtBQUNBOzs7OztBQXlCQTs7Ozs7QUE0QkE7Ozs7Ozs7O0FBZUE7Ozs7O0FBY0E7Ozs7OztBQWFBO0FBSUE7Ozs7O0FBZUE7Ozs7O0FBVUE7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQVdBOzs7OztBQWFBOzs7Ozs7OztBQWdCQTs7Ozs7O0FBZ0JBOzs7OztBQVlBOzs7OztBQXdCQTs7Ozs7Ozs7QUFtQkE7QUFNQTtBQUdBO0FBQ0E7QUFTQTs7O0FBZUE7Ozs7Ozs7OztBQWdCQTs7Ozs7QUFXQTtBQUlBO0FBQ0E7Ozs7O0FBU0E7QUFHQTtBQU9BOzs7OztBQWVBOzs7OztBQU9BOzs7OztBQVNBOzs7Ozs7Ozs7Ozs7OztBQW9CQTs7OztBQWNBOzs7O0FBc0JBOzs7O0FBZ0JBO0FBRUE7Ozs7QUFtQ0E7Ozs7O0FBbUJBOztBQVVBOzs7OztBQU9BOzs7Ozs7Ozs7O0FBY0E7QUFZQTs7Ozs7QUFrQkE7QUFXQTtBQUNBOzs7Ozs7O0FBYUE7QUFZQTs7Ozs7OztBQVVBOzs7Ozs7O0FBaUJBOzs7Ozs7O0FBNEJBOzs7Ozs7O0FBZ0JBOzs7OztBQXlCQTs7Ozs7QUFRQTtBQU9BOztBQU9BOzs7Ozs7Ozs7OztBQVlBO0FBTUE7Ozs7O0FBV0E7Ozs7O0FBU0E7QUFTQTtBQUNBO0FBUUE7QUFDQTs7Ozs7OztBQThCQTtBQVNBOzs7QUFRQTtBQUVBO0FBQ0E7QUFDQTs7QUFnQkE7Ozs7Ozs7Ozs7QUFXQTtBQU1BOzs7OztBQVdBOzs7OztBQVNBO0FBU0E7QUFDQTtBQVFBO0FBQ0E7OztBQXFCQTs7Ozs7OztBQXlCQTtBQVNBOzs7QUFRQTs7QUFpQkE7Ozs7O0FBT0E7Ozs7O0FBU0E7QUFTQTtBQUNBOzs7Ozs7O0FBNEJBOzs7QUFPQTs7QUFvQkE7O0FBSUE7Ozs7O0FBUUE7QUFNQTs7Ozs7QUFrQkE7Ozs7Ozs7QUF5QkE7QUFZQTs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7QUF3QkE7O0FBZ0JBOzs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7O0FBTUE7Ozs7O0FBUUE7QUFLQTs7Ozs7QUFrQkE7Ozs7Ozs7O0FBc0JBOzs7Ozs7OztBQXNDQTs7QUFzQkE7Ozs7OztBQU9BOzs7Ozs7QUFnQkE7Ozs7OztBQWdCQTs7Ozs7O0FBZUE7O0FBU0E7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBVUE7Ozs7Ozs7QUF5QkE7Ozs7Ozs7QUFTQTs7Ozs7OztBQVNBOzs7Ozs7OztBQVVBOzs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7OztBQVNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFRQTtBQUtBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7Ozs7Ozs7Ozs7O0FBK0JBO0FBRUE7QUFFQTs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7QUFzQkE7QUFLQTtBQUdBO0FBQ0E7O0FBZUE7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7OztBQThDQTtBQWtCQTtBQUNBOzs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBO0FBcUJBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBOzs7Ozs7OztBQXdCQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBMEJBOzs7OztBQVVBOzs7OztBQWlCQTtBQU9BOzs7OztBQXVEQTtBQWFBOzs7OztBQXdCQTs7QUFzQkE7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFVQTtBQUNBOzs7Ozs7OztBQW1CQTtBQU1BOzs7Ozs7Ozs7QUFlQTtBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBV0E7QUFDQTs7Ozs7Ozs7QUFvQkE7QUFNQTs7Ozs7Ozs7O0FBZUE7QUFLQTtBQUNBO0FBQ0E7O0FBY0E7Ozs7QUFLQTs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUNBO0FBU0E7Ozs7O0FBd0JBOzs7Ozs7QUFhQTs7O0FBWUE7OztBQWtDQTs7QUFrREE7Ozs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7QUE2QkE7Ozs7Ozs7O0FBWUE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQW1CQTtBQUtBO0FBeUJBO0FBYUE7Ozs7QUFPQTtBQU1BOzs7QUFTQTs7Ozs7Ozs7Ozs7O0FBc0JBO0FBS0E7Ozs7O0FBU0E7Ozs7Ozs7O0FBc0JBOzs7OztBQVlBOzs7Ozs7O0FBY0E7Ozs7O0FBWUE7Ozs7QUFXQTs7O0FBYUE7Ozs7OztBQWdCQTs7Ozs7QUFXQTtBQUdBOzs7OztBQVdBO0FBSUE7QUFDQTs7Ozs7QUFXQTtBQUdBO0FBR0E7Ozs7Ozs7OztBQXVCQTtBQUtBOzs7QUFxQkE7Ozs7QUFrQkE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7OztBQW9CQTs7Ozs7QUFlQTtBQUVBOzs7OztBQU9BOzs7Ozs7Ozs7QUFnQkE7Ozs7O0FBVUE7Ozs7O0FBT0E7Ozs7O0FBTUE7Ozs7O0FBMEJBO0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFDQTs7Ozs7QUFVQTs7Ozs7QUFTQTtBQU9BO0FBQ0E7OztBQWFBOzs7Ozs7Ozs7Ozs7OztBQXVFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7QUFVQTtBQUtBO0FBS0E7Ozs7O0FBZ0JBO0FBSUE7Ozs7Ozs7Ozs7QUFrQkE7Ozs7QUFXQTs7OztBQVNBOzs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7OztBQWVBO0FBcUJBOzs7Ozs7OztBQWdCQTs7Ozs7QUEyQkE7Ozs7O0FBT0E7Ozs7O0FBT0E7Ozs7O0FBT0E7Ozs7O0FBT0E7Ozs7OztBQWlCQTs7Ozs7O0FBUUE7Ozs7OztBQVFBOzs7OztBQU1BOzs7Ozs7QUFTQTs7Ozs7Ozs7QUFXQTs7Ozs7OztBQVVBOzs7Ozs7O0FBVUE7Ozs7OztBQVNBOzs7Ozs7Ozs7OztBQWNBOzs7Ozs7OztBQVdBO0FBU0E7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7Ozs7O0FBMkJBOzs7QUFjQTs7Ozs7QUFTQTs7Ozs7QUFPQTs7Ozs7OztBQXVCQTtBQUtBO0FBQ0E7QUFRQTs7OztBQWdCQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBY0E7QUFDQTs7OztBQVFBO0FBaUVBO0FBSUE7QUFDQTtBQU1BO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7O0FBY0E7Ozs7Ozs7Ozs7OztBQWFBO0FBRUE7QUFnQkE7QUFHQTtBQUdBOztBQVNBOzs7OztBQU9BOzs7Ozs7Ozs7OztBQWVBO0FBSUE7QUFHQTtBQUVBO0FBUUE7QUFDQTtBQUtBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBYUE7Ozs7O0FBT0E7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBZ0JBO0FBSUE7QUFjQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7O0FBNEJBO0FBYUE7Ozs7O0FBWUE7O0FBU0E7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7Ozs7Ozs7OztBQWNBOzs7Ozs7OztBQWVBO0FBR0E7QUFNQTs7Ozs7Ozs7QUFlQTs7QUFZQTs7OztBQU1BOzs7Ozs7OztBQVlBOztBQWVBOzs7OztBQWFBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQWtCQTtBQU1BO0FBQ0E7Ozs7O0FBZUE7QUFPQTtBQUNBOzs7Ozs7Ozs7O0FBcUJBO0FBRUE7O0FBbUJBOzs7Ozs7Ozs7Ozs7O0FBNkJBO0FBR0E7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBTUE7Ozs7QUFVQTs7Ozs7Ozs7Ozs7QUFlQTtBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQThCQTtBQWFBO0FBR0E7QUFLQTtBQWNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBbUJBOzs7OztBQWdCQTs7QUFjQTs7Ozs7O0FBZUE7QUFNQTtBQUNBO0FBRUE7Ozs7O0FBcUNBOztBQWlGQTs7OztBQU1BOzs7OztBQWNBOztBQWVBOzs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQVlBO0FBR0E7QUFHQTs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBUUE7OztBQVNBOzs7QUFXQTs7Ozs7Ozs7QUFnQkE7QUFHQTtBQUtBOztBQVdBOzs7OztBQU9BOzs7OztBQXNCQTs7Ozs7Ozs7OztBQWlCQTtBQUlBOzs7OztBQTRDQTs7QUFPQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7O0FBWUE7O0FBV0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7O0FBbUJBOzs7Ozs7O0FBb0JBO0FBS0E7Ozs7Ozs7QUFhQTtBQUlBOzs7Ozs7O0FBYUE7QUFJQTtBQUdBOzs7OztBQWNBOzs7QUFTQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFXQTtBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFHQTs7QUFRQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQWtCQTtBQVVBOzs7OztBQTBCQTs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7QUFzQkE7Ozs7O0FBYUE7O0FBT0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFpQkE7Ozs7Ozs7QUFjQTtBQUVBOzs7Ozs7Ozs7QUFpQkE7Ozs7O0FBa0JBOztBQU9BOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBWUE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7O0FBb0JBOztBQU9BOzs7OztBQU9BOzs7OztBQWNBOztBQWVBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBa0JBOzs7Ozs7Ozs7O0FBaUJBOzs7Ozs7OztBQWVBO0FBTUE7QUFDQTs7Ozs7Ozs7O0FBbUJBOzs7OztBQWtCQTs7QUFPQTtBQUVBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBa0JBOzs7Ozs7OztBQWlDQTs7QUFnQkE7Ozs7O0FBT0E7Ozs7Ozs7O0FBWUE7QUFJQTtBQUtBOzs7OztBQWNBOztBQVNBOztBQTRCQTs7Ozs7Ozs7Ozs7Ozs7QUEyQ0E7QUFLQTs7Ozs7Ozs7O0FBNEJBOzs7OztBQWFBOzs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7OztBQWNBOzs7OztBQVlBOzs7Ozs7QUFtQkE7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFLQTtBQUlBOzs7Ozs7Ozs7O0FBc0JBOzs7Ozs7O0FBbUJBOzs7Ozs7Ozs7QUFnQkE7QUFFQTtBQUtBOzs7Ozs7O0FBZUE7Ozs7OztBQWFBOzs7Ozs7Ozs7O0FBa0JBOztBQXNCQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQWtCQTs7Ozs7OztBQXVCQTtBQU9BO0FBRUE7QUFNQTtBQUdBO0FBV0E7QUFLQTs7QUFjQTs7OztBQU1BOzs7OztBQWNBOzs7Ozs7Ozs7QUFrQkE7QUFNQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUNBOztBQWtCQTs7Ozs7QUFPQTs7Ozs7QUFjQTs7Ozs7Ozs7OztBQW9CQTtBQUlBOzs7OztBQTJCQTtBQUtBOztBQVNBOzs7Ozs7O0FBU0E7Ozs7Ozs7O0FBWUE7Ozs7O0FBaUJBOzs7Ozs7Ozs7O0FBbUJBO0FBSUE7Ozs7O0FBd0JBOztBQVNBO0FBQ0E7QUFHQTs7Ozs7QUFTQTs7Ozs7Ozs7QUFZQTtBQVdBO0FBQ0E7Ozs7O0FBNEJBOzs7Ozs7Ozs7OztBQXNCQTtBQUlBO0FBR0E7QUFHQTs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7O0FBZUE7Ozs7O0FBWUE7Ozs7Ozs7QUFnQkE7Ozs7Ozs7QUF1QkE7QUFRQTtBQUtBOzs7Ozs7O0FBbUNBOzs7Ozs7QUFZQTs7QUFXQTs7QUFTQTs7Ozs7OztBQWNBOzs7Ozs7OztBQW1CQTtBQUdBO0FBTUE7Ozs7O0FBZUE7QUFNQTs7OztBQVNBOztBQU9BOzs7OztBQU9BOzs7Ozs7OztBQVlBOzs7OztBQW9CQTs7Ozs7Ozs7QUFpQkE7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7QUFXQTs7Ozs7QUFjQTs7QUFTQTs7QUF1QkE7Ozs7Ozs7O0FBMkJBOzs7Ozs7OztBQW9CQTs7Ozs7QUFvQkE7O0FBU0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFpQkE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7QUFxQkE7Ozs7O0FBbUJBOzs7Ozs7Ozs7OztBQWdCQTtBQUVBOztBQWdCQTs7OztBQU1BOzs7OztBQWNBOztBQWVBO0FBQ0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFxQkE7Ozs7Ozs7QUFtQkE7Ozs7Ozs7QUFrQkE7O0FBY0E7Ozs7O0FBY0E7O0FBWUE7O0FBVUE7Ozs7Ozs7QUFlQTs7OztBQWNBOzs7Ozs7O0FBY0E7Ozs7O0FBdUJBOzs7O0FBVUE7O0FBT0E7QUFDQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBT0E7QUFDQTtBQU1BO0FBVUE7QUFDQTs7Ozs7QUFzQkE7Ozs7Ozs7O0FBdUJBOzs7Ozs7OztBQW9CQTs7Ozs7Ozs7QUFvQkE7Ozs7O0FBZUE7O0FBU0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQUlBOzs7OztBQWdCQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7OztBQWtCQTtBQWFBOzs7Ozs7QUFlQTs7Ozs7QUFvQkE7O0FBT0E7QUFDQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFZQTtBQVdBO0FBQ0E7QUFNQTtBQUtBO0FBQ0E7Ozs7O0FBZ0JBOzs7OztBQVlBOzs7OztBQVlBOzs7OztBQXVCQTs7QUFTQTs7Ozs7QUFPQTs7Ozs7Ozs7O0FBYUE7Ozs7OztBQXdCQTtBQUlBO0FBSUE7QUFDQTs7Ozs7QUFlQTtBQWlCQTtBQUNBOzs7Ozs7O0FBd0JBO0FBRUE7QUFLQTs7QUFXQTs7QUFjQTs7Ozs7QUFpQkE7O0FBK0JBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFZQTs7QUF5QkE7Ozs7O0FBaUJBOzs7OztBQWtCQTs7Ozs7OztBQVdBO0FBR0E7QUFpQkE7Ozs7QUFlQTs7Ozs7QUFVQTs7Ozs7QUFjQTtBQUlBO0FBT0E7Ozs7O0FBYUE7QUFJQTs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7OztBQW1CQTtBQUVBO0FBQ0E7QUFFQTs7QUFnQkE7O0FBU0E7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7QUFlQTtBQUdBO0FBS0E7QUFHQTtBQUdBOzs7Ozs7OztBQW1CQTtBQUdBO0FBS0E7QUFHQTs7QUFVQTtBQU9BO0FBQ0E7QUFFQTs7QUFZQTs7QUFhQTs7QUFjQTs7QUFlQTs7OztBQU1BOzs7Ozs7OztBQVlBOztBQW9DQTs7OztBQU1BOzs7Ozs7Ozs7QUFhQTtBQVdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBRUE7Ozs7Ozs7Ozs7QUFzQkE7Ozs7O0FBWUE7QUFNQTtBQUNBO0FBS0E7O0FBYUE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQU9BO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBSUE7QUFhQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7OztBQXNDQTtBQVNBO0FBY0E7O0FBYUE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQUlBO0FBQ0E7QUFtQkE7Ozs7O0FBYUE7O0FBNENBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7Ozs7O0FBb0JBO0FBTUE7QUFDQTtBQU1BO0FBa0JBO0FBS0E7O0FBbUJBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFRQTs7Ozs7Ozs7OztBQXlCQTs7Ozs7OztBQWdCQTtBQUtBOztBQVdBOzs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7QUFhQTs7Ozs7Ozs7O0FBb0JBOzs7Ozs7QUFnQkE7QUFVQTtBQWFBOzs7OztBQW1CQTtBQUtBOzs7Ozs7QUFpQkE7Ozs7O0FBZUE7Ozs7O0FBYUE7Ozs7O0FBa0NBOzs7OztBQVFBOztBQU9BOzs7O0FBTUE7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7QUF5QkE7QUFLQTtBQVVBOzs7OztBQWVBOzs7OztBQW1CQTs7Ozs7QUFRQTs7QUFPQTs7OztBQU1BOzs7Ozs7Ozs7OztBQWVBOzs7OztBQWFBOzs7OztBQW1CQTs7Ozs7QUFRQTs7QUFPQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBYUE7Ozs7Ozs7Ozs7QUF3QkE7O0FBWUE7Ozs7QUFNQTs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7QUFhQTs7Ozs7QUFnQkE7Ozs7O0FBdUJBOzs7OztBQVFBOztBQU9BOzs7OztBQU9BOztBQWdDQTs7OztBQU1BO0FBUUE7QUFDQTs7Ozs7QUFrQkE7Ozs7O0FBZ0JBOzs7OztBQXdCQTs7Ozs7O0FBU0E7O0FBT0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQU9BOzs7Ozs7Ozs7O0FBNkJBOzs7Ozs7O0FBc0JBOztBQVlBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBaUJBOzs7Ozs7OztBQW1CQTtBQUlBO0FBVUE7Ozs7O0FBa0JBOztBQU1BOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFPQTs7Ozs7Ozs7OztBQTBCQTs7Ozs7OztBQWVBOzs7OztBQWVBOztBQU9BOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBcUJBOzs7OztBQTJCQTs7Ozs7QUFnQkE7O0FBa0JBO0FBRUE7Ozs7Ozs7Ozs7QUFnQkE7QUFFQTtBQUlBOzs7OztBQW1CQTs7Ozs7O0FBYUE7Ozs7Ozs7QUFjQTs7Ozs7OztBQWtCQTs7Ozs7QUFpQkE7O0FBT0E7Ozs7O0FBT0E7Ozs7O0FBY0E7Ozs7O0FBWUE7O0FBY0E7Ozs7QUFNQTs7Ozs7QUFjQTs7Ozs7QUFZQTtBQU1BO0FBQ0E7O0FBWUE7QUFDQTs7OztBQU1BOzs7OztBQWNBO0FBTUE7QUFDQTs7Ozs7QUFlQTs7QUFTQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFZQTs7Ozs7OztBQW1CQTs7Ozs7QUFZQTs7OztBQWdCQTs7QUFZQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdURBO0FBT0E7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7Ozs7OztBQXFCQTs7OztBQW1CQTs7Ozs7Ozs7QUFZQTtBQVVBO0FBWUE7Ozs7Ozs7Ozs7QUEyQ0E7Ozs7Ozs7QUEwQkE7Ozs7Ozs7QUFnQkE7Ozs7Ozs7QUFnQkE7Ozs7Ozs7QUFnQkE7Ozs7Ozs7QUFpQkE7Ozs7Ozs7QUFpQkE7Ozs7O0FBaUNBOzs7OztBQXNCQTs7QUFhQTs7QUFlQTs7QUFtQkE7O0FBdUJBOzs7O0FBZUE7O0FBeUJBOzs7OztBQU9BOzs7Ozs7OztBQVlBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQXFCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFXQTtBQUtBOzs7Ozs7O0FBYUE7QUFLQTtBQWdCQTtBQUNBO0FBZ0JBO0FBSUE7QUFDQTtBQUlBO0FBS0E7QUFFQTtBQUlBOzs7OztBQVlBO0FBNERBOzs7OztBQWVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQVlBO0FBcUJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBa0NBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQWFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBS0E7QUFLQTtBQUtBOzs7OztBQWVBO0FBTUE7Ozs7O0FBV0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7Ozs7QUFxQkE7Ozs7O0FBWUE7Ozs7Ozs7OztBQWdCQTs7Ozs7O0FBbUNBO0FBS0E7O0FBWUE7QUFLQTtBQUNBO0FBR0E7QUFDQTs7QUFjQTs7Ozs7Ozs7Ozs7O0FBbUJBO0FBTUE7OztBQVNBOzs7Ozs7O0FBY0E7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0E7Ozs7Ozs7Ozs7O0FBMENBOzs7OztBQWtCQTs7Ozs7Ozs7QUEyQkE7Ozs7OztBQW1DQTs7Ozs7O0FBZ0JBO0FBRUE7Ozs7OztBQWdCQTs7Ozs7OztBQVlBOzs7Ozs7OztBQWFBO0FBRUE7Ozs7OztBQWlCQTtBQUVBO0FBQ0E7QUFJQTs7Ozs7O0FBaUJBOzs7Ozs7QUFXQTs7Ozs7O0FBV0E7Ozs7O0FBVUE7Ozs7O0FBUUE7Ozs7Ozs7O0FBV0E7Ozs7Ozs7QUFVQTtBQUdBO0FBQ0E7Ozs7OztBQU9BOzs7Ozs7QUFTQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFRQTtBQUdBO0FBT0E7QUFTQTtBQWtCQTtBQVlBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUtBO0FBa0JBO0FBQ0E7QUFJQTtBQUtBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7O0FBZUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7QUFjQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7QUFhQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQVFBOzs7Ozs7QUFTQTs7Ozs7O0FBU0E7Ozs7Ozs7O0FBaUJBOzs7Ozs7OztBQVdBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUFtQkE7QUFHQTtBQUlBOzs7Ozs7Ozs7OztBQXFCQTs7QUFPQTtBQUdBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBT0E7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFPQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7OztBQWVBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBR0E7QUFzQkE7QUFDQTtBQUtBO0FBR0E7QUFHQTtBQUNBO0FBS0E7QUFHQTtBQUdBO0FBR0E7QUFFQTtBQVdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUNBOzs7OztBQVNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBbUJBO0FBR0E7QUFDQTtBQU9BO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBR0E7QUFLQTtBQUNBOzs7Ozs7O0FBeUJBOzs7OztBQU9BO0FBRUE7QUFRQTtBQXVCQTs7Ozs7QUFXQTtBQWFBO0FBQ0E7QUFtQkE7QUFHQTtBQUtBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQVNBO0FBTUE7QUFVQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTtBQVNBO0FBZ0JBOzs7OztBQU9BOzs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7OztBQVlBO0FBTUE7QUFNQTtBQUNBOzs7OztBQWFBO0FBd0JBO0FBRUE7QUFHQTtBQUdBO0FBSUE7QUFLQTtBQUdBO0FBR0E7QUFLQTtBQUdBO0FBSUE7QUFPQTs7Ozs7Ozs7Ozs7QUFtQkE7QUFJQTtBQVFBO0FBU0E7QUFHQTtBQW1DQTtBQVNBO0FBS0E7QUE0QkE7QUFDQTtBQUtBOzs7O0FBYUE7QUFJQTs7Ozs7Ozs7OztBQTJCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7Ozs7QUFXQTtBQUVBO0FBQ0E7Ozs7QUFjQTtBQUlBO0FBS0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7OztBQW1CQTtBQUdBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBT0E7QUFJQTs7Ozs7Ozs7Ozs7QUFtQkE7QUFHQTs7Ozs7OztBQTJCQTtBQU1BOzs7Ozs7QUFRQTs7Ozs7O0FBWUE7Ozs7O0FBVUE7Ozs7Ozs7QUFnQkE7Ozs7O0FBUUE7Ozs7OztBQVlBOzs7Ozs7QUFTQTs7Ozs7O0FBWUE7Ozs7O0FBUUE7Ozs7OztBQVlBOzs7OztBQVFBOzs7Ozs7QUFZQTs7Ozs7QUFRQTs7Ozs7Ozs7QUFjQTtBQUVBO0FBQ0E7Ozs7Ozs7O0FBZUE7Ozs7OztBQVlBOzs7OztBQVNBOzs7Ozs7QUFZQTs7Ozs7QUFlQTs7Ozs7QUFXQTs7Ozs7Ozs7QUFlQTtBQU1BO0FBQ0E7Ozs7OztBQW9CQTs7Ozs7QUFZQTs7Ozs7QUFZQTs7Ozs7Ozs7O0FBa0JBO0FBRUE7Ozs7O0FBV0E7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7O0FBbUJBOzs7OztBQVVBOzs7OztBQVdBOzs7Ozs7QUFlQTs7Ozs7QUFhQTs7Ozs7QUFXQTs7Ozs7Ozs7OztBQWlCQTtBQUdBOzs7Ozs7Ozs7O0FBNkJBO0FBVUE7QUFDQTtBQUNBO0FBS0E7QUFNQTtBQU9BOzs7Ozs7O0FBZUE7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFXQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFtQkE7Ozs7OztBQWFBO0FBRUE7Ozs7Ozs7QUFhQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7QUF3QkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUdBO0FBTUE7QUFNQTs7O0FBV0E7Ozs7OztBQWFBOzs7Ozs7QUFhQTtBQUtBO0FBRUE7Ozs7Ozs7OztBQVlBOzs7Ozs7O0FBb0JBOzs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7QUEwQkE7QUFLQTtBQVlBOzs7Ozs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBOzs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7O0FBcUJBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7O0FBT0E7QUFNQTtBQUNBO0FBR0E7QUFDQTs7O0FBS0E7Ozs7QUFXQTtBQU1BOzs7QUFVQTs7Ozs7QUFZQTtBQUlBO0FBR0E7QUFHQTtBQUdBOzs7QUFNQTs7Ozs7O0FBWUE7Ozs7QUFpQkE7QUFLQTtBQUdBO0FBR0E7QUFDQTs7O0FBSUE7Ozs7Ozs7Ozs7QUFnQkE7QUFJQTtBQUtBO0FBQ0E7QUFLQTtBQU1BOzs7Ozs7Ozs7O0FBeUJBO0FBSUE7QUFDQTtBQU9BO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFnQ0E7QUFDQTtBQUVBO0FBR0E7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBSUE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBUUE7QUFJQTtBQUdBO0FBV0E7QUFLQTtBQUNBO0FBT0E7Ozs7Ozs7Ozs7OztBQXFCQTtBQVdBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVdBOztBQVVBOzs7QUFVQTs7Ozs7QUFhQTtBQUtBOzs7OztBQWVBOzs7Ozs7QUFhQTs7Ozs7OztBQWNBOzs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7OztBQXFCQTs7Ozs7O0FBbUJBO0FBR0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7QUFzQkE7QUFNQTtBQUNBO0FBS0E7QUFHQTtBQUdBOzs7OztBQU1BOzs7Ozs7Ozs7OztBQWlCQTtBQUtBOzs7Ozs7Ozs7OztBQWtCQTtBQVFBOzs7QUFpQkE7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBUUE7Ozs7O0FBZUE7Ozs7O0FBVUE7Ozs7Ozs7Ozs7O0FBa0JBO0FBTUE7QUFZQTtBQUdBO0FBQ0E7OztBQU1BOzs7OztBQWFBOzs7Ozs7Ozs7Ozs7QUFtQkE7OztBQXFCQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQWNBOzs7O0FBVUE7QUFRQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFJQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUdBO0FBR0E7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7OztBQWtCQTtBQU1BO0FBRUE7Ozs7Ozs7OztBQWlCQTs7Ozs7QUFZQTs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7QUFrQkE7Ozs7OztBQWFBO0FBVUE7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7O0FBNkJBO0FBY0E7QUFFQTtBQUNBO0FBYUE7QUFNQTs7Ozs7O0FBc0JBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7OztBQWdCQTs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7QUFTQTs7Ozs7OztBQVNBO0FBU0E7QUFDQTs7OztBQVVBOzs7Ozs7O0FBWUE7QUFFQTtBQU1BO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFLQTtBQUdBOzs7OztBQVVBOzs7OztBQU9BOzs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7QUFtQkE7Ozs7O0FBT0E7Ozs7Ozs7QUFTQTs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7OztBQWNBOztBQUtBOzs7Ozs7QUFPQTs7Ozs7O0FBU0E7Ozs7O0FBUUE7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTtBQUdBO0FBQ0E7QUFZQTs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7OztBQVVBO0FBVUE7QUFDQTtBQU9BO0FBQ0E7QUFHQTs7QUFRQTs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7O0FBWUE7Ozs7O0FBV0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFrQkE7QUFDQTs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7OztBQXVCQTs7OztBQU9BOzs7O0FBU0E7Ozs7QUFTQTs7Ozs7QUFXQTs7Ozs7O0FBUUE7Ozs7O0FBT0E7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7O0FBZUE7OztBQUtBOzs7Ozs7Ozs7Ozs7QUFhQTtBQWdCQTs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBcUJBOzs7QUFhQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFJQTtBQUNBO0FBSUE7QUFLQTtBQUdBO0FBWUE7QUFHQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFtQkE7OztBQWFBOzs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7O0FBdUJBO0FBY0E7QUFlQTtBQUNBO0FBQ0E7Ozs7QUFPQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFVQTs7OztBQU9BOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7O0FBYUE7Ozs7O0FBUUE7Ozs7O0FBVUE7Ozs7Ozs7QUFVQTs7Ozs7QUFRQTs7Ozs7OztBQVVBOzs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7OztBQVdBOzs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7QUFlQTs7OztBQWVBOzs7O0FBT0E7O0FBR0E7Ozs7OztBQVNBOzs7O0FBT0E7Ozs7QUFPQTs7OztBQU9BOzs7Ozs7O0FBVUE7Ozs7QUFPQTs7OztBQU9BOzs7O0FBT0E7Ozs7Ozs7Ozs7QUFhQTs7OztBQU9BOzs7OztBQVFBOzs7OztBQVFBOzs7OztBQVNBOzs7OztBQU9BOzs7OztBQU9BOzs7OztBQU9BOzs7OztBQU9BOzs7OztBQU9BOzs7Ozs7QUFRQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFVQTs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7OztBQWlCQTs7O0FBTUE7OztBQU1BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\nvar minDoc = __webpack_require__(17);\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19nbG9iYWxANC4zLjJAZ2xvYmFsL2RvY3VtZW50LmpzP2NjYjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvcExldmVsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge31cbnZhciBtaW5Eb2MgPSByZXF1aXJlKCdtaW4tZG9jdW1lbnQnKTtcblxudmFyIGRvY2N5O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRvY2N5ID0gZG9jdW1lbnQ7XG59IGVsc2Uge1xuICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcblxuICAgIGlmICghZG9jY3kpIHtcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb2NjeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvZG9jdW1lbnQuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbWluLWRvY3VtZW50IChpZ25vcmVkKT9lZDIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIG1pbi1kb2N1bWVudCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction clean(s) {\n  return s.replace(/\\n\\r?\\s*/g, '');\n}\n\nmodule.exports = function tsml(sa) {\n  var s = '',\n      i = 0;\n\n  for (; i < arguments.length; i++) {\n    s += clean(sa[i]) + (arguments[i + 1] || '');\n  }return s;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL190c21sQDEuMC4xQHRzbWwvdHNtbC5qcz84MmFkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsZWFuIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcblxccj9cXHMqL2csICcnKVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHNtbCAoc2EpIHtcbiAgdmFyIHMgPSAnJ1xuICAgICwgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBzICs9IGNsZWFuKHNhW2ldKSArIChhcmd1bWVudHNbaSArIDFdIHx8ICcnKVxuXG4gIHJldHVybiBzXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fdHNtbEAxLjAuMUB0c21sL3RzbWwuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = SafeParseTuple;\n\nfunction SafeParseTuple(obj, reviver) {\n    var json;\n    var error = null;\n\n    try {\n        json = JSON.parse(obj, reviver);\n    } catch (err) {\n        error = err;\n    }\n\n    return [error, json];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19zYWZlLWpzb24tcGFyc2VANC4wLjBAc2FmZS1qc29uLXBhcnNlL3R1cGxlLmpzP2I1YTEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBTYWZlUGFyc2VUdXBsZVxuXG5mdW5jdGlvbiBTYWZlUGFyc2VUdXBsZShvYmosIHJldml2ZXIpIHtcbiAgICB2YXIganNvblxuICAgIHZhciBlcnJvciA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKG9iaiwgcmV2aXZlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICByZXR1cm4gW2Vycm9yLCBqc29uXVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fc2FmZS1qc29uLXBhcnNlQDQuMC4wQHNhZmUtanNvbi1wYXJzZS90dXBsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar window = __webpack_require__(2);\nvar isFunction = __webpack_require__(5);\nvar parseHeaders = __webpack_require__(21);\nvar xtend = __webpack_require__(24);\n\nmodule.exports = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop;\ncreateXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n        options = initParams(uri, options, callback);\n        options.method = method.toUpperCase();\n        return _createXHR(options);\n    };\n});\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i]);\n    }\n}\n\nfunction isEmpty(obj) {\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) return false;\n    }\n    return true;\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri;\n\n    if (isFunction(options)) {\n        callback = options;\n        if (typeof uri === \"string\") {\n            params = { uri: uri };\n        }\n    } else {\n        params = xtend(options, { uri: uri });\n    }\n\n    params.callback = callback;\n    return params;\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback);\n    return _createXHR(options);\n}\n\nfunction _createXHR(options) {\n    if (typeof options.callback === \"undefined\") {\n        throw new Error(\"callback argument missing\");\n    }\n\n    var called = false;\n    var callback = function cbOnce(err, response, body) {\n        if (!called) {\n            called = true;\n            options.callback(err, response, body);\n        }\n    };\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0);\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined;\n\n        if (xhr.response) {\n            body = xhr.response;\n        } else {\n            body = xhr.responseText || getXml(xhr);\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body);\n            } catch (e) {}\n        }\n\n        return body;\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer);\n        if (!(evt instanceof Error)) {\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n        }\n        evt.statusCode = 0;\n        return callback(evt, failureResponse);\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return;\n        var status;\n        clearTimeout(timeoutTimer);\n        if (options.useXDR && xhr.status === undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200;\n        } else {\n            status = xhr.status === 1223 ? 204 : xhr.status;\n        }\n        var response = failureResponse;\n        var err = null;\n\n        if (status !== 0) {\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            };\n            if (xhr.getAllResponseHeaders) {\n                //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders());\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\");\n        }\n        return callback(err, response, response.body);\n    }\n\n    var xhr = options.xhr || null;\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest();\n        } else {\n            xhr = new createXHR.XMLHttpRequest();\n        }\n    }\n\n    var key;\n    var aborted;\n    var uri = xhr.url = options.uri || options.url;\n    var method = xhr.method = options.method || \"GET\";\n    var body = options.body || options.data;\n    var headers = xhr.headers = options.headers || {};\n    var sync = !!options.sync;\n    var isJson = false;\n    var timeoutTimer;\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    };\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true;\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json);\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange;\n    xhr.onload = loadFunc;\n    xhr.onerror = errorFunc;\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    };\n    xhr.onabort = function () {\n        aborted = true;\n    };\n    xhr.ontimeout = errorFunc;\n    xhr.open(method, uri, !sync, options.username, options.password);\n    //has to be after open\n    if (!sync) {\n        xhr.withCredentials = !!options.withCredentials;\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0) {\n        timeoutTimer = setTimeout(function () {\n            if (aborted) return;\n            aborted = true; //IE9 may still call readystatechange\n            xhr.abort(\"timeout\");\n            var e = new Error(\"XMLHttpRequest timeout\");\n            e.code = \"ETIMEDOUT\";\n            errorFunc(e);\n        }, options.timeout);\n    }\n\n    if (xhr.setRequestHeader) {\n        for (key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType;\n    }\n\n    if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n        options.beforeSend(xhr);\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null);\n\n    return xhr;\n}\n\nfunction getXml(xhr) {\n    if (xhr.responseType === \"document\") {\n        return xhr.responseXML;\n    }\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n    if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n        return xhr.responseXML;\n    }\n\n    return null;\n}\n\nfunction noop() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL194aHJAMi40LjBAeGhyL2luZGV4LmpzP2M4NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcImlzLWZ1bmN0aW9uXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZShcInBhcnNlLWhlYWRlcnNcIilcbnZhciB4dGVuZCA9IHJlcXVpcmUoXCJ4dGVuZFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0ID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKSkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxuZm9yRWFjaEFycmF5KFtcImdldFwiLCBcInB1dFwiLCBcInBvc3RcIiwgXCJwYXRjaFwiLCBcImhlYWRcIiwgXCJkZWxldGVcIl0sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGNyZWF0ZVhIUlttZXRob2QgPT09IFwiZGVsZXRlXCIgPyBcImRlbFwiIDogbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxuICAgIH1cbn0pXG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmope1xuICAgIGZvcih2YXIgaSBpbiBvYmope1xuICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gdXJpXG5cbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB1cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt1cmk6dXJpfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0geHRlbmQob3B0aW9ucywge3VyaTogdXJpfSlcbiAgICB9XG5cbiAgICBwYXJhbXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gY3JlYXRlWEhSKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKVxuICAgIH1cblxuICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNiT25jZShlcnIsIHJlc3BvbnNlLCBib2R5KXtcbiAgICAgICAgaWYoIWNhbGxlZCl7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobG9hZEZ1bmMsIDApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgZ2V0WG1sKHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwiVW5rbm93biBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgdmFyIHN0YXR1c1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZihvcHRpb25zLnVzZVhEUiAmJiB4aHIuc3RhdHVzPT09dW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxuICAgICAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG5cbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5XG4gICAgdmFyIGFib3J0ZWRcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG4gICAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgc3RhdHVzQ29kZTogMCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIHVybDogdXJpLFxuICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICB9XG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uID09PSB0cnVlID8gYm9keSA6IG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICBpZighc3luYykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIH1cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpXG4gICAgICAgICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSlcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IClcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cblxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIC8vIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIgc2VuZHMgXCJ1bmRlZmluZWRcIiB3aGVuIHNlbmQgaXMgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHZhbHVlLlxuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IHNwZWMgc2F5cyB0byBwYXNzIG51bGwgYXMgYm9keSB0byBpbmRpY2F0ZSBubyBib2R5XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXVndHVyL3hoci9pc3N1ZXMvMTAwLlxuICAgIHhoci5zZW5kKGJvZHkgfHwgbnVsbClcblxuICAgIHJldHVybiB4aHJcblxuXG59XG5cbmZ1bmN0aW9uIGdldFhtbCh4aHIpIHtcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUxcbiAgICB9XG4gICAgdmFyIGZpcmVmb3hCdWdUYWtlbkVmZmVjdCA9IHhoci5yZXNwb25zZVhNTCAmJiB4aHIucmVzcG9uc2VYTUwuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCJcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJcIiAmJiAhZmlyZWZveEJ1Z1Rha2VuRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VYTUxcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3hockAyLjQuMEB4aHIvaW5kZXguanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar trim = __webpack_require__(22),\n    forEach = __webpack_require__(23),\n    isArray = function isArray(arg) {\n  return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nmodule.exports = function (headers) {\n  if (!headers) return {};\n\n  var result = {};\n\n  forEach(trim(headers).split('\\n'), function (row) {\n    var index = row.indexOf(':'),\n        key = trim(row.slice(0, index)).toLowerCase(),\n        value = trim(row.slice(index + 1));\n\n    if (typeof result[key] === 'undefined') {\n      result[key] = value;\n    } else if (isArray(result[key])) {\n      result[key].push(value);\n    } else {\n      result[key] = [result[key], value];\n    }\n  });\n\n  return result;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19wYXJzZS1oZWFkZXJzQDIuMC4xQHBhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcz8yZTc3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3BhcnNlLWhlYWRlcnNAMi4wLjFAcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports = module.exports = trim;\n\nfunction trim(str) {\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function (str) {\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function (str) {\n  return str.replace(/\\s*$/, '');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL190cmltQDAuMC4xQHRyaW0vaW5kZXguanM/ODJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL190cmltQDAuMC4xQHRyaW0vaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isFunction = __webpack_require__(5);\n\nmodule.exports = forEach;\n\nvar toString = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction forEach(list, iterator, context) {\n    if (!isFunction(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    if (arguments.length < 3) {\n        context = this;\n    }\n\n    if (toString.call(list) === '[object Array]') forEachArray(list, iterator, context);else if (typeof list === 'string') forEachString(list, iterator, context);else forEachObject(list, iterator, context);\n}\n\nfunction forEachArray(array, iterator, context) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            iterator.call(context, array[i], i, array);\n        }\n    }\n}\n\nfunction forEachString(string, iterator, context) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        iterator.call(context, string.charAt(i), i, string);\n    }\n}\n\nfunction forEachObject(object, iterator, context) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            iterator.call(context, object[k], k, object);\n        }\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL19mb3ItZWFjaEAwLjMuMkBmb3ItZWFjaC9pbmRleC5qcz9jNzUxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBjb250ZXh0ID0gdGhpc1xuICAgIH1cbiAgICBcbiAgICBpZiAodG9TdHJpbmcuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlXG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W2ldLCBpLCBhcnJheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fZm9yLWVhY2hAMC4zLjJAZm9yLWVhY2gvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = extend;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL194dGVuZEA0LjAuMUB4dGVuZC9pbW11dGFibGUuanM/MmJiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9feHRlbmRANC4wLjFAeHRlbmQvaW1tdXRhYmxlLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Default exports for Node. Export the extended versions of VTTCue and\n// VTTRegion in Node since we likely want the capability to convert back and\n// forth between JSON. If we don't then it's not that big of a deal since we're\n// off browser.\n\nvar window = __webpack_require__(2);\n\nvar vttjs = module.exports = {\n  WebVTT: __webpack_require__(26),\n  VTTCue: __webpack_require__(27),\n  VTTRegion: __webpack_require__(28)\n};\n\nwindow.vttjs = vttjs;\nwindow.WebVTT = vttjs.WebVTT;\n\nvar cueShim = vttjs.VTTCue;\nvar regionShim = vttjs.VTTRegion;\nvar nativeVTTCue = window.VTTCue;\nvar nativeVTTRegion = window.VTTRegion;\n\nvttjs.shim = function () {\n  window.VTTCue = cueShim;\n  window.VTTRegion = regionShim;\n};\n\nvttjs.restore = function () {\n  window.VTTCue = nativeVTTCue;\n  window.VTTRegion = nativeVTTRegion;\n};\n\nif (!window.VTTCue) {\n  vttjs.shim();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL2Jyb3dzZXItaW5kZXguanM/YTk2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vIERlZmF1bHQgZXhwb3J0cyBmb3IgTm9kZS4gRXhwb3J0IHRoZSBleHRlbmRlZCB2ZXJzaW9ucyBvZiBWVFRDdWUgYW5kXG4vLyBWVFRSZWdpb24gaW4gTm9kZSBzaW5jZSB3ZSBsaWtlbHkgd2FudCB0aGUgY2FwYWJpbGl0eSB0byBjb252ZXJ0IGJhY2sgYW5kXG4vLyBmb3J0aCBiZXR3ZWVuIEpTT04uIElmIHdlIGRvbid0IHRoZW4gaXQncyBub3QgdGhhdCBiaWcgb2YgYSBkZWFsIHNpbmNlIHdlJ3JlXG4vLyBvZmYgYnJvd3Nlci5cblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKTtcblxudmFyIHZ0dGpzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlZUVDogcmVxdWlyZShcIi4vdnR0LmpzXCIpLFxuICBWVFRDdWU6IHJlcXVpcmUoXCIuL3Z0dGN1ZS5qc1wiKSxcbiAgVlRUUmVnaW9uOiByZXF1aXJlKFwiLi92dHRyZWdpb24uanNcIilcbn07XG5cbndpbmRvdy52dHRqcyA9IHZ0dGpzO1xud2luZG93LldlYlZUVCA9IHZ0dGpzLldlYlZUVDtcblxudmFyIGN1ZVNoaW0gPSB2dHRqcy5WVFRDdWU7XG52YXIgcmVnaW9uU2hpbSA9IHZ0dGpzLlZUVFJlZ2lvbjtcbnZhciBuYXRpdmVWVFRDdWUgPSB3aW5kb3cuVlRUQ3VlO1xudmFyIG5hdGl2ZVZUVFJlZ2lvbiA9IHdpbmRvdy5WVFRSZWdpb247XG5cbnZ0dGpzLnNoaW0gPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LlZUVEN1ZSA9IGN1ZVNoaW07XG4gIHdpbmRvdy5WVFRSZWdpb24gPSByZWdpb25TaGltO1xufTtcblxudnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gbmF0aXZlVlRUQ3VlO1xuICB3aW5kb3cuVlRUUmVnaW9uID0gbmF0aXZlVlRUUmVnaW9uO1xufTtcblxuaWYgKCF3aW5kb3cuVlRUQ3VlKSB7XG4gIHZ0dGpzLnNoaW0oKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3ZpZGVvanMtdnR0LmpzQDAuMTIuNEB2aWRlb2pzLXZ0dC5qcy9saWIvYnJvd3Nlci1pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\nvar _objCreate = Object.create || function () {\n  function F() {}\n  return function (o) {\n    if (arguments.length !== 1) {\n      throw new Error('Object.create shim only accepts one parameter.');\n    }\n    F.prototype = o;\n    return new F();\n  };\n}();\n\n// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n// See ParsingError.Errors below for acceptable errors.\nfunction ParsingError(errorData, message) {\n  this.name = \"ParsingError\";\n  this.code = errorData.code;\n  this.message = message || errorData.message;\n}\nParsingError.prototype = _objCreate(Error.prototype);\nParsingError.prototype.constructor = ParsingError;\n\n// ParsingError metadata for acceptable ParsingErrors.\nParsingError.Errors = {\n  BadSignature: {\n    code: 0,\n    message: \"Malformed WebVTT signature.\"\n  },\n  BadTimeStamp: {\n    code: 1,\n    message: \"Malformed time stamp.\"\n  }\n};\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0, m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = _objCreate(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function set(k, v) {\n    if (!this.get(k) && v !== \"\") {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function has(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function percent(k, v) {\n    var m;\n    if (m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== \"string\") {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n        case \"region\":\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case \"vertical\":\n          settings.alt(k, v, [\"rl\", \"lr\"]);\n          break;\n        case \"line\":\n          var vals = v.split(\",\"),\n              vals0 = vals[0];\n          settings.integer(k, vals0);\n          settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n          settings.alt(k, vals0, [\"auto\"]);\n          if (vals.length === 2) {\n            settings.alt(\"lineAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n          }\n          break;\n        case \"position\":\n          vals = v.split(\",\");\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt(\"positionAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n          }\n          break;\n        case \"size\":\n          settings.percent(k, v);\n          break;\n        case \"align\":\n          settings.alt(k, v, [\"start\", \"middle\", \"end\", \"left\", \"right\"]);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get(\"region\", null);\n    cue.vertical = settings.get(\"vertical\", \"\");\n    cue.line = settings.get(\"line\", \"auto\");\n    cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n    cue.snapToLines = settings.get(\"snapToLines\", true);\n    cue.size = settings.get(\"size\", 100);\n    cue.align = settings.get(\"align\", \"middle\");\n    cue.position = settings.get(\"position\", {\n      start: 0,\n      left: 0,\n      middle: 50,\n      end: 100,\n      right: 100\n    }, cue.align);\n    cue.positionAlign = settings.get(\"positionAlign\", {\n      start: \"start\",\n      left: \"start\",\n      middle: \"middle\",\n      end: \"end\",\n      right: \"end\"\n    }, cue.align);\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, \"\");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== \"-->\") {\n    // (3) next characters must match \"-->\"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nvar ESCAPE = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\",\n  \"&nbsp;\": \"\\xA0\"\n};\n\nvar TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\"\n};\n\nvar TAG_ANNOTATION = {\n  v: \"title\",\n  lang: \"lang\"\n};\n\nvar NEEDS_PARENT = {\n  rt: \"ruby\"\n};\n\n// Parse content into a document fragment.\nfunction parseContent(window, input) {\n  function nextToken() {\n    // Check for end-of-string.\n    if (!input) {\n      return null;\n    }\n\n    // Consume 'n' characters from the input.\n    function consume(result) {\n      input = input.substr(result.length);\n      return result;\n    }\n\n    var m = input.match(/^([^<]*)(<[^>]+>?)?/);\n    // If there is some text before the next tag, return it, otherwise return\n    // the tag.\n    return consume(m[1] ? m[1] : m[2]);\n  }\n\n  // Unescape a string 's'.\n  function unescape1(e) {\n    return ESCAPE[e];\n  }\n  function unescape(s) {\n    while (m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/)) {\n      s = s.replace(m[0], unescape1);\n    }\n    return s;\n  }\n\n  function shouldAdd(current, element) {\n    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\n  }\n\n  // Create an element for this tag.\n  function createElement(type, annotation) {\n    var tagName = TAG_NAME[type];\n    if (!tagName) {\n      return null;\n    }\n    var element = window.document.createElement(tagName);\n    element.localName = tagName;\n    var name = TAG_ANNOTATION[type];\n    if (name && annotation) {\n      element[name] = annotation.trim();\n    }\n    return element;\n  }\n\n  var rootDiv = window.document.createElement(\"div\"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n\n  while ((t = nextToken()) !== null) {\n    if (t[0] === '<') {\n      if (t[1] === \"/\") {\n        // If the closing tag matches, move back up to the parent node.\n        if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n          tagStack.pop();\n          current = current.parentNode;\n        }\n        // Otherwise just ignore the end tag.\n        continue;\n      }\n      var ts = parseTimeStamp(t.substr(1, t.length - 2));\n      var node;\n      if (ts) {\n        // Timestamps are lead nodes as well.\n        node = window.document.createProcessingInstruction(\"timestamp\", ts);\n        current.appendChild(node);\n        continue;\n      }\n      var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n      // If we can't parse the tag, skip to the next tag.\n      if (!m) {\n        continue;\n      }\n      // Try to construct an element, and ignore the tag if we couldn't.\n      node = createElement(m[1], m[3]);\n      if (!node) {\n        continue;\n      }\n      // Determine if the tag should be added based on the context of where it\n      // is placed in the cuetext.\n      if (!shouldAdd(current, node)) {\n        continue;\n      }\n      // Set the class list (as a list of classes, separated by space).\n      if (m[2]) {\n        node.className = m[2].substr(1).replace('.', ' ');\n      }\n      // Append the node to the current node, and enter the scope of the new\n      // node.\n      tagStack.push(m[1]);\n      current.appendChild(node);\n      current = node;\n      continue;\n    }\n\n    // Text nodes are leaf nodes.\n    current.appendChild(window.document.createTextNode(unescape(t)));\n  }\n\n  return rootDiv;\n}\n\n// This is a list of all the Unicode characters that have a strong\n// right-to-left category. What this means is that these characters are\n// written right-to-left for sure. It was generated by pulling all the strong\n// right-to-left characters out of the Unicode data table. That table can\n// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\nfunction isStrongRTLChar(charCode) {\n  for (var i = 0; i < strongRTLRanges.length; i++) {\n    var currentRange = strongRTLRanges[i];\n    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction determineBidi(cueDiv) {\n  var nodeStack = [],\n      text = \"\",\n      charCode;\n\n  if (!cueDiv || !cueDiv.childNodes) {\n    return \"ltr\";\n  }\n\n  function pushNodes(nodeStack, node) {\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      nodeStack.push(node.childNodes[i]);\n    }\n  }\n\n  function nextTextNode(nodeStack) {\n    if (!nodeStack || !nodeStack.length) {\n      return null;\n    }\n\n    var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n    if (text) {\n      // TODO: This should match all unicode type B characters (paragraph\n      // separator characters). See issue #115.\n      var m = text.match(/^.*(\\n|\\r)/);\n      if (m) {\n        nodeStack.length = 0;\n        return m[0];\n      }\n      return text;\n    }\n    if (node.tagName === \"ruby\") {\n      return nextTextNode(nodeStack);\n    }\n    if (node.childNodes) {\n      pushNodes(nodeStack, node);\n      return nextTextNode(nodeStack);\n    }\n  }\n\n  pushNodes(nodeStack, cueDiv);\n  while (text = nextTextNode(nodeStack)) {\n    for (var i = 0; i < text.length; i++) {\n      charCode = text.charCodeAt(i);\n      if (isStrongRTLChar(charCode)) {\n        return \"rtl\";\n      }\n    }\n  }\n  return \"ltr\";\n}\n\nfunction computeLinePos(cue) {\n  if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\n    return cue.line;\n  }\n  if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\n    return -1;\n  }\n  var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n    if (trackList[i].mode === \"showing\") {\n      count++;\n    }\n  }\n  return ++count * -1;\n}\n\nfunction StyleBox() {}\n\n// Apply styles to a div. If there is no div passed then it defaults to the\n// div on 'this'.\nStyleBox.prototype.applyStyles = function (styles, div) {\n  div = div || this.div;\n  for (var prop in styles) {\n    if (styles.hasOwnProperty(prop)) {\n      div.style[prop] = styles[prop];\n    }\n  }\n};\n\nStyleBox.prototype.formatStyle = function (val, unit) {\n  return val === 0 ? 0 : val + unit;\n};\n\n// Constructs the computed display state of the cue (a div). Places the div\n// into the overlay which should be a block level element (usually a div).\nfunction CueStyleBox(window, cue, styleOptions) {\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n  var color = \"rgba(255, 255, 255, 1)\";\n  var backgroundColor = \"rgba(0, 0, 0, 0.8)\";\n\n  if (isIE8) {\n    color = \"rgb(255, 255, 255)\";\n    backgroundColor = \"rgb(0, 0, 0)\";\n  }\n\n  StyleBox.call(this);\n  this.cue = cue;\n\n  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n  // have inline positioning and will function as the cue background box.\n  this.cueDiv = parseContent(window, cue.text);\n  var styles = {\n    color: color,\n    backgroundColor: backgroundColor,\n    position: \"relative\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    display: \"inline\"\n  };\n\n  if (!isIE8) {\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\";\n    styles.unicodeBidi = \"plaintext\";\n  }\n  this.applyStyles(styles, this.cueDiv);\n\n  // Create an absolutely positioned div that will be used to position the cue\n  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n  // mirrors of them except \"middle\" which is \"center\" in CSS.\n  this.div = window.document.createElement(\"div\");\n  styles = {\n    textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n    font: styleOptions.font,\n    whiteSpace: \"pre-line\",\n    position: \"absolute\"\n  };\n\n  if (!isIE8) {\n    styles.direction = determineBidi(this.cueDiv);\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\".stylesunicodeBidi = \"plaintext\";\n  }\n\n  this.applyStyles(styles);\n\n  this.div.appendChild(this.cueDiv);\n\n  // Calculate the distance from the reference edge of the viewport to the text\n  // position of the cue box. The reference edge will be resolved later when\n  // the box orientation styles are applied.\n  var textPos = 0;\n  switch (cue.positionAlign) {\n    case \"start\":\n      textPos = cue.position;\n      break;\n    case \"middle\":\n      textPos = cue.position - cue.size / 2;\n      break;\n    case \"end\":\n      textPos = cue.position - cue.size;\n      break;\n  }\n\n  // Horizontal box orientation; textPos is the distance from the left edge of the\n  // area to the left edge of the box and cue.size is the distance extending to\n  // the right from there.\n  if (cue.vertical === \"\") {\n    this.applyStyles({\n      left: this.formatStyle(textPos, \"%\"),\n      width: this.formatStyle(cue.size, \"%\")\n    });\n    // Vertical box orientation; textPos is the distance from the top edge of the\n    // area to the top edge of the box and cue.size is the height extending\n    // downwards from there.\n  } else {\n    this.applyStyles({\n      top: this.formatStyle(textPos, \"%\"),\n      height: this.formatStyle(cue.size, \"%\")\n    });\n  }\n\n  this.move = function (box) {\n    this.applyStyles({\n      top: this.formatStyle(box.top, \"px\"),\n      bottom: this.formatStyle(box.bottom, \"px\"),\n      left: this.formatStyle(box.left, \"px\"),\n      right: this.formatStyle(box.right, \"px\"),\n      height: this.formatStyle(box.height, \"px\"),\n      width: this.formatStyle(box.width, \"px\")\n    });\n  };\n}\nCueStyleBox.prototype = _objCreate(StyleBox.prototype);\nCueStyleBox.prototype.constructor = CueStyleBox;\n\n// Represents the co-ordinates of an Element in a way that we can easily\n// compute things with such as if it overlaps or intersects with another Element.\n// Can initialize it with either a StyleBox or another BoxPosition.\nfunction BoxPosition(obj) {\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n\n  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n  // was passed in and we need to copy the results of 'getBoundingClientRect'\n  // as the object returned is readonly. All co-ordinate values are in reference\n  // to the viewport origin (top left).\n  var lh, height, width, top;\n  if (obj.div) {\n    height = obj.div.offsetHeight;\n    width = obj.div.offsetWidth;\n    top = obj.div.offsetTop;\n\n    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\n    obj = obj.div.getBoundingClientRect();\n    // In certain cases the outter div will be slightly larger then the sum of\n    // the inner div's lines. This could be due to bold text, etc, on some platforms.\n    // In this case we should get the average line height and use that. This will\n    // result in the desired behaviour.\n    lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\n  }\n  this.left = obj.left;\n  this.right = obj.right;\n  this.top = obj.top || top;\n  this.height = obj.height || height;\n  this.bottom = obj.bottom || top + (obj.height || height);\n  this.width = obj.width || width;\n  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n\n  if (isIE8 && !this.lineHeight) {\n    this.lineHeight = 13;\n  }\n}\n\n// Move the box along a particular axis. Optionally pass in an amount to move\n// the box. If no amount is passed then the default is the line height of the\n// box.\nBoxPosition.prototype.move = function (axis, toMove) {\n  toMove = toMove !== undefined ? toMove : this.lineHeight;\n  switch (axis) {\n    case \"+x\":\n      this.left += toMove;\n      this.right += toMove;\n      break;\n    case \"-x\":\n      this.left -= toMove;\n      this.right -= toMove;\n      break;\n    case \"+y\":\n      this.top += toMove;\n      this.bottom += toMove;\n      break;\n    case \"-y\":\n      this.top -= toMove;\n      this.bottom -= toMove;\n      break;\n  }\n};\n\n// Check if this box overlaps another box, b2.\nBoxPosition.prototype.overlaps = function (b2) {\n  return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\n};\n\n// Check if this box overlaps any other boxes in boxes.\nBoxPosition.prototype.overlapsAny = function (boxes) {\n  for (var i = 0; i < boxes.length; i++) {\n    if (this.overlaps(boxes[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if this box is within another box.\nBoxPosition.prototype.within = function (container) {\n  return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\n};\n\n// Check if this box is entirely within the container or it is overlapping\n// on the edge opposite of the axis direction passed. For example, if \"+x\" is\n// passed and the box is overlapping on the left edge of the container, then\n// return true.\nBoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\n  switch (axis) {\n    case \"+x\":\n      return this.left < container.left;\n    case \"-x\":\n      return this.right > container.right;\n    case \"+y\":\n      return this.top < container.top;\n    case \"-y\":\n      return this.bottom > container.bottom;\n  }\n};\n\n// Find the percentage of the area that this box is overlapping with another\n// box.\nBoxPosition.prototype.intersectPercentage = function (b2) {\n  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n  return intersectArea / (this.height * this.width);\n};\n\n// Convert the positions from this box to CSS compatible positions using\n// the reference container's positions. This has to be done because this\n// box's positions are in reference to the viewport origin, whereas, CSS\n// values are in referecne to their respective edges.\nBoxPosition.prototype.toCSSCompatValues = function (reference) {\n  return {\n    top: this.top - reference.top,\n    bottom: reference.bottom - this.bottom,\n    left: this.left - reference.left,\n    right: reference.right - this.right,\n    height: this.height,\n    width: this.width\n  };\n};\n\n// Get an object that represents the box's position without anything extra.\n// Can pass a StyleBox, HTMLElement, or another BoxPositon.\nBoxPosition.getSimpleBoxPosition = function (obj) {\n  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n  obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\n  var ret = {\n    left: obj.left,\n    right: obj.right,\n    top: obj.top || top,\n    height: obj.height || height,\n    bottom: obj.bottom || top + (obj.height || height),\n    width: obj.width || width\n  };\n  return ret;\n};\n\n// Move a StyleBox to its specified, or next best, position. The containerBox\n// is the box that contains the StyleBox, such as a div. boxPositions are\n// a list of other boxes that the styleBox can't overlap with.\nfunction moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n  // Find the best position for a cue box, b, on the video. The axis parameter\n  // is a list of axis, the order of which, it will move the box along. For example:\n  // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n  // direction. If it doesn't find a good position for it there it will then move\n  // it along the x axis in the negative direction.\n  function findBestPosition(b, axis) {\n    var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n    for (var i = 0; i < axis.length; i++) {\n      while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\n        b.move(axis[i]);\n      }\n      // We found a spot where we aren't overlapping anything. This is our\n      // best position.\n      if (b.within(containerBox)) {\n        return b;\n      }\n      var p = b.intersectPercentage(containerBox);\n      // If we're outside the container box less then we were on our last try\n      // then remember this position as the best position.\n      if (percentage > p) {\n        bestPosition = new BoxPosition(b);\n        percentage = p;\n      }\n      // Reset the box position to the specified position.\n      b = new BoxPosition(specifiedPosition);\n    }\n    return bestPosition || specifiedPosition;\n  }\n\n  var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n  // If we have a line number to align the cue to.\n  if (cue.snapToLines) {\n    var size;\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n\n    var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n    // If the specified intial position is greater then the max position then\n    // clamp the box to the amount of steps it would take for the box to\n    // reach the max position.\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    // If computed line position returns negative then line numbers are\n    // relative to the bottom of the video instead of the top. Therefore, we\n    // need to increase our initial position by the length or width of the\n    // video, depending on the writing direction, and reverse our axis directions.\n    if (linePos < 0) {\n      position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n      axis = axis.reverse();\n    }\n\n    // Move the box to the specified position. This may not be its best\n    // position.\n    boxPosition.move(initialAxis, position);\n  } else {\n    // If we have a percentage line value for the cue.\n    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\n\n    switch (cue.lineAlign) {\n      case \"middle\":\n        linePos -= calculatedPercentage / 2;\n        break;\n      case \"end\":\n        linePos -= calculatedPercentage;\n        break;\n    }\n\n    // Apply initial line position to the cue box.\n    switch (cue.vertical) {\n      case \"\":\n        styleBox.applyStyles({\n          top: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"rl\":\n        styleBox.applyStyles({\n          left: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"lr\":\n        styleBox.applyStyles({\n          right: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n    }\n\n    axis = [\"+y\", \"-x\", \"+x\", \"-y\"];\n\n    // Get the box position again after we've applied the specified positioning\n    // to it.\n    boxPosition = new BoxPosition(styleBox);\n  }\n\n  var bestPosition = findBestPosition(boxPosition, axis);\n  styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n}\n\nfunction WebVTT() {}\n// Nothing\n\n\n// Helper to allow strings to be decoded instead of the default binary utf8 data.\nWebVTT.StringDecoder = function () {\n  return {\n    decode: function decode(data) {\n      if (!data) {\n        return \"\";\n      }\n      if (typeof data !== \"string\") {\n        throw new Error(\"Error - expected string data.\");\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n};\n\nWebVTT.convertCueToDOMTree = function (window, cuetext) {\n  if (!window || !cuetext) {\n    return null;\n  }\n  return parseContent(window, cuetext);\n};\n\nvar FONT_SIZE_PERCENT = 0.05;\nvar FONT_STYLE = \"sans-serif\";\nvar CUE_BACKGROUND_PADDING = \"1.5%\";\n\n// Runs the processing model over the cues and regions passed to it.\n// @param overlay A block level element (usually a div) that the computed cues\n//                and regions will be placed into.\nWebVTT.processCues = function (window, cues, overlay) {\n  if (!window || !cues || !overlay) {\n    return null;\n  }\n\n  // Remove all previous children.\n  while (overlay.firstChild) {\n    overlay.removeChild(overlay.firstChild);\n  }\n\n  var paddedOverlay = window.document.createElement(\"div\");\n  paddedOverlay.style.position = \"absolute\";\n  paddedOverlay.style.left = \"0\";\n  paddedOverlay.style.right = \"0\";\n  paddedOverlay.style.top = \"0\";\n  paddedOverlay.style.bottom = \"0\";\n  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n  overlay.appendChild(paddedOverlay);\n\n  // Determine if we need to compute the display states of the cues. This could\n  // be the case if a cue's state has been changed since the last computation or\n  // if it has not been computed yet.\n  function shouldCompute(cues) {\n    for (var i = 0; i < cues.length; i++) {\n      if (cues[i].hasBeenReset || !cues[i].displayState) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // We don't need to recompute the cues' display states. Just reuse them.\n  if (!shouldCompute(cues)) {\n    for (var i = 0; i < cues.length; i++) {\n      paddedOverlay.appendChild(cues[i].displayState);\n    }\n    return;\n  }\n\n  var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n  var styleOptions = {\n    font: fontSize + \"px \" + FONT_STYLE\n  };\n\n  (function () {\n    var styleBox, cue;\n\n    for (var i = 0; i < cues.length; i++) {\n      cue = cues[i];\n\n      // Compute the intial position and styles of the cue div.\n      styleBox = new CueStyleBox(window, cue, styleOptions);\n      paddedOverlay.appendChild(styleBox.div);\n\n      // Move the cue div to it's correct line position.\n      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n      // Remember the computed div so that we don't have to recompute it later\n      // if we don't have too.\n      cue.displayState = styleBox.div;\n\n      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n    }\n  })();\n};\n\nWebVTT.Parser = function (window, vttjs, decoder) {\n  if (!decoder) {\n    decoder = vttjs;\n    vttjs = {};\n  }\n  if (!vttjs) {\n    vttjs = {};\n  }\n\n  this.window = window;\n  this.vttjs = vttjs;\n  this.state = \"INITIAL\";\n  this.buffer = \"\";\n  this.decoder = decoder || new TextDecoder(\"utf8\");\n  this.regionList = [];\n};\n\nWebVTT.Parser.prototype = {\n  // If the error is a ParsingError then report it to the consumer if\n  // possible. If it's not a ParsingError then throw it like normal.\n  reportOrThrowError: function reportOrThrowError(e) {\n    if (e instanceof ParsingError) {\n      this.onparsingerror && this.onparsingerror(e);\n    } else {\n      throw e;\n    }\n  },\n  parse: function parse(data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, { stream: true });\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.4 WebVTT region and WebVTT region settings syntax\n    function parseRegion(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case \"id\":\n            settings.set(k, v);\n            break;\n          case \"width\":\n            settings.percent(k, v);\n            break;\n          case \"lines\":\n            settings.integer(k, v);\n            break;\n          case \"regionanchor\":\n          case \"viewportanchor\":\n            var xy = v.split(',');\n            if (xy.length !== 2) {\n              break;\n            }\n            // We have to make sure both x and y parse, so use a temporary\n            // settings object here.\n            var anchor = new Settings();\n            anchor.percent(\"x\", xy[0]);\n            anchor.percent(\"y\", xy[1]);\n            if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n              break;\n            }\n            settings.set(k + \"X\", anchor.get(\"x\"));\n            settings.set(k + \"Y\", anchor.get(\"y\"));\n            break;\n          case \"scroll\":\n            settings.alt(k, v, [\"up\"]);\n            break;\n        }\n      }, /=/, /\\s/);\n\n      // Create the region, using default values for any values that were not\n      // specified.\n      if (settings.has(\"id\")) {\n        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n        region.width = settings.get(\"width\", 100);\n        region.lines = settings.get(\"lines\", 3);\n        region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n        region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n        region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n        region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n        region.scroll = settings.get(\"scroll\", \"\");\n        // Register the region.\n        self.onregion && self.onregion(region);\n        // Remember the VTTRegion for later in case we parse any VTTCues that\n        // reference it.\n        self.regionList.push({\n          id: settings.get(\"id\"),\n          region: region\n        });\n      }\n    }\n\n    // draft-pantos-http-live-streaming-20\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n    // 3.5 WebVTT\n    function parseTimestampMap(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case \"MPEGT\":\n            settings.integer(k + 'S', v);\n            break;\n          case \"LOCA\":\n            settings.set(k + 'L', parseTimeStamp(v));\n            break;\n        }\n      }, /[^\\d]:/, /,/);\n\n      self.ontimestampmap && self.ontimestampmap({\n        \"MPEGTS\": settings.get(\"MPEGTS\"),\n        \"LOCAL\": settings.get(\"LOCAL\")\n      });\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      if (input.match(/X-TIMESTAMP-MAP/)) {\n        // This line contains HLS X-TIMESTAMP-MAP metadata\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"X-TIMESTAMP-MAP\":\n              parseTimestampMap(v);\n              break;\n          }\n        }, /=/);\n      } else {\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"Region\":\n              // 3.3 WebVTT region metadata header syntax\n              parseRegion(v);\n              break;\n          }\n        }, /:/);\n      }\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === \"INITIAL\") {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self.state = \"HEADER\";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n          case \"HEADER\":\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              self.state = \"ID\";\n            }\n            continue;\n          case \"NOTE\":\n            // Ignore NOTE blocks.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n          case \"ID\":\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              self.state = \"NOTE\";\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n            self.state = \"CUE\";\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf(\"-->\") === -1) {\n              self.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /*falls through*/\n          case \"CUE\":\n            // 40 - Collect cue timings and settings.\n            try {\n              parseCue(line, self.cue, self.regionList);\n            } catch (e) {\n              self.reportOrThrowError(e);\n              // In case of an error ignore rest of the cue.\n              self.cue = null;\n              self.state = \"BADCUE\";\n              continue;\n            }\n            self.state = \"CUETEXT\";\n            continue;\n          case \"CUETEXT\":\n            var hasSubstring = line.indexOf(\"-->\") !== -1;\n            // 34 - If we have an empty line then report the cue.\n            // 35 - If we have the special substring '-->' then report the cue,\n            // but do not collect the line as we need to process the current\n            // one as a new cue.\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n              // We are done parsing self cue.\n              self.oncue && self.oncue(self.cue);\n              self.cue = null;\n              self.state = \"ID\";\n              continue;\n            }\n            if (self.cue.text) {\n              self.cue.text += \"\\n\";\n            }\n            self.cue.text += line;\n            continue;\n          case \"BADCUE\":\n            // BADCUE\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  },\n  flush: function flush() {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === \"HEADER\") {\n        self.buffer += \"\\n\\n\";\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === \"INITIAL\") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n    }\n    self.onflush && self.onflush();\n    return this;\n  }\n};\n\nmodule.exports = WebVTT;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dC5qcz9iYzk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogLSotIE1vZGU6IEphdmE7IHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cbnZhciBfb2JqQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEYoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdC5jcmVhdGUgc2hpbSBvbmx5IGFjY2VwdHMgb25lIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgRi5wcm90b3R5cGUgPSBvO1xuICAgIHJldHVybiBuZXcgRigpO1xuICB9O1xufSkoKTtcblxuLy8gQ3JlYXRlcyBhIG5ldyBQYXJzZXJFcnJvciBvYmplY3QgZnJvbSBhbiBlcnJvckRhdGEgb2JqZWN0LiBUaGUgZXJyb3JEYXRhXG4vLyBvYmplY3Qgc2hvdWxkIGhhdmUgZGVmYXVsdCBjb2RlIGFuZCBtZXNzYWdlIHByb3BlcnRpZXMuIFRoZSBkZWZhdWx0IG1lc3NhZ2Vcbi8vIHByb3BlcnR5IGNhbiBiZSBvdmVycmlkZW4gYnkgcGFzc2luZyBpbiBhIG1lc3NhZ2UgcGFyYW1ldGVyLlxuLy8gU2VlIFBhcnNpbmdFcnJvci5FcnJvcnMgYmVsb3cgZm9yIGFjY2VwdGFibGUgZXJyb3JzLlxuZnVuY3Rpb24gUGFyc2luZ0Vycm9yKGVycm9yRGF0YSwgbWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlBhcnNpbmdFcnJvclwiO1xuICB0aGlzLmNvZGUgPSBlcnJvckRhdGEuY29kZTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBlcnJvckRhdGEubWVzc2FnZTtcbn1cblBhcnNpbmdFcnJvci5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5QYXJzaW5nRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2luZ0Vycm9yO1xuXG4vLyBQYXJzaW5nRXJyb3IgbWV0YWRhdGEgZm9yIGFjY2VwdGFibGUgUGFyc2luZ0Vycm9ycy5cblBhcnNpbmdFcnJvci5FcnJvcnMgPSB7XG4gIEJhZFNpZ25hdHVyZToge1xuICAgIGNvZGU6IDAsXG4gICAgbWVzc2FnZTogXCJNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS5cIlxuICB9LFxuICBCYWRUaW1lU3RhbXA6IHtcbiAgICBjb2RlOiAxLFxuICAgIG1lc3NhZ2U6IFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAuXCJcbiAgfVxufTtcblxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cbmZ1bmN0aW9uIHBhcnNlVGltZVN0YW1wKGlucHV0KSB7XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xuICAgIHJldHVybiAoaCB8IDApICogMzYwMCArIChtIHwgMCkgKiA2MCArIChzIHwgMCkgKyAoZiB8IDApIC8gMTAwMDtcbiAgfVxuXG4gIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFxkKyk6KFxcZHsyfSkoOlxcZHsyfSk/XFwuKFxcZHszfSkvKTtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobVszXSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgbVszXS5yZXBsYWNlKFwiOlwiLCBcIlwiKSwgbVs0XSk7XG4gIH0gZWxzZSBpZiAobVsxXSA+IDU5KSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdLlttaWxsaXNlY29uZHNdXG4gICAgLy8gRmlyc3QgcG9zaXRpb24gaXMgaG91cnMgYXMgaXQncyBvdmVyIDU5LlxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCAgbVs0XSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFttaW51dGVzXTpbc2Vjb25kc10uW21pbGxpc2Vjb25kc11cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XG4gIH1cbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XG4gIHRoaXMudmFsdWVzID0gX29iakNyZWF0ZShudWxsKTtcbn1cblxuU2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvLyBPbmx5IGFjY2VwdCB0aGUgZmlyc3QgYXNzaWdubWVudCB0byBhbnkga2V5LlxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09IFwiXCIpIHtcbiAgICAgIHRoaXMudmFsdWVzW2tdID0gdjtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQ6IGZ1bmN0aW9uKGssIGRmbHQsIGRlZmF1bHRLZXkpIHtcbiAgICBpZiAoZGVmYXVsdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHQ7XG4gIH0sXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIHZhbHVlIGZvciBhIGtleS5cbiAgaGFzOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxuICBhbHQ6IGZ1bmN0aW9uKGssIHYsIGEpIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICh2ID09PSBhW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgaW50ZWdlcjogZnVuY3Rpb24oaywgdikge1xuICAgIGlmICgvXi0/XFxkKyQvLnRlc3QodikpIHsgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH0sXG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgcGVyY2VudDogZnVuY3Rpb24oaywgdikge1xuICAgIHZhciBtO1xuICAgIGlmICgobSA9IHYubWF0Y2goL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8pKSkge1xuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgICBpZiAodiA+PSAwICYmIHYgPD0gMTAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaW5wdXQgaW50byBncm91cHMgc2VwYXJhdGVkIGJ5ICdncm91cERlbGltJywgYW5kXG4vLyBpbnRlcnByZXRlIGVhY2ggZ3JvdXAgYXMgYSBrZXkvdmFsdWUgcGFpciBzZXBhcmF0ZWQgYnkgJ2tleVZhbHVlRGVsaW0nLlxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xuICB2YXIgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcbiAgICBpZiAoa3YubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGsgPSBrdlswXTtcbiAgICB2YXIgdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKGssIHYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gIHZhciBvSW5wdXQgPSBpbnB1dDtcbiAgLy8gNC4xIFdlYlZUVCB0aW1lc3RhbXBcbiAgZnVuY3Rpb24gY29uc3VtZVRpbWVTdGFtcCgpIHtcbiAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XG4gICAgaWYgKHRzID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFsZm9ybWVkIHRpbWVzdGFtcDogXCIgKyBvSW5wdXQpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgXCJcIik7XG4gICAgcmV0dXJuIHRzO1xuICB9XG5cbiAgLy8gNC40LjIgV2ViVlRUIGN1ZSBzZXR0aW5nc1xuICBmdW5jdGlvbiBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSkge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlIFwicmVnaW9uXCI6XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgcmVnaW9uIHdlIHBhcnNlZCB3aXRoIHRoZSBzYW1lIHJlZ2lvbiBpZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHJlZ2lvbkxpc3RbaV0ucmVnaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wicmxcIiwgXCJsclwiXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgdmFyIHZhbHMgPSB2LnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcbiAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2YWxzMCk7XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsczApID8gc2V0dGluZ3Muc2V0KFwic25hcFRvTGluZXNcIiwgZmFsc2UpIDogbnVsbDtcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbXCJhdXRvXCJdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KFwibGluZUFsaWduXCIsIHZhbHNbMV0sIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb3NpdGlvblwiOlxuICAgICAgICB2YWxzID0gdi5zcGxpdChcIixcIik7XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdmFsc1swXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdChcInBvc2l0aW9uQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWxpZ25cIjpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSwgLzovLCAvXFxzLyk7XG5cbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxuICAgIGN1ZS5yZWdpb24gPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25cIiwgbnVsbCk7XG4gICAgY3VlLnZlcnRpY2FsID0gc2V0dGluZ3MuZ2V0KFwidmVydGljYWxcIiwgXCJcIik7XG4gICAgY3VlLmxpbmUgPSBzZXR0aW5ncy5nZXQoXCJsaW5lXCIsIFwiYXV0b1wiKTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KFwibGluZUFsaWduXCIsIFwic3RhcnRcIik7XG4gICAgY3VlLnNuYXBUb0xpbmVzID0gc2V0dGluZ3MuZ2V0KFwic25hcFRvTGluZXNcIiwgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoXCJzaXplXCIsIDEwMCk7XG4gICAgY3VlLmFsaWduID0gc2V0dGluZ3MuZ2V0KFwiYWxpZ25cIiwgXCJtaWRkbGVcIik7XG4gICAgY3VlLnBvc2l0aW9uID0gc2V0dGluZ3MuZ2V0KFwicG9zaXRpb25cIiwge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgbWlkZGxlOiA1MCxcbiAgICAgIGVuZDogMTAwLFxuICAgICAgcmlnaHQ6IDEwMFxuICAgIH0sIGN1ZS5hbGlnbik7XG4gICAgY3VlLnBvc2l0aW9uQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvbkFsaWduXCIsIHtcbiAgICAgIHN0YXJ0OiBcInN0YXJ0XCIsXG4gICAgICBsZWZ0OiBcInN0YXJ0XCIsXG4gICAgICBtaWRkbGU6IFwibWlkZGxlXCIsXG4gICAgICBlbmQ6IFwiZW5kXCIsXG4gICAgICByaWdodDogXCJlbmRcIlxuICAgIH0sIGN1ZS5hbGlnbik7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15cXHMrLywgXCJcIik7XG4gIH1cblxuICAvLyA0LjEgV2ViVlRUIGN1ZSB0aW1pbmdzLlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgIC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGlmIChpbnB1dC5zdWJzdHIoMCwgMykgIT09IFwiLS0+XCIpIHsgICAgIC8vICgzKSBuZXh0IGNoYXJhY3RlcnMgbXVzdCBtYXRjaCBcIi0tPlwiXG4gICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgb0lucHV0KTtcbiAgfVxuICBpbnB1dCA9IGlucHV0LnN1YnN0cigzKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgICAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcblxuICAvLyA0LjEgV2ViVlRUIGN1ZSBzZXR0aW5ncyBsaXN0LlxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjb25zdW1lQ3VlU2V0dGluZ3MoaW5wdXQsIGN1ZSk7XG59XG5cbnZhciBFU0NBUEUgPSB7XG4gIFwiJmFtcDtcIjogXCImXCIsXG4gIFwiJmx0O1wiOiBcIjxcIixcbiAgXCImZ3Q7XCI6IFwiPlwiLFxuICBcIiZscm07XCI6IFwiXFx1MjAwZVwiLFxuICBcIiZybG07XCI6IFwiXFx1MjAwZlwiLFxuICBcIiZuYnNwO1wiOiBcIlxcdTAwYTBcIlxufTtcblxudmFyIFRBR19OQU1FID0ge1xuICBjOiBcInNwYW5cIixcbiAgaTogXCJpXCIsXG4gIGI6IFwiYlwiLFxuICB1OiBcInVcIixcbiAgcnVieTogXCJydWJ5XCIsXG4gIHJ0OiBcInJ0XCIsXG4gIHY6IFwic3BhblwiLFxuICBsYW5nOiBcInNwYW5cIlxufTtcblxudmFyIFRBR19BTk5PVEFUSU9OID0ge1xuICB2OiBcInRpdGxlXCIsXG4gIGxhbmc6IFwibGFuZ1wiXG59O1xuXG52YXIgTkVFRFNfUEFSRU5UID0ge1xuICBydDogXCJydWJ5XCJcbn07XG5cbi8vIFBhcnNlIGNvbnRlbnQgaW50byBhIGRvY3VtZW50IGZyYWdtZW50LlxuZnVuY3Rpb24gcGFyc2VDb250ZW50KHdpbmRvdywgaW5wdXQpIHtcbiAgZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgIC8vIENoZWNrIGZvciBlbmQtb2Ytc3RyaW5nLlxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgJ24nIGNoYXJhY3RlcnMgZnJvbSB0aGUgaW5wdXQuXG4gICAgZnVuY3Rpb24gY29uc3VtZShyZXN1bHQpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFtePF0qKSg8W14+XSs+Pyk/Lyk7XG4gICAgLy8gSWYgdGhlcmUgaXMgc29tZSB0ZXh0IGJlZm9yZSB0aGUgbmV4dCB0YWcsIHJldHVybiBpdCwgb3RoZXJ3aXNlIHJldHVyblxuICAgIC8vIHRoZSB0YWcuXG4gICAgcmV0dXJuIGNvbnN1bWUobVsxXSA/IG1bMV0gOiBtWzJdKTtcbiAgfVxuXG4gIC8vIFVuZXNjYXBlIGEgc3RyaW5nICdzJy5cbiAgZnVuY3Rpb24gdW5lc2NhcGUxKGUpIHtcbiAgICByZXR1cm4gRVNDQVBFW2VdO1xuICB9XG4gIGZ1bmN0aW9uIHVuZXNjYXBlKHMpIHtcbiAgICB3aGlsZSAoKG0gPSBzLm1hdGNoKC8mKGFtcHxsdHxndHxscm18cmxtfG5ic3ApOy8pKSkge1xuICAgICAgcyA9IHMucmVwbGFjZShtWzBdLCB1bmVzY2FwZTEpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEFkZChjdXJyZW50LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuICFORUVEU19QQVJFTlRbZWxlbWVudC5sb2NhbE5hbWVdIHx8XG4gICAgICAgICAgIE5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gPT09IGN1cnJlbnQubG9jYWxOYW1lO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoaXMgdGFnLlxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGFubm90YXRpb24pIHtcbiAgICB2YXIgdGFnTmFtZSA9IFRBR19OQU1FW3R5cGVdO1xuICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgZWxlbWVudC5sb2NhbE5hbWUgPSB0YWdOYW1lO1xuICAgIHZhciBuYW1lID0gVEFHX0FOTk9UQVRJT05bdHlwZV07XG4gICAgaWYgKG5hbWUgJiYgYW5ub3RhdGlvbikge1xuICAgICAgZWxlbWVudFtuYW1lXSA9IGFubm90YXRpb24udHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHZhciByb290RGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICBjdXJyZW50ID0gcm9vdERpdixcbiAgICAgIHQsXG4gICAgICB0YWdTdGFjayA9IFtdO1xuXG4gIHdoaWxlICgodCA9IG5leHRUb2tlbigpKSAhPT0gbnVsbCkge1xuICAgIGlmICh0WzBdID09PSAnPCcpIHtcbiAgICAgIGlmICh0WzFdID09PSBcIi9cIikge1xuICAgICAgICAvLyBJZiB0aGUgY2xvc2luZyB0YWcgbWF0Y2hlcywgbW92ZSBiYWNrIHVwIHRvIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgICAgaWYgKHRhZ1N0YWNrLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGFnU3RhY2tbdGFnU3RhY2subGVuZ3RoIC0gMV0gPT09IHQuc3Vic3RyKDIpLnJlcGxhY2UoXCI+XCIsIFwiXCIpKSB7XG4gICAgICAgICAgdGFnU3RhY2sucG9wKCk7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBpZ25vcmUgdGhlIGVuZCB0YWcuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAodC5zdWJzdHIoMSwgdC5sZW5ndGggLSAyKSk7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIGlmICh0cykge1xuICAgICAgICAvLyBUaW1lc3RhbXBzIGFyZSBsZWFkIG5vZGVzIGFzIHdlbGwuXG4gICAgICAgIG5vZGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKFwidGltZXN0YW1wXCIsIHRzKTtcbiAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbSA9IHQubWF0Y2goL148KFteLlxccy8wLTk+XSspKFxcLlteXFxzXFxcXD5dKyk/KFtePlxcXFxdKyk/KFxcXFw/KT4/JC8pO1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgcGFyc2UgdGhlIHRhZywgc2tpcCB0byB0aGUgbmV4dCB0YWcuXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gY29uc3RydWN0IGFuIGVsZW1lbnQsIGFuZCBpZ25vcmUgdGhlIHRhZyBpZiB3ZSBjb3VsZG4ndC5cbiAgICAgIG5vZGUgPSBjcmVhdGVFbGVtZW50KG1bMV0sIG1bM10pO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB0YWcgc2hvdWxkIGJlIGFkZGVkIGJhc2VkIG9uIHRoZSBjb250ZXh0IG9mIHdoZXJlIGl0XG4gICAgICAvLyBpcyBwbGFjZWQgaW4gdGhlIGN1ZXRleHQuXG4gICAgICBpZiAoIXNob3VsZEFkZChjdXJyZW50LCBub2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFNldCB0aGUgY2xhc3MgbGlzdCAoYXMgYSBsaXN0IG9mIGNsYXNzZXMsIHNlcGFyYXRlZCBieSBzcGFjZSkuXG4gICAgICBpZiAobVsyXSkge1xuICAgICAgICBub2RlLmNsYXNzTmFtZSA9IG1bMl0uc3Vic3RyKDEpLnJlcGxhY2UoJy4nLCAnICcpO1xuICAgICAgfVxuICAgICAgLy8gQXBwZW5kIHRoZSBub2RlIHRvIHRoZSBjdXJyZW50IG5vZGUsIGFuZCBlbnRlciB0aGUgc2NvcGUgb2YgdGhlIG5ld1xuICAgICAgLy8gbm9kZS5cbiAgICAgIHRhZ1N0YWNrLnB1c2gobVsxXSk7XG4gICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgY3VycmVudCA9IG5vZGU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUZXh0IG5vZGVzIGFyZSBsZWFmIG5vZGVzLlxuICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHVuZXNjYXBlKHQpKSk7XG4gIH1cblxuICByZXR1cm4gcm9vdERpdjtcbn1cblxuLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIHRoZSBVbmljb2RlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGEgc3Ryb25nXG4vLyByaWdodC10by1sZWZ0IGNhdGVnb3J5LiBXaGF0IHRoaXMgbWVhbnMgaXMgdGhhdCB0aGVzZSBjaGFyYWN0ZXJzIGFyZVxuLy8gd3JpdHRlbiByaWdodC10by1sZWZ0IGZvciBzdXJlLiBJdCB3YXMgZ2VuZXJhdGVkIGJ5IHB1bGxpbmcgYWxsIHRoZSBzdHJvbmdcbi8vIHJpZ2h0LXRvLWxlZnQgY2hhcmFjdGVycyBvdXQgb2YgdGhlIFVuaWNvZGUgZGF0YSB0YWJsZS4gVGhhdCB0YWJsZSBjYW5cbi8vIGZvdW5kIGF0OiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VTklEQVRBL1VuaWNvZGVEYXRhLnR4dFxudmFyIHN0cm9uZ1JUTFJhbmdlcyA9IFtbMHg1YmUsIDB4NWJlXSwgWzB4NWMwLCAweDVjMF0sIFsweDVjMywgMHg1YzNdLCBbMHg1YzYsIDB4NWM2XSxcbiBbMHg1ZDAsIDB4NWVhXSwgWzB4NWYwLCAweDVmNF0sIFsweDYwOCwgMHg2MDhdLCBbMHg2MGIsIDB4NjBiXSwgWzB4NjBkLCAweDYwZF0sXG4gWzB4NjFiLCAweDYxYl0sIFsweDYxZSwgMHg2NGFdLCBbMHg2NmQsIDB4NjZmXSwgWzB4NjcxLCAweDZkNV0sIFsweDZlNSwgMHg2ZTZdLFxuIFsweDZlZSwgMHg2ZWZdLCBbMHg2ZmEsIDB4NzBkXSwgWzB4NzBmLCAweDcxMF0sIFsweDcxMiwgMHg3MmZdLCBbMHg3NGQsIDB4N2E1XSxcbiBbMHg3YjEsIDB4N2IxXSwgWzB4N2MwLCAweDdlYV0sIFsweDdmNCwgMHg3ZjVdLCBbMHg3ZmEsIDB4N2ZhXSwgWzB4ODAwLCAweDgxNV0sXG4gWzB4ODFhLCAweDgxYV0sIFsweDgyNCwgMHg4MjRdLCBbMHg4MjgsIDB4ODI4XSwgWzB4ODMwLCAweDgzZV0sIFsweDg0MCwgMHg4NThdLFxuIFsweDg1ZSwgMHg4NWVdLCBbMHg4YTAsIDB4OGEwXSwgWzB4OGEyLCAweDhhY10sIFsweDIwMGYsIDB4MjAwZl0sXG4gWzB4ZmIxZCwgMHhmYjFkXSwgWzB4ZmIxZiwgMHhmYjI4XSwgWzB4ZmIyYSwgMHhmYjM2XSwgWzB4ZmIzOCwgMHhmYjNjXSxcbiBbMHhmYjNlLCAweGZiM2VdLCBbMHhmYjQwLCAweGZiNDFdLCBbMHhmYjQzLCAweGZiNDRdLCBbMHhmYjQ2LCAweGZiYzFdLFxuIFsweGZiZDMsIDB4ZmQzZF0sIFsweGZkNTAsIDB4ZmQ4Zl0sIFsweGZkOTIsIDB4ZmRjN10sIFsweGZkZjAsIDB4ZmRmY10sXG4gWzB4ZmU3MCwgMHhmZTc0XSwgWzB4ZmU3NiwgMHhmZWZjXSwgWzB4MTA4MDAsIDB4MTA4MDVdLCBbMHgxMDgwOCwgMHgxMDgwOF0sXG4gWzB4MTA4MGEsIDB4MTA4MzVdLCBbMHgxMDgzNywgMHgxMDgzOF0sIFsweDEwODNjLCAweDEwODNjXSwgWzB4MTA4M2YsIDB4MTA4NTVdLFxuIFsweDEwODU3LCAweDEwODVmXSwgWzB4MTA5MDAsIDB4MTA5MWJdLCBbMHgxMDkyMCwgMHgxMDkzOV0sIFsweDEwOTNmLCAweDEwOTNmXSxcbiBbMHgxMDk4MCwgMHgxMDliN10sIFsweDEwOWJlLCAweDEwOWJmXSwgWzB4MTBhMDAsIDB4MTBhMDBdLCBbMHgxMGExMCwgMHgxMGExM10sXG4gWzB4MTBhMTUsIDB4MTBhMTddLCBbMHgxMGExOSwgMHgxMGEzM10sIFsweDEwYTQwLCAweDEwYTQ3XSwgWzB4MTBhNTAsIDB4MTBhNThdLFxuIFsweDEwYTYwLCAweDEwYTdmXSwgWzB4MTBiMDAsIDB4MTBiMzVdLCBbMHgxMGI0MCwgMHgxMGI1NV0sIFsweDEwYjU4LCAweDEwYjcyXSxcbiBbMHgxMGI3OCwgMHgxMGI3Zl0sIFsweDEwYzAwLCAweDEwYzQ4XSwgWzB4MWVlMDAsIDB4MWVlMDNdLCBbMHgxZWUwNSwgMHgxZWUxZl0sXG4gWzB4MWVlMjEsIDB4MWVlMjJdLCBbMHgxZWUyNCwgMHgxZWUyNF0sIFsweDFlZTI3LCAweDFlZTI3XSwgWzB4MWVlMjksIDB4MWVlMzJdLFxuIFsweDFlZTM0LCAweDFlZTM3XSwgWzB4MWVlMzksIDB4MWVlMzldLCBbMHgxZWUzYiwgMHgxZWUzYl0sIFsweDFlZTQyLCAweDFlZTQyXSxcbiBbMHgxZWU0NywgMHgxZWU0N10sIFsweDFlZTQ5LCAweDFlZTQ5XSwgWzB4MWVlNGIsIDB4MWVlNGJdLCBbMHgxZWU0ZCwgMHgxZWU0Zl0sXG4gWzB4MWVlNTEsIDB4MWVlNTJdLCBbMHgxZWU1NCwgMHgxZWU1NF0sIFsweDFlZTU3LCAweDFlZTU3XSwgWzB4MWVlNTksIDB4MWVlNTldLFxuIFsweDFlZTViLCAweDFlZTViXSwgWzB4MWVlNWQsIDB4MWVlNWRdLCBbMHgxZWU1ZiwgMHgxZWU1Zl0sIFsweDFlZTYxLCAweDFlZTYyXSxcbiBbMHgxZWU2NCwgMHgxZWU2NF0sIFsweDFlZTY3LCAweDFlZTZhXSwgWzB4MWVlNmMsIDB4MWVlNzJdLCBbMHgxZWU3NCwgMHgxZWU3N10sXG4gWzB4MWVlNzksIDB4MWVlN2NdLCBbMHgxZWU3ZSwgMHgxZWU3ZV0sIFsweDFlZTgwLCAweDFlZTg5XSwgWzB4MWVlOGIsIDB4MWVlOWJdLFxuIFsweDFlZWExLCAweDFlZWEzXSwgWzB4MWVlYTUsIDB4MWVlYTldLCBbMHgxZWVhYiwgMHgxZWViYl0sIFsweDEwZmZmZCwgMHgxMGZmZmRdXTtcblxuZnVuY3Rpb24gaXNTdHJvbmdSVExDaGFyKGNoYXJDb2RlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Ryb25nUlRMUmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRSYW5nZSA9IHN0cm9uZ1JUTFJhbmdlc1tpXTtcbiAgICBpZiAoY2hhckNvZGUgPj0gY3VycmVudFJhbmdlWzBdICYmIGNoYXJDb2RlIDw9IGN1cnJlbnRSYW5nZVsxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVCaWRpKGN1ZURpdikge1xuICB2YXIgbm9kZVN0YWNrID0gW10sXG4gICAgICB0ZXh0ID0gXCJcIixcbiAgICAgIGNoYXJDb2RlO1xuXG4gIGlmICghY3VlRGl2IHx8ICFjdWVEaXYuY2hpbGROb2Rlcykge1xuICAgIHJldHVybiBcImx0clwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaE5vZGVzKG5vZGVTdGFjaywgbm9kZSkge1xuICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG5vZGVTdGFjay5wdXNoKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRleHROb2RlKG5vZGVTdGFjaykge1xuICAgIGlmICghbm9kZVN0YWNrIHx8ICFub2RlU3RhY2subGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5vZGVTdGFjay5wb3AoKSxcbiAgICAgICAgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgbm9kZS5pbm5lclRleHQ7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG1hdGNoIGFsbCB1bmljb2RlIHR5cGUgQiBjaGFyYWN0ZXJzIChwYXJhZ3JhcGhcbiAgICAgIC8vIHNlcGFyYXRvciBjaGFyYWN0ZXJzKS4gU2VlIGlzc3VlICMxMTUuXG4gICAgICB2YXIgbSA9IHRleHQubWF0Y2goL14uKihcXG58XFxyKS8pO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgbm9kZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGlmIChub2RlLnRhZ05hbWUgPT09IFwicnVieVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkTm9kZXMpIHtcbiAgICAgIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpO1xuICAgICAgcmV0dXJuIG5leHRUZXh0Tm9kZShub2RlU3RhY2spO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hOb2Rlcyhub2RlU3RhY2ssIGN1ZURpdik7XG4gIHdoaWxlICgodGV4dCA9IG5leHRUZXh0Tm9kZShub2RlU3RhY2spKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaXNTdHJvbmdSVExDaGFyKGNoYXJDb2RlKSkge1xuICAgICAgICByZXR1cm4gXCJydGxcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwibHRyXCI7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lUG9zKGN1ZSkge1xuICBpZiAodHlwZW9mIGN1ZS5saW5lID09PSBcIm51bWJlclwiICYmXG4gICAgICAoY3VlLnNuYXBUb0xpbmVzIHx8IChjdWUubGluZSA+PSAwICYmIGN1ZS5saW5lIDw9IDEwMCkpKSB7XG4gICAgcmV0dXJuIGN1ZS5saW5lO1xuICB9XG4gIGlmICghY3VlLnRyYWNrIHx8ICFjdWUudHJhY2sudGV4dFRyYWNrTGlzdCB8fFxuICAgICAgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0Lm1lZGlhRWxlbWVudCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgdHJhY2sgPSBjdWUudHJhY2ssXG4gICAgICB0cmFja0xpc3QgPSB0cmFjay50ZXh0VHJhY2tMaXN0LFxuICAgICAgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGggJiYgdHJhY2tMaXN0W2ldICE9PSB0cmFjazsgaSsrKSB7XG4gICAgaWYgKHRyYWNrTGlzdFtpXS5tb2RlID09PSBcInNob3dpbmdcIikge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICsrY291bnQgKiAtMTtcbn1cblxuZnVuY3Rpb24gU3R5bGVCb3goKSB7XG59XG5cbi8vIEFwcGx5IHN0eWxlcyB0byBhIGRpdi4gSWYgdGhlcmUgaXMgbm8gZGl2IHBhc3NlZCB0aGVuIGl0IGRlZmF1bHRzIHRvIHRoZVxuLy8gZGl2IG9uICd0aGlzJy5cblN0eWxlQm94LnByb3RvdHlwZS5hcHBseVN0eWxlcyA9IGZ1bmN0aW9uKHN0eWxlcywgZGl2KSB7XG4gIGRpdiA9IGRpdiB8fCB0aGlzLmRpdjtcbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICBkaXYuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgfVxuICB9XG59O1xuXG5TdHlsZUJveC5wcm90b3R5cGUuZm9ybWF0U3R5bGUgPSBmdW5jdGlvbih2YWwsIHVuaXQpIHtcbiAgcmV0dXJuIHZhbCA9PT0gMCA/IDAgOiB2YWwgKyB1bml0O1xufTtcblxuLy8gQ29uc3RydWN0cyB0aGUgY29tcHV0ZWQgZGlzcGxheSBzdGF0ZSBvZiB0aGUgY3VlIChhIGRpdikuIFBsYWNlcyB0aGUgZGl2XG4vLyBpbnRvIHRoZSBvdmVybGF5IHdoaWNoIHNob3VsZCBiZSBhIGJsb2NrIGxldmVsIGVsZW1lbnQgKHVzdWFsbHkgYSBkaXYpLlxuZnVuY3Rpb24gQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucykge1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBjb2xvciA9IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAxKVwiO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIDAuOClcIjtcblxuICBpZiAoaXNJRTgpIHtcbiAgICBjb2xvciA9IFwicmdiKDI1NSwgMjU1LCAyNTUpXCI7XG4gICAgYmFja2dyb3VuZENvbG9yID0gXCJyZ2IoMCwgMCwgMClcIjtcbiAgfVxuXG4gIFN0eWxlQm94LmNhbGwodGhpcyk7XG4gIHRoaXMuY3VlID0gY3VlO1xuXG4gIC8vIFBhcnNlIG91ciBjdWUncyB0ZXh0IGludG8gYSBET00gdHJlZSByb290ZWQgYXQgJ2N1ZURpdicuIFRoaXMgZGl2IHdpbGxcbiAgLy8gaGF2ZSBpbmxpbmUgcG9zaXRpb25pbmcgYW5kIHdpbGwgZnVuY3Rpb24gYXMgdGhlIGN1ZSBiYWNrZ3JvdW5kIGJveC5cbiAgdGhpcy5jdWVEaXYgPSBwYXJzZUNvbnRlbnQod2luZG93LCBjdWUudGV4dCk7XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgfTtcblxuICBpZiAoIWlzSUU4KSB7XG4gICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VlLnZlcnRpY2FsID09PSBcImxyXCIgPyBcInZlcnRpY2FsLWxyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJ2ZXJ0aWNhbC1ybFwiO1xuICAgIHN0eWxlcy51bmljb2RlQmlkaSA9IFwicGxhaW50ZXh0XCI7XG4gIH1cbiAgdGhpcy5hcHBseVN0eWxlcyhzdHlsZXMsIHRoaXMuY3VlRGl2KTtcblxuICAvLyBDcmVhdGUgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwb3NpdGlvbiB0aGUgY3VlXG4gIC8vIGRpdi4gTm90ZSwgYWxsIFdlYlZUVCBjdWUtc2V0dGluZyBhbGlnbm1lbnRzIGFyZSBlcXVpdmFsZW50IHRvIHRoZSBDU1NcbiAgLy8gbWlycm9ycyBvZiB0aGVtIGV4Y2VwdCBcIm1pZGRsZVwiIHdoaWNoIGlzIFwiY2VudGVyXCIgaW4gQ1NTLlxuICB0aGlzLmRpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzdHlsZXMgPSB7XG4gICAgdGV4dEFsaWduOiBjdWUuYWxpZ24gPT09IFwibWlkZGxlXCIgPyBcImNlbnRlclwiIDogY3VlLmFsaWduLFxuICAgIGZvbnQ6IHN0eWxlT3B0aW9ucy5mb250LFxuICAgIHdoaXRlU3BhY2U6IFwicHJlLWxpbmVcIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gIH07XG5cbiAgaWYgKCFpc0lFOCkge1xuICAgIHN0eWxlcy5kaXJlY3Rpb24gPSBkZXRlcm1pbmVCaWRpKHRoaXMuY3VlRGl2KTtcbiAgICBzdHlsZXMud3JpdGluZ01vZGUgPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInZlcnRpY2FsLXJsXCIuXG4gICAgc3R5bGVzdW5pY29kZUJpZGkgPSAgXCJwbGFpbnRleHRcIjtcbiAgfVxuXG4gIHRoaXMuYXBwbHlTdHlsZXMoc3R5bGVzKTtcblxuICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmN1ZURpdik7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByZWZlcmVuY2UgZWRnZSBvZiB0aGUgdmlld3BvcnQgdG8gdGhlIHRleHRcbiAgLy8gcG9zaXRpb24gb2YgdGhlIGN1ZSBib3guIFRoZSByZWZlcmVuY2UgZWRnZSB3aWxsIGJlIHJlc29sdmVkIGxhdGVyIHdoZW5cbiAgLy8gdGhlIGJveCBvcmllbnRhdGlvbiBzdHlsZXMgYXJlIGFwcGxpZWQuXG4gIHZhciB0ZXh0UG9zID0gMDtcbiAgc3dpdGNoIChjdWUucG9zaXRpb25BbGlnbikge1xuICBjYXNlIFwic3RhcnRcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uO1xuICAgIGJyZWFrO1xuICBjYXNlIFwibWlkZGxlXCI6XG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbiAtIChjdWUuc2l6ZSAvIDIpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiZW5kXCI6XG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbiAtIGN1ZS5zaXplO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSG9yaXpvbnRhbCBib3ggb3JpZW50YXRpb247IHRleHRQb3MgaXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGVcbiAgLy8gYXJlYSB0byB0aGUgbGVmdCBlZGdlIG9mIHRoZSBib3ggYW5kIGN1ZS5zaXplIGlzIHRoZSBkaXN0YW5jZSBleHRlbmRpbmcgdG9cbiAgLy8gdGhlIHJpZ2h0IGZyb20gdGhlcmUuXG4gIGlmIChjdWUudmVydGljYWwgPT09IFwiXCIpIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIGxlZnQ6ICB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcbiAgICAgIHdpZHRoOiB0aGlzLmZvcm1hdFN0eWxlKGN1ZS5zaXplLCBcIiVcIilcbiAgICB9KTtcbiAgLy8gVmVydGljYWwgYm94IG9yaWVudGF0aW9uOyB0ZXh0UG9zIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGVcbiAgLy8gYXJlYSB0byB0aGUgdG9wIGVkZ2Ugb2YgdGhlIGJveCBhbmQgY3VlLnNpemUgaXMgdGhlIGhlaWdodCBleHRlbmRpbmdcbiAgLy8gZG93bndhcmRzIGZyb20gdGhlcmUuXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICB0b3A6IHRoaXMuZm9ybWF0U3R5bGUodGV4dFBvcywgXCIlXCIpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGN1ZS5zaXplLCBcIiVcIilcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMubW92ZSA9IGZ1bmN0aW9uKGJveCkge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKGJveC50b3AsIFwicHhcIiksXG4gICAgICBib3R0b206IHRoaXMuZm9ybWF0U3R5bGUoYm94LmJvdHRvbSwgXCJweFwiKSxcbiAgICAgIGxlZnQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LmxlZnQsIFwicHhcIiksXG4gICAgICByaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3gucmlnaHQsIFwicHhcIiksXG4gICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LmhlaWdodCwgXCJweFwiKSxcbiAgICAgIHdpZHRoOiB0aGlzLmZvcm1hdFN0eWxlKGJveC53aWR0aCwgXCJweFwiKVxuICAgIH0pO1xuICB9O1xufVxuQ3VlU3R5bGVCb3gucHJvdG90eXBlID0gX29iakNyZWF0ZShTdHlsZUJveC5wcm90b3R5cGUpO1xuQ3VlU3R5bGVCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3VlU3R5bGVCb3g7XG5cbi8vIFJlcHJlc2VudHMgdGhlIGNvLW9yZGluYXRlcyBvZiBhbiBFbGVtZW50IGluIGEgd2F5IHRoYXQgd2UgY2FuIGVhc2lseVxuLy8gY29tcHV0ZSB0aGluZ3Mgd2l0aCBzdWNoIGFzIGlmIGl0IG92ZXJsYXBzIG9yIGludGVyc2VjdHMgd2l0aCBhbm90aGVyIEVsZW1lbnQuXG4vLyBDYW4gaW5pdGlhbGl6ZSBpdCB3aXRoIGVpdGhlciBhIFN0eWxlQm94IG9yIGFub3RoZXIgQm94UG9zaXRpb24uXG5mdW5jdGlvbiBCb3hQb3NpdGlvbihvYmopIHtcbiAgdmFyIGlzSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gIC8vIEVpdGhlciBhIEJveFBvc2l0aW9uIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSBpdCwgb3IgYSBTdHlsZUJveFxuICAvLyB3YXMgcGFzc2VkIGluIGFuZCB3ZSBuZWVkIHRvIGNvcHkgdGhlIHJlc3VsdHMgb2YgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCdcbiAgLy8gYXMgdGhlIG9iamVjdCByZXR1cm5lZCBpcyByZWFkb25seS4gQWxsIGNvLW9yZGluYXRlIHZhbHVlcyBhcmUgaW4gcmVmZXJlbmNlXG4gIC8vIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4gKHRvcCBsZWZ0KS5cbiAgdmFyIGxoLCBoZWlnaHQsIHdpZHRoLCB0b3A7XG4gIGlmIChvYmouZGl2KSB7XG4gICAgaGVpZ2h0ID0gb2JqLmRpdi5vZmZzZXRIZWlnaHQ7XG4gICAgd2lkdGggPSBvYmouZGl2Lm9mZnNldFdpZHRoO1xuICAgIHRvcCA9IG9iai5kaXYub2Zmc2V0VG9wO1xuXG4gICAgdmFyIHJlY3RzID0gKHJlY3RzID0gb2JqLmRpdi5jaGlsZE5vZGVzKSAmJiAocmVjdHMgPSByZWN0c1swXSkgJiZcbiAgICAgICAgICAgICAgICByZWN0cy5nZXRDbGllbnRSZWN0cyAmJiByZWN0cy5nZXRDbGllbnRSZWN0cygpO1xuICAgIG9iaiA9IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gSW4gY2VydGFpbiBjYXNlcyB0aGUgb3V0dGVyIGRpdiB3aWxsIGJlIHNsaWdodGx5IGxhcmdlciB0aGVuIHRoZSBzdW0gb2ZcbiAgICAvLyB0aGUgaW5uZXIgZGl2J3MgbGluZXMuIFRoaXMgY291bGQgYmUgZHVlIHRvIGJvbGQgdGV4dCwgZXRjLCBvbiBzb21lIHBsYXRmb3Jtcy5cbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIGdldCB0aGUgYXZlcmFnZSBsaW5lIGhlaWdodCBhbmQgdXNlIHRoYXQuIFRoaXMgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZGVzaXJlZCBiZWhhdmlvdXIuXG4gICAgbGggPSByZWN0cyA/IE1hdGgubWF4KChyZWN0c1swXSAmJiByZWN0c1swXS5oZWlnaHQpIHx8IDAsIG9iai5oZWlnaHQgLyByZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICAgICA6IDA7XG5cbiAgfVxuICB0aGlzLmxlZnQgPSBvYmoubGVmdDtcbiAgdGhpcy5yaWdodCA9IG9iai5yaWdodDtcbiAgdGhpcy50b3AgPSBvYmoudG9wIHx8IHRvcDtcbiAgdGhpcy5oZWlnaHQgPSBvYmouaGVpZ2h0IHx8IGhlaWdodDtcbiAgdGhpcy5ib3R0b20gPSBvYmouYm90dG9tIHx8ICh0b3AgKyAob2JqLmhlaWdodCB8fCBoZWlnaHQpKTtcbiAgdGhpcy53aWR0aCA9IG9iai53aWR0aCB8fCB3aWR0aDtcbiAgdGhpcy5saW5lSGVpZ2h0ID0gbGggIT09IHVuZGVmaW5lZCA/IGxoIDogb2JqLmxpbmVIZWlnaHQ7XG5cbiAgaWYgKGlzSUU4ICYmICF0aGlzLmxpbmVIZWlnaHQpIHtcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAxMztcbiAgfVxufVxuXG4vLyBNb3ZlIHRoZSBib3ggYWxvbmcgYSBwYXJ0aWN1bGFyIGF4aXMuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBhbW91bnQgdG8gbW92ZVxuLy8gdGhlIGJveC4gSWYgbm8gYW1vdW50IGlzIHBhc3NlZCB0aGVuIHRoZSBkZWZhdWx0IGlzIHRoZSBsaW5lIGhlaWdodCBvZiB0aGVcbi8vIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oYXhpcywgdG9Nb3ZlKSB7XG4gIHRvTW92ZSA9IHRvTW92ZSAhPT0gdW5kZWZpbmVkID8gdG9Nb3ZlIDogdGhpcy5saW5lSGVpZ2h0O1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgY2FzZSBcIit4XCI6XG4gICAgdGhpcy5sZWZ0ICs9IHRvTW92ZTtcbiAgICB0aGlzLnJpZ2h0ICs9IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIi14XCI6XG4gICAgdGhpcy5sZWZ0IC09IHRvTW92ZTtcbiAgICB0aGlzLnJpZ2h0IC09IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIit5XCI6XG4gICAgdGhpcy50b3AgKz0gdG9Nb3ZlO1xuICAgIHRoaXMuYm90dG9tICs9IHRvTW92ZTtcbiAgICBicmVhaztcbiAgY2FzZSBcIi15XCI6XG4gICAgdGhpcy50b3AgLT0gdG9Nb3ZlO1xuICAgIHRoaXMuYm90dG9tIC09IHRvTW92ZTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggb3ZlcmxhcHMgYW5vdGhlciBib3gsIGIyLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYjIpIHtcbiAgcmV0dXJuIHRoaXMubGVmdCA8IGIyLnJpZ2h0ICYmXG4gICAgICAgICB0aGlzLnJpZ2h0ID4gYjIubGVmdCAmJlxuICAgICAgICAgdGhpcy50b3AgPCBiMi5ib3R0b20gJiZcbiAgICAgICAgIHRoaXMuYm90dG9tID4gYjIudG9wO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggb3ZlcmxhcHMgYW55IG90aGVyIGJveGVzIGluIGJveGVzLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzQW55ID0gZnVuY3Rpb24oYm94ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzLm92ZXJsYXBzKGJveGVzW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIHdpdGhpbiBhbm90aGVyIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgcmV0dXJuIHRoaXMudG9wID49IGNvbnRhaW5lci50b3AgJiZcbiAgICAgICAgIHRoaXMuYm90dG9tIDw9IGNvbnRhaW5lci5ib3R0b20gJiZcbiAgICAgICAgIHRoaXMubGVmdCA+PSBjb250YWluZXIubGVmdCAmJlxuICAgICAgICAgdGhpcy5yaWdodCA8PSBjb250YWluZXIucmlnaHQ7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBpcyBlbnRpcmVseSB3aXRoaW4gdGhlIGNvbnRhaW5lciBvciBpdCBpcyBvdmVybGFwcGluZ1xuLy8gb24gdGhlIGVkZ2Ugb3Bwb3NpdGUgb2YgdGhlIGF4aXMgZGlyZWN0aW9uIHBhc3NlZC4gRm9yIGV4YW1wbGUsIGlmIFwiK3hcIiBpc1xuLy8gcGFzc2VkIGFuZCB0aGUgYm94IGlzIG92ZXJsYXBwaW5nIG9uIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGNvbnRhaW5lciwgdGhlblxuLy8gcmV0dXJuIHRydWUuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNPcHBvc2l0ZUF4aXMgPSBmdW5jdGlvbihjb250YWluZXIsIGF4aXMpIHtcbiAgc3dpdGNoIChheGlzKSB7XG4gIGNhc2UgXCIreFwiOlxuICAgIHJldHVybiB0aGlzLmxlZnQgPCBjb250YWluZXIubGVmdDtcbiAgY2FzZSBcIi14XCI6XG4gICAgcmV0dXJuIHRoaXMucmlnaHQgPiBjb250YWluZXIucmlnaHQ7XG4gIGNhc2UgXCIreVwiOlxuICAgIHJldHVybiB0aGlzLnRvcCA8IGNvbnRhaW5lci50b3A7XG4gIGNhc2UgXCIteVwiOlxuICAgIHJldHVybiB0aGlzLmJvdHRvbSA+IGNvbnRhaW5lci5ib3R0b207XG4gIH1cbn07XG5cbi8vIEZpbmQgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGFyZWEgdGhhdCB0aGlzIGJveCBpcyBvdmVybGFwcGluZyB3aXRoIGFub3RoZXJcbi8vIGJveC5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5pbnRlcnNlY3RQZXJjZW50YWdlID0gZnVuY3Rpb24oYjIpIHtcbiAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnJpZ2h0LCBiMi5yaWdodCkgLSBNYXRoLm1heCh0aGlzLmxlZnQsIGIyLmxlZnQpKSxcbiAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLmJvdHRvbSwgYjIuYm90dG9tKSAtIE1hdGgubWF4KHRoaXMudG9wLCBiMi50b3ApKSxcbiAgICAgIGludGVyc2VjdEFyZWEgPSB4ICogeTtcbiAgcmV0dXJuIGludGVyc2VjdEFyZWEgLyAodGhpcy5oZWlnaHQgKiB0aGlzLndpZHRoKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIHBvc2l0aW9ucyBmcm9tIHRoaXMgYm94IHRvIENTUyBjb21wYXRpYmxlIHBvc2l0aW9ucyB1c2luZ1xuLy8gdGhlIHJlZmVyZW5jZSBjb250YWluZXIncyBwb3NpdGlvbnMuIFRoaXMgaGFzIHRvIGJlIGRvbmUgYmVjYXVzZSB0aGlzXG4vLyBib3gncyBwb3NpdGlvbnMgYXJlIGluIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb3JpZ2luLCB3aGVyZWFzLCBDU1Ncbi8vIHZhbHVlcyBhcmUgaW4gcmVmZXJlY25lIHRvIHRoZWlyIHJlc3BlY3RpdmUgZWRnZXMuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUudG9DU1NDb21wYXRWYWx1ZXMgPSBmdW5jdGlvbihyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHRoaXMudG9wIC0gcmVmZXJlbmNlLnRvcCxcbiAgICBib3R0b206IHJlZmVyZW5jZS5ib3R0b20gLSB0aGlzLmJvdHRvbSxcbiAgICBsZWZ0OiB0aGlzLmxlZnQgLSByZWZlcmVuY2UubGVmdCxcbiAgICByaWdodDogcmVmZXJlbmNlLnJpZ2h0IC0gdGhpcy5yaWdodCxcbiAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgIHdpZHRoOiB0aGlzLndpZHRoXG4gIH07XG59O1xuXG4vLyBHZXQgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgYm94J3MgcG9zaXRpb24gd2l0aG91dCBhbnl0aGluZyBleHRyYS5cbi8vIENhbiBwYXNzIGEgU3R5bGVCb3gsIEhUTUxFbGVtZW50LCBvciBhbm90aGVyIEJveFBvc2l0b24uXG5Cb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgaGVpZ2h0ID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0SGVpZ2h0IDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0SGVpZ2h0IDogMDtcbiAgdmFyIHdpZHRoID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0V2lkdGggOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRXaWR0aCA6IDA7XG4gIHZhciB0b3AgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRUb3AgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRUb3AgOiAwO1xuXG4gIG9iaiA9IG9iai5kaXYgPyBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDpcbiAgICAgICAgICAgICAgICBvYmoudGFnTmFtZSA/IG9iai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG9iajtcbiAgdmFyIHJldCA9IHtcbiAgICBsZWZ0OiBvYmoubGVmdCxcbiAgICByaWdodDogb2JqLnJpZ2h0LFxuICAgIHRvcDogb2JqLnRvcCB8fCB0b3AsXG4gICAgaGVpZ2h0OiBvYmouaGVpZ2h0IHx8IGhlaWdodCxcbiAgICBib3R0b206IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpLFxuICAgIHdpZHRoOiBvYmoud2lkdGggfHwgd2lkdGhcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIE1vdmUgYSBTdHlsZUJveCB0byBpdHMgc3BlY2lmaWVkLCBvciBuZXh0IGJlc3QsIHBvc2l0aW9uLiBUaGUgY29udGFpbmVyQm94XG4vLyBpcyB0aGUgYm94IHRoYXQgY29udGFpbnMgdGhlIFN0eWxlQm94LCBzdWNoIGFzIGEgZGl2LiBib3hQb3NpdGlvbnMgYXJlXG4vLyBhIGxpc3Qgb2Ygb3RoZXIgYm94ZXMgdGhhdCB0aGUgc3R5bGVCb3ggY2FuJ3Qgb3ZlcmxhcCB3aXRoLlxuZnVuY3Rpb24gbW92ZUJveFRvTGluZVBvc2l0aW9uKHdpbmRvdywgc3R5bGVCb3gsIGNvbnRhaW5lckJveCwgYm94UG9zaXRpb25zKSB7XG5cbiAgLy8gRmluZCB0aGUgYmVzdCBwb3NpdGlvbiBmb3IgYSBjdWUgYm94LCBiLCBvbiB0aGUgdmlkZW8uIFRoZSBheGlzIHBhcmFtZXRlclxuICAvLyBpcyBhIGxpc3Qgb2YgYXhpcywgdGhlIG9yZGVyIG9mIHdoaWNoLCBpdCB3aWxsIG1vdmUgdGhlIGJveCBhbG9uZy4gRm9yIGV4YW1wbGU6XG4gIC8vIFBhc3NpbmcgW1wiK3hcIiwgXCIteFwiXSB3aWxsIG1vdmUgdGhlIGJveCBmaXJzdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBwb3NpdGl2ZVxuICAvLyBkaXJlY3Rpb24uIElmIGl0IGRvZXNuJ3QgZmluZCBhIGdvb2QgcG9zaXRpb24gZm9yIGl0IHRoZXJlIGl0IHdpbGwgdGhlbiBtb3ZlXG4gIC8vIGl0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbi5cbiAgZnVuY3Rpb24gZmluZEJlc3RQb3NpdGlvbihiLCBheGlzKSB7XG4gICAgdmFyIGJlc3RQb3NpdGlvbixcbiAgICAgICAgc3BlY2lmaWVkUG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYiksXG4gICAgICAgIHBlcmNlbnRhZ2UgPSAxOyAvLyBIaWdoZXN0IHBvc3NpYmxlIHNvIHRoZSBmaXJzdCB0aGluZyB3ZSBnZXQgaXMgYmV0dGVyLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3aGlsZSAoYi5vdmVybGFwc09wcG9zaXRlQXhpcyhjb250YWluZXJCb3gsIGF4aXNbaV0pIHx8XG4gICAgICAgICAgICAgKGIud2l0aGluKGNvbnRhaW5lckJveCkgJiYgYi5vdmVybGFwc0FueShib3hQb3NpdGlvbnMpKSkge1xuICAgICAgICBiLm1vdmUoYXhpc1tpXSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBmb3VuZCBhIHNwb3Qgd2hlcmUgd2UgYXJlbid0IG92ZXJsYXBwaW5nIGFueXRoaW5nLiBUaGlzIGlzIG91clxuICAgICAgLy8gYmVzdCBwb3NpdGlvbi5cbiAgICAgIGlmIChiLndpdGhpbihjb250YWluZXJCb3gpKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgdmFyIHAgPSBiLmludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyQm94KTtcbiAgICAgIC8vIElmIHdlJ3JlIG91dHNpZGUgdGhlIGNvbnRhaW5lciBib3ggbGVzcyB0aGVuIHdlIHdlcmUgb24gb3VyIGxhc3QgdHJ5XG4gICAgICAvLyB0aGVuIHJlbWVtYmVyIHRoaXMgcG9zaXRpb24gYXMgdGhlIGJlc3QgcG9zaXRpb24uXG4gICAgICBpZiAocGVyY2VudGFnZSA+IHApIHtcbiAgICAgICAgYmVzdFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKGIpO1xuICAgICAgICBwZXJjZW50YWdlID0gcDtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IHRoZSBib3ggcG9zaXRpb24gdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgIGIgPSBuZXcgQm94UG9zaXRpb24oc3BlY2lmaWVkUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdFBvc2l0aW9uIHx8IHNwZWNpZmllZFBvc2l0aW9uO1xuICB9XG5cbiAgdmFyIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KSxcbiAgICAgIGN1ZSA9IHN0eWxlQm94LmN1ZSxcbiAgICAgIGxpbmVQb3MgPSBjb21wdXRlTGluZVBvcyhjdWUpLFxuICAgICAgYXhpcyA9IFtdO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBsaW5lIG51bWJlciB0byBhbGlnbiB0aGUgY3VlIHRvLlxuICBpZiAoY3VlLnNuYXBUb0xpbmVzKSB7XG4gICAgdmFyIHNpemU7XG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICBjYXNlIFwiXCI6XG4gICAgICBheGlzID0gWyBcIit5XCIsIFwiLXlcIiBdO1xuICAgICAgc2l6ZSA9IFwiaGVpZ2h0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmxcIjpcbiAgICAgIGF4aXMgPSBbIFwiK3hcIiwgXCIteFwiIF07XG4gICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxyXCI6XG4gICAgICBheGlzID0gWyBcIi14XCIsIFwiK3hcIiBdO1xuICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzdGVwID0gYm94UG9zaXRpb24ubGluZUhlaWdodCxcbiAgICAgICAgcG9zaXRpb24gPSBzdGVwICogTWF0aC5yb3VuZChsaW5lUG9zKSxcbiAgICAgICAgbWF4UG9zaXRpb24gPSBjb250YWluZXJCb3hbc2l6ZV0gKyBzdGVwLFxuICAgICAgICBpbml0aWFsQXhpcyA9IGF4aXNbMF07XG5cbiAgICAvLyBJZiB0aGUgc3BlY2lmaWVkIGludGlhbCBwb3NpdGlvbiBpcyBncmVhdGVyIHRoZW4gdGhlIG1heCBwb3NpdGlvbiB0aGVuXG4gICAgLy8gY2xhbXAgdGhlIGJveCB0byB0aGUgYW1vdW50IG9mIHN0ZXBzIGl0IHdvdWxkIHRha2UgZm9yIHRoZSBib3ggdG9cbiAgICAvLyByZWFjaCB0aGUgbWF4IHBvc2l0aW9uLlxuICAgIGlmIChNYXRoLmFicyhwb3NpdGlvbikgPiBtYXhQb3NpdGlvbikge1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA8IDAgPyAtMSA6IDE7XG4gICAgICBwb3NpdGlvbiAqPSBNYXRoLmNlaWwobWF4UG9zaXRpb24gLyBzdGVwKSAqIHN0ZXA7XG4gICAgfVxuXG4gICAgLy8gSWYgY29tcHV0ZWQgbGluZSBwb3NpdGlvbiByZXR1cm5zIG5lZ2F0aXZlIHRoZW4gbGluZSBudW1iZXJzIGFyZVxuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHZpZGVvIGluc3RlYWQgb2YgdGhlIHRvcC4gVGhlcmVmb3JlLCB3ZVxuICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugb3VyIGluaXRpYWwgcG9zaXRpb24gYnkgdGhlIGxlbmd0aCBvciB3aWR0aCBvZiB0aGVcbiAgICAvLyB2aWRlbywgZGVwZW5kaW5nIG9uIHRoZSB3cml0aW5nIGRpcmVjdGlvbiwgYW5kIHJldmVyc2Ugb3VyIGF4aXMgZGlyZWN0aW9ucy5cbiAgICBpZiAobGluZVBvcyA8IDApIHtcbiAgICAgIHBvc2l0aW9uICs9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IGNvbnRhaW5lckJveC5oZWlnaHQgOiBjb250YWluZXJCb3gud2lkdGg7XG4gICAgICBheGlzID0gYXhpcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0aGUgYm94IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFRoaXMgbWF5IG5vdCBiZSBpdHMgYmVzdFxuICAgIC8vIHBvc2l0aW9uLlxuICAgIGJveFBvc2l0aW9uLm1vdmUoaW5pdGlhbEF4aXMsIHBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgYSBwZXJjZW50YWdlIGxpbmUgdmFsdWUgZm9yIHRoZSBjdWUuXG4gICAgdmFyIGNhbGN1bGF0ZWRQZXJjZW50YWdlID0gKGJveFBvc2l0aW9uLmxpbmVIZWlnaHQgLyBjb250YWluZXJCb3guaGVpZ2h0KSAqIDEwMDtcblxuICAgIHN3aXRjaCAoY3VlLmxpbmVBbGlnbikge1xuICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgIGxpbmVQb3MgLT0gKGNhbGN1bGF0ZWRQZXJjZW50YWdlIC8gMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBsaW5lUG9zIC09IGNhbGN1bGF0ZWRQZXJjZW50YWdlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgaW5pdGlhbCBsaW5lIHBvc2l0aW9uIHRvIHRoZSBjdWUgYm94LlxuICAgIHN3aXRjaCAoY3VlLnZlcnRpY2FsKSB7XG4gICAgY2FzZSBcIlwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICB0b3A6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmxcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgbGVmdDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsclwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICByaWdodDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteFwiLCBcIit4XCIsIFwiLXlcIiBdO1xuXG4gICAgLy8gR2V0IHRoZSBib3ggcG9zaXRpb24gYWdhaW4gYWZ0ZXIgd2UndmUgYXBwbGllZCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uaW5nXG4gICAgLy8gdG8gaXQuXG4gICAgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpO1xuICB9XG5cbiAgdmFyIGJlc3RQb3NpdGlvbiA9IGZpbmRCZXN0UG9zaXRpb24oYm94UG9zaXRpb24sIGF4aXMpO1xuICBzdHlsZUJveC5tb3ZlKGJlc3RQb3NpdGlvbi50b0NTU0NvbXBhdFZhbHVlcyhjb250YWluZXJCb3gpKTtcbn1cblxuZnVuY3Rpb24gV2ViVlRUKCkge1xuICAvLyBOb3RoaW5nXG59XG5cbi8vIEhlbHBlciB0byBhbGxvdyBzdHJpbmdzIHRvIGJlIGRlY29kZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBiaW5hcnkgdXRmOCBkYXRhLlxuV2ViVlRULlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIGV4cGVjdGVkIHN0cmluZyBkYXRhLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9XG4gIH07XG59O1xuXG5XZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSA9IGZ1bmN0aW9uKHdpbmRvdywgY3VldGV4dCkge1xuICBpZiAoIXdpbmRvdyB8fCAhY3VldGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXJzZUNvbnRlbnQod2luZG93LCBjdWV0ZXh0KTtcbn07XG5cbnZhciBGT05UX1NJWkVfUEVSQ0VOVCA9IDAuMDU7XG52YXIgRk9OVF9TVFlMRSA9IFwic2Fucy1zZXJpZlwiO1xudmFyIENVRV9CQUNLR1JPVU5EX1BBRERJTkcgPSBcIjEuNSVcIjtcblxuLy8gUnVucyB0aGUgcHJvY2Vzc2luZyBtb2RlbCBvdmVyIHRoZSBjdWVzIGFuZCByZWdpb25zIHBhc3NlZCB0byBpdC5cbi8vIEBwYXJhbSBvdmVybGF5IEEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikgdGhhdCB0aGUgY29tcHV0ZWQgY3Vlc1xuLy8gICAgICAgICAgICAgICAgYW5kIHJlZ2lvbnMgd2lsbCBiZSBwbGFjZWQgaW50by5cbldlYlZUVC5wcm9jZXNzQ3VlcyA9IGZ1bmN0aW9uKHdpbmRvdywgY3Vlcywgb3ZlcmxheSkge1xuICBpZiAoIXdpbmRvdyB8fCAhY3VlcyB8fCAhb3ZlcmxheSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBjaGlsZHJlbi5cbiAgd2hpbGUgKG92ZXJsYXkuZmlyc3RDaGlsZCkge1xuICAgIG92ZXJsYXkucmVtb3ZlQ2hpbGQob3ZlcmxheS5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHZhciBwYWRkZWRPdmVybGF5ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUubGVmdCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUudG9wID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUuYm90dG9tID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUubWFyZ2luID0gQ1VFX0JBQ0tHUk9VTkRfUEFERElORztcbiAgb3ZlcmxheS5hcHBlbmRDaGlsZChwYWRkZWRPdmVybGF5KTtcblxuICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBkaXNwbGF5IHN0YXRlcyBvZiB0aGUgY3Vlcy4gVGhpcyBjb3VsZFxuICAvLyBiZSB0aGUgY2FzZSBpZiBhIGN1ZSdzIHN0YXRlIGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY29tcHV0YXRpb24gb3JcbiAgLy8gaWYgaXQgaGFzIG5vdCBiZWVuIGNvbXB1dGVkIHlldC5cbiAgZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShjdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY3Vlc1tpXS5oYXNCZWVuUmVzZXQgfHwgIWN1ZXNbaV0uZGlzcGxheVN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlY29tcHV0ZSB0aGUgY3VlcycgZGlzcGxheSBzdGF0ZXMuIEp1c3QgcmV1c2UgdGhlbS5cbiAgaWYgKCFzaG91bGRDb21wdXRlKGN1ZXMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKGN1ZXNbaV0uZGlzcGxheVN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJveFBvc2l0aW9ucyA9IFtdLFxuICAgICAgY29udGFpbmVyQm94ID0gQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24ocGFkZGVkT3ZlcmxheSksXG4gICAgICBmb250U2l6ZSA9IE1hdGgucm91bmQoY29udGFpbmVyQm94LmhlaWdodCAqIEZPTlRfU0laRV9QRVJDRU5UICogMTAwKSAvIDEwMDtcbiAgdmFyIHN0eWxlT3B0aW9ucyA9IHtcbiAgICBmb250OiBmb250U2l6ZSArIFwicHggXCIgKyBGT05UX1NUWUxFXG4gIH07XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHlsZUJveCwgY3VlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdWUgPSBjdWVzW2ldO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBpbnRpYWwgcG9zaXRpb24gYW5kIHN0eWxlcyBvZiB0aGUgY3VlIGRpdi5cbiAgICAgIHN0eWxlQm94ID0gbmV3IEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpO1xuICAgICAgcGFkZGVkT3ZlcmxheS5hcHBlbmRDaGlsZChzdHlsZUJveC5kaXYpO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBjdWUgZGl2IHRvIGl0J3MgY29ycmVjdCBsaW5lIHBvc2l0aW9uLlxuICAgICAgbW92ZUJveFRvTGluZVBvc2l0aW9uKHdpbmRvdywgc3R5bGVCb3gsIGNvbnRhaW5lckJveCwgYm94UG9zaXRpb25zKTtcblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGNvbXB1dGVkIGRpdiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIGl0IGxhdGVyXG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvby5cbiAgICAgIGN1ZS5kaXNwbGF5U3RhdGUgPSBzdHlsZUJveC5kaXY7XG5cbiAgICAgIGJveFBvc2l0aW9ucy5wdXNoKEJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uKHN0eWxlQm94KSk7XG4gICAgfVxuICB9KSgpO1xufTtcblxuV2ViVlRULlBhcnNlciA9IGZ1bmN0aW9uKHdpbmRvdywgdnR0anMsIGRlY29kZXIpIHtcbiAgaWYgKCFkZWNvZGVyKSB7XG4gICAgZGVjb2RlciA9IHZ0dGpzO1xuICAgIHZ0dGpzID0ge307XG4gIH1cbiAgaWYgKCF2dHRqcykge1xuICAgIHZ0dGpzID0ge307XG4gIH1cblxuICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgdGhpcy52dHRqcyA9IHZ0dGpzO1xuICB0aGlzLnN0YXRlID0gXCJJTklUSUFMXCI7XG4gIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgdGhpcy5kZWNvZGVyID0gZGVjb2RlciB8fCBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpO1xuICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcbn07XG5cbldlYlZUVC5QYXJzZXIucHJvdG90eXBlID0ge1xuICAvLyBJZiB0aGUgZXJyb3IgaXMgYSBQYXJzaW5nRXJyb3IgdGhlbiByZXBvcnQgaXQgdG8gdGhlIGNvbnN1bWVyIGlmXG4gIC8vIHBvc3NpYmxlLiBJZiBpdCdzIG5vdCBhIFBhcnNpbmdFcnJvciB0aGVuIHRocm93IGl0IGxpa2Ugbm9ybWFsLlxuICByZXBvcnRPclRocm93RXJyb3I6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikge1xuICAgICAgdGhpcy5vbnBhcnNpbmdlcnJvciAmJiB0aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZGF0YSB0aGVuIHdlIHdvbid0IGRlY29kZSBpdCwgYnV0IHdpbGwganVzdCB0cnkgdG8gcGFyc2VcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXG4gICAgLy8gZXhhbXBsZSB3aGVuIGZsdXNoKCkgaXMgY2FsbGVkLlxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKGRhdGEsIHtzdHJlYW06IHRydWV9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TmV4dExpbmUoKSB7XG4gICAgICB2YXIgYnVmZmVyID0gc2VsZi5idWZmZXI7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICB2YXIgbGluZSA9IGJ1ZmZlci5zdWJzdHIoMCwgcG9zKTtcbiAgICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBlYXJseSBpbiBjYXNlIHdlIGZhaWwgYmVsb3cuXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgLy8gMy40IFdlYlZUVCByZWdpb24gYW5kIFdlYlZUVCByZWdpb24gc2V0dGluZ3Mgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VSZWdpb24oaW5wdXQpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW5lc1wiOlxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWdpb25hbmNob3JcIjpcbiAgICAgICAgY2FzZSBcInZpZXdwb3J0YW5jaG9yXCI6XG4gICAgICAgICAgdmFyIHh5ID0gdi5zcGxpdCgnLCcpO1xuICAgICAgICAgIGlmICh4eS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1ha2Ugc3VyZSBib3RoIHggYW5kIHkgcGFyc2UsIHNvIHVzZSBhIHRlbXBvcmFyeVxuICAgICAgICAgIC8vIHNldHRpbmdzIG9iamVjdCBoZXJlLlxuICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgU2V0dGluZ3MoKTtcbiAgICAgICAgICBhbmNob3IucGVyY2VudChcInhcIiwgeHlbMF0pO1xuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieVwiLCB4eVsxXSk7XG4gICAgICAgICAgaWYgKCFhbmNob3IuaGFzKFwieFwiKSB8fCAhYW5jaG9yLmhhcyhcInlcIikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWFwiLCBhbmNob3IuZ2V0KFwieFwiKSk7XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyBcIllcIiwgYW5jaG9yLmdldChcInlcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInVwXCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgLz0vLCAvXFxzLyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVnaW9uLCB1c2luZyBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IHZhbHVlcyB0aGF0IHdlcmUgbm90XG4gICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICBpZiAoc2V0dGluZ3MuaGFzKFwiaWRcIikpIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyAoc2VsZi52dHRqcy5WVFRSZWdpb24gfHwgc2VsZi53aW5kb3cuVlRUUmVnaW9uKSgpO1xuICAgICAgICByZWdpb24ud2lkdGggPSBzZXR0aW5ncy5nZXQoXCJ3aWR0aFwiLCAxMDApO1xuICAgICAgICByZWdpb24ubGluZXMgPSBzZXR0aW5ncy5nZXQoXCJsaW5lc1wiLCAzKTtcbiAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JYXCIsIDApO1xuICAgICAgICByZWdpb24ucmVnaW9uQW5jaG9yWSA9IHNldHRpbmdzLmdldChcInJlZ2lvbmFuY2hvcllcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWCA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWFwiLCAwKTtcbiAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWSA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWVwiLCAxMDApO1xuICAgICAgICByZWdpb24uc2Nyb2xsID0gc2V0dGluZ3MuZ2V0KFwic2Nyb2xsXCIsIFwiXCIpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgcmVnaW9uLlxuICAgICAgICBzZWxmLm9ucmVnaW9uICYmIHNlbGYub25yZWdpb24ocmVnaW9uKTtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIFZUVFJlZ2lvbiBmb3IgbGF0ZXIgaW4gY2FzZSB3ZSBwYXJzZSBhbnkgVlRUQ3VlcyB0aGF0XG4gICAgICAgIC8vIHJlZmVyZW5jZSBpdC5cbiAgICAgICAgc2VsZi5yZWdpb25MaXN0LnB1c2goe1xuICAgICAgICAgIGlkOiBzZXR0aW5ncy5nZXQoXCJpZFwiKSxcbiAgICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0yMFxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1wYW50b3MtaHR0cC1saXZlLXN0cmVhbWluZy0yMCNzZWN0aW9uLTMuNVxuICAgIC8vIDMuNSBXZWJWVFRcbiAgICBmdW5jdGlvbiBwYXJzZVRpbWVzdGFtcE1hcChpbnB1dCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICBzd2l0Y2goaykge1xuICAgICAgICBjYXNlIFwiTVBFR1RcIjpcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGsgKyAnUycsIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTE9DQVwiOlxuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgJ0wnLCBwYXJzZVRpbWVTdGFtcCh2KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC9bXlxcZF06LywgLywvKTtcblxuICAgICAgc2VsZi5vbnRpbWVzdGFtcG1hcCAmJiBzZWxmLm9udGltZXN0YW1wbWFwKHtcbiAgICAgICAgXCJNUEVHVFNcIjogc2V0dGluZ3MuZ2V0KFwiTVBFR1RTXCIpLFxuICAgICAgICBcIkxPQ0FMXCI6IHNldHRpbmdzLmdldChcIkxPQ0FMXCIpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0Lm1hdGNoKC9YLVRJTUVTVEFNUC1NQVAvKSkge1xuICAgICAgICAvLyBUaGlzIGxpbmUgY29udGFpbnMgSExTIFgtVElNRVNUQU1QLU1BUCBtZXRhZGF0YVxuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICBzd2l0Y2goaykge1xuICAgICAgICAgIGNhc2UgXCJYLVRJTUVTVEFNUC1NQVBcIjpcbiAgICAgICAgICAgIHBhcnNlVGltZXN0YW1wTWFwKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAvPS8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgIHN3aXRjaCAoaykge1xuICAgICAgICAgIGNhc2UgXCJSZWdpb25cIjpcbiAgICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcbiAgICAgICAgICAgIHBhcnNlUmVnaW9uKHYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAvOi8pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHN0YXJ0IHBhcnNpbmcgdW50aWwgd2UgaGF2ZSB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcblxuICAgICAgICB2YXIgbSA9IGxpbmUubWF0Y2goL15XRUJWVFQoWyBcXHRdLiopPyQvKTtcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnN0YXRlID0gXCJIRUFERVJcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICB3aGlsZSAoc2VsZi5idWZmZXIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdChzZWxmLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RlZExpbmUpIHtcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2VsZi5zdGF0ZSkge1xuICAgICAgICBjYXNlIFwiSEVBREVSXCI6XG4gICAgICAgICAgLy8gMTMtMTggLSBBbGxvdyBhIGhlYWRlciAobWV0YWRhdGEpIHVuZGVyIHRoZSBXRUJWVFQgbGluZS5cbiAgICAgICAgICBpZiAoLzovLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IGxpbmUgdGVybWluYXRlcyB0aGUgaGVhZGVyIGFuZCBzdGFydHMgdGhlIGJvZHkgKGN1ZXMpLlxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJOT1RFXCI6XG4gICAgICAgICAgLy8gSWdub3JlIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJJRFwiOlxuICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgc3RhcnQgb2YgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKC9eTk9URSgkfFsgXFx0XSkvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIk5PVEVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY3VlID0gbmV3IChzZWxmLnZ0dGpzLlZUVEN1ZSB8fCBzZWxmLndpbmRvdy5WVFRDdWUpKDAsIDAsIFwiXCIpO1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkNVRVwiO1xuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXG4gICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZihcIi0tPlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLmlkID0gbGluZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9jZXNzIGxpbmUgYXMgc3RhcnQgb2YgYSBjdWUuXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cbiAgICAgICAgY2FzZSBcIkNVRVwiOlxuICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIHNlbGYuY3VlLCBzZWxmLnJlZ2lvbkxpc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciBpZ25vcmUgcmVzdCBvZiB0aGUgY3VlLlxuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQkFEQ1VFXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFVEVYVFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiQ1VFVEVYVFwiOlxuICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoXCItLT5cIikgIT09IC0xO1xuICAgICAgICAgIC8vIDM0IC0gSWYgd2UgaGF2ZSBhbiBlbXB0eSBsaW5lIHRoZW4gcmVwb3J0IHRoZSBjdWUuXG4gICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyBvbmUgYXMgYSBuZXcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXG4gICAgICAgICAgICBzZWxmLm9uY3VlICYmIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xuICAgICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJCQURDVUVcIjogLy8gQkFEQ1VFXG4gICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxuICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcblxuICAgICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBwYXJzaW5nIGEgY3VlLCByZXBvcnQgd2hhdCB3ZSBoYXZlLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiQ1VFVEVYVFwiICYmIHNlbGYuY3VlICYmIHNlbGYub25jdWUpIHtcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICB9XG4gICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIiA/IFwiQkFEV0VCVlRUXCIgOiBcIkJBRENVRVwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZSgpO1xuICAgICAgLy8gU3ludGhlc2l6ZSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGN1ZSBvciByZWdpb24uXG4gICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gXCJIRUFERVJcIikge1xuICAgICAgICBzZWxmLmJ1ZmZlciArPSBcIlxcblxcblwiO1xuICAgICAgICBzZWxmLnBhcnNlKCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSd2ZSBmbHVzaGVkLCBwYXJzZWQsIGFuZCB3ZSdyZSBzdGlsbCBvbiB0aGUgSU5JVElBTCBzdGF0ZSB0aGVuXG4gICAgICAvLyB0aGF0IG1lYW5zIHdlIGRvbid0IGhhdmUgZW5vdWdoIG9mIHRoZSBzdHJlYW0gdG8gcGFyc2UgdGhlIGZpcnN0XG4gICAgICAvLyBsaW5lLlxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRTaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG4gICAgfVxuICAgIHNlbGYub25mbHVzaCAmJiBzZWxmLm9uZmx1c2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJWVFQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBTEE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhEQTtBQUNBO0FBa0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE3QkE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2RUE7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvUkE7QUFDQTtBQWlTQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar autoKeyword = \"auto\";\nvar directionSetting = {\n  \"\": true,\n  \"lr\": true,\n  \"rl\": true\n};\nvar alignSetting = {\n  \"start\": true,\n  \"middle\": true,\n  \"end\": true,\n  \"left\": true,\n  \"right\": true\n};\n\nfunction findDirectionSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var dir = directionSetting[value.toLowerCase()];\n  return dir ? value.toLowerCase() : false;\n}\n\nfunction findAlignSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var align = alignSetting[value.toLowerCase()];\n  return align ? value.toLowerCase() : false;\n}\n\nfunction extend(obj) {\n  var i = 1;\n  for (; i < arguments.length; i++) {\n    var cobj = arguments[i];\n    for (var p in cobj) {\n      obj[p] = cobj[p];\n    }\n  }\n\n  return obj;\n}\n\nfunction VTTCue(startTime, endTime, text) {\n  var cue = this;\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n  var baseObj = {};\n\n  if (isIE8) {\n    cue = document.createElement('custom');\n  } else {\n    baseObj.enumerable = true;\n  }\n\n  /**\n   * Shim implementation specific properties. These properties are not in\n   * the spec.\n   */\n\n  // Lets us know when the VTTCue's data has changed in such a way that we need\n  // to recompute its display state. This lets us compute its display state\n  // lazily.\n  cue.hasBeenReset = false;\n\n  /**\n   * VTTCue and TextTrackCue properties\n   * http://dev.w3.org/html5/webvtt/#vttcue-interface\n   */\n\n  var _id = \"\";\n  var _pauseOnExit = false;\n  var _startTime = startTime;\n  var _endTime = endTime;\n  var _text = text;\n  var _region = null;\n  var _vertical = \"\";\n  var _snapToLines = true;\n  var _line = \"auto\";\n  var _lineAlign = \"start\";\n  var _position = 50;\n  var _positionAlign = \"middle\";\n  var _size = 50;\n  var _align = \"middle\";\n\n  Object.defineProperty(cue, \"id\", extend({}, baseObj, {\n    get: function get() {\n      return _id;\n    },\n    set: function set(value) {\n      _id = \"\" + value;\n    }\n  }));\n\n  Object.defineProperty(cue, \"pauseOnExit\", extend({}, baseObj, {\n    get: function get() {\n      return _pauseOnExit;\n    },\n    set: function set(value) {\n      _pauseOnExit = !!value;\n    }\n  }));\n\n  Object.defineProperty(cue, \"startTime\", extend({}, baseObj, {\n    get: function get() {\n      return _startTime;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\") {\n        throw new TypeError(\"Start time must be set to a number.\");\n      }\n      _startTime = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"endTime\", extend({}, baseObj, {\n    get: function get() {\n      return _endTime;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\") {\n        throw new TypeError(\"End time must be set to a number.\");\n      }\n      _endTime = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"text\", extend({}, baseObj, {\n    get: function get() {\n      return _text;\n    },\n    set: function set(value) {\n      _text = \"\" + value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"region\", extend({}, baseObj, {\n    get: function get() {\n      return _region;\n    },\n    set: function set(value) {\n      _region = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"vertical\", extend({}, baseObj, {\n    get: function get() {\n      return _vertical;\n    },\n    set: function set(value) {\n      var setting = findDirectionSetting(value);\n      // Have to check for false because the setting an be an empty string.\n      if (setting === false) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _vertical = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"snapToLines\", extend({}, baseObj, {\n    get: function get() {\n      return _snapToLines;\n    },\n    set: function set(value) {\n      _snapToLines = !!value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"line\", extend({}, baseObj, {\n    get: function get() {\n      return _line;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\" && value !== autoKeyword) {\n        throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n      }\n      _line = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"lineAlign\", extend({}, baseObj, {\n    get: function get() {\n      return _lineAlign;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _lineAlign = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"position\", extend({}, baseObj, {\n    get: function get() {\n      return _position;\n    },\n    set: function set(value) {\n      if (value < 0 || value > 100) {\n        throw new Error(\"Position must be between 0 and 100.\");\n      }\n      _position = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"positionAlign\", extend({}, baseObj, {\n    get: function get() {\n      return _positionAlign;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _positionAlign = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"size\", extend({}, baseObj, {\n    get: function get() {\n      return _size;\n    },\n    set: function set(value) {\n      if (value < 0 || value > 100) {\n        throw new Error(\"Size must be between 0 and 100.\");\n      }\n      _size = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"align\", extend({}, baseObj, {\n    get: function get() {\n      return _align;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _align = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  /**\n   * Other <track> spec defined properties\n   */\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n  cue.displayState = undefined;\n\n  if (isIE8) {\n    return cue;\n  }\n}\n\n/**\n * VTTCue methods\n */\n\nVTTCue.prototype.getCueAsHTML = function () {\n  // Assume WebVTT.convertCueToDOMTree is on the global.\n  return WebVTT.convertCueToDOMTree(window, this.text);\n};\n\nmodule.exports = VTTCue;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dGN1ZS5qcz9iOGYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIGF1dG9LZXl3b3JkID0gXCJhdXRvXCI7XG52YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJsclwiOiB0cnVlLFxuICBcInJsXCI6IHRydWVcbn07XG52YXIgYWxpZ25TZXR0aW5nID0ge1xuICBcInN0YXJ0XCI6IHRydWUsXG4gIFwibWlkZGxlXCI6IHRydWUsXG4gIFwiZW5kXCI6IHRydWUsXG4gIFwibGVmdFwiOiB0cnVlLFxuICBcInJpZ2h0XCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSA9IDE7XG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgdmFyIGN1ZSA9IHRoaXM7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGJhc2VPYmogPSB7fTtcblxuICBpZiAoaXNJRTgpIHtcbiAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAqIHRoZSBzcGVjLlxuICAgKi9cblxuICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gIC8vIGxhemlseS5cbiAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgKi9cblxuICB2YXIgX2lkID0gXCJcIjtcbiAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgdmFyIF9yZWdpb24gPSBudWxsO1xuICB2YXIgX3ZlcnRpY2FsID0gXCJcIjtcbiAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gIHZhciBfbGluZSA9IFwiYXV0b1wiO1xuICB2YXIgX2xpbmVBbGlnbiA9IFwic3RhcnRcIjtcbiAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSBcIm1pZGRsZVwiO1xuICB2YXIgX3NpemUgPSA1MDtcbiAgdmFyIF9hbGlnbiA9IFwibWlkZGxlXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImlkXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBhdXNlT25FeGl0XCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzdGFydFRpbWVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJlbmRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidGV4dFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJyZWdpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidmVydGljYWxcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNuYXBUb0xpbmVzXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVBbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwb3NpdGlvbkFsaWduXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNpemVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJhbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgLyoqXG4gICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICovXG5cbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgcmV0dXJuIGN1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFZUVEN1ZSBtZXRob2RzXG4gKi9cblxuVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVEN1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3ZpZGVvanMtdnR0LmpzQDAuMTIuNEB2aWRlb2pzLXZ0dC5qcy9saWIvdnR0Y3VlLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar scrollSetting = {\n  \"\": true,\n  \"up\": true\n};\n\nfunction findScrollSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var scroll = scrollSetting[value.toLowerCase()];\n  return scroll ? value.toLowerCase() : false;\n}\n\nfunction isValidPercentValue(value) {\n  return typeof value === \"number\" && value >= 0 && value <= 100;\n}\n\n// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\nfunction VTTRegion() {\n  var _width = 100;\n  var _lines = 3;\n  var _regionAnchorX = 0;\n  var _regionAnchorY = 100;\n  var _viewportAnchorX = 0;\n  var _viewportAnchorY = 100;\n  var _scroll = \"\";\n\n  Object.defineProperties(this, {\n    \"width\": {\n      enumerable: true,\n      get: function get() {\n        return _width;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"Width must be between 0 and 100.\");\n        }\n        _width = value;\n      }\n    },\n    \"lines\": {\n      enumerable: true,\n      get: function get() {\n        return _lines;\n      },\n      set: function set(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Lines must be set to a number.\");\n        }\n        _lines = value;\n      }\n    },\n    \"regionAnchorY\": {\n      enumerable: true,\n      get: function get() {\n        return _regionAnchorY;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n        }\n        _regionAnchorY = value;\n      }\n    },\n    \"regionAnchorX\": {\n      enumerable: true,\n      get: function get() {\n        return _regionAnchorX;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n        }\n        _regionAnchorX = value;\n      }\n    },\n    \"viewportAnchorY\": {\n      enumerable: true,\n      get: function get() {\n        return _viewportAnchorY;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n        }\n        _viewportAnchorY = value;\n      }\n    },\n    \"viewportAnchorX\": {\n      enumerable: true,\n      get: function get() {\n        return _viewportAnchorX;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n        }\n        _viewportAnchorX = value;\n      }\n    },\n    \"scroll\": {\n      enumerable: true,\n      get: function get() {\n        return _scroll;\n      },\n      set: function set(value) {\n        var setting = findScrollSetting(value);\n        // Have to check for false as an empty string is a legal value.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _scroll = setting;\n      }\n    }\n  });\n}\n\nmodule.exports = VTTRegion;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dHJlZ2lvbi5qcz9mYmU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIHNjcm9sbFNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwidXBcIjogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2Nyb2xsID0gc2Nyb2xsU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIHNjcm9sbCA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEwMCk7XG59XG5cbi8vIFZUVFJlZ2lvbiBzaGltIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0cmVnaW9uLWludGVyZmFjZVxuZnVuY3Rpb24gVlRUUmVnaW9uKCkge1xuICB2YXIgX3dpZHRoID0gMTAwO1xuICB2YXIgX2xpbmVzID0gMztcbiAgdmFyIF9yZWdpb25BbmNob3JYID0gMDtcbiAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWCA9IDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JZID0gMTAwO1xuICB2YXIgX3Njcm9sbCA9IFwiXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIFwid2lkdGhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3dpZHRoID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmVzXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lcyBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVzID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9yZWdpb25BbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmlld3BvcnRBbmNob3JZXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNjcm9sbFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zY3JvbGw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYXMgYW4gZW1wdHkgc3RyaW5nIGlzIGEgbGVnYWwgdmFsdWUuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Njcm9sbCA9IHNldHRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWVFRSZWdpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dHJlZ2lvbi5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUF6RUE7QUF3RkE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvX3ZpZGVvLmpzQDYuNi4wQHZpZGVvLmpzL2Rpc3QvdmlkZW8tanMuY3NzP2FlZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fdmlkZW8uanNANi42LjBAdmlkZW8uanMvZGlzdC92aWRlby1qcy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9pbmRleC5zY3NzP2Q0OTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zY3NzL2luZGV4LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * jQuery.scrollfire()\n *\n * (a) Wil Neeley, Trestle Media, LLC.\n * Code may be freely distributed under the MIT license.\n */\n;\n(function ($, window, document, undefined) {\n\n    var\n\n    // The plugin's name\n    plugin_name = 'scrollfire',\n\n\n    // Ref to plugin itself\n    plugin_ref = null,\n\n\n    // The plugin's defaults\n    defaults = {\n\n        // Executes ONCE when element comes in from TOP (DOWN)\n        onTopIn: function onTopIn() {},\n\n        // Executes ONCE when element goes out the TOP (UP)\n        onTopOut: function onTopOut() {},\n\n        // Executes ONCE when element comes in from the BOTTOM (DOWN)\n        onBottomIn: function onBottomIn() {},\n\n        // Executes ONCE when element goes out the BOTTOM (UP)\n        onBottomOut: function onBottomOut() {},\n\n        // Executes ONCE when element goes out the TOP (UP) and is completely hidden\n        onTopHidden: function onTopHidden() {},\n\n        // Executes ONCE when element comes in from the BOTTOM (DOWN) and is completely in view\n        onBottomVisible: function onBottomVisible() {},\n\n        // Executes ONCE when element goes out the BOTTOM (UP) and is completely hidden\n        onBottomHidden: function onBottomHidden() {},\n\n        // Executes ONCE when element comes in from TOP (DOWN) and is completely in view\n        onTopVisible: function onTopVisible() {},\n\n        // Executes CONTINUOUSLY when scrolling in either direction WHILE element is in view\n        onScroll: function onScroll() {},\n\n        // Executes CONTINUOUSLY when scrolling down WHILE element is in view\n        onScrollDown: function onScrollDown() {},\n\n        // Executes CONTINUOUSLY when scrolling up WHILE element is in view\n        onScrollUp: function onScrollUp() {},\n\n        // Executes CONTINUOUSLY when scrolling in either direction\n        onScrollAlways: function onScrollAlways() {},\n\n        // Executes CONTINUOUSLY when scrolling down\n        onScrollDownAlways: function onScrollDownAlways() {},\n\n        // Executes CONTINUOUSLY when scrolling up\n        onScrollUpAlways: function onScrollUpAlways() {},\n\n        // Offset (constrain the top and bottom of the viewport by a pixel value)\n        offset: 0,\n\n        // Top Offset (constrain the top of the viewport by a pixel value)\n        topOffset: 0,\n\n        // Bottom Offset (constrain the bottom of the viewport by a pixel value)\n        bottomOffset: 0,\n\n        // Parallax object definition\n        parallax: {\n\n            // Are we to parallax this element?\n            active: false,\n\n            // The element the parallax scroll is to be relative to\n            parent: null,\n\n            // Respect the parallax elements margins as a boundary within the parent\n            bound: false,\n\n            // The animation duration of the parallax\n            speed: 10,\n\n            // The animation easing of the parallax\n            easing: 'linear',\n\n            // Invert the Y-axis parallax direction\n            invert: false,\n\n            // Multiplies the scroll distance by this factor, increasing/decreasing parallax distance\n            scalar: 1\n        }\n    },\n\n\n    // The plugin's globals\n    globals = {\n\n        // A place to store references to scrollfire elements\n        registry: {},\n\n        // A starting unique ID\n        guid: 0,\n\n        // Helps us determine which direction is being scrolled\n        last_scroll_pos: 0,\n\n        // Referene the scroll fire scroll event handler\n        scroll_handler: null\n    };\n\n    // Plugin constructor\n    function Plugin(element, options) {\n        this.element = element;\n        this.options = $.extend(true, {}, defaults, options);\n        this._defaults = defaults;\n        this._name = plugin_name;\n        this.init();\n    }\n\n    // Initialization - meat and potatoes\n    Plugin.prototype.init = function () {\n        var plugin = this;\n\n        // Create a new scroll registration object\n        var scroll_obj = {\n\n            // Reference to the element itself\n            _element: plugin.element,\n\n            // The element's unique ID\n            _guid: globals.guid,\n\n            // Handlers for entry/exit of elements\n            _on_top_in: plugin.options.onTopIn,\n            _on_top_in_once: true,\n            _on_top_out: plugin.options.onTopOut,\n            _on_top_out_once: true,\n            _on_bottom_in: plugin.options.onBottomIn,\n            _on_bottom_in_once: true,\n            _on_bottom_out: plugin.options.onBottomOut,\n            _on_bottom_out_once: true,\n\n            // Callbacks for element fully in-view/out-of-view top/bottom\n            _on_top_hidden: plugin.options.onTopHidden,\n            _on_top_hidden_once: true,\n            _on_bottom_visible: plugin.options.onBottomVisible,\n            _on_bottom_visible_once: true,\n            _on_bottom_hidden: plugin.options.onBottomHidden,\n            _on_bottom_hidden_once: true,\n            _on_top_visible: plugin.options.onTopVisible,\n            _on_top_visible_once: true,\n\n            // Handler for continuous scroll while element is in view\n            _on_scroll: plugin.options.onScroll,\n            _on_scroll_down: plugin.options.onScrollDown,\n            _on_scroll_up: plugin.options.onScrollUp,\n\n            // Handler for scroll direction (regardless if element is in view)\n            _on_scroll_always: plugin.options.onScrollAlways,\n            _on_scroll_down_always: plugin.options.onScrollDownAlways,\n            _on_scroll_up_always: plugin.options.onScrollUpAlways,\n\n            // Offset boundary properties\n            _offset: plugin.options.offset,\n            _top_offset: plugin.options.topOffset,\n            _bottom_offset: plugin.options.bottomOffset,\n\n            // Parallax object property implementation\n            _parallax: plugin.options.parallax\n        };\n\n        // Define the scroll handler\n        var scrollFireHandler = function scrollFireHandler(e) {\n\n            // Position of current scroll\n            var scroll_pos = $(window).scrollTop();\n\n            // Reference the scroll direction\n            var scroll_dir = scroll_pos > globals.last_scroll_pos ? 'down' : 'up';\n\n            // Calculate the scroll difference (distance scrolled since last scroll event)\n            var scroll_diff = Math.abs(globals.last_scroll_pos - scroll_pos);\n\n            // Fire callbacks on the registration objects\n            $.each(globals.registry, function (index, value) {\n\n                // Determine offset values\n                var offset = $.isFunction(value._offset) ? value._offset() : value._offset;\n                var topOffset = $.isFunction(value._top_offset) ? value._top_offset() : value._top_offset;\n                var bottomOffset = $.isFunction(value._bottom_offset) ? value._bottom_offset() : value._bottom_offset;\n\n                // Reference the target element\n                var elm = $(value._element);\n\n                // Change our reference during parallax to the container element instead of selected element\n                if (value._parallax.active) {\n                    elm = value._parallax.parent || elm.parent();\n                }\n\n                // Viewport dimensions\n                var viewport_height = $(window).height();\n\n                // Element dimensions\n                var elm_height = elm.outerHeight();\n\n                // Elements position from the top\n                var elm_pos_top = elm.offset().top;\n\n                // Bottom of element position from the top\n                var elm_pos_bot = elm.offset().top + elm_height;\n\n                // Fire the onScrollAlways callback constantly\n                value._on_scroll_always(value._element, scroll_diff, value);\n\n                // Execute down scrolling callbacks\n                if (scroll_dir == 'down') {\n\n                    // When scrolling down determine the true top offset\n                    offset = topOffset ? topOffset : offset;\n\n                    // Conditions for when element is PARTIALLY visible in the viewport (inclusive of offset)\n                    var partiallyVisibleTop = scroll_pos <= elm_pos_top + elm_height - offset;\n                    var partiallyVisibleBottom = scroll_pos + viewport_height >= elm_pos_top + offset;\n\n                    // Conditions for when element is FULLY visible in the viewport (inclusive of offset)\n                    var fullyVisibleTop = scroll_pos <= elm_pos_top - offset;\n                    var fullyVisibleBottom = scroll_pos + viewport_height >= elm_pos_top + elm_height + offset;\n\n                    // Conditions stipulating if element is within the viewport/offset boundaries\n                    var partiallyInBounds = partiallyVisibleTop && partiallyVisibleBottom;\n                    var fullyInBounds = fullyVisibleTop && fullyVisibleBottom;\n\n                    // Conditions for when element begins to go out/come in the viewport (inclusive of offset)\n                    var onTopOut = scroll_pos >= elm_pos_top - offset;\n                    var onBottomIn = scroll_pos + viewport_height >= elm_pos_top + offset;\n\n                    // Fire the registered onTopOut callback\n                    if (onTopOut && value._on_top_out_once) {\n                        value._on_top_in_once = true;\n                        value._on_top_visible_once = true;\n                        value._on_top_out_once = false;\n                        value._on_top_out(value._element, scroll_diff, value);\n                    }\n\n                    // Fire the registered onBottomIn callback\n                    if (onBottomIn && value._on_bottom_in_once) {\n                        value._on_bottom_out_once = true;\n                        value._on_bottom_hidden_once = true;\n                        value._on_bottom_in_once = false;\n                        value._on_bottom_in(value._element, scroll_diff, value);\n                    }\n\n                    // Fire the registered onScrollDownAlways callback\n                    value._on_scroll_down_always(value._element, scroll_diff, value);\n\n                    // Fire callbacks that should occur when element is PARTIALLY in viewport\n                    if (partiallyInBounds) {\n\n                        // Fire the registered onScroll callback\n                        value._on_scroll(value._element, scroll_diff, value);\n\n                        // Fire callback\n                        value._on_scroll_down(value._element, scroll_diff, value);\n                    }\n\n                    // Calculate point at which element becomes visible from the bottom\n                    var to_top_distance_vis = elm_pos_top + elm_height - scroll_pos;\n                    var perc_from_top_vis = (to_top_distance_vis + offset) / viewport_height;\n                    perc_from_top_vis = perc_from_top_vis > 1 ? 1.00 : perc_from_top_vis.toFixed(2);\n\n                    // Calculate the point at which the element becomes hidden at the top\n                    var to_top_distance_hid = elm_pos_top + elm_height - scroll_pos;\n                    var perc_from_top_hid = (to_top_distance_hid - offset) / viewport_height;\n                    perc_from_top_hid = perc_from_top_hid > 1 ? 1.00 : perc_from_top_hid.toFixed(2);\n\n                    // Fire the onBottomVisible callback when element is completely in view\n                    if (perc_from_top_vis < 1 && perc_from_top_hid <= 0 && value._on_bottom_visible_once) {\n                        value._on_bottom_visible_once = false;\n                        value._on_bottom_visible(value._element, scroll_diff, value);\n                    }\n\n                    // Fire onTopHidden callback when element is completely out of view\n                    if (perc_from_top_hid <= 0 && perc_from_top_vis < 1 && value._on_top_hidden_once) {\n                        value._on_top_hidden_once = false;\n                        value._on_top_hidden(value._element, scroll_diff, value);\n                    }\n\n                    // Execute parallax when active\n                    if (value._parallax.active) {\n                        initParallax(value._parallax, $(value._element), offset, scroll_pos, viewport_height);\n                    }\n\n                    // Execute up scrolling callbacks\n                } else {\n\n                    // When scrolling down determine the true top offset\n                    offset = bottomOffset ? bottomOffset : offset;\n\n                    // Conditions for when element is PARTIALLY visible in the viewport (inclusive of offset)\n                    var partiallyVisibleTop = scroll_pos <= elm_pos_top + elm_height - offset;\n                    var partiallyVisibleBottom = scroll_pos + viewport_height >= elm_pos_top + offset;\n\n                    // Conditions for when element is FULLY visible in the viewport (inclusive of offset)\n                    var fullyVisibleTop = scroll_pos <= elm_pos_top - offset;\n                    var fullyVisibleBottom = scroll_pos + viewport_height >= elm_pos_top + elm_height + offset;\n\n                    // Conditions stipulating if element is within the viewport/offset boundaries\n                    var partiallyInBounds = partiallyVisibleTop && partiallyVisibleBottom;\n                    var fullyInBounds = fullyVisibleTop && fullyVisibleBottom;\n\n                    // Conditions for when elements begin to come in/go out the viewport (inclusive of offset)\n                    var onTopIn = scroll_pos <= elm_pos_bot - offset;\n                    var onBottomOut = scroll_pos + viewport_height <= elm_pos_bot + offset;\n\n                    // Fire the registered onTopIn callback\n                    if (onTopIn && value._on_top_in_once) {\n                        value._on_top_out_once = true;\n                        value._on_top_hidden_once = true;\n                        value._on_top_in_once = false;\n                        value._on_top_in(value._element, scroll_diff, value);\n                    }\n\n                    // Fire the registered onBottomOut callback\n                    if (onBottomOut && value._on_bottom_out_once) {\n                        value._on_bottom_in_once = true;\n                        value._on_bottom_visible_once = true;\n                        value._on_bottom_out_once = false;\n                        value._on_bottom_out(value._element, scroll_diff, value);\n                    }\n\n                    // Fire the registered onScrollUpAlways callback\n                    value._on_scroll_up_always(value._element, scroll_diff, value);\n\n                    // Fire callbacks that should occur when element is PARTIALLY in viewport\n                    if (partiallyInBounds) {\n\n                        // Fire the registered onScroll callback\n                        value._on_scroll(value._element, scroll_diff, value);\n\n                        // Fire callback\n                        value._on_scroll_up(value._element, scroll_diff, value);\n                    }\n\n                    // Calculate point at which element becomes visible from the top\n                    var to_top_distance_vis = elm_pos_top + elm_height - (scroll_pos + elm_height + offset);\n                    var perc_from_top_vis = to_top_distance_vis / viewport_height;\n                    perc_from_top_vis = perc_from_top_vis > 1 ? 1.00 : perc_from_top_vis.toFixed(2);\n\n                    // Calculate point at which element becomes hidden at the bottom\n                    var to_top_distance_hid = elm_pos_top + elm_height - (scroll_pos + elm_height - offset);\n                    var perc_from_top_hid = to_top_distance_hid / viewport_height;\n                    perc_from_top_hid = perc_from_top_hid > 1 ? 1.00 : perc_from_top_hid.toFixed(2);\n\n                    // Fire onTopVisible when element is completely in view\n                    if (perc_from_top_vis >= 0 && perc_from_top_hid >= 1 && value._on_top_visible_once) {\n                        value._on_top_visible_once = false;\n                        value._on_top_visible(value._element, scroll_diff, value);\n                    }\n\n                    // Fire the onBottomHidden callback when element is completely out of view\n                    if (perc_from_top_hid >= 1 && perc_from_top_vis >= 0 && value._on_bottom_hidden_once) {\n                        value._on_bottom_hidden_once = false;\n                        value._on_bottom_hidden(value._element, scroll_diff, value);\n                    }\n\n                    // Execute parallax when active\n                    if (value._parallax.active) {\n                        initParallax(value._parallax, $(value._element), offset, scroll_pos, viewport_height);\n                    }\n                }\n            });\n\n            // Update the global scroll position\n            globals.last_scroll_pos = scroll_pos;\n        };\n\n        // Reference the scroll event handler in the registration object\n        scroll_obj['_scroll_handler'] = scrollFireHandler;\n\n        // Register our element(s)\n        globals.registry[globals.guid] = scroll_obj;\n\n        // Update the unique IDs associated with the current element(s)\n        if (!$.data(plugin.element, 'uids')) {\n            $.data(plugin.element, 'uids', [globals.guid]);\n        } else {\n            var uids = $.data(plugin.element, 'uids');\n            uids.push(globals.guid);\n            $.data(plugin.element, 'uids', uids);\n        }\n\n        // Increment the global unique ID for our next round\n        globals.guid++;\n\n        // Attach the scroll handler only once to both the scroll and resize events\n        if (!globals.scroll_handler) {\n            globals.scroll_handler = scrollFireHandler;\n            $(window).bind('scroll resize load', scrollFireHandler);\n        }\n    };\n\n    /**\n     * Returns an elements margin on the specified side ('top', 'right', 'bottom', 'left').\n     * @param elm\n     * @param side\n     */\n    var getElementMargin = function getElementMargin(elm, side) {\n        return parseInt(elm.css('margin-' + side).replace(/px|em|%|auto|inherit/g, \"\"));\n    };\n\n    /**\n     * Initializes and controls parallax effect on elements.\n     * @param conf\n     * @param elm\n     * @param offset\n     * @param scroll_pos\n     * @param viewport_height\n     */\n    var initParallax = function initParallax(conf, elm, offset, scroll_pos, viewport_height) {\n\n        // Reference parallax elements' container\n        var c_elm = conf.parent || elm.parent();\n        var c_height = c_elm.outerHeight();\n        var c_top = c_elm.offset().top;\n\n        // The margin of the element\n        var m_diff = getElementMargin(elm, 'top');\n\n        // Percentage distance container is from starting to go in/out of view\n        var c_dist = c_top - scroll_pos;\n        var c_pos = (c_dist - offset) / (viewport_height - c_height) * conf.scalar;\n\n        // When the parallax direction is inverted\n        if (conf.invert) {\n            c_pos = (c_pos - 1) * -1 * conf.scalar;\n        }\n\n        // Calculate the move to position including margin bounds\n        var p_pos = (c_height - elm.outerHeight(conf.bound)) * c_pos;\n\n        // Determine the location to move to\n        var moveTo = 0;\n        if (c_pos >= 0 && c_pos <= 1) {\n            moveTo = p_pos - (conf.bound ? 0 : m_diff);\n        } else if (c_pos < 0 && conf.scalar == 1) {\n            moveTo = conf.bound ? 0 : -m_diff;\n        } else if (c_pos > 1 && conf.scalar == 1) {\n            moveTo = c_height - (conf.bound ? 0 : m_diff) - elm.outerHeight() - (conf.bound ? m_diff * 2 : 0);\n        }\n\n        // Animate the parallax element\n        elm.stop().animate({\n            top: moveTo\n        }, {\n            duration: conf.speed,\n            easing: conf.easing\n        });\n    };\n\n    // Public methods\n    var public_methods = {\n\n        /**\n         * Removes elements from scrollfire handler.\n         */\n        remove: function remove(elms) {\n            elms.each(function (index, value) {\n                var uid = $(value).data('uids');\n                if (uid) {\n                    delete globals.registry[uid];\n                }\n            });\n            return plugin_ref;\n        }\n    };\n\n    // Plugin wrapper around constructor\n    $.fn[plugin_name] = function (options) {\n\n        // Reference the plugin globally\n        plugin_ref = this;\n\n        // Call methods or init plugin as appropriate\n        if (typeof options == 'string') {\n            var method_name = options;\n            var args = $(arguments).toArray();\n            args.shift();\n            args.unshift(this);\n            return public_methods[method_name].apply(this, args);\n        } else {\n            return this.each(function () {\n                $.data(this, 'plugin_' + plugin_name, new Plugin(this, options));\n            });\n        }\n    };\n})(jQuery, window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9qcXVlcnkuc2Nyb2xsZmlyZS5qcz9lN2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogalF1ZXJ5LnNjcm9sbGZpcmUoKVxuICpcbiAqIChhKSBXaWwgTmVlbGV5LCBUcmVzdGxlIE1lZGlhLCBMTEMuXG4gKiBDb2RlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG47XG4oZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICB2YXJcblxuICAgICAgICAvLyBUaGUgcGx1Z2luJ3MgbmFtZVxuICAgICAgICBwbHVnaW5fbmFtZSA9ICdzY3JvbGxmaXJlJyxcblxuICAgICAgICAvLyBSZWYgdG8gcGx1Z2luIGl0c2VsZlxuICAgICAgICBwbHVnaW5fcmVmID0gbnVsbCxcblxuICAgICAgICAvLyBUaGUgcGx1Z2luJ3MgZGVmYXVsdHNcbiAgICAgICAgZGVmYXVsdHMgPSB7XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIE9OQ0Ugd2hlbiBlbGVtZW50IGNvbWVzIGluIGZyb20gVE9QIChET1dOKVxuICAgICAgICAgICAgb25Ub3BJbjogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgT05DRSB3aGVuIGVsZW1lbnQgZ29lcyBvdXQgdGhlIFRPUCAoVVApXG4gICAgICAgICAgICBvblRvcE91dDogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgT05DRSB3aGVuIGVsZW1lbnQgY29tZXMgaW4gZnJvbSB0aGUgQk9UVE9NIChET1dOKVxuICAgICAgICAgICAgb25Cb3R0b21JbjogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgT05DRSB3aGVuIGVsZW1lbnQgZ29lcyBvdXQgdGhlIEJPVFRPTSAoVVApXG4gICAgICAgICAgICBvbkJvdHRvbU91dDogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgT05DRSB3aGVuIGVsZW1lbnQgZ29lcyBvdXQgdGhlIFRPUCAoVVApIGFuZCBpcyBjb21wbGV0ZWx5IGhpZGRlblxuICAgICAgICAgICAgb25Ub3BIaWRkZW46IGZ1bmN0aW9uKCkge30sXG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIE9OQ0Ugd2hlbiBlbGVtZW50IGNvbWVzIGluIGZyb20gdGhlIEJPVFRPTSAoRE9XTikgYW5kIGlzIGNvbXBsZXRlbHkgaW4gdmlld1xuICAgICAgICAgICAgb25Cb3R0b21WaXNpYmxlOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgICAgICAvLyBFeGVjdXRlcyBPTkNFIHdoZW4gZWxlbWVudCBnb2VzIG91dCB0aGUgQk9UVE9NIChVUCkgYW5kIGlzIGNvbXBsZXRlbHkgaGlkZGVuXG4gICAgICAgICAgICBvbkJvdHRvbUhpZGRlbjogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgT05DRSB3aGVuIGVsZW1lbnQgY29tZXMgaW4gZnJvbSBUT1AgKERPV04pIGFuZCBpcyBjb21wbGV0ZWx5IGluIHZpZXdcbiAgICAgICAgICAgIG9uVG9wVmlzaWJsZTogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgQ09OVElOVU9VU0xZIHdoZW4gc2Nyb2xsaW5nIGluIGVpdGhlciBkaXJlY3Rpb24gV0hJTEUgZWxlbWVudCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBvblNjcm9sbDogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgQ09OVElOVU9VU0xZIHdoZW4gc2Nyb2xsaW5nIGRvd24gV0hJTEUgZWxlbWVudCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBvblNjcm9sbERvd246IGZ1bmN0aW9uKCkge30sXG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIENPTlRJTlVPVVNMWSB3aGVuIHNjcm9sbGluZyB1cCBXSElMRSBlbGVtZW50IGlzIGluIHZpZXdcbiAgICAgICAgICAgIG9uU2Nyb2xsVXA6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGVzIENPTlRJTlVPVVNMWSB3aGVuIHNjcm9sbGluZyBpbiBlaXRoZXIgZGlyZWN0aW9uXG4gICAgICAgICAgICBvblNjcm9sbEFsd2F5czogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgQ09OVElOVU9VU0xZIHdoZW4gc2Nyb2xsaW5nIGRvd25cbiAgICAgICAgICAgIG9uU2Nyb2xsRG93bkFsd2F5czogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgQ09OVElOVU9VU0xZIHdoZW4gc2Nyb2xsaW5nIHVwXG4gICAgICAgICAgICBvblNjcm9sbFVwQWx3YXlzOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgICAgICAvLyBPZmZzZXQgKGNvbnN0cmFpbiB0aGUgdG9wIGFuZCBib3R0b20gb2YgdGhlIHZpZXdwb3J0IGJ5IGEgcGl4ZWwgdmFsdWUpXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXG5cbiAgICAgICAgICAgIC8vIFRvcCBPZmZzZXQgKGNvbnN0cmFpbiB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydCBieSBhIHBpeGVsIHZhbHVlKVxuICAgICAgICAgICAgdG9wT2Zmc2V0OiAwLFxuXG4gICAgICAgICAgICAvLyBCb3R0b20gT2Zmc2V0IChjb25zdHJhaW4gdGhlIGJvdHRvbSBvZiB0aGUgdmlld3BvcnQgYnkgYSBwaXhlbCB2YWx1ZSlcbiAgICAgICAgICAgIGJvdHRvbU9mZnNldDogMCxcblxuICAgICAgICAgICAgLy8gUGFyYWxsYXggb2JqZWN0IGRlZmluaXRpb25cbiAgICAgICAgICAgIHBhcmFsbGF4OiB7XG5cbiAgICAgICAgICAgICAgICAvLyBBcmUgd2UgdG8gcGFyYWxsYXggdGhpcyBlbGVtZW50P1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB0aGUgcGFyYWxsYXggc2Nyb2xsIGlzIHRvIGJlIHJlbGF0aXZlIHRvXG4gICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLy8gUmVzcGVjdCB0aGUgcGFyYWxsYXggZWxlbWVudHMgbWFyZ2lucyBhcyBhIGJvdW5kYXJ5IHdpdGhpbiB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgYm91bmQ6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBvZiB0aGUgcGFyYWxsYXhcbiAgICAgICAgICAgICAgICBzcGVlZDogMTAsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYW5pbWF0aW9uIGVhc2luZyBvZiB0aGUgcGFyYWxsYXhcbiAgICAgICAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuXG4gICAgICAgICAgICAgICAgLy8gSW52ZXJ0IHRoZSBZLWF4aXMgcGFyYWxsYXggZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaW52ZXJ0OiBmYWxzZSxcblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGxpZXMgdGhlIHNjcm9sbCBkaXN0YW5jZSBieSB0aGlzIGZhY3RvciwgaW5jcmVhc2luZy9kZWNyZWFzaW5nIHBhcmFsbGF4IGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgc2NhbGFyOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhlIHBsdWdpbidzIGdsb2JhbHNcbiAgICAgICAgZ2xvYmFscyA9IHtcblxuICAgICAgICAgICAgLy8gQSBwbGFjZSB0byBzdG9yZSByZWZlcmVuY2VzIHRvIHNjcm9sbGZpcmUgZWxlbWVudHNcbiAgICAgICAgICAgIHJlZ2lzdHJ5OiB7fSxcblxuICAgICAgICAgICAgLy8gQSBzdGFydGluZyB1bmlxdWUgSURcbiAgICAgICAgICAgIGd1aWQ6IDAsXG5cbiAgICAgICAgICAgIC8vIEhlbHBzIHVzIGRldGVybWluZSB3aGljaCBkaXJlY3Rpb24gaXMgYmVpbmcgc2Nyb2xsZWRcbiAgICAgICAgICAgIGxhc3Rfc2Nyb2xsX3BvczogMCxcblxuICAgICAgICAgICAgLy8gUmVmZXJlbmUgdGhlIHNjcm9sbCBmaXJlIHNjcm9sbCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBzY3JvbGxfaGFuZGxlcjogbnVsbFxuICAgICAgICB9O1xuXG5cbiAgICAvLyBQbHVnaW4gY29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICB0aGlzLl9uYW1lID0gcGx1Z2luX25hbWU7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemF0aW9uIC0gbWVhdCBhbmQgcG90YXRvZXNcbiAgICBQbHVnaW4ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNjcm9sbCByZWdpc3RyYXRpb24gb2JqZWN0XG4gICAgICAgIHZhciBzY3JvbGxfb2JqID0ge1xuXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgaXRzZWxmXG4gICAgICAgICAgICBfZWxlbWVudDogcGx1Z2luLmVsZW1lbnQsXG5cbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50J3MgdW5pcXVlIElEXG4gICAgICAgICAgICBfZ3VpZDogZ2xvYmFscy5ndWlkLFxuXG4gICAgICAgICAgICAvLyBIYW5kbGVycyBmb3IgZW50cnkvZXhpdCBvZiBlbGVtZW50c1xuICAgICAgICAgICAgX29uX3RvcF9pbjogcGx1Z2luLm9wdGlvbnMub25Ub3BJbixcbiAgICAgICAgICAgIF9vbl90b3BfaW5fb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIF9vbl90b3Bfb3V0OiBwbHVnaW4ub3B0aW9ucy5vblRvcE91dCxcbiAgICAgICAgICAgIF9vbl90b3Bfb3V0X29uY2U6IHRydWUsXG4gICAgICAgICAgICBfb25fYm90dG9tX2luOiBwbHVnaW4ub3B0aW9ucy5vbkJvdHRvbUluLFxuICAgICAgICAgICAgX29uX2JvdHRvbV9pbl9vbmNlOiB0cnVlLFxuICAgICAgICAgICAgX29uX2JvdHRvbV9vdXQ6IHBsdWdpbi5vcHRpb25zLm9uQm90dG9tT3V0LFxuICAgICAgICAgICAgX29uX2JvdHRvbV9vdXRfb25jZTogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gQ2FsbGJhY2tzIGZvciBlbGVtZW50IGZ1bGx5IGluLXZpZXcvb3V0LW9mLXZpZXcgdG9wL2JvdHRvbVxuICAgICAgICAgICAgX29uX3RvcF9oaWRkZW46IHBsdWdpbi5vcHRpb25zLm9uVG9wSGlkZGVuLFxuICAgICAgICAgICAgX29uX3RvcF9oaWRkZW5fb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIF9vbl9ib3R0b21fdmlzaWJsZTogcGx1Z2luLm9wdGlvbnMub25Cb3R0b21WaXNpYmxlLFxuICAgICAgICAgICAgX29uX2JvdHRvbV92aXNpYmxlX29uY2U6IHRydWUsXG4gICAgICAgICAgICBfb25fYm90dG9tX2hpZGRlbjogcGx1Z2luLm9wdGlvbnMub25Cb3R0b21IaWRkZW4sXG4gICAgICAgICAgICBfb25fYm90dG9tX2hpZGRlbl9vbmNlOiB0cnVlLFxuICAgICAgICAgICAgX29uX3RvcF92aXNpYmxlOiBwbHVnaW4ub3B0aW9ucy5vblRvcFZpc2libGUsXG4gICAgICAgICAgICBfb25fdG9wX3Zpc2libGVfb25jZTogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmb3IgY29udGludW91cyBzY3JvbGwgd2hpbGUgZWxlbWVudCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBfb25fc2Nyb2xsOiBwbHVnaW4ub3B0aW9ucy5vblNjcm9sbCxcbiAgICAgICAgICAgIF9vbl9zY3JvbGxfZG93bjogcGx1Z2luLm9wdGlvbnMub25TY3JvbGxEb3duLFxuICAgICAgICAgICAgX29uX3Njcm9sbF91cDogcGx1Z2luLm9wdGlvbnMub25TY3JvbGxVcCxcblxuICAgICAgICAgICAgLy8gSGFuZGxlciBmb3Igc2Nyb2xsIGRpcmVjdGlvbiAocmVnYXJkbGVzcyBpZiBlbGVtZW50IGlzIGluIHZpZXcpXG4gICAgICAgICAgICBfb25fc2Nyb2xsX2Fsd2F5czogcGx1Z2luLm9wdGlvbnMub25TY3JvbGxBbHdheXMsXG4gICAgICAgICAgICBfb25fc2Nyb2xsX2Rvd25fYWx3YXlzOiBwbHVnaW4ub3B0aW9ucy5vblNjcm9sbERvd25BbHdheXMsXG4gICAgICAgICAgICBfb25fc2Nyb2xsX3VwX2Fsd2F5czogcGx1Z2luLm9wdGlvbnMub25TY3JvbGxVcEFsd2F5cyxcblxuICAgICAgICAgICAgLy8gT2Zmc2V0IGJvdW5kYXJ5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIF9vZmZzZXQ6IHBsdWdpbi5vcHRpb25zLm9mZnNldCxcbiAgICAgICAgICAgIF90b3Bfb2Zmc2V0OiBwbHVnaW4ub3B0aW9ucy50b3BPZmZzZXQsXG4gICAgICAgICAgICBfYm90dG9tX29mZnNldDogcGx1Z2luLm9wdGlvbnMuYm90dG9tT2Zmc2V0LFxuXG4gICAgICAgICAgICAvLyBQYXJhbGxheCBvYmplY3QgcHJvcGVydHkgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIF9wYXJhbGxheDogcGx1Z2luLm9wdGlvbnMucGFyYWxsYXhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWZpbmUgdGhlIHNjcm9sbCBoYW5kbGVyXG4gICAgICAgIHZhciBzY3JvbGxGaXJlSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICAgICAgLy8gUG9zaXRpb24gb2YgY3VycmVudCBzY3JvbGxcbiAgICAgICAgICAgIHZhciBzY3JvbGxfcG9zID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2UgdGhlIHNjcm9sbCBkaXJlY3Rpb25cbiAgICAgICAgICAgIHZhciBzY3JvbGxfZGlyID0gKHNjcm9sbF9wb3MgPiBnbG9iYWxzLmxhc3Rfc2Nyb2xsX3BvcykgPyAnZG93bicgOiAndXAnO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjcm9sbCBkaWZmZXJlbmNlIChkaXN0YW5jZSBzY3JvbGxlZCBzaW5jZSBsYXN0IHNjcm9sbCBldmVudClcbiAgICAgICAgICAgIHZhciBzY3JvbGxfZGlmZiA9IE1hdGguYWJzKGdsb2JhbHMubGFzdF9zY3JvbGxfcG9zIC0gc2Nyb2xsX3Bvcyk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgY2FsbGJhY2tzIG9uIHRoZSByZWdpc3RyYXRpb24gb2JqZWN0c1xuICAgICAgICAgICAgJC5lYWNoKGdsb2JhbHMucmVnaXN0cnksIGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIG9mZnNldCB2YWx1ZXNcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKCQuaXNGdW5jdGlvbih2YWx1ZS5fb2Zmc2V0KSkgPyB2YWx1ZS5fb2Zmc2V0KCkgOiB2YWx1ZS5fb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciB0b3BPZmZzZXQgPSAoJC5pc0Z1bmN0aW9uKHZhbHVlLl90b3Bfb2Zmc2V0KSkgPyB2YWx1ZS5fdG9wX29mZnNldCgpIDogdmFsdWUuX3RvcF9vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGJvdHRvbU9mZnNldCA9ICgkLmlzRnVuY3Rpb24odmFsdWUuX2JvdHRvbV9vZmZzZXQpKSA/IHZhbHVlLl9ib3R0b21fb2Zmc2V0KCkgOiB2YWx1ZS5fYm90dG9tX29mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgZWxtID0gJCh2YWx1ZS5fZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2Ugb3VyIHJlZmVyZW5jZSBkdXJpbmcgcGFyYWxsYXggdG8gdGhlIGNvbnRhaW5lciBlbGVtZW50IGluc3RlYWQgb2Ygc2VsZWN0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fcGFyYWxsYXguYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbSA9IHZhbHVlLl9wYXJhbGxheC5wYXJlbnQgfHwgZWxtLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFZpZXdwb3J0IGRpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRfaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgdmFyIGVsbV9oZWlnaHQgPSBlbG0ub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnRzIHBvc2l0aW9uIGZyb20gdGhlIHRvcFxuICAgICAgICAgICAgICAgIHZhciBlbG1fcG9zX3RvcCA9IGVsbS5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gb2YgZWxlbWVudCBwb3NpdGlvbiBmcm9tIHRoZSB0b3BcbiAgICAgICAgICAgICAgICB2YXIgZWxtX3Bvc19ib3QgPSBlbG0ub2Zmc2V0KCkudG9wICsgZWxtX2hlaWdodDtcblxuICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIG9uU2Nyb2xsQWx3YXlzIGNhbGxiYWNrIGNvbnN0YW50bHlcbiAgICAgICAgICAgICAgICB2YWx1ZS5fb25fc2Nyb2xsX2Fsd2F5cyh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgZG93biBzY3JvbGxpbmcgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbF9kaXIgPT0gJ2Rvd24nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biBkZXRlcm1pbmUgdGhlIHRydWUgdG9wIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAodG9wT2Zmc2V0KSA/IHRvcE9mZnNldCA6IG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25kaXRpb25zIGZvciB3aGVuIGVsZW1lbnQgaXMgUEFSVElBTExZIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0IChpbmNsdXNpdmUgb2Ygb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbGx5VmlzaWJsZVRvcCA9IHNjcm9sbF9wb3MgPD0gKGVsbV9wb3NfdG9wICsgZWxtX2hlaWdodCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsbHlWaXNpYmxlQm90dG9tID0gKHNjcm9sbF9wb3MgKyB2aWV3cG9ydF9oZWlnaHQpID49IChlbG1fcG9zX3RvcCArIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGl0aW9ucyBmb3Igd2hlbiBlbGVtZW50IGlzIEZVTExZIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0IChpbmNsdXNpdmUgb2Ygb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlWaXNpYmxlVG9wID0gc2Nyb2xsX3BvcyA8PSAoZWxtX3Bvc190b3AgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlWaXNpYmxlQm90dG9tID0gKHNjcm9sbF9wb3MgKyB2aWV3cG9ydF9oZWlnaHQpID49IChlbG1fcG9zX3RvcCArIGVsbV9oZWlnaHQgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmRpdGlvbnMgc3RpcHVsYXRpbmcgaWYgZWxlbWVudCBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0L29mZnNldCBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsbHlJbkJvdW5kcyA9IChwYXJ0aWFsbHlWaXNpYmxlVG9wICYmIHBhcnRpYWxseVZpc2libGVCb3R0b20pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlJbkJvdW5kcyA9IChmdWxseVZpc2libGVUb3AgJiYgZnVsbHlWaXNpYmxlQm90dG9tKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25kaXRpb25zIGZvciB3aGVuIGVsZW1lbnQgYmVnaW5zIHRvIGdvIG91dC9jb21lIGluIHRoZSB2aWV3cG9ydCAoaW5jbHVzaXZlIG9mIG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uVG9wT3V0ID0gc2Nyb2xsX3BvcyA+PSAoZWxtX3Bvc190b3AgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25Cb3R0b21JbiA9IChzY3JvbGxfcG9zICsgdmlld3BvcnRfaGVpZ2h0KSA+PSAoZWxtX3Bvc190b3AgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIHJlZ2lzdGVyZWQgb25Ub3BPdXQgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uVG9wT3V0ICYmIHZhbHVlLl9vbl90b3Bfb3V0X29uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3BfaW5fb25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fdG9wX3Zpc2libGVfb25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fdG9wX291dF9vbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fdG9wX291dCh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIHJlZ2lzdGVyZWQgb25Cb3R0b21JbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAob25Cb3R0b21JbiAmJiB2YWx1ZS5fb25fYm90dG9tX2luX29uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl9ib3R0b21fb3V0X29uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV9oaWRkZW5fb25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fYm90dG9tX2luX29uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl9ib3R0b21faW4odmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSByZWdpc3RlcmVkIG9uU2Nyb2xsRG93bkFsd2F5cyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fc2Nyb2xsX2Rvd25fYWx3YXlzKHZhbHVlLl9lbGVtZW50LCBzY3JvbGxfZGlmZiwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgY2FsbGJhY2tzIHRoYXQgc2hvdWxkIG9jY3VyIHdoZW4gZWxlbWVudCBpcyBQQVJUSUFMTFkgaW4gdmlld3BvcnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRpYWxseUluQm91bmRzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIHJlZ2lzdGVyZWQgb25TY3JvbGwgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl9zY3JvbGwodmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl9zY3JvbGxfZG93bih2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb2ludCBhdCB3aGljaCBlbGVtZW50IGJlY29tZXMgdmlzaWJsZSBmcm9tIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvX3RvcF9kaXN0YW5jZV92aXMgPSAoZWxtX3Bvc190b3AgKyBlbG1faGVpZ2h0KSAtIHNjcm9sbF9wb3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjX2Zyb21fdG9wX3ZpcyA9ICgodG9fdG9wX2Rpc3RhbmNlX3ZpcyArIG9mZnNldCkgLyB2aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBwZXJjX2Zyb21fdG9wX3ZpcyA9IChwZXJjX2Zyb21fdG9wX3ZpcyA+IDEpID8gMS4wMCA6IHBlcmNfZnJvbV90b3BfdmlzLnRvRml4ZWQoMik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2ludCBhdCB3aGljaCB0aGUgZWxlbWVudCBiZWNvbWVzIGhpZGRlbiBhdCB0aGUgdG9wXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b190b3BfZGlzdGFuY2VfaGlkID0gKGVsbV9wb3NfdG9wICsgZWxtX2hlaWdodCkgLSBzY3JvbGxfcG9zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY19mcm9tX3RvcF9oaWQgPSAoKHRvX3RvcF9kaXN0YW5jZV9oaWQgLSBvZmZzZXQpIC8gdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcGVyY19mcm9tX3RvcF9oaWQgPSAocGVyY19mcm9tX3RvcF9oaWQgPiAxKSA/IDEuMDAgOiBwZXJjX2Zyb21fdG9wX2hpZC50b0ZpeGVkKDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIG9uQm90dG9tVmlzaWJsZSBjYWxsYmFjayB3aGVuIGVsZW1lbnQgaXMgY29tcGxldGVseSBpbiB2aWV3XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjX2Zyb21fdG9wX3ZpcyA8IDEgJiYgcGVyY19mcm9tX3RvcF9oaWQgPD0gMCAmJiB2YWx1ZS5fb25fYm90dG9tX3Zpc2libGVfb25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV92aXNpYmxlX29uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl9ib3R0b21fdmlzaWJsZSh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgb25Ub3BIaWRkZW4gY2FsbGJhY2sgd2hlbiBlbGVtZW50IGlzIGNvbXBsZXRlbHkgb3V0IG9mIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNfZnJvbV90b3BfaGlkIDw9IDAgJiYgcGVyY19mcm9tX3RvcF92aXMgPCAxICYmIHZhbHVlLl9vbl90b3BfaGlkZGVuX29uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3BfaGlkZGVuX29uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3BfaGlkZGVuKHZhbHVlLl9lbGVtZW50LCBzY3JvbGxfZGlmZiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBwYXJhbGxheCB3aGVuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuX3BhcmFsbGF4LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFsbGF4KHZhbHVlLl9wYXJhbGxheCwgJCh2YWx1ZS5fZWxlbWVudCksIG9mZnNldCwgc2Nyb2xsX3Bvcywgdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdXAgc2Nyb2xsaW5nIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgZG93biBkZXRlcm1pbmUgdGhlIHRydWUgdG9wIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAoYm90dG9tT2Zmc2V0KSA/IGJvdHRvbU9mZnNldCA6IG9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25kaXRpb25zIGZvciB3aGVuIGVsZW1lbnQgaXMgUEFSVElBTExZIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0IChpbmNsdXNpdmUgb2Ygb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbGx5VmlzaWJsZVRvcCA9IHNjcm9sbF9wb3MgPD0gKGVsbV9wb3NfdG9wICsgZWxtX2hlaWdodCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsbHlWaXNpYmxlQm90dG9tID0gKHNjcm9sbF9wb3MgKyB2aWV3cG9ydF9oZWlnaHQpID49IChlbG1fcG9zX3RvcCArIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGl0aW9ucyBmb3Igd2hlbiBlbGVtZW50IGlzIEZVTExZIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0IChpbmNsdXNpdmUgb2Ygb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlWaXNpYmxlVG9wID0gc2Nyb2xsX3BvcyA8PSAoZWxtX3Bvc190b3AgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlWaXNpYmxlQm90dG9tID0gKHNjcm9sbF9wb3MgKyB2aWV3cG9ydF9oZWlnaHQpID49IChlbG1fcG9zX3RvcCArIGVsbV9oZWlnaHQgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmRpdGlvbnMgc3RpcHVsYXRpbmcgaWYgZWxlbWVudCBpcyB3aXRoaW4gdGhlIHZpZXdwb3J0L29mZnNldCBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsbHlJbkJvdW5kcyA9IChwYXJ0aWFsbHlWaXNpYmxlVG9wICYmIHBhcnRpYWxseVZpc2libGVCb3R0b20pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHlJbkJvdW5kcyA9IChmdWxseVZpc2libGVUb3AgJiYgZnVsbHlWaXNpYmxlQm90dG9tKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb25kaXRpb25zIGZvciB3aGVuIGVsZW1lbnRzIGJlZ2luIHRvIGNvbWUgaW4vZ28gb3V0IHRoZSB2aWV3cG9ydCAoaW5jbHVzaXZlIG9mIG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uVG9wSW4gPSBzY3JvbGxfcG9zIDw9IChlbG1fcG9zX2JvdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkJvdHRvbU91dCA9IChzY3JvbGxfcG9zICsgdmlld3BvcnRfaGVpZ2h0KSA8PSAoZWxtX3Bvc19ib3QgKyBvZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIHJlZ2lzdGVyZWQgb25Ub3BJbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBpZiAob25Ub3BJbiAmJiB2YWx1ZS5fb25fdG9wX2luX29uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3Bfb3V0X29uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX3RvcF9oaWRkZW5fb25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fdG9wX2luX29uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3BfaW4odmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSByZWdpc3RlcmVkIG9uQm90dG9tT3V0IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkJvdHRvbU91dCAmJiB2YWx1ZS5fb25fYm90dG9tX291dF9vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb25fYm90dG9tX2luX29uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV92aXNpYmxlX29uY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV9vdXRfb25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV9vdXQodmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIHRoZSByZWdpc3RlcmVkIG9uU2Nyb2xsVXBBbHdheXMgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX3Njcm9sbF91cF9hbHdheXModmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBjYWxsYmFja3MgdGhhdCBzaG91bGQgb2NjdXIgd2hlbiBlbGVtZW50IGlzIFBBUlRJQUxMWSBpbiB2aWV3cG9ydFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGlhbGx5SW5Cb3VuZHMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgcmVnaXN0ZXJlZCBvblNjcm9sbCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX3Njcm9sbCh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX3Njcm9sbF91cCh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb2ludCBhdCB3aGljaCBlbGVtZW50IGJlY29tZXMgdmlzaWJsZSBmcm9tIHRoZSB0b3BcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvX3RvcF9kaXN0YW5jZV92aXMgPSAoZWxtX3Bvc190b3AgKyBlbG1faGVpZ2h0KSAtIChzY3JvbGxfcG9zICsgZWxtX2hlaWdodCArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjX2Zyb21fdG9wX3ZpcyA9ICh0b190b3BfZGlzdGFuY2VfdmlzIC8gdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcGVyY19mcm9tX3RvcF92aXMgPSAocGVyY19mcm9tX3RvcF92aXMgPiAxKSA/IDEuMDAgOiBwZXJjX2Zyb21fdG9wX3Zpcy50b0ZpeGVkKDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb2ludCBhdCB3aGljaCBlbGVtZW50IGJlY29tZXMgaGlkZGVuIGF0IHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvX3RvcF9kaXN0YW5jZV9oaWQgPSAoZWxtX3Bvc190b3AgKyBlbG1faGVpZ2h0KSAtIChzY3JvbGxfcG9zICsgZWxtX2hlaWdodCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjX2Zyb21fdG9wX2hpZCA9ICh0b190b3BfZGlzdGFuY2VfaGlkIC8gdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcGVyY19mcm9tX3RvcF9oaWQgPSAocGVyY19mcm9tX3RvcF9oaWQgPiAxKSA/IDEuMDAgOiBwZXJjX2Zyb21fdG9wX2hpZC50b0ZpeGVkKDIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgb25Ub3BWaXNpYmxlIHdoZW4gZWxlbWVudCBpcyBjb21wbGV0ZWx5IGluIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNfZnJvbV90b3BfdmlzID49IDAgJiYgcGVyY19mcm9tX3RvcF9oaWQgPj0gMSAmJiB2YWx1ZS5fb25fdG9wX3Zpc2libGVfb25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX3RvcF92aXNpYmxlX29uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vbl90b3BfdmlzaWJsZSh2YWx1ZS5fZWxlbWVudCwgc2Nyb2xsX2RpZmYsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgdGhlIG9uQm90dG9tSGlkZGVuIGNhbGxiYWNrIHdoZW4gZWxlbWVudCBpcyBjb21wbGV0ZWx5IG91dCBvZiB2aWV3XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJjX2Zyb21fdG9wX2hpZCA+PSAxICYmIHBlcmNfZnJvbV90b3BfdmlzID49IDAgJiYgdmFsdWUuX29uX2JvdHRvbV9oaWRkZW5fb25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV9oaWRkZW5fb25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX29uX2JvdHRvbV9oaWRkZW4odmFsdWUuX2VsZW1lbnQsIHNjcm9sbF9kaWZmLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHBhcmFsbGF4IHdoZW4gYWN0aXZlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fcGFyYWxsYXguYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0UGFyYWxsYXgodmFsdWUuX3BhcmFsbGF4LCAkKHZhbHVlLl9lbGVtZW50KSwgb2Zmc2V0LCBzY3JvbGxfcG9zLCB2aWV3cG9ydF9oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2xvYmFsIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgZ2xvYmFscy5sYXN0X3Njcm9sbF9wb3MgPSBzY3JvbGxfcG9zO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSB0aGUgc2Nyb2xsIGV2ZW50IGhhbmRsZXIgaW4gdGhlIHJlZ2lzdHJhdGlvbiBvYmplY3RcbiAgICAgICAgc2Nyb2xsX29ialsnX3Njcm9sbF9oYW5kbGVyJ10gPSBzY3JvbGxGaXJlSGFuZGxlcjtcblxuICAgICAgICAvLyBSZWdpc3RlciBvdXIgZWxlbWVudChzKVxuICAgICAgICBnbG9iYWxzLnJlZ2lzdHJ5W2dsb2JhbHMuZ3VpZF0gPSBzY3JvbGxfb2JqO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdW5pcXVlIElEcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudChzKVxuICAgICAgICBpZiAoISQuZGF0YShwbHVnaW4uZWxlbWVudCwgJ3VpZHMnKSkge1xuICAgICAgICAgICAgJC5kYXRhKHBsdWdpbi5lbGVtZW50LCAndWlkcycsIFtnbG9iYWxzLmd1aWRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1aWRzID0gJC5kYXRhKHBsdWdpbi5lbGVtZW50LCAndWlkcycpO1xuICAgICAgICAgICAgdWlkcy5wdXNoKGdsb2JhbHMuZ3VpZCk7XG4gICAgICAgICAgICAkLmRhdGEocGx1Z2luLmVsZW1lbnQsICd1aWRzJywgdWlkcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGdsb2JhbCB1bmlxdWUgSUQgZm9yIG91ciBuZXh0IHJvdW5kXG4gICAgICAgIGdsb2JhbHMuZ3VpZCsrO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgc2Nyb2xsIGhhbmRsZXIgb25seSBvbmNlIHRvIGJvdGggdGhlIHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50c1xuICAgICAgICBpZiAoIWdsb2JhbHMuc2Nyb2xsX2hhbmRsZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbHMuc2Nyb2xsX2hhbmRsZXIgPSBzY3JvbGxGaXJlSGFuZGxlcjtcbiAgICAgICAgICAgICQod2luZG93KS5iaW5kKCdzY3JvbGwgcmVzaXplIGxvYWQnLCBzY3JvbGxGaXJlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbGVtZW50cyBtYXJnaW4gb24gdGhlIHNwZWNpZmllZCBzaWRlICgndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JykuXG4gICAgICogQHBhcmFtIGVsbVxuICAgICAqIEBwYXJhbSBzaWRlXG4gICAgICovXG4gICAgdmFyIGdldEVsZW1lbnRNYXJnaW4gPSBmdW5jdGlvbihlbG0sIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGVsbS5jc3MoJ21hcmdpbi0nICsgc2lkZSkucmVwbGFjZSgvcHh8ZW18JXxhdXRvfGluaGVyaXQvZywgXCJcIikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgY29udHJvbHMgcGFyYWxsYXggZWZmZWN0IG9uIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSBjb25mXG4gICAgICogQHBhcmFtIGVsbVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gc2Nyb2xsX3Bvc1xuICAgICAqIEBwYXJhbSB2aWV3cG9ydF9oZWlnaHRcbiAgICAgKi9cbiAgICB2YXIgaW5pdFBhcmFsbGF4ID0gZnVuY3Rpb24oY29uZiwgZWxtLCBvZmZzZXQsIHNjcm9sbF9wb3MsIHZpZXdwb3J0X2hlaWdodCkge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSBwYXJhbGxheCBlbGVtZW50cycgY29udGFpbmVyXG4gICAgICAgIHZhciBjX2VsbSA9IGNvbmYucGFyZW50IHx8IGVsbS5wYXJlbnQoKTtcbiAgICAgICAgdmFyIGNfaGVpZ2h0ID0gY19lbG0ub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgdmFyIGNfdG9wID0gY19lbG0ub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgIC8vIFRoZSBtYXJnaW4gb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgdmFyIG1fZGlmZiA9IGdldEVsZW1lbnRNYXJnaW4oZWxtLCAndG9wJyk7XG5cbiAgICAgICAgLy8gUGVyY2VudGFnZSBkaXN0YW5jZSBjb250YWluZXIgaXMgZnJvbSBzdGFydGluZyB0byBnbyBpbi9vdXQgb2Ygdmlld1xuICAgICAgICB2YXIgY19kaXN0ID0gKGNfdG9wKSAtIHNjcm9sbF9wb3M7XG4gICAgICAgIHZhciBjX3BvcyA9ICgoY19kaXN0IC0gb2Zmc2V0KSAvICh2aWV3cG9ydF9oZWlnaHQgLSBjX2hlaWdodCkpICogY29uZi5zY2FsYXI7XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgcGFyYWxsYXggZGlyZWN0aW9uIGlzIGludmVydGVkXG4gICAgICAgIGlmIChjb25mLmludmVydCkge1xuICAgICAgICAgICAgY19wb3MgPSAoKGNfcG9zIC0gMSkgKiAtMSkgKiBjb25mLnNjYWxhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbW92ZSB0byBwb3NpdGlvbiBpbmNsdWRpbmcgbWFyZ2luIGJvdW5kc1xuICAgICAgICB2YXIgcF9wb3MgPSAoY19oZWlnaHQgLSBlbG0ub3V0ZXJIZWlnaHQoY29uZi5ib3VuZCkpICogY19wb3M7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBsb2NhdGlvbiB0byBtb3ZlIHRvXG4gICAgICAgIHZhciBtb3ZlVG8gPSAwO1xuICAgICAgICBpZiAoY19wb3MgPj0gMCAmJiBjX3BvcyA8PSAxKSB7XG4gICAgICAgICAgICBtb3ZlVG8gPSAocF9wb3MgLSAoY29uZi5ib3VuZCA/IDAgOiBtX2RpZmYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjX3BvcyA8IDAgJiYgY29uZi5zY2FsYXIgPT0gMSkge1xuICAgICAgICAgICAgbW92ZVRvID0gKGNvbmYuYm91bmQgPyAwIDogLW1fZGlmZik7XG4gICAgICAgIH0gZWxzZSBpZiAoY19wb3MgPiAxICYmIGNvbmYuc2NhbGFyID09IDEpIHtcbiAgICAgICAgICAgIG1vdmVUbyA9IGNfaGVpZ2h0IC0gKGNvbmYuYm91bmQgPyAwIDogbV9kaWZmKSAtIGVsbS5vdXRlckhlaWdodCgpIC0gKGNvbmYuYm91bmQgPyAobV9kaWZmICogMikgOiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuaW1hdGUgdGhlIHBhcmFsbGF4IGVsZW1lbnRcbiAgICAgICAgZWxtLnN0b3AoKS5hbmltYXRlKHtcbiAgICAgICAgICAgIHRvcDogbW92ZVRvXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBjb25mLnNwZWVkLFxuICAgICAgICAgICAgZWFzaW5nOiBjb25mLmVhc2luZ1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUHVibGljIG1ldGhvZHNcbiAgICB2YXIgcHVibGljX21ldGhvZHMgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBzY3JvbGxmaXJlIGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGVsbXMpIHtcbiAgICAgICAgICAgIGVsbXMuZWFjaChmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gJCh2YWx1ZSkuZGF0YSgndWlkcycpO1xuICAgICAgICAgICAgICAgIGlmICh1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbHMucmVnaXN0cnlbdWlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5fcmVmO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBsdWdpbiB3cmFwcGVyIGFyb3VuZCBjb25zdHJ1Y3RvclxuICAgICQuZm5bcGx1Z2luX25hbWVdID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZSB0aGUgcGx1Z2luIGdsb2JhbGx5XG4gICAgICAgIHBsdWdpbl9yZWYgPSB0aGlzO1xuXG4gICAgICAgIC8vIENhbGwgbWV0aG9kcyBvciBpbml0IHBsdWdpbiBhcyBhcHByb3ByaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgYXJncyA9ICQoYXJndW1lbnRzKS50b0FycmF5KCk7XG4gICAgICAgICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcHVibGljX21ldGhvZHNbbWV0aG9kX25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkLmRhdGEodGhpcywgJ3BsdWdpbl8nICsgcGx1Z2luX25hbWUsIG5ldyBQbHVnaW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KShqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saWIvanF1ZXJ5LnNjcm9sbGZpcmUuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXREQTtBQUNBO0FBQ0E7QUE2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUNBO0FBQ0E7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/** @preserve jQuery animateNumber plugin v0.0.10\n * (c) 2013, Alexandr Borisov.\n * https://github.com/aishek/jquery-animateNumber\n */\n\n// ['...'] notation using to avoid names minification by Google Closure Compiler\n(function ($) {\n  var reverse = function reverse(value) {\n    return value.split('').reverse().join('');\n  };\n\n  var defaults = {\n    numberStep: function numberStep(now, tween) {\n      var floored_number = Math.floor(now),\n          target = $(tween.elem);\n\n      target.text(floored_number);\n    }\n  };\n\n  var handle = function handle(tween) {\n    var elem = tween.elem;\n    if (elem.nodeType && elem.parentNode) {\n      var handler = elem._animateNumberSetter;\n      if (!handler) {\n        handler = defaults.numberStep;\n      }\n      handler(tween.now, tween);\n    }\n  };\n\n  if (!$.Tween || !$.Tween.propHooks) {\n    $.fx.step.number = handle;\n  } else {\n    $.Tween.propHooks.number = {\n      set: handle\n    };\n  }\n\n  var extract_number_parts = function extract_number_parts(separated_number, group_length) {\n    var numbers = separated_number.split('').reverse(),\n        number_parts = [],\n        current_number_part,\n        current_index,\n        q;\n\n    for (var i = 0, l = Math.ceil(separated_number.length / group_length); i < l; i++) {\n      current_number_part = '';\n      for (q = 0; q < group_length; q++) {\n        current_index = i * group_length + q;\n        if (current_index === separated_number.length) {\n          break;\n        }\n\n        current_number_part = current_number_part + numbers[current_index];\n      }\n      number_parts.push(current_number_part);\n    }\n\n    return number_parts;\n  };\n\n  var remove_precending_zeros = function remove_precending_zeros(number_parts) {\n    var last_index = number_parts.length - 1,\n        last = reverse(number_parts[last_index]);\n\n    number_parts[last_index] = reverse(parseInt(last, 10).toString());\n    return number_parts;\n  };\n\n  $.animateNumber = {\n    numberStepFactories: {\n      /**\n       * Creates numberStep handler, which appends string to floored animated number on each step.\n       *\n       * @example\n       * // will animate to 100 with \"1 %\", \"2 %\", \"3 %\", ...\n       * $('#someid').animateNumber({\n       *   number: 100,\n       *   numberStep: $.animateNumber.numberStepFactories.append(' %')\n       * });\n       *\n       * @params {String} suffix string to append to animated number\n       * @returns {Function} numberStep-compatible function for use in animateNumber's parameters\n       */\n      append: function append(suffix) {\n        return function (now, tween) {\n          var floored_number = Math.floor(now),\n              target = $(tween.elem);\n\n          target.prop('number', now).text(floored_number + suffix);\n        };\n      },\n\n      /**\n       * Creates numberStep handler, which format floored numbers by separating them to groups.\n       *\n       * @example\n       * // will animate with 1 ... 217,980 ... 95,217,980 ... 7,095,217,980\n       * $('#world-population').animateNumber({\n       *    number: 7095217980,\n       *    numberStep: $.animateNumber.numberStepFactories.separator(',')\n       * });\n       *\n       * @params {String} [separator=' '] string to separate number groups\n       * @params {String} [group_length=3] number group length\n       * @returns {Function} numberStep-compatible function for use in animateNumber's parameters\n       */\n      separator: function separator(_separator, group_length) {\n        _separator = _separator || ' ';\n        group_length = group_length || 3;\n\n        return function (now, tween) {\n          var floored_number = Math.floor(now),\n              separated_number = floored_number.toString(),\n              target = $(tween.elem);\n\n          if (separated_number.length > group_length) {\n            var number_parts = extract_number_parts(separated_number, group_length);\n\n            separated_number = remove_precending_zeros(number_parts).join(_separator);\n            separated_number = reverse(separated_number);\n          }\n\n          target.prop('number', now).text(separated_number);\n        };\n      }\n    }\n  };\n\n  $.fn.animateNumber = function () {\n    var options = arguments[0],\n        settings = $.extend({}, defaults, options),\n        target = $(this),\n        args = [settings];\n\n    for (var i = 1, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n\n    // needs of custom step function usage\n    if (options.numberStep) {\n      // assigns custom step functions\n      var items = this.each(function () {\n        this._animateNumberSetter = options.numberStep;\n      });\n\n      // cleanup of custom step functions after animation\n      var generic_complete = settings.complete;\n      settings.complete = function () {\n        items.each(function () {\n          delete this._animateNumberSetter;\n        });\n\n        if (generic_complete) {\n          generic_complete.apply(this, arguments);\n        }\n      };\n    }\n\n    return target.animate.apply(target, args);\n  };\n})($);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2xpYi9hbmltYXRlTnVtYmVyLmpzP2Q4ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBwcmVzZXJ2ZSBqUXVlcnkgYW5pbWF0ZU51bWJlciBwbHVnaW4gdjAuMC4xMFxuICogKGMpIDIwMTMsIEFsZXhhbmRyIEJvcmlzb3YuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWlzaGVrL2pxdWVyeS1hbmltYXRlTnVtYmVyXG4gKi9cblxuLy8gWycuLi4nXSBub3RhdGlvbiB1c2luZyB0byBhdm9pZCBuYW1lcyBtaW5pZmljYXRpb24gYnkgR29vZ2xlIENsb3N1cmUgQ29tcGlsZXJcbihmdW5jdGlvbigkKSB7XG4gIHZhciByZXZlcnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgbnVtYmVyU3RlcDogZnVuY3Rpb24obm93LCB0d2Vlbikge1xuICAgICAgdmFyIGZsb29yZWRfbnVtYmVyID0gTWF0aC5mbG9vcihub3cpLFxuICAgICAgICAgIHRhcmdldCA9ICQodHdlZW4uZWxlbSk7XG5cbiAgICAgIHRhcmdldC50ZXh0KGZsb29yZWRfbnVtYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZSA9IGZ1bmN0aW9uKCB0d2VlbiApIHtcbiAgICB2YXIgZWxlbSA9IHR3ZWVuLmVsZW07XG4gICAgaWYgKCBlbGVtLm5vZGVUeXBlICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcbiAgICAgIHZhciBoYW5kbGVyID0gZWxlbS5fYW5pbWF0ZU51bWJlclNldHRlcjtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyID0gZGVmYXVsdHMubnVtYmVyU3RlcDtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIodHdlZW4ubm93LCB0d2Vlbik7XG4gICAgfVxuICB9O1xuXG4gIGlmICghJC5Ud2VlbiB8fCAhJC5Ud2Vlbi5wcm9wSG9va3MpIHtcbiAgICAkLmZ4LnN0ZXAubnVtYmVyID0gaGFuZGxlO1xuICB9IGVsc2Uge1xuICAgICQuVHdlZW4ucHJvcEhvb2tzLm51bWJlciA9IHtcbiAgICAgIHNldDogaGFuZGxlXG4gICAgfTtcbiAgfVxuXG4gIHZhciBleHRyYWN0X251bWJlcl9wYXJ0cyA9IGZ1bmN0aW9uKHNlcGFyYXRlZF9udW1iZXIsIGdyb3VwX2xlbmd0aCkge1xuICAgIHZhciBudW1iZXJzID0gc2VwYXJhdGVkX251bWJlci5zcGxpdCgnJykucmV2ZXJzZSgpLFxuICAgICAgICBudW1iZXJfcGFydHMgPSBbXSxcbiAgICAgICAgY3VycmVudF9udW1iZXJfcGFydCxcbiAgICAgICAgY3VycmVudF9pbmRleCxcbiAgICAgICAgcTtcblxuICAgIGZvcih2YXIgaSA9IDAsIGwgPSBNYXRoLmNlaWwoc2VwYXJhdGVkX251bWJlci5sZW5ndGggLyBncm91cF9sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjdXJyZW50X251bWJlcl9wYXJ0ID0gJyc7XG4gICAgICBmb3IocSA9IDA7IHEgPCBncm91cF9sZW5ndGg7IHErKykge1xuICAgICAgICBjdXJyZW50X2luZGV4ID0gaSAqIGdyb3VwX2xlbmd0aCArIHE7XG4gICAgICAgIGlmIChjdXJyZW50X2luZGV4ID09PSBzZXBhcmF0ZWRfbnVtYmVyLmxlbmd0aCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudF9udW1iZXJfcGFydCA9IGN1cnJlbnRfbnVtYmVyX3BhcnQgKyBudW1iZXJzW2N1cnJlbnRfaW5kZXhdO1xuICAgICAgfVxuICAgICAgbnVtYmVyX3BhcnRzLnB1c2goY3VycmVudF9udW1iZXJfcGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bWJlcl9wYXJ0cztcbiAgfTtcblxuICB2YXIgcmVtb3ZlX3ByZWNlbmRpbmdfemVyb3MgPSBmdW5jdGlvbihudW1iZXJfcGFydHMpIHtcbiAgICB2YXIgbGFzdF9pbmRleCA9IG51bWJlcl9wYXJ0cy5sZW5ndGggLSAxLFxuICAgICAgICBsYXN0ID0gcmV2ZXJzZShudW1iZXJfcGFydHNbbGFzdF9pbmRleF0pO1xuXG4gICAgbnVtYmVyX3BhcnRzW2xhc3RfaW5kZXhdID0gcmV2ZXJzZShwYXJzZUludChsYXN0LCAxMCkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIG51bWJlcl9wYXJ0cztcbiAgfTtcblxuICAkLmFuaW1hdGVOdW1iZXIgPSB7XG4gICAgbnVtYmVyU3RlcEZhY3Rvcmllczoge1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIG51bWJlclN0ZXAgaGFuZGxlciwgd2hpY2ggYXBwZW5kcyBzdHJpbmcgdG8gZmxvb3JlZCBhbmltYXRlZCBudW1iZXIgb24gZWFjaCBzdGVwLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAvLyB3aWxsIGFuaW1hdGUgdG8gMTAwIHdpdGggXCIxICVcIiwgXCIyICVcIiwgXCIzICVcIiwgLi4uXG4gICAgICAgKiAkKCcjc29tZWlkJykuYW5pbWF0ZU51bWJlcih7XG4gICAgICAgKiAgIG51bWJlcjogMTAwLFxuICAgICAgICogICBudW1iZXJTdGVwOiAkLmFuaW1hdGVOdW1iZXIubnVtYmVyU3RlcEZhY3Rvcmllcy5hcHBlbmQoJyAlJylcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbXMge1N0cmluZ30gc3VmZml4IHN0cmluZyB0byBhcHBlbmQgdG8gYW5pbWF0ZWQgbnVtYmVyXG4gICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IG51bWJlclN0ZXAtY29tcGF0aWJsZSBmdW5jdGlvbiBmb3IgdXNlIGluIGFuaW1hdGVOdW1iZXIncyBwYXJhbWV0ZXJzXG4gICAgICAgKi9cbiAgICAgIGFwcGVuZDogZnVuY3Rpb24oc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub3csIHR3ZWVuKSB7XG4gICAgICAgICAgdmFyIGZsb29yZWRfbnVtYmVyID0gTWF0aC5mbG9vcihub3cpLFxuICAgICAgICAgICAgICB0YXJnZXQgPSAkKHR3ZWVuLmVsZW0pO1xuXG4gICAgICAgICAgdGFyZ2V0LnByb3AoJ251bWJlcicsIG5vdykudGV4dChmbG9vcmVkX251bWJlciArIHN1ZmZpeCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgbnVtYmVyU3RlcCBoYW5kbGVyLCB3aGljaCBmb3JtYXQgZmxvb3JlZCBudW1iZXJzIGJ5IHNlcGFyYXRpbmcgdGhlbSB0byBncm91cHMuXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIC8vIHdpbGwgYW5pbWF0ZSB3aXRoIDEgLi4uIDIxNyw5ODAgLi4uIDk1LDIxNyw5ODAgLi4uIDcsMDk1LDIxNyw5ODBcbiAgICAgICAqICQoJyN3b3JsZC1wb3B1bGF0aW9uJykuYW5pbWF0ZU51bWJlcih7XG4gICAgICAgKiAgICBudW1iZXI6IDcwOTUyMTc5ODAsXG4gICAgICAgKiAgICBudW1iZXJTdGVwOiAkLmFuaW1hdGVOdW1iZXIubnVtYmVyU3RlcEZhY3Rvcmllcy5zZXBhcmF0b3IoJywnKVxuICAgICAgICogfSk7XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtcyB7U3RyaW5nfSBbc2VwYXJhdG9yPScgJ10gc3RyaW5nIHRvIHNlcGFyYXRlIG51bWJlciBncm91cHNcbiAgICAgICAqIEBwYXJhbXMge1N0cmluZ30gW2dyb3VwX2xlbmd0aD0zXSBudW1iZXIgZ3JvdXAgbGVuZ3RoXG4gICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IG51bWJlclN0ZXAtY29tcGF0aWJsZSBmdW5jdGlvbiBmb3IgdXNlIGluIGFuaW1hdGVOdW1iZXIncyBwYXJhbWV0ZXJzXG4gICAgICAgKi9cbiAgICAgIHNlcGFyYXRvcjogZnVuY3Rpb24oc2VwYXJhdG9yLCBncm91cF9sZW5ndGgpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcgJztcbiAgICAgICAgZ3JvdXBfbGVuZ3RoID0gZ3JvdXBfbGVuZ3RoIHx8IDM7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vdywgdHdlZW4pIHtcbiAgICAgICAgICB2YXIgZmxvb3JlZF9udW1iZXIgPSBNYXRoLmZsb29yKG5vdyksXG4gICAgICAgICAgICAgIHNlcGFyYXRlZF9udW1iZXIgPSBmbG9vcmVkX251bWJlci50b1N0cmluZygpLFxuICAgICAgICAgICAgICB0YXJnZXQgPSAkKHR3ZWVuLmVsZW0pO1xuXG4gICAgICAgICAgaWYgKHNlcGFyYXRlZF9udW1iZXIubGVuZ3RoID4gZ3JvdXBfbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyX3BhcnRzID0gZXh0cmFjdF9udW1iZXJfcGFydHMoc2VwYXJhdGVkX251bWJlciwgZ3JvdXBfbGVuZ3RoKTtcblxuICAgICAgICAgICAgc2VwYXJhdGVkX251bWJlciA9IHJlbW92ZV9wcmVjZW5kaW5nX3plcm9zKG51bWJlcl9wYXJ0cykuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgc2VwYXJhdGVkX251bWJlciA9IHJldmVyc2Uoc2VwYXJhdGVkX251bWJlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0LnByb3AoJ251bWJlcicsIG5vdykudGV4dChzZXBhcmF0ZWRfbnVtYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgJC5mbi5hbmltYXRlTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKSxcblxuICAgICAgICB0YXJnZXQgPSAkKHRoaXMpLFxuICAgICAgICBhcmdzID0gW3NldHRpbmdzXTtcblxuICAgIGZvcih2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBuZWVkcyBvZiBjdXN0b20gc3RlcCBmdW5jdGlvbiB1c2FnZVxuICAgIGlmIChvcHRpb25zLm51bWJlclN0ZXApIHtcbiAgICAgIC8vIGFzc2lnbnMgY3VzdG9tIHN0ZXAgZnVuY3Rpb25zXG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZU51bWJlclNldHRlciA9IG9wdGlvbnMubnVtYmVyU3RlcDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjbGVhbnVwIG9mIGN1c3RvbSBzdGVwIGZ1bmN0aW9ucyBhZnRlciBhbmltYXRpb25cbiAgICAgIHZhciBnZW5lcmljX2NvbXBsZXRlID0gc2V0dGluZ3MuY29tcGxldGU7XG4gICAgICBzZXR0aW5ncy5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2FuaW1hdGVOdW1iZXJTZXR0ZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICggZ2VuZXJpY19jb21wbGV0ZSApIHtcbiAgICAgICAgICBnZW5lcmljX2NvbXBsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5hbmltYXRlLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gIH07XG5cbn0oJCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9saWIvYW5pbWF0ZU51bWJlci5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2REE7QUFEQTtBQUNBO0FBMkRBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32\n");

/***/ })
/******/ ]);