var index =
webpackJsonp_name_([1],{

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = isFunction;\n\nvar toString = Object.prototype.toString;\n\nfunction isFunction(fn) {\n  var string = toString.call(fn);\n  return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (\n  // IE8 and below\n  fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9faXMtZnVuY3Rpb25AMS4wLjFAaXMtZnVuY3Rpb24vaW5kZXguanM/ZDI1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL19pcy1mdW5jdGlvbkAxLjAuMUBpcy1mdW5jdGlvbi9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFJQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///125\n");

/***/ }),

/***/ 130:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n// materialize\n\n\nvar _jquery = __webpack_require__(1);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\n__webpack_require__(131);\n\nvar _materializeCss = __webpack_require__(5);\n\nvar _materializeCss2 = _interopRequireDefault(_materializeCss);\n\n__webpack_require__(132);\n\nvar _video = __webpack_require__(133);\n\nvar _video2 = _interopRequireDefault(_video);\n\n__webpack_require__(147);\n\n__webpack_require__(148);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Index = function () {\n    function Index() {\n        _classCallCheck(this, Index);\n\n        this.initEvent();\n    }\n\n    _createClass(Index, [{\n        key: 'initEvent',\n        value: function initEvent() {\n            this.declareVar();\n            this.pluginsInit();\n            this.videoPlay();\n        }\n    }, {\n        key: 'declareVar',\n        value: function declareVar() {\n            this.$animateNumber = (0, _jquery2.default)('.animateNumber');\n            this.$carousel = (0, _jquery2.default)('.carousel.carousel-slider');\n            this.$videoPlay = (0, _jquery2.default)('#videoPlay');\n        }\n    }, {\n        key: 'videoPlay',\n        value: function videoPlay() {\n            var _this = this;\n\n            var that = this;\n            this.$videoPlay.on('click', function (e) {\n                _this.$videoPlay.addClass('hide').siblings('.index-mask').addClass('hide');\n                that.videoPlayer.play();\n            });\n        }\n    }, {\n        key: 'pluginsInit',\n        value: function pluginsInit() {\n            this.$animateNumber.prop('number', 0).animateNumber({\n                number: 9567,\n                easing: 'easeOut'\n            }, 4000);\n            this.$carousel.carousel({\n                fullWidth: true,\n                indicators: true\n            });\n            this.videoPlayer = (0, _video2.default)('video', {\n                controls: true,\n                autoplay: false,\n                preload: 'auto'\n            });\n        }\n    }]);\n\n    return Index;\n}();\n\nnew Index();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9lbnRyeS9pbmRleC5qcz9jNDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgJ0BsaWIvYW5pbWF0ZU51bWJlcidcbi8vIG1hdGVyaWFsaXplXG5pbXBvcnQgTSBmcm9tICdtYXRlcmlhbGl6ZS1jc3MnXG5pbXBvcnQgJ21hdGVyaWFsaXplLWNzcy9zYXNzL21hdGVyaWFsaXplLnNjc3MnXG5pbXBvcnQgdmlkZW9qcyBmcm9tICd2aWRlby5qcydcbmltcG9ydCAndmlkZW8uanMvZGlzdC92aWRlby1qcy5jc3MnXG5pbXBvcnQgJ0BzY3NzL2luZGV4LnNjc3MnO1xuXG5jbGFzcyBJbmRleCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbml0RXZlbnQoKTtcbiAgICB9XG5cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyZVZhcigpXG4gICAgICAgIHRoaXMucGx1Z2luc0luaXQoKVxuICAgICAgICB0aGlzLnZpZGVvUGxheSgpXG4gICAgfVxuXG4gICAgZGVjbGFyZVZhcigpIHtcbiAgICAgICAgdGhpcy4kYW5pbWF0ZU51bWJlciA9ICQoJy5hbmltYXRlTnVtYmVyJyk7XG4gICAgICAgIHRoaXMuJGNhcm91c2VsID0gJCgnLmNhcm91c2VsLmNhcm91c2VsLXNsaWRlcicpO1xuICAgICAgICB0aGlzLiR2aWRlb1BsYXkgPSAkKCcjdmlkZW9QbGF5Jyk7XG4gICAgfVxuXG4gICAgdmlkZW9QbGF5KCkge1xuICAgICAgICBsZXQgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuJHZpZGVvUGxheS5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuJHZpZGVvUGxheS5hZGRDbGFzcygnaGlkZScpLnNpYmxpbmdzKCcuaW5kZXgtbWFzaycpLmFkZENsYXNzKCdoaWRlJyk7XG4gICAgICAgICAgICB0aGF0LnZpZGVvUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwbHVnaW5zSW5pdCgpIHtcbiAgICAgICAgdGhpcy4kYW5pbWF0ZU51bWJlci5wcm9wKCdudW1iZXInLCAwKS5hbmltYXRlTnVtYmVyKHtcbiAgICAgICAgICAgIG51bWJlcjogOTU2NyxcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXQnXG4gICAgICAgIH0sIDQwMDApXG4gICAgICAgIHRoaXMuJGNhcm91c2VsLmNhcm91c2VsKHtcbiAgICAgICAgICAgIGZ1bGxXaWR0aDogdHJ1ZSxcbiAgICAgICAgICAgIGluZGljYXRvcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5ZXIgPSB2aWRlb2pzKCd2aWRlbycsIHtcbiAgICAgICAgICAgIGNvbnRyb2xzOiB0cnVlLFxuICAgICAgICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgcHJlbG9hZDogJ2F1dG8nXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubmV3IEluZGV4KCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2VudHJ5L2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOzs7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///130\n");

/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\n/** @preserve jQuery animateNumber plugin v0.0.10\n * (c) 2013, Alexandr Borisov.\n * https://github.com/aishek/jquery-animateNumber\n */\n\n// ['...'] notation using to avoid names minification by Google Closure Compiler\n(function ($) {\n  var reverse = function reverse(value) {\n    return value.split('').reverse().join('');\n  };\n\n  var defaults = {\n    numberStep: function numberStep(now, tween) {\n      var floored_number = Math.floor(now),\n          target = $(tween.elem);\n\n      target.text(floored_number);\n    }\n  };\n\n  var handle = function handle(tween) {\n    var elem = tween.elem;\n    if (elem.nodeType && elem.parentNode) {\n      var handler = elem._animateNumberSetter;\n      if (!handler) {\n        handler = defaults.numberStep;\n      }\n      handler(tween.now, tween);\n    }\n  };\n\n  if (!$.Tween || !$.Tween.propHooks) {\n    $.fx.step.number = handle;\n  } else {\n    $.Tween.propHooks.number = {\n      set: handle\n    };\n  }\n\n  var extract_number_parts = function extract_number_parts(separated_number, group_length) {\n    var numbers = separated_number.split('').reverse(),\n        number_parts = [],\n        current_number_part,\n        current_index,\n        q;\n\n    for (var i = 0, l = Math.ceil(separated_number.length / group_length); i < l; i++) {\n      current_number_part = '';\n      for (q = 0; q < group_length; q++) {\n        current_index = i * group_length + q;\n        if (current_index === separated_number.length) {\n          break;\n        }\n\n        current_number_part = current_number_part + numbers[current_index];\n      }\n      number_parts.push(current_number_part);\n    }\n\n    return number_parts;\n  };\n\n  var remove_precending_zeros = function remove_precending_zeros(number_parts) {\n    var last_index = number_parts.length - 1,\n        last = reverse(number_parts[last_index]);\n\n    number_parts[last_index] = reverse(parseInt(last, 10).toString());\n    return number_parts;\n  };\n\n  $.animateNumber = {\n    numberStepFactories: {\n      /**\n       * Creates numberStep handler, which appends string to floored animated number on each step.\n       *\n       * @example\n       * // will animate to 100 with \"1 %\", \"2 %\", \"3 %\", ...\n       * $('#someid').animateNumber({\n       *   number: 100,\n       *   numberStep: $.animateNumber.numberStepFactories.append(' %')\n       * });\n       *\n       * @params {String} suffix string to append to animated number\n       * @returns {Function} numberStep-compatible function for use in animateNumber's parameters\n       */\n      append: function append(suffix) {\n        return function (now, tween) {\n          var floored_number = Math.floor(now),\n              target = $(tween.elem);\n\n          target.prop('number', now).text(floored_number + suffix);\n        };\n      },\n\n      /**\n       * Creates numberStep handler, which format floored numbers by separating them to groups.\n       *\n       * @example\n       * // will animate with 1 ... 217,980 ... 95,217,980 ... 7,095,217,980\n       * $('#world-population').animateNumber({\n       *    number: 7095217980,\n       *    numberStep: $.animateNumber.numberStepFactories.separator(',')\n       * });\n       *\n       * @params {String} [separator=' '] string to separate number groups\n       * @params {String} [group_length=3] number group length\n       * @returns {Function} numberStep-compatible function for use in animateNumber's parameters\n       */\n      separator: function separator(_separator, group_length) {\n        _separator = _separator || ' ';\n        group_length = group_length || 3;\n\n        return function (now, tween) {\n          var floored_number = Math.floor(now),\n              separated_number = floored_number.toString(),\n              target = $(tween.elem);\n\n          if (separated_number.length > group_length) {\n            var number_parts = extract_number_parts(separated_number, group_length);\n\n            separated_number = remove_precending_zeros(number_parts).join(_separator);\n            separated_number = reverse(separated_number);\n          }\n\n          target.prop('number', now).text(separated_number);\n        };\n      }\n    }\n  };\n\n  $.fn.animateNumber = function () {\n    var options = arguments[0],\n        settings = $.extend({}, defaults, options),\n        target = $(this),\n        args = [settings];\n\n    for (var i = 1, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n\n    // needs of custom step function usage\n    if (options.numberStep) {\n      // assigns custom step functions\n      var items = this.each(function () {\n        this._animateNumberSetter = options.numberStep;\n      });\n\n      // cleanup of custom step functions after animation\n      var generic_complete = settings.complete;\n      settings.complete = function () {\n        items.each(function () {\n          delete this._animateNumberSetter;\n        });\n\n        if (generic_complete) {\n          generic_complete.apply(this, arguments);\n        }\n      };\n    }\n\n    return target.animate.apply(target, args);\n  };\n})($);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9saWIvYW5pbWF0ZU51bWJlci5qcz9kOGZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAcHJlc2VydmUgalF1ZXJ5IGFuaW1hdGVOdW1iZXIgcGx1Z2luIHYwLjAuMTBcbiAqIChjKSAyMDEzLCBBbGV4YW5kciBCb3Jpc292LlxuICogaHR0cHM6Ly9naXRodWIuY29tL2Fpc2hlay9qcXVlcnktYW5pbWF0ZU51bWJlclxuICovXG5cbi8vIFsnLi4uJ10gbm90YXRpb24gdXNpbmcgdG8gYXZvaWQgbmFtZXMgbWluaWZpY2F0aW9uIGJ5IEdvb2dsZSBDbG9zdXJlIENvbXBpbGVyXG4oZnVuY3Rpb24oJCkge1xuICB2YXIgcmV2ZXJzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG51bWJlclN0ZXA6IGZ1bmN0aW9uKG5vdywgdHdlZW4pIHtcbiAgICAgIHZhciBmbG9vcmVkX251bWJlciA9IE1hdGguZmxvb3Iobm93KSxcbiAgICAgICAgICB0YXJnZXQgPSAkKHR3ZWVuLmVsZW0pO1xuXG4gICAgICB0YXJnZXQudGV4dChmbG9vcmVkX251bWJlcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGUgPSBmdW5jdGlvbiggdHdlZW4gKSB7XG4gICAgdmFyIGVsZW0gPSB0d2Vlbi5lbGVtO1xuICAgIGlmICggZWxlbS5ub2RlVHlwZSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGVsZW0uX2FuaW1hdGVOdW1iZXJTZXR0ZXI7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlciA9IGRlZmF1bHRzLm51bWJlclN0ZXA7XG4gICAgICB9XG4gICAgICBoYW5kbGVyKHR3ZWVuLm5vdywgdHdlZW4pO1xuICAgIH1cbiAgfTtcblxuICBpZiAoISQuVHdlZW4gfHwgISQuVHdlZW4ucHJvcEhvb2tzKSB7XG4gICAgJC5meC5zdGVwLm51bWJlciA9IGhhbmRsZTtcbiAgfSBlbHNlIHtcbiAgICAkLlR3ZWVuLnByb3BIb29rcy5udW1iZXIgPSB7XG4gICAgICBzZXQ6IGhhbmRsZVxuICAgIH07XG4gIH1cblxuICB2YXIgZXh0cmFjdF9udW1iZXJfcGFydHMgPSBmdW5jdGlvbihzZXBhcmF0ZWRfbnVtYmVyLCBncm91cF9sZW5ndGgpIHtcbiAgICB2YXIgbnVtYmVycyA9IHNlcGFyYXRlZF9udW1iZXIuc3BsaXQoJycpLnJldmVyc2UoKSxcbiAgICAgICAgbnVtYmVyX3BhcnRzID0gW10sXG4gICAgICAgIGN1cnJlbnRfbnVtYmVyX3BhcnQsXG4gICAgICAgIGN1cnJlbnRfaW5kZXgsXG4gICAgICAgIHE7XG5cbiAgICBmb3IodmFyIGkgPSAwLCBsID0gTWF0aC5jZWlsKHNlcGFyYXRlZF9udW1iZXIubGVuZ3RoIC8gZ3JvdXBfbGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuICAgICAgY3VycmVudF9udW1iZXJfcGFydCA9ICcnO1xuICAgICAgZm9yKHEgPSAwOyBxIDwgZ3JvdXBfbGVuZ3RoOyBxKyspIHtcbiAgICAgICAgY3VycmVudF9pbmRleCA9IGkgKiBncm91cF9sZW5ndGggKyBxO1xuICAgICAgICBpZiAoY3VycmVudF9pbmRleCA9PT0gc2VwYXJhdGVkX251bWJlci5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRfbnVtYmVyX3BhcnQgPSBjdXJyZW50X251bWJlcl9wYXJ0ICsgbnVtYmVyc1tjdXJyZW50X2luZGV4XTtcbiAgICAgIH1cbiAgICAgIG51bWJlcl9wYXJ0cy5wdXNoKGN1cnJlbnRfbnVtYmVyX3BhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiBudW1iZXJfcGFydHM7XG4gIH07XG5cbiAgdmFyIHJlbW92ZV9wcmVjZW5kaW5nX3plcm9zID0gZnVuY3Rpb24obnVtYmVyX3BhcnRzKSB7XG4gICAgdmFyIGxhc3RfaW5kZXggPSBudW1iZXJfcGFydHMubGVuZ3RoIC0gMSxcbiAgICAgICAgbGFzdCA9IHJldmVyc2UobnVtYmVyX3BhcnRzW2xhc3RfaW5kZXhdKTtcblxuICAgIG51bWJlcl9wYXJ0c1tsYXN0X2luZGV4XSA9IHJldmVyc2UocGFyc2VJbnQobGFzdCwgMTApLnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiBudW1iZXJfcGFydHM7XG4gIH07XG5cbiAgJC5hbmltYXRlTnVtYmVyID0ge1xuICAgIG51bWJlclN0ZXBGYWN0b3JpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBudW1iZXJTdGVwIGhhbmRsZXIsIHdoaWNoIGFwcGVuZHMgc3RyaW5nIHRvIGZsb29yZWQgYW5pbWF0ZWQgbnVtYmVyIG9uIGVhY2ggc3RlcC5cbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogLy8gd2lsbCBhbmltYXRlIHRvIDEwMCB3aXRoIFwiMSAlXCIsIFwiMiAlXCIsIFwiMyAlXCIsIC4uLlxuICAgICAgICogJCgnI3NvbWVpZCcpLmFuaW1hdGVOdW1iZXIoe1xuICAgICAgICogICBudW1iZXI6IDEwMCxcbiAgICAgICAqICAgbnVtYmVyU3RlcDogJC5hbmltYXRlTnVtYmVyLm51bWJlclN0ZXBGYWN0b3JpZXMuYXBwZW5kKCcgJScpXG4gICAgICAgKiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW1zIHtTdHJpbmd9IHN1ZmZpeCBzdHJpbmcgdG8gYXBwZW5kIHRvIGFuaW1hdGVkIG51bWJlclxuICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBudW1iZXJTdGVwLWNvbXBhdGlibGUgZnVuY3Rpb24gZm9yIHVzZSBpbiBhbmltYXRlTnVtYmVyJ3MgcGFyYW1ldGVyc1xuICAgICAgICovXG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uKHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obm93LCB0d2Vlbikge1xuICAgICAgICAgIHZhciBmbG9vcmVkX251bWJlciA9IE1hdGguZmxvb3Iobm93KSxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gJCh0d2Vlbi5lbGVtKTtcblxuICAgICAgICAgIHRhcmdldC5wcm9wKCdudW1iZXInLCBub3cpLnRleHQoZmxvb3JlZF9udW1iZXIgKyBzdWZmaXgpO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIG51bWJlclN0ZXAgaGFuZGxlciwgd2hpY2ggZm9ybWF0IGZsb29yZWQgbnVtYmVycyBieSBzZXBhcmF0aW5nIHRoZW0gdG8gZ3JvdXBzLlxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAvLyB3aWxsIGFuaW1hdGUgd2l0aCAxIC4uLiAyMTcsOTgwIC4uLiA5NSwyMTcsOTgwIC4uLiA3LDA5NSwyMTcsOTgwXG4gICAgICAgKiAkKCcjd29ybGQtcG9wdWxhdGlvbicpLmFuaW1hdGVOdW1iZXIoe1xuICAgICAgICogICAgbnVtYmVyOiA3MDk1MjE3OTgwLFxuICAgICAgICogICAgbnVtYmVyU3RlcDogJC5hbmltYXRlTnVtYmVyLm51bWJlclN0ZXBGYWN0b3JpZXMuc2VwYXJhdG9yKCcsJylcbiAgICAgICAqIH0pO1xuICAgICAgICpcbiAgICAgICAqIEBwYXJhbXMge1N0cmluZ30gW3NlcGFyYXRvcj0nICddIHN0cmluZyB0byBzZXBhcmF0ZSBudW1iZXIgZ3JvdXBzXG4gICAgICAgKiBAcGFyYW1zIHtTdHJpbmd9IFtncm91cF9sZW5ndGg9M10gbnVtYmVyIGdyb3VwIGxlbmd0aFxuICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBudW1iZXJTdGVwLWNvbXBhdGlibGUgZnVuY3Rpb24gZm9yIHVzZSBpbiBhbmltYXRlTnVtYmVyJ3MgcGFyYW1ldGVyc1xuICAgICAgICovXG4gICAgICBzZXBhcmF0b3I6IGZ1bmN0aW9uKHNlcGFyYXRvciwgZ3JvdXBfbGVuZ3RoKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnICc7XG4gICAgICAgIGdyb3VwX2xlbmd0aCA9IGdyb3VwX2xlbmd0aCB8fCAzO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub3csIHR3ZWVuKSB7XG4gICAgICAgICAgdmFyIGZsb29yZWRfbnVtYmVyID0gTWF0aC5mbG9vcihub3cpLFxuICAgICAgICAgICAgICBzZXBhcmF0ZWRfbnVtYmVyID0gZmxvb3JlZF9udW1iZXIudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gJCh0d2Vlbi5lbGVtKTtcblxuICAgICAgICAgIGlmIChzZXBhcmF0ZWRfbnVtYmVyLmxlbmd0aCA+IGdyb3VwX2xlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG51bWJlcl9wYXJ0cyA9IGV4dHJhY3RfbnVtYmVyX3BhcnRzKHNlcGFyYXRlZF9udW1iZXIsIGdyb3VwX2xlbmd0aCk7XG5cbiAgICAgICAgICAgIHNlcGFyYXRlZF9udW1iZXIgPSByZW1vdmVfcHJlY2VuZGluZ196ZXJvcyhudW1iZXJfcGFydHMpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHNlcGFyYXRlZF9udW1iZXIgPSByZXZlcnNlKHNlcGFyYXRlZF9udW1iZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldC5wcm9wKCdudW1iZXInLCBub3cpLnRleHQoc2VwYXJhdGVkX251bWJlcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gICQuZm4uYW5pbWF0ZU51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzBdLFxuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyksXG5cbiAgICAgICAgdGFyZ2V0ID0gJCh0aGlzKSxcbiAgICAgICAgYXJncyA9IFtzZXR0aW5nc107XG5cbiAgICBmb3IodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gbmVlZHMgb2YgY3VzdG9tIHN0ZXAgZnVuY3Rpb24gdXNhZ2VcbiAgICBpZiAob3B0aW9ucy5udW1iZXJTdGVwKSB7XG4gICAgICAvLyBhc3NpZ25zIGN1c3RvbSBzdGVwIGZ1bmN0aW9uc1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVOdW1iZXJTZXR0ZXIgPSBvcHRpb25zLm51bWJlclN0ZXA7XG4gICAgICB9KTtcblxuICAgICAgLy8gY2xlYW51cCBvZiBjdXN0b20gc3RlcCBmdW5jdGlvbnMgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICB2YXIgZ2VuZXJpY19jb21wbGV0ZSA9IHNldHRpbmdzLmNvbXBsZXRlO1xuICAgICAgc2V0dGluZ3MuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hbmltYXRlTnVtYmVyU2V0dGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIGdlbmVyaWNfY29tcGxldGUgKSB7XG4gICAgICAgICAgZ2VuZXJpY19jb21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuYW5pbWF0ZS5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG59KCQpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGliL2FuaW1hdGVOdW1iZXIuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkRBO0FBREE7QUFDQTtBQTJEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///131\n");

/***/ }),

/***/ 132:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL19tYXRlcmlhbGl6ZS1jc3NAMS4wLjAtYWxwaGEuM0BtYXRlcmlhbGl6ZS1jc3Mvc2Fzcy9tYXRlcmlhbGl6ZS5zY3NzP2FlMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9fbWF0ZXJpYWxpemUtY3NzQDEuMC4wLWFscGhhLjNAbWF0ZXJpYWxpemUtY3NzL3Nhc3MvbWF0ZXJpYWxpemUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///132\n");

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var _typeof2=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};/**\n * @license\n * Video.js 6.6.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/master/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>\n */function _interopDefault(ex){return ex&&(typeof ex==='undefined'?'undefined':_typeof2(ex))==='object'&&'default'in ex?ex['default']:ex;}var window=_interopDefault(__webpack_require__(3));var document=_interopDefault(__webpack_require__(134));var tsml=_interopDefault(__webpack_require__(136));var safeParseTuple=_interopDefault(__webpack_require__(137));var xhr=_interopDefault(__webpack_require__(138));var vtt=_interopDefault(__webpack_require__(143));var version=\"6.6.0\";/**\n * @file browser.js\n * @module browser\n */var USER_AGENT=window.navigator&&window.navigator.userAgent||'';var webkitVersionMap=/AppleWebKit\\/([\\d.]+)/i.exec(USER_AGENT);var appleWebkitVersion=webkitVersionMap?parseFloat(webkitVersionMap.pop()):null;/*\n * Device is an iPhone\n *\n * @type {Boolean}\n * @constant\n * @private\n */var IS_IPAD=/iPad/i.test(USER_AGENT);// The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n// to identify iPhones, we need to exclude iPads.\n// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\nvar IS_IPHONE=/iPhone/i.test(USER_AGENT)&&!IS_IPAD;var IS_IPOD=/iPod/i.test(USER_AGENT);var IS_IOS=IS_IPHONE||IS_IPAD||IS_IPOD;var IOS_VERSION=function(){var match=USER_AGENT.match(/OS (\\d+)_/i);if(match&&match[1]){return match[1];}return null;}();var IS_ANDROID=/Android/i.test(USER_AGENT);var ANDROID_VERSION=function(){// This matches Android Major.Minor.Patch versions\n// ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\nvar match=USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);if(!match){return null;}var major=match[1]&&parseFloat(match[1]);var minor=match[2]&&parseFloat(match[2]);if(major&&minor){return parseFloat(match[1]+'.'+match[2]);}else if(major){return major;}return null;}();// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser\nvar IS_OLD_ANDROID=IS_ANDROID&&/webkit/i.test(USER_AGENT)&&ANDROID_VERSION<2.3;var IS_NATIVE_ANDROID=IS_ANDROID&&ANDROID_VERSION<5&&appleWebkitVersion<537;var IS_FIREFOX=/Firefox/i.test(USER_AGENT);var IS_EDGE=/Edge/i.test(USER_AGENT);var IS_CHROME=!IS_EDGE&&/Chrome/i.test(USER_AGENT);var CHROME_VERSION=function(){var match=USER_AGENT.match(/Chrome\\/(\\d+)/);if(match&&match[1]){return parseFloat(match[1]);}return null;}();var IS_IE8=/MSIE\\s8\\.0/.test(USER_AGENT);var IE_VERSION=function(){var result=/MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);var version=result&&parseFloat(result[1]);if(!version&&/Trident\\/7.0/i.test(USER_AGENT)&&/rv:11.0/.test(USER_AGENT)){// IE 11 has a different user agent string than other IE versions\nversion=11.0;}return version;}();var IS_SAFARI=/Safari/i.test(USER_AGENT)&&!IS_CHROME&&!IS_ANDROID&&!IS_EDGE;var IS_ANY_SAFARI=IS_SAFARI||IS_IOS;var TOUCH_ENABLED=isReal()&&('ontouchstart'in window||window.DocumentTouch&&window.document instanceof window.DocumentTouch);var BACKGROUND_SIZE_SUPPORTED=isReal()&&'backgroundSize'in window.document.createElement('video').style;var browser=(Object.freeze||Object)({IS_IPAD:IS_IPAD,IS_IPHONE:IS_IPHONE,IS_IPOD:IS_IPOD,IS_IOS:IS_IOS,IOS_VERSION:IOS_VERSION,IS_ANDROID:IS_ANDROID,ANDROID_VERSION:ANDROID_VERSION,IS_OLD_ANDROID:IS_OLD_ANDROID,IS_NATIVE_ANDROID:IS_NATIVE_ANDROID,IS_FIREFOX:IS_FIREFOX,IS_EDGE:IS_EDGE,IS_CHROME:IS_CHROME,CHROME_VERSION:CHROME_VERSION,IS_IE8:IS_IE8,IE_VERSION:IE_VERSION,IS_SAFARI:IS_SAFARI,IS_ANY_SAFARI:IS_ANY_SAFARI,TOUCH_ENABLED:TOUCH_ENABLED,BACKGROUND_SIZE_SUPPORTED:BACKGROUND_SIZE_SUPPORTED});var _typeof=typeof Symbol===\"function\"&&_typeof2(Symbol.iterator)===\"symbol\"?function(obj){return typeof obj==='undefined'?'undefined':_typeof2(obj);}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj==='undefined'?'undefined':_typeof2(obj);};var classCallCheck=function classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}};var inherits=function inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+(typeof superClass==='undefined'?'undefined':_typeof2(superClass)));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;};var possibleConstructorReturn=function possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&((typeof call==='undefined'?'undefined':_typeof2(call))===\"object\"||typeof call===\"function\")?call:self;};var taggedTemplateLiteralLoose=function taggedTemplateLiteralLoose(strings,raw){strings.raw=raw;return strings;};/**\n * @file obj.js\n * @module obj\n *//**\n * @callback obj:EachCallback\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *//**\n * @callback obj:ReduceCallback\n *\n * @param {Mixed} accum\n *        The value that is accumulating over the reduce loop.\n *\n * @param {Mixed} value\n *        The current key for the object that is being iterated over.\n *\n * @param {string} key\n *        The current key-value for object that is being iterated over\n *\n * @return {Mixed}\n *         The new accumulated value.\n */var toString=Object.prototype.toString;/**\n * Get the keys of an Object\n *\n * @param {Object}\n *        The Object to get the keys from\n *\n * @return {string[]}\n *         An array of the keys from the object. Returns an empty array if the\n *         object passed in was invalid or had no keys.\n *\n * @private\n */var keys=function keys(object){return isObject(object)?Object.keys(object):[];};/**\n * Array-like iteration for objects.\n *\n * @param {Object} object\n *        The object to iterate over\n *\n * @param {obj:EachCallback} fn\n *        The callback function which is called for each key in the object.\n */function each(object,fn){keys(object).forEach(function(key){return fn(object[key],key);});}/**\n * Array-like reduce for objects.\n *\n * @param {Object} object\n *        The Object that you want to reduce.\n *\n * @param {Function} fn\n *         A callback function which is called for each key in the object. It\n *         receives the accumulated value and the per-iteration value and key\n *         as arguments.\n *\n * @param {Mixed} [initial = 0]\n *        Starting value\n *\n * @return {Mixed}\n *         The final accumulated value.\n */function reduce(object,fn){var initial=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;return keys(object).reduce(function(accum,key){return fn(accum,object[key],key);},initial);}/**\n * Object.assign-style object shallow merge/extend.\n *\n * @param  {Object} target\n * @param  {Object} ...sources\n * @return {Object}\n */function assign(target){for(var _len=arguments.length,sources=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){sources[_key-1]=arguments[_key];}if(Object.assign){return Object.assign.apply(Object,[target].concat(sources));}sources.forEach(function(source){if(!source){return;}each(source,function(value,key){target[key]=value;});});return target;}/**\n * Returns whether a value is an object of any kind - including DOM nodes,\n * arrays, regular expressions, etc. Not functions, though.\n *\n * This avoids the gotcha where using `typeof` on a `null` value\n * results in `'object'`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */function isObject(value){return!!value&&(typeof value==='undefined'?'undefined':_typeof(value))==='object';}/**\n * Returns whether an object appears to be a \"plain\" object - that is, a\n * direct instance of `Object`.\n *\n * @param  {Object} value\n * @return {Boolean}\n */function isPlain(value){return isObject(value)&&toString.call(value)==='[object Object]'&&value.constructor===Object;}/**\n * @file log.js\n * @module log\n */var log=void 0;// This is the private tracking variable for logging level.\nvar level='info';// This is the private tracking variable for the logging history.\nvar history=[];/**\n * Log messages to the console and history based on the type of message\n *\n * @private\n * @param  {string} type\n *         The name of the console method to use.\n *\n * @param  {Array} args\n *         The arguments to be passed to the matching console method.\n *\n * @param  {boolean} [stringify]\n *         By default, only old IEs should get console argument stringification,\n *         but this is exposed as a parameter to facilitate testing.\n */var logByType=function logByType(type,args){var stringify=arguments.length>2&&arguments[2]!==undefined?arguments[2]:!!IE_VERSION&&IE_VERSION<11;var lvl=log.levels[level];var lvlRegExp=new RegExp('^('+lvl+')$');if(type!=='log'){// Add the type to the front of the message when it's not \"log\".\nargs.unshift(type.toUpperCase()+':');}// Add a clone of the args at this point to history.\nif(history){history.push([].concat(args));}// Add console prefix after adding to history.\nargs.unshift('VIDEOJS:');// If there's no console then don't try to output messages, but they will\n// still be stored in history.\nif(!window.console){return;}// Was setting these once outside of this function, but containing them\n// in the function makes it easier to test cases where console doesn't exist\n// when the module is executed.\nvar fn=window.console[type];if(!fn&&type==='debug'){// Certain browsers don't have support for console.debug. For those, we\n// should default to the closest comparable log.\nfn=window.console.info||window.console.log;}// Bail out if there's no console or if this type is not allowed by the\n// current logging level.\nif(!fn||!lvl||!lvlRegExp.test(type)){return;}// IEs previous to 11 log objects uselessly as \"[object Object]\"; so, JSONify\n// objects and arrays for those less-capable browsers.\nif(stringify){args=args.map(function(a){if(isObject(a)||Array.isArray(a)){try{return JSON.stringify(a);}catch(x){return String(a);}}// Cast to string before joining, so we get null and undefined explicitly\n// included in output (as we would in a modern console).\nreturn String(a);}).join(' ');}// Old IE versions do not allow .apply() for console methods (they are\n// reported as objects rather than functions).\nif(!fn.apply){fn(args);}else{fn[Array.isArray(args)?'apply':'call'](window.console,args);}};/**\n * Logs plain debug messages. Similar to `console.log`.\n *\n * @class\n * @param    {Mixed[]} args\n *           One or more messages or objects that should be logged.\n */log=function log(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}logByType('log',args);};/**\n * Enumeration of available logging levels, where the keys are the level names\n * and the values are `|`-separated strings containing logging methods allowed\n * in that logging level. These strings are used to create a regular expression\n * matching the function name being called.\n *\n * Levels provided by video.js are:\n *\n * - `off`: Matches no calls. Any value that can be cast to `false` will have\n *   this effect. The most restrictive.\n * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n *   `log.warn`, and `log.error`).\n * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n * - `warn`: Matches `log.warn` and `log.error` calls.\n * - `error`: Matches only `log.error` calls.\n *\n * @type {Object}\n */log.levels={all:'debug|log|warn|error',off:'',debug:'debug|log|warn|error',info:'log|warn|error',warn:'warn|error',error:'error',DEFAULT:level};/**\n * Get or set the current logging level. If a string matching a key from\n * {@link log.levels} is provided, acts as a setter. Regardless of argument,\n * returns the current logging level.\n *\n * @param  {string} [lvl]\n *         Pass to set a new logging level.\n *\n * @return {string}\n *         The current logging level.\n */log.level=function(lvl){if(typeof lvl==='string'){if(!log.levels.hasOwnProperty(lvl)){throw new Error('\"'+lvl+'\" in not a valid log level');}level=lvl;}return level;};/**\n * Returns an array containing everything that has been logged to the history.\n *\n * This array is a shallow clone of the internal history record. However, its\n * contents are _not_ cloned; so, mutating objects inside this array will\n * mutate them in history.\n *\n * @return {Array}\n */log.history=function(){return history?[].concat(history):[];};/**\n * Clears the internal history tracking, but does not prevent further history\n * tracking.\n */log.history.clear=function(){if(history){history.length=0;}};/**\n * Disable history tracking if it is currently enabled.\n */log.history.disable=function(){if(history!==null){history.length=0;history=null;}};/**\n * Enable history tracking if it is currently disabled.\n */log.history.enable=function(){if(history===null){history=[];}};/**\n * Logs error messages. Similar to `console.error`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as an error\n */log.error=function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return logByType('error',args);};/**\n * Logs warning messages. Similar to `console.warn`.\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as a warning.\n */log.warn=function(){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}return logByType('warn',args);};/**\n * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n * log if `console.debug` is not available\n *\n * @param {Mixed[]} args\n *        One or more messages or objects that should be logged as debug.\n */log.debug=function(){for(var _len4=arguments.length,args=Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}return logByType('debug',args);};var log$1=log;/**\n * @file computed-style.js\n * @module computed-style\n *//**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is needed because in Firefox, if the player is loaded in an iframe with\n * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to\n * make sure  that the player doesn't break in these cases.\n *\n * @param {Element} el\n *        The element you want the computed style of\n *\n * @param {string} prop\n *        The property name you want\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n *\n * @static\n * @const\n */function computedStyle(el,prop){if(!el||!prop){return'';}if(typeof window.getComputedStyle==='function'){var cs=window.getComputedStyle(el);return cs?cs[prop]:'';}return el.currentStyle[prop]||'';}var _templateObject=taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ',' to ','.'],['Setting attributes in the second argument of createEl()\\n                has been deprecated. Use the third argument instead.\\n                createEl(type, properties, attributes). Attempting to set ',' to ','.']);/**\n * @file dom.js\n * @module dom\n *//**\n * Detect if a value is a string with any non-whitespace characters.\n *\n * @param {string} str\n *        The string to check\n *\n * @return {boolean}\n *         - True if the string is non-blank\n *         - False otherwise\n *\n */function isNonBlankString(str){return typeof str==='string'&&/\\S/.test(str);}/**\n * Throws an error if the passed string has whitespace. This is used by\n * class methods to be relatively consistent with the classList API.\n *\n * @param {string} str\n *         The string to check for whitespace.\n *\n * @throws {Error}\n *         Throws an error if there is whitespace in the string.\n *\n */function throwIfWhitespace(str){if(/\\s/.test(str)){throw new Error('class has illegal whitespace characters');}}/**\n * Produce a regular expression for matching a className within an elements className.\n *\n * @param {string} className\n *         The className to generate the RegExp for.\n *\n * @return {RegExp}\n *         The RegExp that will check for a specific `className` in an elements\n *         className.\n */function classRegExp(className){return new RegExp('(^|\\\\s)'+className+'($|\\\\s)');}/**\n * Whether the current DOM interface appears to be real.\n *\n * @return {Boolean}\n */function isReal(){return(// Both document and window will never be undefined thanks to `global`.\ndocument===window.document&&// In IE < 9, DOM methods return \"object\" as their type, so all we can\n// confidently check is that it exists.\ntypeof document.createElement!=='undefined');}/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @param {Mixed} value\n *        The thing to check\n *\n * @return {boolean}\n *         - True if it is a DOM element\n *         - False otherwise\n */function isEl(value){return isObject(value)&&value.nodeType===1;}/**\n * Determines if the current DOM is embedded in an iframe.\n *\n * @return {boolean}\n *\n */function isInFrame(){// We need a try/catch here because Safari will throw errors when attempting\n// to get either `parent` or `self`\ntry{return window.parent!==window.self;}catch(x){return true;}}/**\n * Creates functions to query the DOM using a given method.\n *\n * @param {string} method\n *         The method to create the query with.\n *\n * @return {Function}\n *         The query method\n */function createQuerier(method){return function(selector,context){if(!isNonBlankString(selector)){return document[method](null);}if(isNonBlankString(context)){context=document.querySelector(context);}var ctx=isEl(context)?context:document;return ctx[method]&&ctx[method](selector);};}/**\n * Creates an element and applies properties.\n *\n * @param {string} [tagName='div']\n *         Name of tag to be created.\n *\n * @param {Object} [properties={}]\n *         Element properties to be applied.\n *\n * @param {Object} [attributes={}]\n *         Element attributes to be applied.\n *\n * @param {String|Element|TextNode|Array|Function} [content]\n *         Contents for the element (see: {@link dom:normalizeContent})\n *\n * @return {Element}\n *         The element that was created.\n */function createEl(){var tagName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'div';var properties=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var content=arguments[3];var el=document.createElement(tagName);Object.getOwnPropertyNames(properties).forEach(function(propName){var val=properties[propName];// See #2176\n// We originally were accepting both properties and attributes in the\n// same object, but that doesn't work so well.\nif(propName.indexOf('aria-')!==-1||propName==='role'||propName==='type'){log$1.warn(tsml(_templateObject,propName,val));el.setAttribute(propName,val);// Handle textContent since it's not supported everywhere and we have a\n// method for it.\n}else if(propName==='textContent'){textContent(el,val);}else{el[propName]=val;}});Object.getOwnPropertyNames(attributes).forEach(function(attrName){el.setAttribute(attrName,attributes[attrName]);});if(content){appendContent(el,content);}return el;}/**\n * Injects text into an element, replacing any existing contents entirely.\n *\n * @param {Element} el\n *        The element to add text content into\n *\n * @param {string} text\n *        The text content to add.\n *\n * @return {Element}\n *         The element with added text content.\n */function textContent(el,text){if(typeof el.textContent==='undefined'){el.innerText=text;}else{el.textContent=text;}return el;}/**\n * Insert an element as the first child node of another\n *\n * @param {Element} child\n *        Element to insert\n *\n * @param {Element} parent\n *        Element to insert child into\n */function prependTo(child,parent){if(parent.firstChild){parent.insertBefore(child,parent.firstChild);}else{parent.appendChild(child);}}/**\n * Check if an element has a CSS class\n *\n * @param {Element} element\n *        Element to check\n *\n * @param {string} classToCheck\n *        Class name to check for\n *\n * @return {boolean}\n *         - True if the element had the class\n *         - False otherwise.\n *\n * @throws {Error}\n *         Throws an error if `classToCheck` has white space.\n */function hasClass(element,classToCheck){throwIfWhitespace(classToCheck);if(element.classList){return element.classList.contains(classToCheck);}return classRegExp(classToCheck).test(element.className);}/**\n * Add a CSS class name to an element\n *\n * @param {Element} element\n *        Element to add class name to.\n *\n * @param {string} classToAdd\n *        Class name to add.\n *\n * @return {Element}\n *         The dom element with the added class name.\n */function addClass(element,classToAdd){if(element.classList){element.classList.add(classToAdd);// Don't need to `throwIfWhitespace` here because `hasElClass` will do it\n// in the case of classList not being supported.\n}else if(!hasClass(element,classToAdd)){element.className=(element.className+' '+classToAdd).trim();}return element;}/**\n * Remove a CSS class name from an element\n *\n * @param {Element} element\n *        Element to remove a class name from.\n *\n * @param {string} classToRemove\n *        Class name to remove\n *\n * @return {Element}\n *         The dom element with class name removed.\n */function removeClass(element,classToRemove){if(element.classList){element.classList.remove(classToRemove);}else{throwIfWhitespace(classToRemove);element.className=element.className.split(/\\s+/).filter(function(c){return c!==classToRemove;}).join(' ');}return element;}/**\n * The callback definition for toggleElClass.\n *\n * @callback Dom~PredicateCallback\n * @param {Element} element\n *        The DOM element of the Component.\n *\n * @param {string} classToToggle\n *        The `className` that wants to be toggled\n *\n * @return {boolean|undefined}\n *         - If true the `classToToggle` will get added to `element`.\n *         - If false the `classToToggle` will get removed from `element`.\n *         - If undefined this callback will be ignored\n *//**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @param {Element} element\n *        The element to toggle a class name on.\n *\n * @param {string} classToToggle\n *        The class that should be toggled\n *\n * @param {boolean|PredicateCallback} [predicate]\n *        See the return value for {@link Dom~PredicateCallback}\n *\n * @return {Element}\n *         The element with a class that has been toggled.\n */function toggleClass(element,classToToggle,predicate){// This CANNOT use `classList` internally because IE does not support the\n// second parameter to the `classList.toggle()` method! Which is fine because\n// `classList` will be used by the add/remove functions.\nvar has=hasClass(element,classToToggle);if(typeof predicate==='function'){predicate=predicate(element,classToToggle);}if(typeof predicate!=='boolean'){predicate=!has;}// If the necessary class operation matches the current state of the\n// element, no action is required.\nif(predicate===has){return;}if(predicate){addClass(element,classToToggle);}else{removeClass(element,classToToggle);}return element;}/**\n * Apply attributes to an HTML element.\n *\n * @param {Element} el\n *        Element to add attributes to.\n *\n * @param {Object} [attributes]\n *        Attributes to be applied.\n */function setAttributes(el,attributes){Object.getOwnPropertyNames(attributes).forEach(function(attrName){var attrValue=attributes[attrName];if(attrValue===null||typeof attrValue==='undefined'||attrValue===false){el.removeAttribute(attrName);}else{el.setAttribute(attrName,attrValue===true?'':attrValue);}});}/**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @param {Element} tag\n *        Element from which to get tag attributes.\n *\n * @return {Object}\n *         All attributes of the element.\n */function getAttributes(tag){var obj={};// known boolean attributes\n// we can check for matching boolean properties, but older browsers\n// won't know about HTML5 boolean attributes that we still read from\nvar knownBooleans=','+'autoplay,controls,playsinline,loop,muted,default,defaultMuted'+',';if(tag&&tag.attributes&&tag.attributes.length>0){var attrs=tag.attributes;for(var i=attrs.length-1;i>=0;i--){var attrName=attrs[i].name;var attrVal=attrs[i].value;// check for known booleans\n// the matching element property will return a value for typeof\nif(typeof tag[attrName]==='boolean'||knownBooleans.indexOf(','+attrName+',')!==-1){// the value of an included boolean attribute is typically an empty\n// string ('') which would equal false if we just check for a false value.\n// we also don't want support bad code like autoplay='false'\nattrVal=attrVal!==null?true:false;}obj[attrName]=attrVal;}}return obj;}/**\n * Get the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to get the value of\n *\n * @return {string}\n *         value of the attribute\n */function getAttribute(el,attribute){return el.getAttribute(attribute);}/**\n * Set the value of an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to set\n *\n * @param {string} value\n *        Value to set the attribute to\n */function setAttribute(el,attribute,value){el.setAttribute(attribute,value);}/**\n * Remove an element's attribute\n *\n * @param {Element} el\n *        A DOM element\n *\n * @param {string} attribute\n *        Attribute to remove\n */function removeAttribute(el,attribute){el.removeAttribute(attribute);}/**\n * Attempt to block the ability to select text while dragging controls\n */function blockTextSelection(){document.body.focus();document.onselectstart=function(){return false;};}/**\n * Turn off text selection blocking\n */function unblockTextSelection(){document.onselectstart=function(){return true;};}/**\n * Identical to the native `getBoundingClientRect` function, but ensures that\n * the method is supported at all (it is in all browsers we claim to support)\n * and that the element is in the DOM before continuing.\n *\n * This wrapper function also shims properties which are not provided by some\n * older browsers (namely, IE8).\n *\n * Additionally, some browsers do not support adding properties to a\n * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n * properties (except `x` and `y` which are not widely supported). This helps\n * avoid implementations where keys are non-enumerable.\n *\n * @param  {Element} el\n *         Element whose `ClientRect` we want to calculate.\n *\n * @return {Object|undefined}\n *         Always returns a plain\n */function getBoundingClientRect(el){if(el&&el.getBoundingClientRect&&el.parentNode){var rect=el.getBoundingClientRect();var result={};['bottom','height','left','right','top','width'].forEach(function(k){if(rect[k]!==undefined){result[k]=rect[k];}});if(!result.height){result.height=parseFloat(computedStyle(el,'height'));}if(!result.width){result.width=parseFloat(computedStyle(el,'width'));}return result;}}/**\n * The postion of a DOM element on the page.\n *\n * @typedef {Object} module:dom~Position\n *\n * @property {number} left\n *           Pixels to the left\n *\n * @property {number} top\n *           Pixels on top\n *//**\n * Offset Left.\n * getBoundingClientRect technique from\n * John Resig\n *\n * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n *\n * @param {Element} el\n *        Element from which to get offset\n *\n * @return {module:dom~Position}\n *         The position of the element that was passed in.\n */function findPosition(el){var box=void 0;if(el.getBoundingClientRect&&el.parentNode){box=el.getBoundingClientRect();}if(!box){return{left:0,top:0};}var docEl=document.documentElement;var body=document.body;var clientLeft=docEl.clientLeft||body.clientLeft||0;var scrollLeft=window.pageXOffset||body.scrollLeft;var left=box.left+scrollLeft-clientLeft;var clientTop=docEl.clientTop||body.clientTop||0;var scrollTop=window.pageYOffset||body.scrollTop;var top=box.top+scrollTop-clientTop;// Android sometimes returns slightly off decimal values, so need to round\nreturn{left:Math.round(left),top:Math.round(top)};}/**\n * x and y coordinates for a dom element or mouse pointer\n *\n * @typedef {Object} Dom~Coordinates\n *\n * @property {number} x\n *           x coordinate in pixels\n *\n * @property {number} y\n *           y coordinate in pixels\n *//**\n * Get pointer position in element\n * Returns an object with x and y coordinates.\n * The base on the coordinates are the bottom left of the element.\n *\n * @param {Element} el\n *        Element on which to get the pointer position on\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {Dom~Coordinates}\n *         A Coordinates object corresponding to the mouse position.\n *\n */function getPointerPosition(el,event){var position={};var box=findPosition(el);var boxW=el.offsetWidth;var boxH=el.offsetHeight;var boxY=box.top;var boxX=box.left;var pageY=event.pageY;var pageX=event.pageX;if(event.changedTouches){pageX=event.changedTouches[0].pageX;pageY=event.changedTouches[0].pageY;}position.y=Math.max(0,Math.min(1,(boxY-pageY+boxH)/boxH));position.x=Math.max(0,Math.min(1,(pageX-boxX)/boxW));return position;}/**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @param {Mixed} value\n *        Check if this value is a text node.\n *\n * @return {boolean}\n *         - True if it is a text node\n *         - False otherwise\n */function isTextNode(value){return isObject(value)&&value.nodeType===3;}/**\n * Empties the contents of an element.\n *\n * @param {Element} el\n *        The element to empty children from\n *\n * @return {Element}\n *         The element with no children\n */function emptyEl(el){while(el.firstChild){el.removeChild(el.firstChild);}return el;}/**\n * Normalizes content for eventual insertion into the DOM.\n *\n * This allows a wide range of content definition methods, but protects\n * from falling into the trap of simply writing to `innerHTML`, which is\n * an XSS concern.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        - String: Normalized into a text node.\n *        - Element/TextNode: Passed through.\n *        - Array: A one-dimensional array of strings, elements, nodes, or functions\n *          (which return single strings, elements, or nodes).\n *        - Function: If the sole argument, is expected to produce a string, element,\n *          node, or array as defined above.\n *\n * @return {Array}\n *         All of the content that was passed in normalized.\n */function normalizeContent(content){// First, invoke content if it is a function. If it produces an array,\n// that needs to happen before normalization.\nif(typeof content==='function'){content=content();}// Next up, normalize to an array, so one or many items can be normalized,\n// filtered, and returned.\nreturn(Array.isArray(content)?content:[content]).map(function(value){// First, invoke value if it is a function to produce a new value,\n// which will be subsequently normalized to a Node of some kind.\nif(typeof value==='function'){value=value();}if(isEl(value)||isTextNode(value)){return value;}if(typeof value==='string'&&/\\S/.test(value)){return document.createTextNode(value);}}).filter(function(value){return value;});}/**\n * Normalizes and appends content to an element.\n *\n * @param {Element} el\n *        Element to append normalized content to.\n *\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with appended normalized content.\n */function appendContent(el,content){normalizeContent(content).forEach(function(node){return el.appendChild(node);});return el;}/**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * @param {Element} el\n *        Element to insert normalized content into.\n *\n * @param {String|Element|TextNode|Array|Function} content\n *        See the `content` argument of {@link dom:normalizeContent}\n *\n * @return {Element}\n *         The element with inserted normalized content.\n *\n */function insertContent(el,content){return appendContent(emptyEl(el),content);}/**\n * Check if event was a single left click\n *\n * @param {EventTarget~Event} event\n *        Event object\n *\n * @return {boolean}\n *         - True if a left click\n *         - False if not a left click\n */function isSingleLeftClick(event){// Note: if you create something draggable, be sure to\n// call it on both `mousedown` and `mousemove` event,\n// otherwise `mousedown` should be enough for a button\nif(event.button===undefined&&event.buttons===undefined){// Why do we need `butttons` ?\n// Because, middle mouse sometimes have this:\n// e.button === 0 and e.buttons === 4\n// Furthermore, we want to prevent combination click, something like\n// HOLD middlemouse then left click, that would be\n// e.button === 0, e.buttons === 5\n// just `button` is not gonna work\n// Alright, then what this block does ?\n// this is for chrome `simulate mobile devices`\n// I want to support this as well\nreturn true;}if(event.button===0&&event.buttons===undefined){// Touch screen, sometimes on some specific device, `buttons`\n// doesn't have anything (safari on ios, blackberry...)\nreturn true;}if(IE_VERSION===9){// Ignore IE9\nreturn true;}if(event.button!==0||event.buttons!==1){// This is the reason we have those if else block above\n// if any special case we can catch and let it slide\n// we do it above, when get to here, this definitely\n// is-not-left-click\nreturn false;}return true;}/**\n * Finds a single DOM element matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *        A valid CSS selector, which will be passed to `querySelector`.\n *\n * @param {Element|String} [context=document]\n *        A DOM element within which to query. Can also be a selector\n *        string in which case the first matching element will be used\n *        as context. If missing (or no element matches selector), falls\n *        back to `document`.\n *\n * @return {Element|null}\n *         The element that was found or null.\n */var $=createQuerier('querySelector');/**\n * Finds a all DOM elements matching `selector` within the optional\n * `context` of another DOM element (defaulting to `document`).\n *\n * @param {string} selector\n *           A valid CSS selector, which will be passed to `querySelectorAll`.\n *\n * @param {Element|String} [context=document]\n *           A DOM element within which to query. Can also be a selector\n *           string in which case the first matching element will be used\n *           as context. If missing (or no element matches selector), falls\n *           back to `document`.\n *\n * @return {NodeList}\n *         A element list of elements that were found. Will be empty if none were found.\n *\n */var $$=createQuerier('querySelectorAll');var Dom=(Object.freeze||Object)({isReal:isReal,isEl:isEl,isInFrame:isInFrame,createEl:createEl,textContent:textContent,prependTo:prependTo,hasClass:hasClass,addClass:addClass,removeClass:removeClass,toggleClass:toggleClass,setAttributes:setAttributes,getAttributes:getAttributes,getAttribute:getAttribute,setAttribute:setAttribute,removeAttribute:removeAttribute,blockTextSelection:blockTextSelection,unblockTextSelection:unblockTextSelection,getBoundingClientRect:getBoundingClientRect,findPosition:findPosition,getPointerPosition:getPointerPosition,isTextNode:isTextNode,emptyEl:emptyEl,normalizeContent:normalizeContent,appendContent:appendContent,insertContent:insertContent,isSingleLeftClick:isSingleLeftClick,$:$,$$:$$});/**\n * @file guid.js\n * @module guid\n *//**\n * Unique ID for an element or function\n * @type {Number}\n */var _guid=1;/**\n * Get a unique auto-incrementing ID by number that has not been returned before.\n *\n * @return {number}\n *         A new unique ID.\n */function newGUID(){return _guid++;}/**\n * @file dom-data.js\n * @module dom-data\n *//**\n * Element Data Store.\n *\n * Allows for binding data to an element without putting it directly on the\n * element. Ex. Event listeners are stored here.\n * (also from jsninja.com, slightly modified and updated for closure compiler)\n *\n * @type {Object}\n * @private\n */var elData={};/*\n * Unique attribute name to store an element's guid in\n *\n * @type {String}\n * @constant\n * @private\n */var elIdAttr='vdata'+new Date().getTime();/**\n * Returns the cache object where data for an element is stored\n *\n * @param {Element} el\n *        Element to store data for.\n *\n * @return {Object}\n *         The cache object for that el that was passed in.\n */function getData(el){var id=el[elIdAttr];if(!id){id=el[elIdAttr]=newGUID();}if(!elData[id]){elData[id]={};}return elData[id];}/**\n * Returns whether or not an element has cached data\n *\n * @param {Element} el\n *        Check if this element has cached data.\n *\n * @return {boolean}\n *         - True if the DOM element has cached data.\n *         - False otherwise.\n */function hasData(el){var id=el[elIdAttr];if(!id){return false;}return!!Object.getOwnPropertyNames(elData[id]).length;}/**\n * Delete data for the element from the cache and the guid attr from getElementById\n *\n * @param {Element} el\n *        Remove cached data for this element.\n */function removeData(el){var id=el[elIdAttr];if(!id){return;}// Remove all stored data\ndelete elData[id];// Remove the elIdAttr property from the DOM node\ntry{delete el[elIdAttr];}catch(e){if(el.removeAttribute){el.removeAttribute(elIdAttr);}else{// IE doesn't appear to support removeAttribute on the document element\nel[elIdAttr]=null;}}}/**\n * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n * robust as jquery's, so there's probably some differences.\n *\n * @module events\n *//**\n * Clean up the listener cache and dispatchers\n *\n * @param {Element|Object} elem\n *        Element to clean up\n *\n * @param {string} type\n *        Type of event to clean up\n */function _cleanUpEvents(elem,type){var data=getData(elem);// Remove the events of a particular type if there are none left\nif(data.handlers[type].length===0){delete data.handlers[type];// data.handlers[type] = null;\n// Setting to null was causing an error with data.handlers\n// Remove the meta-handler from the element\nif(elem.removeEventListener){elem.removeEventListener(type,data.dispatcher,false);}else if(elem.detachEvent){elem.detachEvent('on'+type,data.dispatcher);}}// Remove the events object if there are no types left\nif(Object.getOwnPropertyNames(data.handlers).length<=0){delete data.handlers;delete data.dispatcher;delete data.disabled;}// Finally remove the element data if there is no data left\nif(Object.getOwnPropertyNames(data).length===0){removeData(elem);}}/**\n * Loops through an array of event types and calls the requested method for each type.\n *\n * @param {Function} fn\n *        The event method we want to use.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} callback\n *        Event listener.\n */function _handleMultipleEvents(fn,elem,types,callback){types.forEach(function(type){// Call the event method for each one of the types\nfn(elem,type,callback);});}/**\n * Fix a native event to have standard property values\n *\n * @param {Object} event\n *        Event object to fix.\n *\n * @return {Object}\n *         Fixed event object.\n */function fixEvent(event){function returnTrue(){return true;}function returnFalse(){return false;}// Test if fixing up is needed\n// Used to check if !event.stopPropagation instead of isPropagationStopped\n// But native events return true for stopPropagation, but don't have\n// other expected methods like isPropagationStopped. Seems to be a problem\n// with the Javascript Ninja code. So we're just overriding all events now.\nif(!event||!event.isPropagationStopped){var old=event||window.event;event={};// Clone the old object so that we can modify the values event = {};\n// IE8 Doesn't like when you mess with native event properties\n// Firefox returns false for event.hasOwnProperty('type') and other props\n//  which makes copying more difficult.\n// TODO: Probably best to create a whitelist of event props\nfor(var key in old){// Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n// Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n// and webkitMovementX/Y\nif(key!=='layerX'&&key!=='layerY'&&key!=='keyLocation'&&key!=='webkitMovementX'&&key!=='webkitMovementY'){// Chrome 32+ warns if you try to copy deprecated returnValue, but\n// we still want to if preventDefault isn't supported (IE8).\nif(!(key==='returnValue'&&old.preventDefault)){event[key]=old[key];}}}// The event occurred on this element\nif(!event.target){event.target=event.srcElement||document;}// Handle which other element the event is related to\nif(!event.relatedTarget){event.relatedTarget=event.fromElement===event.target?event.toElement:event.fromElement;}// Stop the default browser action\nevent.preventDefault=function(){if(old.preventDefault){old.preventDefault();}event.returnValue=false;old.returnValue=false;event.defaultPrevented=true;};event.defaultPrevented=false;// Stop the event from bubbling\nevent.stopPropagation=function(){if(old.stopPropagation){old.stopPropagation();}event.cancelBubble=true;old.cancelBubble=true;event.isPropagationStopped=returnTrue;};event.isPropagationStopped=returnFalse;// Stop the event from bubbling and executing other handlers\nevent.stopImmediatePropagation=function(){if(old.stopImmediatePropagation){old.stopImmediatePropagation();}event.isImmediatePropagationStopped=returnTrue;event.stopPropagation();};event.isImmediatePropagationStopped=returnFalse;// Handle mouse position\nif(event.clientX!==null&&event.clientX!==undefined){var doc=document.documentElement;var body=document.body;event.pageX=event.clientX+(doc&&doc.scrollLeft||body&&body.scrollLeft||0)-(doc&&doc.clientLeft||body&&body.clientLeft||0);event.pageY=event.clientY+(doc&&doc.scrollTop||body&&body.scrollTop||0)-(doc&&doc.clientTop||body&&body.clientTop||0);}// Handle key presses\nevent.which=event.charCode||event.keyCode;// Fix button for mouse clicks:\n// 0 == left; 1 == middle; 2 == right\nif(event.button!==null&&event.button!==undefined){// The following is disabled because it does not pass videojs-standard\n// and... yikes.\n/* eslint-disable */event.button=event.button&1?0:event.button&4?1:event.button&2?2:0;/* eslint-enable */}}// Returns fixed-up instance\nreturn event;}/**\n * Whether passive event listeners are supported\n */var _supportsPassive=false;(function(){try{var opts=Object.defineProperty({},'passive',{get:function get(){_supportsPassive=true;}});window.addEventListener('test',null,opts);window.removeEventListener('test',null,opts);}catch(e){// disregard\n}})();/**\n * Touch events Chrome expects to be passive\n */var passiveEvents=['touchstart','touchmove'];/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @param {Element|Object} elem\n *        Element or object to bind listeners to\n *\n * @param {string|string[]} type\n *        Type of event to bind to.\n *\n * @param {EventTarget~EventListener} fn\n *        Event listener.\n */function on(elem,type,fn){if(Array.isArray(type)){return _handleMultipleEvents(on,elem,type,fn);}var data=getData(elem);// We need a place to store all our handler data\nif(!data.handlers){data.handlers={};}if(!data.handlers[type]){data.handlers[type]=[];}if(!fn.guid){fn.guid=newGUID();}data.handlers[type].push(fn);if(!data.dispatcher){data.disabled=false;data.dispatcher=function(event,hash){if(data.disabled){return;}event=fixEvent(event);var handlers=data.handlers[event.type];if(handlers){// Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\nvar handlersCopy=handlers.slice(0);for(var m=0,n=handlersCopy.length;m<n;m++){if(event.isImmediatePropagationStopped()){break;}else{try{handlersCopy[m].call(elem,event,hash);}catch(e){log$1.error(e);}}}}};}if(data.handlers[type].length===1){if(elem.addEventListener){var options=false;if(_supportsPassive&&passiveEvents.indexOf(type)>-1){options={passive:true};}elem.addEventListener(type,data.dispatcher,options);}else if(elem.attachEvent){elem.attachEvent('on'+type,data.dispatcher);}}}/**\n * Removes event listeners from an element\n *\n * @param {Element|Object} elem\n *        Object to remove listeners from.\n *\n * @param {string|string[]} [type]\n *        Type of listener to remove. Don't include to remove all events from element.\n *\n * @param {EventTarget~EventListener} [fn]\n *        Specific listener to remove. Don't include to remove listeners for an event\n *        type.\n */function off(elem,type,fn){// Don't want to add a cache object through getElData if not needed\nif(!hasData(elem)){return;}var data=getData(elem);// If no events exist, nothing to unbind\nif(!data.handlers){return;}if(Array.isArray(type)){return _handleMultipleEvents(off,elem,type,fn);}// Utility function\nvar removeType=function removeType(el,t){data.handlers[t]=[];_cleanUpEvents(el,t);};// Are we removing all bound events?\nif(type===undefined){for(var t in data.handlers){if(Object.prototype.hasOwnProperty.call(data.handlers||{},t)){removeType(elem,t);}}return;}var handlers=data.handlers[type];// If no handlers exist, nothing to unbind\nif(!handlers){return;}// If no listener was provided, remove all listeners for type\nif(!fn){removeType(elem,type);return;}// We're only removing a single handler\nif(fn.guid){for(var n=0;n<handlers.length;n++){if(handlers[n].guid===fn.guid){handlers.splice(n--,1);}}}_cleanUpEvents(elem,type);}/**\n * Trigger an event for an element\n *\n * @param {Element|Object} elem\n *        Element to trigger an event on\n *\n * @param {EventTarget~Event|string} event\n *        A string (the type) or an event object with a type attribute\n *\n * @param {Object} [hash]\n *        data hash to pass along with the event\n *\n * @return {boolean|undefined}\n *         - Returns the opposite of `defaultPrevented` if default was prevented\n *         - Otherwise returns undefined\n */function trigger(elem,event,hash){// Fetches element data and a reference to the parent (for bubbling).\n// Don't want to add a data object to cache for every parent,\n// so checking hasElData first.\nvar elemData=hasData(elem)?getData(elem):{};var parent=elem.parentNode||elem.ownerDocument;// type = event.type || event,\n// handler;\n// If an event name was passed as a string, creates an event out of it\nif(typeof event==='string'){event={type:event,target:elem};}// Normalizes the event properties.\nevent=fixEvent(event);// If the passed element has a dispatcher, executes the established handlers.\nif(elemData.dispatcher){elemData.dispatcher.call(elem,event,hash);}// Unless explicitly stopped or the event does not bubble (e.g. media events)\n// recursively calls this function to bubble the event up the DOM.\nif(parent&&!event.isPropagationStopped()&&event.bubbles===true){trigger.call(null,parent,event,hash);// If at the top of the DOM, triggers the default action unless disabled.\n}else if(!parent&&!event.defaultPrevented){var targetData=getData(event.target);// Checks if the target has a default action for this event.\nif(event.target[event.type]){// Temporarily disables event dispatching on the target as we have already executed the handler.\ntargetData.disabled=true;// Executes the default action.\nif(typeof event.target[event.type]==='function'){event.target[event.type]();}// Re-enables event dispatching.\ntargetData.disabled=false;}}// Inform the triggerer if the default was prevented by returning false\nreturn!event.defaultPrevented;}/**\n * Trigger a listener only once for an event\n *\n * @param {Element|Object} elem\n *        Element or object to bind to.\n *\n * @param {string|string[]} type\n *        Name/type of event\n *\n * @param {Event~EventListener} fn\n *        Event Listener function\n */function one(elem,type,fn){if(Array.isArray(type)){return _handleMultipleEvents(one,elem,type,fn);}var func=function func(){off(elem,type,func);fn.apply(this,arguments);};// copy the guid to the new function so it can removed using the original function's ID\nfunc.guid=fn.guid=fn.guid||newGUID();on(elem,type,func);}var Events=(Object.freeze||Object)({fixEvent:fixEvent,on:on,off:off,trigger:trigger,one:one});/**\n * @file setup.js - Functions for setting up a player without\n * user interaction based on the data-setup `attribute` of the video tag.\n *\n * @module setup\n */var _windowLoaded=false;var videojs$2=void 0;/**\n * Set up any tags that have a data-setup `attribute` when the player is started.\n */var autoSetup=function autoSetup(){// Protect against breakage in non-browser environments.\nif(!isReal()){return;}// One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*\n// var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n// var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n// var mediaEls = vids.concat(audios);\n// Because IE8 doesn't support calling slice on a node list, we need to loop\n// through each list of elements to build up a new, combined list of elements.\nvar vids=document.getElementsByTagName('video');var audios=document.getElementsByTagName('audio');var divs=document.getElementsByTagName('video-js');var mediaEls=[];if(vids&&vids.length>0){for(var i=0,e=vids.length;i<e;i++){mediaEls.push(vids[i]);}}if(audios&&audios.length>0){for(var _i=0,_e=audios.length;_i<_e;_i++){mediaEls.push(audios[_i]);}}if(divs&&divs.length>0){for(var _i2=0,_e2=divs.length;_i2<_e2;_i2++){mediaEls.push(divs[_i2]);}}// Check if any media elements exist\nif(mediaEls&&mediaEls.length>0){for(var _i3=0,_e3=mediaEls.length;_i3<_e3;_i3++){var mediaEl=mediaEls[_i3];// Check if element exists, has getAttribute func.\n// IE seems to consider typeof el.getAttribute == 'object' instead of\n// 'function' like expected, at least when loading the player immediately.\nif(mediaEl&&mediaEl.getAttribute){// Make sure this player hasn't already been set up.\nif(mediaEl.player===undefined){var options=mediaEl.getAttribute('data-setup');// Check if data-setup attr exists.\n// We only auto-setup if they've added the data-setup attr.\nif(options!==null){// Create new video.js instance.\nvideojs$2(mediaEl);}}// If getAttribute isn't defined, we need to wait for the DOM.\n}else{autoSetupTimeout(1);break;}}// No videos were found, so keep looping unless page is finished loading.\n}else if(!_windowLoaded){autoSetupTimeout(1);}};/**\n * Wait until the page is loaded before running autoSetup. This will be called in\n * autoSetup if `hasLoaded` returns false.\n *\n * @param {number} wait\n *        How long to wait in ms\n *\n * @param {module:videojs} [vjs]\n *        The videojs library function\n */function autoSetupTimeout(wait,vjs){if(vjs){videojs$2=vjs;}window.setTimeout(autoSetup,wait);}if(isReal()&&document.readyState==='complete'){_windowLoaded=true;}else{/**\n   * Listen for the load event on window, and set _windowLoaded to true.\n   *\n   * @listens load\n   */one(window,'load',function(){_windowLoaded=true;});}/**\n * @file stylesheet.js\n * @module stylesheet\n *//**\n * Create a DOM syle element given a className for it.\n *\n * @param {string} className\n *        The className to add to the created style element.\n *\n * @return {Element}\n *         The element that was created.\n */var createStyleElement=function createStyleElement(className){var style=document.createElement('style');style.className=className;return style;};/**\n * Add text to a DOM element.\n *\n * @param {Element} el\n *        The Element to add text content to.\n *\n * @param {string} content\n *        The text to add to the element.\n */var setTextContent=function setTextContent(el,content){if(el.styleSheet){el.styleSheet.cssText=content;}else{el.textContent=content;}};/**\n * @file fn.js\n * @module fn\n *//**\n * Bind (a.k.a proxy or Context). A simple method for changing the context of a function\n * It also stores a unique id on the function so it can be easily removed from events.\n *\n * @param {Mixed} context\n *        The object to bind as scope.\n *\n * @param {Function} fn\n *        The function to be bound to a scope.\n *\n * @param {number} [uid]\n *        An optional unique ID for the function to be set\n *\n * @return {Function}\n *         The new function that will be bound into the context given\n */var bind=function bind(context,fn,uid){// Make sure the function has a unique ID\nif(!fn.guid){fn.guid=newGUID();}// Create the new function that changes the context\nvar bound=function bound(){return fn.apply(context,arguments);};// Allow for the ability to individualize this function\n// Needed in the case where multiple objects might share the same prototype\n// IF both items add an event listener with the same function, then you try to remove just one\n// it will remove both because they both have the same guid.\n// when using this, you need to use the bind method when you remove the listener as well.\n// currently used in text tracks\nbound.guid=uid?uid+'_'+fn.guid:fn.guid;return bound;};/**\n * Wraps the given function, `fn`, with a new function that only invokes `fn`\n * at most once per every `wait` milliseconds.\n *\n * @param  {Function} fn\n *         The function to be throttled.\n *\n * @param  {Number}   wait\n *         The number of milliseconds by which to throttle.\n *\n * @return {Function}\n */var throttle=function throttle(fn,wait){var last=Date.now();var throttled=function throttled(){var now=Date.now();if(now-last>=wait){fn.apply(undefined,arguments);last=now;}};return throttled;};/**\n * @file src/js/event-target.js\n *//**\n * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n * adds shorthand functions that wrap around lengthy functions. For example:\n * the `on` function is a wrapper around `addEventListener`.\n *\n * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n * @class EventTarget\n */var EventTarget=function EventTarget(){};/**\n * A Custom DOM event.\n *\n * @typedef {Object} EventTarget~Event\n * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n *//**\n * All event listeners should follow the following format.\n *\n * @callback EventTarget~EventListener\n * @this {EventTarget}\n *\n * @param {EventTarget~Event} event\n *        the event that triggered this function\n *\n * @param {Object} [hash]\n *        hash of data sent during the event\n *//**\n * An object containing event names as keys and booleans as values.\n *\n * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n *         will have extra functionality. See that function for more information.\n *\n * @property EventTarget.prototype.allowedEvents_\n * @private\n */EventTarget.prototype.allowedEvents_={};/**\n * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n * function that will get called when an event with a certain name gets triggered.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to call with `EventTarget`s\n */EventTarget.prototype.on=function(type,fn){// Remove the addEventListener alias before calling Events.on\n// so we don't get into an infinite type loop\nvar ael=this.addEventListener;this.addEventListener=function(){};on(this,type,fn);this.addEventListener=ael;};/**\n * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#on}\n */EventTarget.prototype.addEventListener=EventTarget.prototype.on;/**\n * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n * This makes it so that the `event listener` will no longer get called when the\n * named event happens.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to remove.\n */EventTarget.prototype.off=function(type,fn){off(this,type,fn);};/**\n * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#off}\n */EventTarget.prototype.removeEventListener=EventTarget.prototype.off;/**\n * This function will add an `event listener` that gets triggered only once. After the\n * first trigger it will get removed. This is like adding an `event listener`\n * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n *\n * @param {string|string[]} type\n *        An event name or an array of event names.\n *\n * @param {EventTarget~EventListener} fn\n *        The function to be called once for each event name.\n */EventTarget.prototype.one=function(type,fn){// Remove the addEventListener alialing Events.on\n// so we don't get into an infinite type loop\nvar ael=this.addEventListener;this.addEventListener=function(){};one(this,type,fn);this.addEventListener=ael;};/**\n * This function causes an event to happen. This will then cause any `event listeners`\n * that are waiting for that event, to get called. If there are no `event listeners`\n * for an event then nothing will happen.\n *\n * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n * Trigger will also call the `on` + `uppercaseEventName` function.\n *\n * Example:\n * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n * `onClick` if it exists.\n *\n * @param {string|EventTarget~Event|Object} event\n *        The name of the event, an `Event`, or an object with a key of type set to\n *        an event name.\n */EventTarget.prototype.trigger=function(event){var type=event.type||event;if(typeof event==='string'){event={type:type};}event=fixEvent(event);if(this.allowedEvents_[type]&&this['on'+type]){this['on'+type](event);}trigger(this,event);};/**\n * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n * the standard DOM API.\n *\n * @function\n * @see {@link EventTarget#trigger}\n */EventTarget.prototype.dispatchEvent=EventTarget.prototype.trigger;/**\n * @file mixins/evented.js\n * @module evented\n *//**\n * Returns whether or not an object has had the evented mixin applied.\n *\n * @param  {Object} object\n *         An object to test.\n *\n * @return {boolean}\n *         Whether or not the object appears to be evented.\n */var isEvented=function isEvented(object){return object instanceof EventTarget||!!object.eventBusEl_&&['on','one','off','trigger'].every(function(k){return typeof object[k]==='function';});};/**\n * Whether a value is a valid event type - non-empty string or array.\n *\n * @private\n * @param  {string|Array} type\n *         The type value to test.\n *\n * @return {boolean}\n *         Whether or not the type is a valid event type.\n */var isValidEventType=function isValidEventType(type){return(// The regex here verifies that the `type` contains at least one non-\n// whitespace character.\ntypeof type==='string'&&/\\S/.test(type)||Array.isArray(type)&&!!type.length);};/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the target does not appear to be a valid event target.\n *\n * @param  {Object} target\n *         The object to test.\n */var validateTarget=function validateTarget(target){if(!target.nodeName&&!isEvented(target)){throw new Error('Invalid target; must be a DOM node or evented object.');}};/**\n * Validates a value to determine if it is a valid event target. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the type does not appear to be a valid event type.\n *\n * @param  {string|Array} type\n *         The type to test.\n */var validateEventType=function validateEventType(type){if(!isValidEventType(type)){throw new Error('Invalid event type; must be a non-empty string or array.');}};/**\n * Validates a value to determine if it is a valid listener. Throws if not.\n *\n * @private\n * @throws {Error}\n *         If the listener is not a function.\n *\n * @param  {Function} listener\n *         The listener to test.\n */var validateListener=function validateListener(listener){if(typeof listener!=='function'){throw new Error('Invalid listener; must be a function.');}};/**\n * Takes an array of arguments given to `on()` or `one()`, validates them, and\n * normalizes them into an object.\n *\n * @private\n * @param  {Object} self\n *         The evented object on which `on()` or `one()` was called. This\n *         object will be bound as the `this` value for the listener.\n *\n * @param  {Array} args\n *         An array of arguments passed to `on()` or `one()`.\n *\n * @return {Object}\n *         An object containing useful values for `on()` or `one()` calls.\n */var normalizeListenArgs=function normalizeListenArgs(self,args){// If the number of arguments is less than 3, the target is always the\n// evented object itself.\nvar isTargetingSelf=args.length<3||args[0]===self||args[0]===self.eventBusEl_;var target=void 0;var type=void 0;var listener=void 0;if(isTargetingSelf){target=self.eventBusEl_;// Deal with cases where we got 3 arguments, but we are still listening to\n// the evented object itself.\nif(args.length>=3){args.shift();}type=args[0];listener=args[1];}else{target=args[0];type=args[1];listener=args[2];}validateTarget(target);validateEventType(type);validateListener(listener);listener=bind(self,listener);return{isTargetingSelf:isTargetingSelf,target:target,type:type,listener:listener};};/**\n * Adds the listener to the event type(s) on the target, normalizing for\n * the type of target.\n *\n * @private\n * @param  {Element|Object} target\n *         A DOM node or evented object.\n *\n * @param  {string} method\n *         The event binding method to use (\"on\" or \"one\").\n *\n * @param  {string|Array} type\n *         One or more event type(s).\n *\n * @param  {Function} listener\n *         A listener function.\n */var listen=function listen(target,method,type,listener){validateTarget(target);if(target.nodeName){Events[method](target,type,listener);}else{target[method](type,listener);}};/**\n * Contains methods that provide event capabilites to an object which is passed\n * to {@link module:evented|evented}.\n *\n * @mixin EventedMixin\n */var EventedMixin={/**\n   * Add a listener to an event (or events) on this object or another evented\n   * object.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */on:function on$$1(){var _this=this;for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _normalizeListenArgs=normalizeListenArgs(this,args),isTargetingSelf=_normalizeListenArgs.isTargetingSelf,target=_normalizeListenArgs.target,type=_normalizeListenArgs.type,listener=_normalizeListenArgs.listener;listen(target,'on',type,listener);// If this object is listening to another evented object.\nif(!isTargetingSelf){// If this object is disposed, remove the listener.\nvar removeListenerOnDispose=function removeListenerOnDispose(){return _this.off(target,type,listener);};// Use the same function ID as the listener so we can remove it later it\n// using the ID of the original listener.\nremoveListenerOnDispose.guid=listener.guid;// Add a listener to the target's dispose event as well. This ensures\n// that if the target is disposed BEFORE this object, we remove the\n// removal listener that was just added. Otherwise, we create a memory leak.\nvar removeRemoverOnTargetDispose=function removeRemoverOnTargetDispose(){return _this.off('dispose',removeListenerOnDispose);};// Use the same function ID as the listener so we can remove it later\n// it using the ID of the original listener.\nremoveRemoverOnTargetDispose.guid=listener.guid;listen(this,'on','dispose',removeListenerOnDispose);listen(target,'on','dispose',removeRemoverOnTargetDispose);}},/**\n   * Add a listener to an event (or events) on this object or another evented\n   * object. The listener will only be called once and then removed.\n   *\n   * @param  {string|Array|Element|Object} targetOrType\n   *         If this is a string or array, it represents the event type(s)\n   *         that will trigger the listener.\n   *\n   *         Another evented object can be passed here instead, which will\n   *         cause the listener to listen for events on _that_ object.\n   *\n   *         In either case, the listener's `this` value will be bound to\n   *         this object.\n   *\n   * @param  {string|Array|Function} typeOrListener\n   *         If the first argument was a string or array, this should be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function.\n   */one:function one$$1(){var _this2=this;for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}var _normalizeListenArgs2=normalizeListenArgs(this,args),isTargetingSelf=_normalizeListenArgs2.isTargetingSelf,target=_normalizeListenArgs2.target,type=_normalizeListenArgs2.type,listener=_normalizeListenArgs2.listener;// Targeting this evented object.\nif(isTargetingSelf){listen(target,'one',type,listener);// Targeting another evented object.\n}else{var wrapper=function wrapper(){for(var _len3=arguments.length,largs=Array(_len3),_key3=0;_key3<_len3;_key3++){largs[_key3]=arguments[_key3];}_this2.off(target,type,wrapper);listener.apply(null,largs);};// Use the same function ID as the listener so we can remove it later\n// it using the ID of the original listener.\nwrapper.guid=listener.guid;listen(target,'one',type,wrapper);}},/**\n   * Removes listener(s) from event(s) on an evented object.\n   *\n   * @param  {string|Array|Element|Object} [targetOrType]\n   *         If this is a string or array, it represents the event type(s).\n   *\n   *         Another evented object can be passed here instead, in which case\n   *         ALL 3 arguments are _required_.\n   *\n   * @param  {string|Array|Function} [typeOrListener]\n   *         If the first argument was a string or array, this may be the\n   *         listener function. Otherwise, this is a string or array of event\n   *         type(s).\n   *\n   * @param  {Function} [listener]\n   *         If the first argument was another evented object, this will be\n   *         the listener function; otherwise, _all_ listeners bound to the\n   *         event type(s) will be removed.\n   */off:function off$$1(targetOrType,typeOrListener,listener){// Targeting this evented object.\nif(!targetOrType||isValidEventType(targetOrType)){off(this.eventBusEl_,targetOrType,typeOrListener);// Targeting another evented object.\n}else{var target=targetOrType;var type=typeOrListener;// Fail fast and in a meaningful way!\nvalidateTarget(target);validateEventType(type);validateListener(listener);// Ensure there's at least a guid, even if the function hasn't been used\nlistener=bind(this,listener);// Remove the dispose listener on this evented object, which was given\n// the same guid as the event listener in on().\nthis.off('dispose',listener);if(target.nodeName){off(target,type,listener);off(target,'dispose',listener);}else if(isEvented(target)){target.off(type,listener);target.off('dispose',listener);}}},/**\n   * Fire an event on this evented object, causing its listeners to be called.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash]\n   *          An additional object to pass along to listeners.\n   *\n   * @returns {boolean}\n   *          Whether or not the default behavior was prevented.\n   */trigger:function trigger$$1(event,hash){return trigger(this.eventBusEl_,event,hash);}};/**\n * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n *\n * @param  {Object} target\n *         The object to which to add event methods.\n *\n * @param  {Object} [options={}]\n *         Options for customizing the mixin behavior.\n *\n * @param  {String} [options.eventBusKey]\n *         By default, adds a `eventBusEl_` DOM element to the target object,\n *         which is used as an event bus. If the target object already has a\n *         DOM element that should be used, pass its key here.\n *\n * @return {Object}\n *         The target object.\n */function evented(target){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var eventBusKey=options.eventBusKey;// Set or create the eventBusEl_.\nif(eventBusKey){if(!target[eventBusKey].nodeName){throw new Error('The eventBusKey \"'+eventBusKey+'\" does not refer to an element.');}target.eventBusEl_=target[eventBusKey];}else{target.eventBusEl_=createEl('span',{className:'vjs-event-bus'});}assign(target,EventedMixin);// When any evented object is disposed, it removes all its listeners.\ntarget.on('dispose',function(){target.off();window.setTimeout(function(){target.eventBusEl_=null;},0);});return target;}/**\n * @file mixins/stateful.js\n * @module stateful\n *//**\n * Contains methods that provide statefulness to an object which is passed\n * to {@link module:stateful}.\n *\n * @mixin StatefulMixin\n */var StatefulMixin={/**\n   * A hash containing arbitrary keys and values representing the state of\n   * the object.\n   *\n   * @type {Object}\n   */state:{},/**\n   * Set the state of an object by mutating its\n   * {@link module:stateful~StatefulMixin.state|state} object in place.\n   *\n   * @fires   module:stateful~StatefulMixin#statechanged\n   * @param   {Object|Function} stateUpdates\n   *          A new set of properties to shallow-merge into the plugin state.\n   *          Can be a plain object or a function returning a plain object.\n   *\n   * @returns {Object|undefined}\n   *          An object containing changes that occurred. If no changes\n   *          occurred, returns `undefined`.\n   */setState:function setState(stateUpdates){var _this=this;// Support providing the `stateUpdates` state as a function.\nif(typeof stateUpdates==='function'){stateUpdates=stateUpdates();}var changes=void 0;each(stateUpdates,function(value,key){// Record the change if the value is different from what's in the\n// current state.\nif(_this.state[key]!==value){changes=changes||{};changes[key]={from:_this.state[key],to:value};}_this.state[key]=value;});// Only trigger \"statechange\" if there were changes AND we have a trigger\n// function. This allows us to not require that the target object be an\n// evented object.\nif(changes&&isEvented(this)){/**\n       * An event triggered on an object that is both\n       * {@link module:stateful|stateful} and {@link module:evented|evented}\n       * indicating that its state has changed.\n       *\n       * @event    module:stateful~StatefulMixin#statechanged\n       * @type     {Object}\n       * @property {Object} changes\n       *           A hash containing the properties that were changed and\n       *           the values they were changed `from` and `to`.\n       */this.trigger({changes:changes,type:'statechanged'});}return changes;}};/**\n * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n * object.\n *\n * If the target object is {@link module:evented|evented} and has a\n * `handleStateChanged` method, that method will be automatically bound to the\n * `statechanged` event on itself.\n *\n * @param   {Object} target\n *          The object to be made stateful.\n *\n * @param   {Object} [defaultState]\n *          A default set of properties to populate the newly-stateful object's\n *          `state` property.\n *\n * @returns {Object}\n *          Returns the `target`.\n */function stateful(target,defaultState){assign(target,StatefulMixin);// This happens after the mixing-in because we need to replace the `state`\n// added in that step.\ntarget.state=assign({},target.state,defaultState);// Auto-bind the `handleStateChanged` method of the target object if it exists.\nif(typeof target.handleStateChanged==='function'&&isEvented(target)){target.on('statechanged',target.handleStateChanged);}return target;}/**\n * @file to-title-case.js\n * @module to-title-case\n *//**\n * Uppercase the first letter of a string.\n *\n * @param {string} string\n *        String to be uppercased\n *\n * @return {string}\n *         The string with an uppercased first letter\n */function toTitleCase(string){if(typeof string!=='string'){return string;}return string.charAt(0).toUpperCase()+string.slice(1);}/**\n * Compares the TitleCase versions of the two strings for equality.\n *\n * @param {string} str1\n *        The first string to compare\n *\n * @param {string} str2\n *        The second string to compare\n *\n * @return {boolean}\n *         Whether the TitleCase versions of the strings are equal\n */function titleCaseEquals(str1,str2){return toTitleCase(str1)===toTitleCase(str2);}/**\n * @file merge-options.js\n * @module merge-options\n *//**\n * Deep-merge one or more options objects, recursively merging **only** plain\n * object properties.\n *\n * @param   {Object[]} sources\n *          One or more objects to merge into a new object.\n *\n * @returns {Object}\n *          A new object that is the merged result of all sources.\n */function mergeOptions(){var result={};for(var _len=arguments.length,sources=Array(_len),_key=0;_key<_len;_key++){sources[_key]=arguments[_key];}sources.forEach(function(source){if(!source){return;}each(source,function(value,key){if(!isPlain(value)){result[key]=value;return;}if(!isPlain(result[key])){result[key]={};}result[key]=mergeOptions(result[key],value);});});return result;}/**\n * Player Component - Base class for all UI objects\n *\n * @file component.js\n *//**\n * Base class for all UI Components.\n * Components are UI objects which represent both a javascript object and an element\n * in the DOM. They can be children of other components, and can have\n * children themselves.\n *\n * Components can also use methods from {@link EventTarget}\n */var Component=function(){/**\n   * A callback that is called when a component is ready. Does not have any\n   * paramters and any callback value will be ignored.\n   *\n   * @callback Component~ReadyCallback\n   * @this Component\n   *//**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Object[]} [options.children]\n   *        An array of children objects to intialize this component with. Children objects have\n   *        a name property that will be used if more than one component of the same type needs to be\n   *        added.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Function that gets called when the `Component` is ready.\n   */function Component(player,options,ready){classCallCheck(this,Component);// The component might be the player itself and we can't pass `this` to super\nif(!player&&this.play){this.player_=player=this;// eslint-disable-line\n}else{this.player_=player;}// Make a copy of prototype.options_ to protect against overriding defaults\nthis.options_=mergeOptions({},this.options_);// Updated options with supplied options\noptions=this.options_=mergeOptions(this.options_,options);// Get ID from options or options element if one is supplied\nthis.id_=options.id||options.el&&options.el.id;// If there was no ID from the options, generate one\nif(!this.id_){// Don't require the player ID function in the case of mock players\nvar id=player&&player.id&&player.id()||'no_player';this.id_=id+'_component_'+newGUID();}this.name_=options.name||null;// Create element if one wasn't provided in options\nif(options.el){this.el_=options.el;}else if(options.createEl!==false){this.el_=this.createEl();}// if evented is anything except false, we want to mixin in evented\nif(options.evented!==false){// Make this an evented object and use `el_`, if available, as its event bus\nevented(this,{eventBusKey:this.el_?'el_':null});}stateful(this,this.constructor.defaultState);this.children_=[];this.childIndex_={};this.childNameIndex_={};// Add any child components in options\nif(options.initChildren!==false){this.initChildren();}this.ready(ready);// Don't want to trigger ready here or it will before init is actually\n// finished for all children that run this constructor\nif(options.reportTouchActivity!==false){this.enableTouchActivity();}}/**\n   * Dispose of the `Component` and all child components.\n   *\n   * @fires Component#dispose\n   */Component.prototype.dispose=function dispose(){/**\n     * Triggered when a `Component` is disposed.\n     *\n     * @event Component#dispose\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up\n     */this.trigger({type:'dispose',bubbles:false});// Dispose all children.\nif(this.children_){for(var i=this.children_.length-1;i>=0;i--){if(this.children_[i].dispose){this.children_[i].dispose();}}}// Delete child references\nthis.children_=null;this.childIndex_=null;this.childNameIndex_=null;if(this.el_){// Remove element from DOM\nif(this.el_.parentNode){this.el_.parentNode.removeChild(this.el_);}removeData(this.el_);this.el_=null;}// remove reference to the player after disposing of the element\nthis.player_=null;};/**\n   * Return the {@link Player} that the `Component` has attached to.\n   *\n   * @return {Player}\n   *         The player that this `Component` has attached to.\n   */Component.prototype.player=function player(){return this.player_;};/**\n   * Deep merge of options objects with new options.\n   * > Note: When both `obj` and `options` contain properties whose values are objects.\n   *         The two properties get merged using {@link module:mergeOptions}\n   *\n   * @param {Object} obj\n   *        The object that contains new options.\n   *\n   * @return {Object}\n   *         A new object of `this.options_` and `obj` merged together.\n   *\n   * @deprecated since version 5\n   */Component.prototype.options=function options(obj){log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');if(!obj){return this.options_;}this.options_=mergeOptions(this.options_,obj);return this.options_;};/**\n   * Get the `Component`s DOM element\n   *\n   * @return {Element}\n   *         The DOM element for this `Component`.\n   */Component.prototype.el=function el(){return this.el_;};/**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tagName]\n   *        Element's DOM node type. e.g. 'div'\n   *\n   * @param {Object} [properties]\n   *        An object of properties that should be set.\n   *\n   * @param {Object} [attributes]\n   *        An object of attributes that should be set.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Component.prototype.createEl=function createEl$$1(tagName,properties,attributes){return createEl(tagName,properties,attributes);};/**\n   * Localize a string given the string in english.\n   *\n   * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.\n   *\n   * If a `defaultValue` is provided, it'll use that over `string`,\n   * if a value isn't found in provided language files.\n   * This is useful if you want to have a descriptive key for token replacement\n   * but have a succinct localized string and not require `en.json` to be included.\n   *\n   * Currently, it is used for the progress bar timing.\n   * ```js\n   * {\n   *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n   * }\n   * ```\n   * It is then used like so:\n   * ```js\n   * this.localize('progress bar timing: currentTime={1} duration{2}',\n   *               [this.player_.currentTime(), this.player_.duration()],\n   *               '{1} of {2}');\n   * ```\n   *\n   * Which outputs something like: `01:23 of 24:56`.\n   *\n   *\n   * @param {string} string\n   *        The string to localize and the key to lookup in the language files.\n   * @param {string[]} [tokens]\n   *        If the current item has token replacements, provide the tokens here.\n   * @param {string} [defaultValue]\n   *        Defaults to `string`. Can be a default value to use for token replacement\n   *        if the lookup key is needed to be separate.\n   *\n   * @return {string}\n   *         The localized string or if no localization exists the english string.\n   */Component.prototype.localize=function localize(string,tokens){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:string;var code=this.player_.language&&this.player_.language();var languages=this.player_.languages&&this.player_.languages();var language=languages&&languages[code];var primaryCode=code&&code.split('-')[0];var primaryLang=languages&&languages[primaryCode];var localizedString=defaultValue;if(language&&language[string]){localizedString=language[string];}else if(primaryLang&&primaryLang[string]){localizedString=primaryLang[string];}if(tokens){localizedString=localizedString.replace(/\\{(\\d+)\\}/g,function(match,index){var value=tokens[index-1];var ret=value;if(typeof value==='undefined'){ret=match;}return ret;});}return localizedString;};/**\n   * Return the `Component`s DOM element. This is where children get inserted.\n   * This will usually be the the same as the element returned in {@link Component#el}.\n   *\n   * @return {Element}\n   *         The content element for this `Component`.\n   */Component.prototype.contentEl=function contentEl(){return this.contentEl_||this.el_;};/**\n   * Get this `Component`s ID\n   *\n   * @return {string}\n   *         The id of this `Component`\n   */Component.prototype.id=function id(){return this.id_;};/**\n   * Get the `Component`s name. The name gets used to reference the `Component`\n   * and is set during registration.\n   *\n   * @return {string}\n   *         The name of this `Component`.\n   */Component.prototype.name=function name(){return this.name_;};/**\n   * Get an array of all child components\n   *\n   * @return {Array}\n   *         The children\n   */Component.prototype.children=function children(){return this.children_;};/**\n   * Returns the child `Component` with the given `id`.\n   *\n   * @param {string} id\n   *        The id of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `id` or undefined.\n   */Component.prototype.getChildById=function getChildById(id){return this.childIndex_[id];};/**\n   * Returns the child `Component` with the given `name`.\n   *\n   * @param {string} name\n   *        The name of the child `Component` to get.\n   *\n   * @return {Component|undefined}\n   *         The child `Component` with the given `name` or undefined.\n   */Component.prototype.getChild=function getChild(name){if(!name){return;}name=toTitleCase(name);return this.childNameIndex_[name];};/**\n   * Add a child `Component` inside the current `Component`.\n   *\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @param {number} [index=this.children_.length]\n   *        The index to attempt to add a child into.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   */Component.prototype.addChild=function addChild(child){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var index=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.children_.length;var component=void 0;var componentName=void 0;// If child is a string, create component with options\nif(typeof child==='string'){componentName=toTitleCase(child);var componentClassName=options.componentClass||componentName;// Set name through options\noptions.name=componentName;// Create a new object & element for this controls set\n// If there's no .player_, this is a player\nvar ComponentClass=Component.getComponent(componentClassName);if(!ComponentClass){throw new Error('Component '+componentClassName+' does not exist');}// data stored directly on the videojs object may be\n// misidentified as a component to retain\n// backwards-compatibility with 4.x. check to make sure the\n// component class can be instantiated.\nif(typeof ComponentClass!=='function'){return null;}component=new ComponentClass(this.player_||this,options);// child is a component instance\n}else{component=child;}this.children_.splice(index,0,component);if(typeof component.id==='function'){this.childIndex_[component.id()]=component;}// If a name wasn't used to create the component, check if we can use the\n// name function of the component\ncomponentName=componentName||component.name&&toTitleCase(component.name());if(componentName){this.childNameIndex_[componentName]=component;}// Add the UI object's element to the container div (box)\n// Having an element is not required\nif(typeof component.el==='function'&&component.el()){var childNodes=this.contentEl().children;var refNode=childNodes[index]||null;this.contentEl().insertBefore(component.el(),refNode);}// Return so it can stored on parent object if desired.\nreturn component;};/**\n   * Remove a child `Component` from this `Component`s list of children. Also removes\n   * the child `Component`s element from this `Component`s element.\n   *\n   * @param {Component} component\n   *        The child `Component` to remove.\n   */Component.prototype.removeChild=function removeChild(component){if(typeof component==='string'){component=this.getChild(component);}if(!component||!this.children_){return;}var childFound=false;for(var i=this.children_.length-1;i>=0;i--){if(this.children_[i]===component){childFound=true;this.children_.splice(i,1);break;}}if(!childFound){return;}this.childIndex_[component.id()]=null;this.childNameIndex_[component.name()]=null;var compEl=component.el();if(compEl&&compEl.parentNode===this.contentEl()){this.contentEl().removeChild(component.el());}};/**\n   * Add and initialize default child `Component`s based upon options.\n   */Component.prototype.initChildren=function initChildren(){var _this=this;var children=this.options_.children;if(children){// `this` is `parent`\nvar parentOptions=this.options_;var handleAdd=function handleAdd(child){var name=child.name;var opts=child.opts;// Allow options for children to be set at the parent options\n// e.g. videojs(id, { controlBar: false });\n// instead of videojs(id, { children: { controlBar: false });\nif(parentOptions[name]!==undefined){opts=parentOptions[name];}// Allow for disabling default components\n// e.g. options['children']['posterImage'] = false\nif(opts===false){return;}// Allow options to be passed as a simple boolean if no configuration\n// is necessary.\nif(opts===true){opts={};}// We also want to pass the original player options\n// to each component as well so they don't need to\n// reach back into the player for options later.\nopts.playerOptions=_this.options_.playerOptions;// Create and add the child component.\n// Add a direct reference to the child by name on the parent instance.\n// If two of the same component are used, different names should be supplied\n// for each\nvar newChild=_this.addChild(name,opts);if(newChild){_this[name]=newChild;}};// Allow for an array of children details to passed in the options\nvar workingChildren=void 0;var Tech=Component.getComponent('Tech');if(Array.isArray(children)){workingChildren=children;}else{workingChildren=Object.keys(children);}workingChildren// children that are in this.options_ but also in workingChildren  would\n// give us extra children we do not want. So, we want to filter them out.\n.concat(Object.keys(this.options_).filter(function(child){return!workingChildren.some(function(wchild){if(typeof wchild==='string'){return child===wchild;}return child===wchild.name;});})).map(function(child){var name=void 0;var opts=void 0;if(typeof child==='string'){name=child;opts=children[name]||_this.options_[name]||{};}else{name=child.name;opts=child;}return{name:name,opts:opts};}).filter(function(child){// we have to make sure that child.name isn't in the techOrder since\n// techs are registerd as Components but can't aren't compatible\n// See https://github.com/videojs/video.js/issues/2772\nvar c=Component.getComponent(child.opts.componentClass||toTitleCase(child.name));return c&&!Tech.isTech(c);}).forEach(handleAdd);}};/**\n   * Builds the default DOM class name. Should be overriden by sub-components.\n   *\n   * @return {string}\n   *         The DOM class name for this object.\n   *\n   * @abstract\n   */Component.prototype.buildCSSClass=function buildCSSClass(){// Child classes can include a function that does:\n// return 'CLASS NAME' + this._super();\nreturn'';};/**\n   * Bind a listener to the component's ready state.\n   * Different from event listeners in that if the ready event has already happened\n   * it will trigger the function immediately.\n   *\n   * @return {Component}\n   *         Returns itself; method can be chained.\n   */Component.prototype.ready=function ready(fn){var sync=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!fn){return;}if(!this.isReady_){this.readyQueue_=this.readyQueue_||[];this.readyQueue_.push(fn);return;}if(sync){fn.call(this);}else{// Call the function asynchronously by default for consistency\nthis.setTimeout(fn,1);}};/**\n   * Trigger all the ready listeners for this `Component`.\n   *\n   * @fires Component#ready\n   */Component.prototype.triggerReady=function triggerReady(){this.isReady_=true;// Ensure ready is triggerd asynchronously\nthis.setTimeout(function(){var readyQueue=this.readyQueue_;// Reset Ready Queue\nthis.readyQueue_=[];if(readyQueue&&readyQueue.length>0){readyQueue.forEach(function(fn){fn.call(this);},this);}// Allow for using event listeners also\n/**\n       * Triggered when a `Component` is ready.\n       *\n       * @event Component#ready\n       * @type {EventTarget~Event}\n       */this.trigger('ready');},1);};/**\n   * Find a single DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelector`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {Element|null}\n   *         the dom element that was found, or null\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */Component.prototype.$=function $$$1(selector,context){return $(selector,context||this.contentEl());};/**\n   * Finds all DOM element matching a `selector`. This can be within the `Component`s\n   * `contentEl()` or another custom context.\n   *\n   * @param {string} selector\n   *        A valid CSS selector, which will be passed to `querySelectorAll`.\n   *\n   * @param {Element|string} [context=this.contentEl()]\n   *        A DOM element within which to query. Can also be a selector string in\n   *        which case the first matching element will get used as context. If\n   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n   *        nothing it falls back to `document`.\n   *\n   * @return {NodeList}\n   *         a list of dom elements that were found\n   *\n   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n   */Component.prototype.$$=function $$$$1(selector,context){return $$(selector,context||this.contentEl());};/**\n   * Check if a component's element has a CSS class name.\n   *\n   * @param {string} classToCheck\n   *        CSS class name to check.\n   *\n   * @return {boolean}\n   *         - True if the `Component` has the class.\n   *         - False if the `Component` does not have the class`\n   */Component.prototype.hasClass=function hasClass$$1(classToCheck){return hasClass(this.el_,classToCheck);};/**\n   * Add a CSS class name to the `Component`s element.\n   *\n   * @param {string} classToAdd\n   *        CSS class name to add\n   */Component.prototype.addClass=function addClass$$1(classToAdd){addClass(this.el_,classToAdd);};/**\n   * Remove a CSS class name from the `Component`s element.\n   *\n   * @param {string} classToRemove\n   *        CSS class name to remove\n   */Component.prototype.removeClass=function removeClass$$1(classToRemove){removeClass(this.el_,classToRemove);};/**\n   * Add or remove a CSS class name from the component's element.\n   * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n   *\n   * @param  {string} classToToggle\n   *         The class to add or remove based on (@link Component#hasClass}\n   *\n   * @param  {boolean|Dom~predicate} [predicate]\n   *         An {@link Dom~predicate} function or a boolean\n   */Component.prototype.toggleClass=function toggleClass$$1(classToToggle,predicate){toggleClass(this.el_,classToToggle,predicate);};/**\n   * Show the `Component`s element if it is hidden by removing the\n   * 'vjs-hidden' class name from it.\n   */Component.prototype.show=function show(){this.removeClass('vjs-hidden');};/**\n   * Hide the `Component`s element if it is currently showing by adding the\n   * 'vjs-hidden` class name to it.\n   */Component.prototype.hide=function hide(){this.addClass('vjs-hidden');};/**\n   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n   * class name to it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */Component.prototype.lockShowing=function lockShowing(){this.addClass('vjs-lock-showing');};/**\n   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n   * class name from it. Used during fadeIn/fadeOut.\n   *\n   * @private\n   */Component.prototype.unlockShowing=function unlockShowing(){this.removeClass('vjs-lock-showing');};/**\n   * Get the value of an attribute on the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to get the value from.\n   *\n   * @return {string|null}\n   *         - The value of the attribute that was asked for.\n   *         - Can be an empty string on some browsers if the attribute does not exist\n   *           or has no value\n   *         - Most browsers will return null if the attibute does not exist or has\n   *           no value.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n   */Component.prototype.getAttribute=function getAttribute$$1(attribute){return getAttribute(this.el_,attribute);};/**\n   * Set the value of an attribute on the `Component`'s element\n   *\n   * @param {string} attribute\n   *        Name of the attribute to set.\n   *\n   * @param {string} value\n   *        Value to set the attribute to.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n   */Component.prototype.setAttribute=function setAttribute$$1(attribute,value){setAttribute(this.el_,attribute,value);};/**\n   * Remove an attribute from the `Component`s element.\n   *\n   * @param {string} attribute\n   *        Name of the attribute to remove.\n   *\n   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n   */Component.prototype.removeAttribute=function removeAttribute$$1(attribute){removeAttribute(this.el_,attribute);};/**\n   * Get or set the width of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The width that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *           postpixed with '%' or 'px'.\n   */Component.prototype.width=function width(num,skipListeners){return this.dimension('width',num,skipListeners);};/**\n   * Get or set the height of the component based upon the CSS styles.\n   * See {@link Component#dimension} for more detailed information.\n   *\n   * @param {number|string} [num]\n   *        The height that you want to set postfixed with '%', 'px' or nothing.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the componentresize event trigger\n   *\n   * @return {number|string}\n   *         The width when getting, zero if there is no width. Can be a string\n   *         postpixed with '%' or 'px'.\n   */Component.prototype.height=function height(num,skipListeners){return this.dimension('height',num,skipListeners);};/**\n   * Set both the width and height of the `Component` element at the same time.\n   *\n   * @param  {number|string} width\n   *         Width to set the `Component`s element to.\n   *\n   * @param  {number|string} height\n   *         Height to set the `Component`s element to.\n   */Component.prototype.dimensions=function dimensions(width,height){// Skip componentresize listeners on width for optimization\nthis.width(width,true);this.height(height);};/**\n   * Get or set width or height of the `Component` element. This is the shared code\n   * for the {@link Component#width} and {@link Component#height}.\n   *\n   * Things to know:\n   * - If the width or height in an number this will return the number postfixed with 'px'.\n   * - If the width/height is a percent this will return the percent postfixed with '%'\n   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n   *   for more information\n   * - If you want the computed style of the component, use {@link Component#currentWidth}\n   *   and {@link {Component#currentHeight}\n   *\n   * @fires Component#componentresize\n   *\n   * @param {string} widthOrHeight\n   8        'width' or 'height'\n   *\n   * @param  {number|string} [num]\n   8         New dimension\n   *\n   * @param  {boolean} [skipListeners]\n   *         Skip componentresize event trigger\n   *\n   * @return {number}\n   *         The dimension when getting or 0 if unset\n   */Component.prototype.dimension=function dimension(widthOrHeight,num,skipListeners){if(num!==undefined){// Set to zero if null or literally NaN (NaN !== NaN)\nif(num===null||num!==num){num=0;}// Check if using css width/height (% or px) and adjust\nif((''+num).indexOf('%')!==-1||(''+num).indexOf('px')!==-1){this.el_.style[widthOrHeight]=num;}else if(num==='auto'){this.el_.style[widthOrHeight]='';}else{this.el_.style[widthOrHeight]=num+'px';}// skipListeners allows us to avoid triggering the resize event when setting both width and height\nif(!skipListeners){/**\n         * Triggered when a component is resized.\n         *\n         * @event Component#componentresize\n         * @type {EventTarget~Event}\n         */this.trigger('componentresize');}return;}// Not setting a value, so getting it\n// Make sure element exists\nif(!this.el_){return 0;}// Get dimension value from style\nvar val=this.el_.style[widthOrHeight];var pxIndex=val.indexOf('px');if(pxIndex!==-1){// Return the pixel value with no 'px'\nreturn parseInt(val.slice(0,pxIndex),10);}// No px so using % or no style was set, so falling back to offsetWidth/height\n// If component has display:none, offset will return 0\n// TODO: handle display:none and no dimension style using px\nreturn parseInt(this.el_['offset'+toTitleCase(widthOrHeight)],10);};/**\n   * Get the width or the height of the `Component` elements computed style. Uses\n   * `window.getComputedStyle`.\n   *\n   * @param {string} widthOrHeight\n   *        A string containing 'width' or 'height'. Whichever one you want to get.\n   *\n   * @return {number}\n   *         The dimension that gets asked for or 0 if nothing was set\n   *         for that dimension.\n   */Component.prototype.currentDimension=function currentDimension(widthOrHeight){var computedWidthOrHeight=0;if(widthOrHeight!=='width'&&widthOrHeight!=='height'){throw new Error('currentDimension only accepts width or height value');}if(typeof window.getComputedStyle==='function'){var computedStyle=window.getComputedStyle(this.el_);computedWidthOrHeight=computedStyle.getPropertyValue(widthOrHeight)||computedStyle[widthOrHeight];}// remove 'px' from variable and parse as integer\ncomputedWidthOrHeight=parseFloat(computedWidthOrHeight);// if the computed value is still 0, it's possible that the browser is lying\n// and we want to check the offset values.\n// This code also runs on IE8 and wherever getComputedStyle doesn't exist.\nif(computedWidthOrHeight===0){var rule='offset'+toTitleCase(widthOrHeight);computedWidthOrHeight=this.el_[rule];}return computedWidthOrHeight;};/**\n   * An object that contains width and height values of the `Component`s\n   * computed style. Uses `window.getComputedStyle`.\n   *\n   * @typedef {Object} Component~DimensionObject\n   *\n   * @property {number} width\n   *           The width of the `Component`s computed style.\n   *\n   * @property {number} height\n   *           The height of the `Component`s computed style.\n   *//**\n   * Get an object that contains width and height values of the `Component`s\n   * computed style.\n   *\n   * @return {Component~DimensionObject}\n   *         The dimensions of the components element\n   */Component.prototype.currentDimensions=function currentDimensions(){return{width:this.currentDimension('width'),height:this.currentDimension('height')};};/**\n   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} width\n   *           The width of the `Component`s computed style.\n   */Component.prototype.currentWidth=function currentWidth(){return this.currentDimension('width');};/**\n   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.\n   *\n   * @return {number} height\n   *           The height of the `Component`s computed style.\n   */Component.prototype.currentHeight=function currentHeight(){return this.currentDimension('height');};/**\n   * Set the focus to this component\n   */Component.prototype.focus=function focus(){this.el_.focus();};/**\n   * Remove the focus from this component\n   */Component.prototype.blur=function blur(){this.el_.blur();};/**\n   * Emit a 'tap' events when touch event support gets detected. This gets used to\n   * support toggling the controls through a tap on the video. They get enabled\n   * because every sub-component would have extra overhead otherwise.\n   *\n   * @private\n   * @fires Component#tap\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchleave\n   * @listens Component#touchcancel\n   * @listens Component#touchend\n    */Component.prototype.emitTapEvents=function emitTapEvents(){// Track the start time so we can determine how long the touch lasted\nvar touchStart=0;var firstTouch=null;// Maximum movement allowed during a touch event to still be considered a tap\n// Other popular libs use anywhere from 2 (hammer.js) to 15,\n// so 10 seems like a nice, round number.\nvar tapMovementThreshold=10;// The maximum length a touch can be while still being considered a tap\nvar touchTimeThreshold=200;var couldBeTap=void 0;this.on('touchstart',function(event){// If more than one finger, don't consider treating this as a click\nif(event.touches.length===1){// Copy pageX/pageY from the object\nfirstTouch={pageX:event.touches[0].pageX,pageY:event.touches[0].pageY};// Record start time so we can detect a tap vs. \"touch and hold\"\ntouchStart=new Date().getTime();// Reset couldBeTap tracking\ncouldBeTap=true;}});this.on('touchmove',function(event){// If more than one finger, don't consider treating this as a click\nif(event.touches.length>1){couldBeTap=false;}else if(firstTouch){// Some devices will throw touchmoves for all but the slightest of taps.\n// So, if we moved only a small distance, this could still be a tap\nvar xdiff=event.touches[0].pageX-firstTouch.pageX;var ydiff=event.touches[0].pageY-firstTouch.pageY;var touchDistance=Math.sqrt(xdiff*xdiff+ydiff*ydiff);if(touchDistance>tapMovementThreshold){couldBeTap=false;}}});var noTap=function noTap(){couldBeTap=false;};// TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\nthis.on('touchleave',noTap);this.on('touchcancel',noTap);// When the touch ends, measure how long it took and trigger the appropriate\n// event\nthis.on('touchend',function(event){firstTouch=null;// Proceed only if the touchmove/leave/cancel event didn't happen\nif(couldBeTap===true){// Measure how long the touch lasted\nvar touchTime=new Date().getTime()-touchStart;// Make sure the touch was less than the threshold to be considered a tap\nif(touchTime<touchTimeThreshold){// Don't let browser turn this into a click\nevent.preventDefault();/**\n           * Triggered when a `Component` is tapped.\n           *\n           * @event Component#tap\n           * @type {EventTarget~Event}\n           */this.trigger('tap');// It may be good to copy the touchend event object and change the\n// type to tap, if the other event properties aren't exact after\n// Events.fixEvent runs (e.g. event.target)\n}}});};/**\n   * This function reports user activity whenever touch events happen. This can get\n   * turned off by any sub-components that wants touch events to act another way.\n   *\n   * Report user touch activity when touch events occur. User activity gets used to\n   * determine when controls should show/hide. It is simple when it comes to mouse\n   * events, because any mouse event should show the controls. So we capture mouse\n   * events that bubble up to the player and report activity when that happens.\n   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n   * controls. So touch events can't help us at the player level either.\n   *\n   * User activity gets checked asynchronously. So what could happen is a tap event\n   * on the video turns the controls off. Then the `touchend` event bubbles up to\n   * the player. Which, if it reported user activity, would turn the controls right\n   * back on. We also don't want to completely block touch events from bubbling up.\n   * Furthermore a `touchmove` event and anything other than a tap, should not turn\n   * controls back on.\n   *\n   * @listens Component#touchstart\n   * @listens Component#touchmove\n   * @listens Component#touchend\n   * @listens Component#touchcancel\n   */Component.prototype.enableTouchActivity=function enableTouchActivity(){// Don't continue if the root player doesn't support reporting user activity\nif(!this.player()||!this.player().reportUserActivity){return;}// listener for reporting that the user is active\nvar report=bind(this.player(),this.player().reportUserActivity);var touchHolding=void 0;this.on('touchstart',function(){report();// For as long as the they are touching the device or have their mouse down,\n// we consider them active even if they're not moving their finger or mouse.\n// So we want to continue to update that they are active\nthis.clearInterval(touchHolding);// report at the same interval as activityCheck\ntouchHolding=this.setInterval(report,250);});var touchEnd=function touchEnd(event){report();// stop the interval that maintains activity if the touch is holding\nthis.clearInterval(touchHolding);};this.on('touchmove',report);this.on('touchend',touchEnd);this.on('touchcancel',touchEnd);};/**\n   * A callback that has no parameters and is bound into `Component`s context.\n   *\n   * @callback Component~GenericCallback\n   * @this Component\n   *//**\n   * Creates a function that runs after an `x` millisecond timeout. This function is a\n   * wrapper around `window.setTimeout`. There are a few reasons to use this one\n   * instead though:\n   * 1. It gets cleared via  {@link Component#clearTimeout} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n   *\n   * > Note: You can use `window.clearTimeout` on the id returned by this function. This\n   *         will cause its dispose listener not to get cleaned up! Please use\n   *         {@link Component#clearTimeout} or {@link Component#dispose}.\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function that will be run after `timeout`.\n   *\n   * @param {number} timeout\n   *        Timeout in milliseconds to delay before executing the specified function.\n   *\n   * @return {number}\n   *         Returns a timeout ID that gets used to identify the timeout. It can also\n   *         get used in {@link Component#clearTimeout} to clear the timeout that\n   *         was set.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n   */Component.prototype.setTimeout=function setTimeout(fn,timeout){var _this2=this;fn=bind(this,fn);var timeoutId=window.setTimeout(fn,timeout);var disposeFn=function disposeFn(){return _this2.clearTimeout(timeoutId);};disposeFn.guid='vjs-timeout-'+timeoutId;this.on('dispose',disposeFn);return timeoutId;};/**\n   * Clears a timeout that gets created via `window.setTimeout` or\n   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n   * use this function instead of `window.clearTimout`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} timeoutId\n   *        The id of the timeout to clear. The return value of\n   *        {@link Component#setTimeout} or `window.setTimeout`.\n   *\n   * @return {number}\n   *         Returns the timeout id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n   */Component.prototype.clearTimeout=function clearTimeout(timeoutId){window.clearTimeout(timeoutId);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-timeout-'+timeoutId;this.off('dispose',disposeFn);return timeoutId;};/**\n   * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n   * around `window.setInterval`. There are a few reasons to use this one instead though.\n   * 1. It gets cleared via  {@link Component#clearInterval} when\n   *    {@link Component#dispose} gets called.\n   * 2. The function callback will be a {@link Component~GenericCallback}\n   *\n   * @param {Component~GenericCallback} fn\n   *        The function to run every `x` seconds.\n   *\n   * @param {number} interval\n   *        Execute the specified function every `x` milliseconds.\n   *\n   * @return {number}\n   *         Returns an id that can be used to identify the interval. It can also be be used in\n   *         {@link Component#clearInterval} to clear the interval.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n   */Component.prototype.setInterval=function setInterval(fn,interval){var _this3=this;fn=bind(this,fn);var intervalId=window.setInterval(fn,interval);var disposeFn=function disposeFn(){return _this3.clearInterval(intervalId);};disposeFn.guid='vjs-interval-'+intervalId;this.on('dispose',disposeFn);return intervalId;};/**\n   * Clears an interval that gets created via `window.setInterval` or\n   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}\n   * use this function instead of `window.clearInterval`. If you don't your dispose\n   * listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} intervalId\n   *        The id of the interval to clear. The return value of\n   *        {@link Component#setInterval} or `window.setInterval`.\n   *\n   * @return {number}\n   *         Returns the interval id that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n   */Component.prototype.clearInterval=function clearInterval(intervalId){window.clearInterval(intervalId);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-interval-'+intervalId;this.off('dispose',disposeFn);return intervalId;};/**\n   * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n   * with a few extra bonuses:\n   *\n   * - Supports browsers that do not support rAF by falling back to\n   *   {@link Component#setTimeout}.\n   *\n   * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n   *   bound to the component).\n   *\n   * - Automatic cancellation of the rAF callback is handled if the component\n   *   is disposed before it is called.\n   *\n   * @param  {Component~GenericCallback} fn\n   *         A function that will be bound to this component and executed just\n   *         before the browser's next repaint.\n   *\n   * @return {number}\n   *         Returns an rAF ID that gets used to identify the timeout. It can\n   *         also be used in {@link Component#cancelAnimationFrame} to cancel\n   *         the animation frame callback.\n   *\n   * @listens Component#dispose\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n   */Component.prototype.requestAnimationFrame=function requestAnimationFrame(fn){var _this4=this;if(this.supportsRaf_){fn=bind(this,fn);var id=window.requestAnimationFrame(fn);var disposeFn=function disposeFn(){return _this4.cancelAnimationFrame(id);};disposeFn.guid='vjs-raf-'+id;this.on('dispose',disposeFn);return id;}// Fall back to using a timer.\nreturn this.setTimeout(fn,1000/60);};/**\n   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n   * (rAF).\n   *\n   * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n   * use this function instead of `window.cancelAnimationFrame`. If you don't,\n   * your dispose listener will not get cleaned up until {@link Component#dispose}!\n   *\n   * @param {number} id\n   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n   *\n   * @return {number}\n   *         Returns the rAF ID that was cleared.\n   *\n   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n   */Component.prototype.cancelAnimationFrame=function cancelAnimationFrame(id){if(this.supportsRaf_){window.cancelAnimationFrame(id);var disposeFn=function disposeFn(){};disposeFn.guid='vjs-raf-'+id;this.off('dispose',disposeFn);return id;}// Fall back to using a timer.\nreturn this.clearTimeout(id);};/**\n   * Register a `Component` with `videojs` given the name and the component.\n   *\n   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n   *         should be registered using {@link Tech.registerTech} or\n   *         {@link videojs:videojs.registerTech}.\n   *\n   * > NOTE: This function can also be seen on videojs as\n   *         {@link videojs:videojs.registerComponent}.\n   *\n   * @param {string} name\n   *        The name of the `Component` to register.\n   *\n   * @param {Component} ComponentToRegister\n   *        The `Component` class to register.\n   *\n   * @return {Component}\n   *         The `Component` that was registered.\n   */Component.registerComponent=function registerComponent(name,ComponentToRegister){if(typeof name!=='string'||!name){throw new Error('Illegal component name, \"'+name+'\"; must be a non-empty string.');}var Tech=Component.getComponent('Tech');// We need to make sure this check is only done if Tech has been registered.\nvar isTech=Tech&&Tech.isTech(ComponentToRegister);var isComp=Component===ComponentToRegister||Component.prototype.isPrototypeOf(ComponentToRegister.prototype);if(isTech||!isComp){var reason=void 0;if(isTech){reason='techs must be registered using Tech.registerTech()';}else{reason='must be a Component subclass';}throw new Error('Illegal component, \"'+name+'\"; '+reason+'.');}name=toTitleCase(name);if(!Component.components_){Component.components_={};}var Player=Component.getComponent('Player');if(name==='Player'&&Player&&Player.players){var players=Player.players;var playerNames=Object.keys(players);// If we have players that were disposed, then their name will still be\n// in Players.players. So, we must loop through and verify that the value\n// for each item is not null. This allows registration of the Player component\n// after all players have been disposed or before any were created.\nif(players&&playerNames.length>0&&playerNames.map(function(pname){return players[pname];}).every(Boolean)){throw new Error('Can not register Player component after player has been created.');}}Component.components_[name]=ComponentToRegister;return ComponentToRegister;};/**\n   * Get a `Component` based on the name it was registered with.\n   *\n   * @param {string} name\n   *        The Name of the component to get.\n   *\n   * @return {Component}\n   *         The `Component` that got registered under the given name.\n   *\n   * @deprecated In `videojs` 6 this will not return `Component`s that were not\n   *             registered using {@link Component.registerComponent}. Currently we\n   *             check the global `videojs` object for a `Component` name and\n   *             return that if it exists.\n   */Component.getComponent=function getComponent(name){if(!name){return;}name=toTitleCase(name);if(Component.components_&&Component.components_[name]){return Component.components_[name];}};return Component;}();/**\n * Whether or not this component supports `requestAnimationFrame`.\n *\n * This is exposed primarily for testing purposes.\n *\n * @private\n * @type {Boolean}\n */Component.prototype.supportsRaf_=typeof window.requestAnimationFrame==='function'&&typeof window.cancelAnimationFrame==='function';Component.registerComponent('Component',Component);/**\n * @file time-ranges.js\n * @module time-ranges\n *//**\n * Returns the time for the specified index at the start or end\n * of a TimeRange object.\n *\n * @function time-ranges:indexFunction\n *\n * @param {number} [index=0]\n *        The range number to return the time for.\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n * @depricated index must be set to a value, in the future this will throw an error.\n *//**\n * An object that contains ranges of time for various reasons.\n *\n * @typedef {Object} TimeRange\n *\n * @property {number} length\n *           The number of time ranges represented by this Object\n *\n * @property {time-ranges:indexFunction} start\n *           Returns the time offset at which a specified time range begins.\n *\n * @property {time-ranges:indexFunction} end\n *           Returns the time offset at which a specified time range begins.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n *//**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {number} index\n *        The index to check\n *\n * @param {number} maxIndex\n *        The maximum possible index\n *\n * @throws {Error} if the timeRanges provided are over the maxIndex\n */function rangeCheck(fnName,index,maxIndex){if(typeof index!=='number'||index<0||index>maxIndex){throw new Error('Failed to execute \\''+fnName+'\\' on \\'TimeRanges\\': The index provided ('+index+') is non-numeric or out of bounds (0-'+maxIndex+').');}}/**\n * Check if any of the time ranges are over the maximum index.\n *\n * @param {string} fnName\n *        The function name to use for logging\n *\n * @param {string} valueIndex\n *        The proprety that should be used to get the time. should be 'start' or 'end'\n *\n * @param {Array} ranges\n *        An array of time ranges\n *\n * @param {Array} [rangeIndex=0]\n *        The index to start the search at\n *\n * @return {number}\n *         The time that offset at the specified index.\n *\n *\n * @depricated rangeIndex must be set to a value, in the future this will throw an error.\n * @throws {Error} if rangeIndex is more than the length of ranges\n */function getRange(fnName,valueIndex,ranges,rangeIndex){rangeCheck(fnName,rangeIndex,ranges.length-1);return ranges[rangeIndex][valueIndex];}/**\n * Create a time range object givent ranges of time.\n *\n * @param {Array} [ranges]\n *        An array of time ranges.\n */function createTimeRangesObj(ranges){if(ranges===undefined||ranges.length===0){return{length:0,start:function start(){throw new Error('This TimeRanges object is empty');},end:function end(){throw new Error('This TimeRanges object is empty');}};}return{length:ranges.length,start:getRange.bind(null,'start',0,ranges),end:getRange.bind(null,'end',1,ranges)};}/**\n * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.\n *\n * @param {number|Array} start\n *        The start of a single range or an array of ranges\n *\n * @param {number} end\n *        The end of a single range.\n *\n * @private\n */function createTimeRanges(start,end){if(Array.isArray(start)){return createTimeRangesObj(start);}else if(start===undefined||end===undefined){return createTimeRangesObj();}return createTimeRangesObj([[start,end]]);}/**\n * @file buffer.js\n * @module buffer\n *//**\n * Compute the percentage of the media that has been buffered.\n *\n * @param {TimeRange} buffered\n *        The current `TimeRange` object representing buffered time ranges\n *\n * @param {number} duration\n *        Total duration of the media\n *\n * @return {number}\n *         Percent buffered of the total duration in decimal form.\n */function bufferedPercent(buffered,duration){var bufferedDuration=0;var start=void 0;var end=void 0;if(!duration){return 0;}if(!buffered||!buffered.length){buffered=createTimeRanges(0,0);}for(var i=0;i<buffered.length;i++){start=buffered.start(i);end=buffered.end(i);// buffered end can be bigger than duration by a very small fraction\nif(end>duration){end=duration;}bufferedDuration+=end-start;}return bufferedDuration/duration;}/**\n * @file fullscreen-api.js\n * @module fullscreen-api\n * @private\n *//**\n * Store the browser-specific methods for the fullscreen API.\n *\n * @type {Object}\n * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n */var FullscreenApi={};// browser API methods\nvar apiMap=[['requestFullscreen','exitFullscreen','fullscreenElement','fullscreenEnabled','fullscreenchange','fullscreenerror'],// WebKit\n['webkitRequestFullscreen','webkitExitFullscreen','webkitFullscreenElement','webkitFullscreenEnabled','webkitfullscreenchange','webkitfullscreenerror'],// Old WebKit (Safari 5.1)\n['webkitRequestFullScreen','webkitCancelFullScreen','webkitCurrentFullScreenElement','webkitCancelFullScreen','webkitfullscreenchange','webkitfullscreenerror'],// Mozilla\n['mozRequestFullScreen','mozCancelFullScreen','mozFullScreenElement','mozFullScreenEnabled','mozfullscreenchange','mozfullscreenerror'],// Microsoft\n['msRequestFullscreen','msExitFullscreen','msFullscreenElement','msFullscreenEnabled','MSFullscreenChange','MSFullscreenError']];var specApi=apiMap[0];var browserApi=void 0;// determine the supported set of functions\nfor(var i=0;i<apiMap.length;i++){// check for exitFullscreen function\nif(apiMap[i][1]in document){browserApi=apiMap[i];break;}}// map the browser API names to the spec API names\nif(browserApi){for(var _i=0;_i<browserApi.length;_i++){FullscreenApi[specApi[_i]]=browserApi[_i];}}/**\n * @file media-error.js\n *//**\n * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n *\n * @param {number|string|Object|MediaError} value\n *        This can be of multiple types:\n *        - number: should be a standard error code\n *        - string: an error message (the code will be 0)\n *        - Object: arbitrary properties\n *        - `MediaError` (native): used to populate a video.js `MediaError` object\n *        - `MediaError` (video.js): will return itself if it's already a\n *          video.js `MediaError` object.\n *\n * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n *\n * @class MediaError\n */function MediaError(value){// Allow redundant calls to this constructor to avoid having `instanceof`\n// checks peppered around the code.\nif(value instanceof MediaError){return value;}if(typeof value==='number'){this.code=value;}else if(typeof value==='string'){// default code is zero, so this is a custom error\nthis.message=value;}else if(isObject(value)){// We assign the `code` property manually because native `MediaError` objects\n// do not expose it as an own/enumerable property of the object.\nif(typeof value.code==='number'){this.code=value.code;}assign(this,value);}if(!this.message){this.message=MediaError.defaultMessages[this.code]||'';}}/**\n * The error code that refers two one of the defined `MediaError` types\n *\n * @type {Number}\n */MediaError.prototype.code=0;/**\n * An optional message that to show with the error. Message is not part of the HTML5\n * video spec but allows for more informative custom errors.\n *\n * @type {String}\n */MediaError.prototype.message='';/**\n * An optional status code that can be set by plugins to allow even more detail about\n * the error. For example a plugin might provide a specific HTTP status code and an\n * error message for that code. Then when the plugin gets that error this class will\n * know how to display an error message for it. This allows a custom message to show\n * up on the `Player` error overlay.\n *\n * @type {Array}\n */MediaError.prototype.status=null;/**\n * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n * specification listed under {@link MediaError} for more information.\n *\n * @enum {array}\n * @readonly\n * @property {string} 0 - MEDIA_ERR_CUSTOM\n * @property {string} 1 - MEDIA_ERR_CUSTOM\n * @property {string} 2 - MEDIA_ERR_ABORTED\n * @property {string} 3 - MEDIA_ERR_NETWORK\n * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n */MediaError.errorTypes=['MEDIA_ERR_CUSTOM','MEDIA_ERR_ABORTED','MEDIA_ERR_NETWORK','MEDIA_ERR_DECODE','MEDIA_ERR_SRC_NOT_SUPPORTED','MEDIA_ERR_ENCRYPTED'];/**\n * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n *\n * @type {Array}\n * @constant\n */MediaError.defaultMessages={1:'You aborted the media playback',2:'A network error caused the media download to fail part-way.',3:'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',4:'The media could not be loaded, either because the server or network failed or because the format is not supported.',5:'The media is encrypted and we do not have the keys to decrypt it.'};// Add types as properties on MediaError\n// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\nfor(var errNum=0;errNum<MediaError.errorTypes.length;errNum++){MediaError[MediaError.errorTypes[errNum]]=errNum;// values should be accessible on both the class and instance\nMediaError.prototype[MediaError.errorTypes[errNum]]=errNum;}/**\n * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n *\n * @param  {Object}  value\n *         An object that may or may not be `Promise`-like.\n *\n * @return {Boolean}\n *         Whether or not the object is `Promise`-like.\n */function isPromise(value){return value!==undefined&&typeof value.then==='function';}/**\n * Silence a Promise-like object.\n *\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n *\n * @param  {Object} value\n *         An object that may or may not be `Promise`-like.\n */function silencePromise(value){if(isPromise(value)){value.then(null,function(e){});}}/**\n * @file text-track-list-converter.js Utilities for capturing text track state and\n * re-creating tracks based on a capture.\n *\n * @module text-track-list-converter\n *//**\n * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n * represents the {@link TextTrack}'s state.\n *\n * @param {TextTrack} track\n *        The text track to query.\n *\n * @return {Object}\n *         A serializable javascript representation of the TextTrack.\n * @private\n */var trackToJson_=function trackToJson_(track){var ret=['kind','label','language','id','inBandMetadataTrackDispatchType','mode','src'].reduce(function(acc,prop,i){if(track[prop]){acc[prop]=track[prop];}return acc;},{cues:track.cues&&Array.prototype.map.call(track.cues,function(cue){return{startTime:cue.startTime,endTime:cue.endTime,text:cue.text,id:cue.id};})});return ret;};/**\n * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n * state of all {@link TextTrack}s currently configured. The return array is compatible with\n * {@link text-track-list-converter:jsonToTextTracks}.\n *\n * @param {Tech} tech\n *        The tech object to query\n *\n * @return {Array}\n *         A serializable javascript representation of the {@link Tech}s\n *         {@link TextTrackList}.\n */var textTracksToJson=function textTracksToJson(tech){var trackEls=tech.$$('track');var trackObjs=Array.prototype.map.call(trackEls,function(t){return t.track;});var tracks=Array.prototype.map.call(trackEls,function(trackEl){var json=trackToJson_(trackEl.track);if(trackEl.src){json.src=trackEl.src;}return json;});return tracks.concat(Array.prototype.filter.call(tech.textTracks(),function(track){return trackObjs.indexOf(track)===-1;}).map(trackToJson_));};/**\n * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n * object {@link TextTrack} representations.\n *\n * @param {Array} json\n *        An array of `TextTrack` representation objects, like those that would be\n *        produced by `textTracksToJson`.\n *\n * @param {Tech} tech\n *        The `Tech` to create the `TextTrack`s on.\n */var jsonToTextTracks=function jsonToTextTracks(json,tech){json.forEach(function(track){var addedTrack=tech.addRemoteTextTrack(track).track;if(!track.src&&track.cues){track.cues.forEach(function(cue){return addedTrack.addCue(cue);});}});return tech.textTracks();};var textTrackConverter={textTracksToJson:textTracksToJson,jsonToTextTracks:jsonToTextTracks,trackToJson_:trackToJson_};/**\n * @file modal-dialog.js\n */var MODAL_CLASS_NAME='vjs-modal-dialog';var ESC=27;/**\n * The `ModalDialog` displays over the video and its controls, which blocks\n * interaction with the player until it is closed.\n *\n * Modal dialogs include a \"Close\" button and will close when that button\n * is activated - or when ESC is pressed anywhere.\n *\n * @extends Component\n */var ModalDialog=function(_Component){inherits(ModalDialog,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Mixed} [options.content=undefined]\n   *        Provide customized content for this modal.\n   *\n   * @param {string} [options.description]\n   *        A text description for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.fillAlways=false]\n   *        Normally, modals are automatically filled only the first time\n   *        they open. This tells the modal to refresh its content\n   *        every time it opens.\n   *\n   * @param {string} [options.label]\n   *        A text label for the modal, primarily for accessibility.\n   *\n   * @param {boolean} [options.temporary=true]\n   *        If `true`, the modal can only be opened once; it will be\n   *        disposed as soon as it's closed.\n   *\n   * @param {boolean} [options.uncloseable=false]\n   *        If `true`, the user will not be able to close the modal\n   *        through the UI in the normal ways. Programmatic closing is\n   *        still possible.\n   */function ModalDialog(player,options){classCallCheck(this,ModalDialog);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.opened_=_this.hasBeenOpened_=_this.hasBeenFilled_=false;_this.closeable(!_this.options_.uncloseable);_this.content(_this.options_.content);// Make sure the contentEl is defined AFTER any children are initialized\n// because we only want the contents of the modal in the contentEl\n// (not the UI elements like the close button).\n_this.contentEl_=createEl('div',{className:MODAL_CLASS_NAME+'-content'},{role:'document'});_this.descEl_=createEl('p',{className:MODAL_CLASS_NAME+'-description vjs-control-text',id:_this.el().getAttribute('aria-describedby')});textContent(_this.descEl_,_this.description());_this.el_.appendChild(_this.descEl_);_this.el_.appendChild(_this.contentEl_);return _this;}/**\n   * Create the `ModalDialog`'s DOM element\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */ModalDialog.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:this.buildCSSClass(),tabIndex:-1},{'aria-describedby':this.id()+'_description','aria-hidden':'true','aria-label':this.label(),'role':'dialog'});};ModalDialog.prototype.dispose=function dispose(){this.contentEl_=null;this.descEl_=null;this.previouslyActiveEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ModalDialog.prototype.buildCSSClass=function buildCSSClass(){return MODAL_CLASS_NAME+' vjs-hidden '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Handles `keydown` events on the document, looking for ESC, which closes\n   * the modal.\n   *\n   * @param {EventTarget~Event} e\n   *        The keypress that triggered this event.\n   *\n   * @listens keydown\n   */ModalDialog.prototype.handleKeyPress=function handleKeyPress(e){if(e.which===ESC&&this.closeable()){this.close();}};/**\n   * Returns the label string for this modal. Primarily used for accessibility.\n   *\n   * @return {string}\n   *         the localized or raw label of this modal.\n   */ModalDialog.prototype.label=function label(){return this.localize(this.options_.label||'Modal Window');};/**\n   * Returns the description string for this modal. Primarily used for\n   * accessibility.\n   *\n   * @return {string}\n   *         The localized or raw description of this modal.\n   */ModalDialog.prototype.description=function description(){var desc=this.options_.description||this.localize('This is a modal window.');// Append a universal closeability message if the modal is closeable.\nif(this.closeable()){desc+=' '+this.localize('This modal can be closed by pressing the Escape key or activating the close button.');}return desc;};/**\n   * Opens the modal.\n   *\n   * @fires ModalDialog#beforemodalopen\n   * @fires ModalDialog#modalopen\n   */ModalDialog.prototype.open=function open(){if(!this.opened_){var player=this.player();/**\n        * Fired just before a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#beforemodalopen\n        * @type {EventTarget~Event}\n        */this.trigger('beforemodalopen');this.opened_=true;// Fill content if the modal has never opened before and\n// never been filled.\nif(this.options_.fillAlways||!this.hasBeenOpened_&&!this.hasBeenFilled_){this.fill();}// If the player was playing, pause it and take note of its previously\n// playing state.\nthis.wasPlaying_=!player.paused();if(this.options_.pauseOnOpen&&this.wasPlaying_){player.pause();}if(this.closeable()){this.on(this.el_.ownerDocument,'keydown',bind(this,this.handleKeyPress));}// Hide controls and note if they were enabled.\nthis.hadControls_=player.controls();player.controls(false);this.show();this.conditionalFocus_();this.el().setAttribute('aria-hidden','false');/**\n        * Fired just after a `ModalDialog` is opened.\n        *\n        * @event ModalDialog#modalopen\n        * @type {EventTarget~Event}\n        */this.trigger('modalopen');this.hasBeenOpened_=true;}};/**\n   * If the `ModalDialog` is currently open or closed.\n   *\n   * @param  {boolean} [value]\n   *         If given, it will open (`true`) or close (`false`) the modal.\n   *\n   * @return {boolean}\n   *         the current open state of the modaldialog\n   */ModalDialog.prototype.opened=function opened(value){if(typeof value==='boolean'){this[value?'open':'close']();}return this.opened_;};/**\n   * Closes the modal, does nothing if the `ModalDialog` is\n   * not open.\n   *\n   * @fires ModalDialog#beforemodalclose\n   * @fires ModalDialog#modalclose\n   */ModalDialog.prototype.close=function close(){if(!this.opened_){return;}var player=this.player();/**\n      * Fired just before a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#beforemodalclose\n      * @type {EventTarget~Event}\n      */this.trigger('beforemodalclose');this.opened_=false;if(this.wasPlaying_&&this.options_.pauseOnOpen){player.play();}if(this.closeable()){this.off(this.el_.ownerDocument,'keydown',bind(this,this.handleKeyPress));}if(this.hadControls_){player.controls(true);}this.hide();this.el().setAttribute('aria-hidden','true');/**\n      * Fired just after a `ModalDialog` is closed.\n      *\n      * @event ModalDialog#modalclose\n      * @type {EventTarget~Event}\n      */this.trigger('modalclose');this.conditionalBlur_();if(this.options_.temporary){this.dispose();}};/**\n   * Check to see if the `ModalDialog` is closeable via the UI.\n   *\n   * @param  {boolean} [value]\n   *         If given as a boolean, it will set the `closeable` option.\n   *\n   * @return {boolean}\n   *         Returns the final value of the closable option.\n   */ModalDialog.prototype.closeable=function closeable(value){if(typeof value==='boolean'){var closeable=this.closeable_=!!value;var close=this.getChild('closeButton');// If this is being made closeable and has no close button, add one.\nif(closeable&&!close){// The close button should be a child of the modal - not its\n// content element, so temporarily change the content element.\nvar temp=this.contentEl_;this.contentEl_=this.el_;close=this.addChild('closeButton',{controlText:'Close Modal Dialog'});this.contentEl_=temp;this.on(close,'close',this.close);}// If this is being made uncloseable and has a close button, remove it.\nif(!closeable&&close){this.off(close,'close',this.close);this.removeChild(close);close.dispose();}}return this.closeable_;};/**\n   * Fill the modal's content element with the modal's \"content\" option.\n   * The content element will be emptied before this change takes place.\n   */ModalDialog.prototype.fill=function fill(){this.fillWith(this.content());};/**\n   * Fill the modal's content element with arbitrary content.\n   * The content element will be emptied before this change takes place.\n   *\n   * @fires ModalDialog#beforemodalfill\n   * @fires ModalDialog#modalfill\n   *\n   * @param {Mixed} [content]\n   *        The same rules apply to this as apply to the `content` option.\n   */ModalDialog.prototype.fillWith=function fillWith(content){var contentEl=this.contentEl();var parentEl=contentEl.parentNode;var nextSiblingEl=contentEl.nextSibling;/**\n     * Fired just before a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#beforemodalfill\n     * @type {EventTarget~Event}\n     */this.trigger('beforemodalfill');this.hasBeenFilled_=true;// Detach the content element from the DOM before performing\n// manipulation to avoid modifying the live DOM multiple times.\nparentEl.removeChild(contentEl);this.empty();insertContent(contentEl,content);/**\n     * Fired just after a `ModalDialog` is filled with content.\n     *\n     * @event ModalDialog#modalfill\n     * @type {EventTarget~Event}\n     */this.trigger('modalfill');// Re-inject the re-filled content element.\nif(nextSiblingEl){parentEl.insertBefore(contentEl,nextSiblingEl);}else{parentEl.appendChild(contentEl);}// make sure that the close button is last in the dialog DOM\nvar closeButton=this.getChild('closeButton');if(closeButton){parentEl.appendChild(closeButton.el_);}};/**\n   * Empties the content element. This happens anytime the modal is filled.\n   *\n   * @fires ModalDialog#beforemodalempty\n   * @fires ModalDialog#modalempty\n   */ModalDialog.prototype.empty=function empty(){/**\n     * Fired just before a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#beforemodalempty\n     * @type {EventTarget~Event}\n     */this.trigger('beforemodalempty');emptyEl(this.contentEl());/**\n     * Fired just after a `ModalDialog` is emptied.\n     *\n     * @event ModalDialog#modalempty\n     * @type {EventTarget~Event}\n     */this.trigger('modalempty');};/**\n   * Gets or sets the modal content, which gets normalized before being\n   * rendered into the DOM.\n   *\n   * This does not update the DOM or fill the modal, but it is called during\n   * that process.\n   *\n   * @param  {Mixed} [value]\n   *         If defined, sets the internal content value to be used on the\n   *         next call(s) to `fill`. This value is normalized before being\n   *         inserted. To \"clear\" the internal content value, pass `null`.\n   *\n   * @return {Mixed}\n   *         The current content of the modal dialog\n   */ModalDialog.prototype.content=function content(value){if(typeof value!=='undefined'){this.content_=value;}return this.content_;};/**\n   * conditionally focus the modal dialog if focus was previously on the player.\n   *\n   * @private\n   */ModalDialog.prototype.conditionalFocus_=function conditionalFocus_(){var activeEl=document.activeElement;var playerEl=this.player_.el_;this.previouslyActiveEl_=null;if(playerEl.contains(activeEl)||playerEl===activeEl){this.previouslyActiveEl_=activeEl;this.focus();this.on(document,'keydown',this.handleKeyDown);}};/**\n   * conditionally blur the element and refocus the last focused element\n   *\n   * @private\n   */ModalDialog.prototype.conditionalBlur_=function conditionalBlur_(){if(this.previouslyActiveEl_){this.previouslyActiveEl_.focus();this.previouslyActiveEl_=null;}this.off(document,'keydown',this.handleKeyDown);};/**\n   * Keydown handler. Attached when modal is focused.\n   *\n   * @listens keydown\n   */ModalDialog.prototype.handleKeyDown=function handleKeyDown(event){// exit early if it isn't a tab key\nif(event.which!==9){return;}var focusableEls=this.focusableEls_();var activeEl=this.el_.querySelector(':focus');var focusIndex=void 0;for(var i=0;i<focusableEls.length;i++){if(activeEl===focusableEls[i]){focusIndex=i;break;}}if(document.activeElement===this.el_){focusIndex=0;}if(event.shiftKey&&focusIndex===0){focusableEls[focusableEls.length-1].focus();event.preventDefault();}else if(!event.shiftKey&&focusIndex===focusableEls.length-1){focusableEls[0].focus();event.preventDefault();}};/**\n   * get all focusable elements\n   *\n   * @private\n   */ModalDialog.prototype.focusableEls_=function focusableEls_(){var allChildren=this.el_.querySelectorAll('*');return Array.prototype.filter.call(allChildren,function(child){return(child instanceof window.HTMLAnchorElement||child instanceof window.HTMLAreaElement)&&child.hasAttribute('href')||(child instanceof window.HTMLInputElement||child instanceof window.HTMLSelectElement||child instanceof window.HTMLTextAreaElement||child instanceof window.HTMLButtonElement)&&!child.hasAttribute('disabled')||child instanceof window.HTMLIFrameElement||child instanceof window.HTMLObjectElement||child instanceof window.HTMLEmbedElement||child.hasAttribute('tabindex')&&child.getAttribute('tabindex')!==-1||child.hasAttribute('contenteditable');});};return ModalDialog;}(Component);/**\n * Default options for `ModalDialog` default options.\n *\n * @type {Object}\n * @private\n */ModalDialog.prototype.options_={pauseOnOpen:true,temporary:true};Component.registerComponent('ModalDialog',ModalDialog);/**\n * @file track-list.js\n *//**\n * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n * {@link VideoTrackList}\n *\n * @extends EventTarget\n */var TrackList=function(_EventTarget){inherits(TrackList,_EventTarget);/**\n   * Create an instance of this class\n   *\n   * @param {Track[]} tracks\n   *        A list of tracks to initialize the list with.\n   *\n   * @param {Object} [list]\n   *        The child object with inheritance done manually for ie8.\n   *\n   * @abstract\n   */function TrackList(){var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var _ret;var list=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;classCallCheck(this,TrackList);var _this=possibleConstructorReturn(this,_EventTarget.call(this));if(!list){list=_this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}}}list.tracks_=[];/**\n     * @memberof TrackList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.tracks_.length;}});for(var i=0;i<tracks.length;i++){list.addTrack(tracks[i]);}// must return the object, as for ie8 it will not be this\n// but a reference to a document object\nreturn _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link Track} to the `TrackList`\n   *\n   * @param {Track} track\n   *        The audio, video, or text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */TrackList.prototype.addTrack=function addTrack(track){var index=this.tracks_.length;if(!(''+index in this)){Object.defineProperty(this,index,{get:function get$$1(){return this.tracks_[index];}});}// Do not add duplicate tracks\nif(this.tracks_.indexOf(track)===-1){this.tracks_.push(track);/**\n       * Triggered when a track is added to a track list.\n       *\n       * @event TrackList#addtrack\n       * @type {EventTarget~Event}\n       * @property {Track} track\n       *           A reference to track that was added.\n       */this.trigger({track:track,type:'addtrack'});}};/**\n   * Remove a {@link Track} from the `TrackList`\n   *\n   * @param {Track} rtrack\n   *        The audio, video, or text track to remove from the list.\n   *\n   * @fires TrackList#removetrack\n   */TrackList.prototype.removeTrack=function removeTrack(rtrack){var track=void 0;for(var i=0,l=this.length;i<l;i++){if(this[i]===rtrack){track=this[i];if(track.off){track.off();}this.tracks_.splice(i,1);break;}}if(!track){return;}/**\n     * Triggered when a track is removed from track list.\n     *\n     * @event TrackList#removetrack\n     * @type {EventTarget~Event}\n     * @property {Track} track\n     *           A reference to track that was removed.\n     */this.trigger({track:track,type:'removetrack'});};/**\n   * Get a Track from the TrackList by a tracks id\n   *\n   * @param {String} id - the id of the track to get\n   * @method getTrackById\n   * @return {Track}\n   * @private\n   */TrackList.prototype.getTrackById=function getTrackById(id){var result=null;for(var i=0,l=this.length;i<l;i++){var track=this[i];if(track.id===id){result=track;break;}}return result;};return TrackList;}(EventTarget);/**\n * Triggered when a different track is selected/enabled.\n *\n * @event TrackList#change\n * @type {EventTarget~Event}\n *//**\n * Events that can be called with on + eventName. See {@link EventHandler}.\n *\n * @property {Object} TrackList#allowedEvents_\n * @private\n */TrackList.prototype.allowedEvents_={change:'change',addtrack:'addtrack',removetrack:'removetrack'};// emulate attribute EventHandler support to allow for feature detection\nfor(var event in TrackList.prototype.allowedEvents_){TrackList.prototype['on'+event]=null;}/**\n * @file audio-track-list.js\n *//**\n * Anywhere we call this function we diverge from the spec\n * as we only support one enabled audiotrack at a time\n *\n * @param {AudioTrackList} list\n *        list to work on\n *\n * @param {AudioTrack} track\n *        The track to skip\n *\n * @private\n */var disableOthers=function disableOthers(list,track){for(var i=0;i<list.length;i++){if(!Object.keys(list[i]).length||track.id===list[i].id){continue;}// another audio track is enabled, disable it\nlist[i].enabled=false;}};/**\n * The current list of {@link AudioTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n * @extends TrackList\n */var AudioTrackList=function(_TrackList){inherits(AudioTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {AudioTrack[]} [tracks=[]]\n   *        A list of `AudioTrack` to instantiate the list with.\n   */function AudioTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,AudioTrackList);var list=void 0;// make sure only 1 track is enabled\n// sorted from last index to first index\nfor(var i=tracks.length-1;i>=0;i--){if(tracks[i].enabled){disableOthers(tracks,tracks[i]);break;}}// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in AudioTrackList.prototype){if(_prop!=='constructor'){list[_prop]=AudioTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);list.changing_=false;return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add an {@link AudioTrack} to the `AudioTrackList`.\n   *\n   * @param {AudioTrack} track\n   *        The AudioTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */AudioTrackList.prototype.addTrack=function addTrack(track){var _this2=this;if(track.enabled){disableOthers(this,track);}_TrackList.prototype.addTrack.call(this,track);// native tracks don't have this\nif(!track.addEventListener){return;}/**\n     * @listens AudioTrack#enabledchange\n     * @fires TrackList#change\n     */track.addEventListener('enabledchange',function(){// when we are disabling other tracks (since we don't support\n// more than one track at a time) we will set changing_\n// to true so that we don't trigger additional change events\nif(_this2.changing_){return;}_this2.changing_=true;disableOthers(_this2,track);_this2.changing_=false;_this2.trigger('change');});};return AudioTrackList;}(TrackList);/**\n * @file video-track-list.js\n *//**\n * Un-select all other {@link VideoTrack}s that are selected.\n *\n * @param {VideoTrackList} list\n *        list to work on\n *\n * @param {VideoTrack} track\n *        The track to skip\n *\n * @private\n */var disableOthers$1=function disableOthers(list,track){for(var i=0;i<list.length;i++){if(!Object.keys(list[i]).length||track.id===list[i].id){continue;}// another video track is enabled, disable it\nlist[i].selected=false;}};/**\n * The current list of {@link VideoTrack} for a video.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n * @extends TrackList\n */var VideoTrackList=function(_TrackList){inherits(VideoTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {VideoTrack[]} [tracks=[]]\n   *        A list of `VideoTrack` to instantiate the list with.\n   */function VideoTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,VideoTrackList);var list=void 0;// make sure only 1 track is enabled\n// sorted from last index to first index\nfor(var i=tracks.length-1;i>=0;i--){if(tracks[i].selected){disableOthers$1(tracks,tracks[i]);break;}}// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in VideoTrackList.prototype){if(_prop!=='constructor'){list[_prop]=VideoTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);list.changing_=false;/**\n     * @member {number} VideoTrackList#selectedIndex\n     *         The current index of the selected {@link VideoTrack`}.\n     */Object.defineProperty(list,'selectedIndex',{get:function get$$1(){for(var _i=0;_i<this.length;_i++){if(this[_i].selected){return _i;}}return-1;},set:function set$$1(){}});return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link VideoTrack} to the `VideoTrackList`.\n   *\n   * @param {VideoTrack} track\n   *        The VideoTrack to add to the list\n   *\n   * @fires TrackList#addtrack\n   */VideoTrackList.prototype.addTrack=function addTrack(track){var _this2=this;if(track.selected){disableOthers$1(this,track);}_TrackList.prototype.addTrack.call(this,track);// native tracks don't have this\nif(!track.addEventListener){return;}/**\n     * @listens VideoTrack#selectedchange\n     * @fires TrackList#change\n     */track.addEventListener('selectedchange',function(){if(_this2.changing_){return;}_this2.changing_=true;disableOthers$1(_this2,track);_this2.changing_=false;_this2.trigger('change');});};return VideoTrackList;}(TrackList);/**\n * @file text-track-list.js\n *//**\n * The current list of {@link TextTrack} for a media file.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n * @extends TrackList\n */var TextTrackList=function(_TrackList){inherits(TextTrackList,_TrackList);/**\n   * Create an instance of this class.\n   *\n   * @param {TextTrack[]} [tracks=[]]\n   *        A list of `TextTrack` to instantiate the list with.\n   */function TextTrackList(){var _this,_ret;var tracks=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,TextTrackList);var list=void 0;// IE8 forces us to implement inheritance ourselves\n// as it does not support Object.defineProperty properly\nif(IS_IE8){list=document.createElement('custom');for(var prop in TrackList.prototype){if(prop!=='constructor'){list[prop]=TrackList.prototype[prop];}}for(var _prop in TextTrackList.prototype){if(_prop!=='constructor'){list[_prop]=TextTrackList.prototype[_prop];}}}list=(_this=possibleConstructorReturn(this,_TrackList.call(this,tracks,list)),_this);return _ret=list,possibleConstructorReturn(_this,_ret);}/**\n   * Add a {@link TextTrack} to the `TextTrackList`\n   *\n   * @param {TextTrack} track\n   *        The text track to add to the list.\n   *\n   * @fires TrackList#addtrack\n   */TextTrackList.prototype.addTrack=function addTrack(track){_TrackList.prototype.addTrack.call(this,track);/**\n     * @listens TextTrack#modechange\n     * @fires TrackList#change\n     */track.addEventListener('modechange',bind(this,function(){this.trigger('change');}));var nonLanguageTextTrackKind=['metadata','chapters'];if(nonLanguageTextTrackKind.indexOf(track.kind)===-1){track.addEventListener('modechange',bind(this,function(){this.trigger('selectedlanguagechange');}));}};return TextTrackList;}(TrackList);/**\n * @file html-track-element-list.js\n *//**\n * The current list of {@link HtmlTrackElement}s.\n */var HtmlTrackElementList=function(){/**\n   * Create an instance of this class.\n   *\n   * @param {HtmlTrackElement[]} [tracks=[]]\n   *        A list of `HtmlTrackElement` to instantiate the list with.\n   */function HtmlTrackElementList(){var trackElements=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,HtmlTrackElementList);var list=this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in HtmlTrackElementList.prototype){if(prop!=='constructor'){list[prop]=HtmlTrackElementList.prototype[prop];}}}list.trackElements_=[];/**\n     * @memberof HtmlTrackElementList\n     * @member {number} length\n     *         The current number of `Track`s in the this Trackist.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.trackElements_.length;}});for(var i=0,length=trackElements.length;i<length;i++){list.addTrackElement_(trackElements[i]);}if(IS_IE8){return list;}}/**\n   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to add to the list.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.addTrackElement_=function addTrackElement_(trackElement){var index=this.trackElements_.length;if(!(''+index in this)){Object.defineProperty(this,index,{get:function get$$1(){return this.trackElements_[index];}});}// Do not add duplicate elements\nif(this.trackElements_.indexOf(trackElement)===-1){this.trackElements_.push(trackElement);}};/**\n   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n   * {@link TextTrack}.\n   *\n   * @param {TextTrack} track\n   *        The track associated with a track element.\n   *\n   * @return {HtmlTrackElement|undefined}\n   *         The track element that was found or undefined.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.getTrackElementByTrack_=function getTrackElementByTrack_(track){var trackElement_=void 0;for(var i=0,length=this.trackElements_.length;i<length;i++){if(track===this.trackElements_[i].track){trackElement_=this.trackElements_[i];break;}}return trackElement_;};/**\n   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n   *\n   * @param {HtmlTrackElement} trackElement\n   *        The track element to remove from the list.\n   *\n   * @private\n   */HtmlTrackElementList.prototype.removeTrackElement_=function removeTrackElement_(trackElement){for(var i=0,length=this.trackElements_.length;i<length;i++){if(trackElement===this.trackElements_[i]){this.trackElements_.splice(i,1);break;}}};return HtmlTrackElementList;}();/**\n * @file text-track-cue-list.js\n *//**\n * @typedef {Object} TextTrackCueList~TextTrackCue\n *\n * @property {string} id\n *           The unique id for this text track cue\n *\n * @property {number} startTime\n *           The start time for this text track cue\n *\n * @property {number} endTime\n *           The end time for this text track cue\n *\n * @property {boolean} pauseOnExit\n *           Pause when the end time is reached if true.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n *//**\n * A List of TextTrackCues.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n */var TextTrackCueList=function(){/**\n   * Create an instance of this class..\n   *\n   * @param {Array} cues\n   *        A list of cues to be initialized with\n   */function TextTrackCueList(cues){classCallCheck(this,TextTrackCueList);var list=this;// eslint-disable-line\nif(IS_IE8){list=document.createElement('custom');for(var prop in TextTrackCueList.prototype){if(prop!=='constructor'){list[prop]=TextTrackCueList.prototype[prop];}}}TextTrackCueList.prototype.setCues_.call(list,cues);/**\n     * @memberof TextTrackCueList\n     * @member {number} length\n     *         The current number of `TextTrackCue`s in the TextTrackCueList.\n     * @instance\n     */Object.defineProperty(list,'length',{get:function get$$1(){return this.length_;}});if(IS_IE8){return list;}}/**\n   * A setter for cues in this list. Creates getters\n   * an an index for the cues.\n   *\n   * @param {Array} cues\n   *        An array of cues to set\n   *\n   * @private\n   */TextTrackCueList.prototype.setCues_=function setCues_(cues){var oldLength=this.length||0;var i=0;var l=cues.length;this.cues_=cues;this.length_=cues.length;var defineProp=function defineProp(index){if(!(''+index in this)){Object.defineProperty(this,''+index,{get:function get$$1(){return this.cues_[index];}});}};if(oldLength<l){i=oldLength;for(;i<l;i++){defineProp.call(this,i);}}};/**\n   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n   *\n   * @param {string} id\n   *        The id of the cue that should be searched for.\n   *\n   * @return {TextTrackCueList~TextTrackCue|null}\n   *         A single cue or null if none was found.\n   */TextTrackCueList.prototype.getCueById=function getCueById(id){var result=null;for(var i=0,l=this.length;i<l;i++){var cue=this[i];if(cue.id===id){result=cue;break;}}return result;};return TextTrackCueList;}();/**\n * @file track-kinds.js\n *//**\n * All possible `VideoTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n * @typedef VideoTrack~Kind\n * @enum\n */var VideoTrackKind={alternative:'alternative',captions:'captions',main:'main',sign:'sign',subtitles:'subtitles',commentary:'commentary'};/**\n * All possible `AudioTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n * @typedef AudioTrack~Kind\n * @enum\n */var AudioTrackKind={'alternative':'alternative','descriptions':'descriptions','main':'main','main-desc':'main-desc','translation':'translation','commentary':'commentary'};/**\n * All possible `TextTrackKind`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n * @typedef TextTrack~Kind\n * @enum\n */var TextTrackKind={subtitles:'subtitles',captions:'captions',descriptions:'descriptions',chapters:'chapters',metadata:'metadata'};/**\n * All possible `TextTrackMode`s\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n * @typedef TextTrack~Mode\n * @enum\n */var TextTrackMode={disabled:'disabled',hidden:'hidden',showing:'showing'};/**\n * @file track.js\n *//**\n * A Track class that contains all of the common functionality for {@link AudioTrack},\n * {@link VideoTrack}, and {@link TextTrack}.\n *\n * > Note: This class should not be used directly\n *\n * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n * @extends EventTarget\n * @abstract\n */var Track=function(_EventTarget){inherits(Track,_EventTarget);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid kind for the track type you are creating.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @abstract\n   */function Track(){var _ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Track);var _this=possibleConstructorReturn(this,_EventTarget.call(this));var track=_this;// eslint-disable-line\nif(IS_IE8){track=document.createElement('custom');for(var prop in Track.prototype){if(prop!=='constructor'){track[prop]=Track.prototype[prop];}}}var trackProps={id:options.id||'vjs_track_'+newGUID(),kind:options.kind||'',label:options.label||'',language:options.language||''};/**\n     * @memberof Track\n     * @member {string} id\n     *         The id of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} kind\n     *         The kind of track that this is. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} label\n     *         The label of this track. Cannot be changed after creation.\n     * @instance\n     *\n     * @readonly\n     *//**\n     * @memberof Track\n     * @member {string} language\n     *         The two letter language code for this track. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */var _loop=function _loop(key){Object.defineProperty(track,key,{get:function get$$1(){return trackProps[key];},set:function set$$1(){}});};for(var key in trackProps){_loop(key);}return _ret=track,possibleConstructorReturn(_this,_ret);}return Track;}(EventTarget);/**\n * @file url.js\n * @module url\n *//**\n * @typedef {Object} url:URLObject\n *\n * @property {string} protocol\n *           The protocol of the url that was parsed.\n *\n * @property {string} hostname\n *           The hostname of the url that was parsed.\n *\n * @property {string} port\n *           The port of the url that was parsed.\n *\n * @property {string} pathname\n *           The pathname of the url that was parsed.\n *\n * @property {string} search\n *           The search query of the url that was parsed.\n *\n * @property {string} hash\n *           The hash of the url that was parsed.\n *\n * @property {string} host\n *           The host of the url that was parsed.\n *//**\n * Resolve and parse the elements of a URL.\n *\n * @param  {String} url\n *         The url to parse\n *\n * @return {url:URLObject}\n *         An object of url details\n */var parseUrl=function parseUrl(url){var props=['protocol','hostname','port','pathname','search','hash','host'];// add the url to an anchor and let the browser parse the URL\nvar a=document.createElement('a');a.href=url;// IE8 (and 9?) Fix\n// ie8 doesn't parse the URL correctly until the anchor is actually\n// added to the body, and an innerHTML is needed to trigger the parsing\nvar addToBody=a.host===''&&a.protocol!=='file:';var div=void 0;if(addToBody){div=document.createElement('div');div.innerHTML='<a href=\"'+url+'\"></a>';a=div.firstChild;// prevent the div from affecting layout\ndiv.setAttribute('style','display:none; position:absolute;');document.body.appendChild(div);}// Copy the specific URL properties to a new object\n// This is also needed for IE8 because the anchor loses its\n// properties when it's removed from the dom\nvar details={};for(var i=0;i<props.length;i++){details[props[i]]=a[props[i]];}// IE9 adds the port to the host property unlike everyone else. If\n// a port identifier is added for standard ports, strip it.\nif(details.protocol==='http:'){details.host=details.host.replace(/:80$/,'');}if(details.protocol==='https:'){details.host=details.host.replace(/:443$/,'');}if(!details.protocol){details.protocol=window.location.protocol;}if(addToBody){document.body.removeChild(div);}return details;};/**\n * Get absolute version of relative URL. Used to tell flash correct URL.\n *\n *\n * @param  {string} url\n *         URL to make absolute\n *\n * @return {string}\n *         Absolute URL\n *\n * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n */var getAbsoluteURL=function getAbsoluteURL(url){// Check if absolute URL\nif(!url.match(/^https?:\\/\\//)){// Convert to absolute URL. Flash hosted off-site needs an absolute URL.\nvar div=document.createElement('div');div.innerHTML='<a href=\"'+url+'\">x</a>';url=div.firstChild.href;}return url;};/**\n * Returns the extension of the passed file name. It will return an empty string\n * if passed an invalid path.\n *\n * @param {string} path\n *        The fileName path like '/path/to/file.mp4'\n *\n * @returns {string}\n *          The extension in lower case or an empty string if no\n *          extension could be found.\n */var getFileExtension=function getFileExtension(path){if(typeof path==='string'){var splitPathRe=/^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/i;var pathParts=splitPathRe.exec(path);if(pathParts){return pathParts.pop().toLowerCase();}}return'';};/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @param {string} url\n *        The url to check.\n *\n * @return {boolean}\n *         Whether it is a cross domain request or not.\n */var isCrossOrigin=function isCrossOrigin(url){var winLoc=window.location;var urlInfo=parseUrl(url);// IE8 protocol relative urls will return ':' for protocol\nvar srcProtocol=urlInfo.protocol===':'?winLoc.protocol:urlInfo.protocol;// Check if url is for another domain/origin\n// IE8 doesn't know location.origin, so we won't rely on it here\nvar crossOrigin=srcProtocol+urlInfo.host!==winLoc.protocol+winLoc.host;return crossOrigin;};var Url=(Object.freeze||Object)({parseUrl:parseUrl,getAbsoluteURL:getAbsoluteURL,getFileExtension:getFileExtension,isCrossOrigin:isCrossOrigin});/**\n * @file text-track.js\n *//**\n * Takes a webvtt file contents and parses it into cues\n *\n * @param {string} srcContent\n *        webVTT file contents\n *\n * @param {TextTrack} track\n *        TextTrack to add cues to. Cues come from the srcContent.\n *\n * @private\n */var parseCues=function parseCues(srcContent,track){var parser=new window.WebVTT.Parser(window,window.vttjs,window.WebVTT.StringDecoder());var errors=[];parser.oncue=function(cue){track.addCue(cue);};parser.onparsingerror=function(error){errors.push(error);};parser.onflush=function(){track.trigger({type:'loadeddata',target:track});};parser.parse(srcContent);if(errors.length>0){if(window.console&&window.console.groupCollapsed){window.console.groupCollapsed('Text Track parsing errors for '+track.src);}errors.forEach(function(error){return log$1.error(error);});if(window.console&&window.console.groupEnd){window.console.groupEnd();}}parser.flush();};/**\n * Load a `TextTrack` from a specifed url.\n *\n * @param {string} src\n *        Url to load track from.\n *\n * @param {TextTrack} track\n *        Track to add cues to. Comes from the content at the end of `url`.\n *\n * @private\n */var loadTrack=function loadTrack(src,track){var opts={uri:src};var crossOrigin=isCrossOrigin(src);if(crossOrigin){opts.cors=crossOrigin;}xhr(opts,bind(this,function(err,response,responseBody){if(err){return log$1.error(err,response);}track.loaded_=true;// Make sure that vttjs has loaded, otherwise, wait till it finished loading\n// NOTE: this is only used for the alt/video.novtt.js build\nif(typeof window.WebVTT!=='function'){if(track.tech_){var loadHandler=function loadHandler(){return parseCues(responseBody,track);};track.tech_.on('vttjsloaded',loadHandler);track.tech_.on('vttjserror',function(){log$1.error('vttjs failed to load, stopping trying to process '+track.src);track.tech_.off('vttjsloaded',loadHandler);});}}else{parseCues(responseBody,track);}}));};/**\n * A representation of a single `TextTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n * @extends Track\n */var TextTrack=function(_Track){inherits(TextTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this TextTrack.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */function TextTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,TextTrack);if(!options.tech){throw new Error('A tech was not provided.');}var settings=mergeOptions(options,{kind:TextTrackKind[options.kind]||'subtitles',language:options.language||options.srclang||''});var mode=TextTrackMode[settings.mode]||'disabled';var default_=settings['default'];if(settings.kind==='metadata'||settings.kind==='chapters'){mode='hidden';}// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar tt=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);tt.tech_=settings.tech;if(IS_IE8){for(var prop in TextTrack.prototype){if(prop!=='constructor'){tt[prop]=TextTrack.prototype[prop];}}}tt.cues_=[];tt.activeCues_=[];var cues=new TextTrackCueList(tt.cues_);var activeCues=new TextTrackCueList(tt.activeCues_);var changed=false;var timeupdateHandler=bind(tt,function(){// Accessing this.activeCues for the side-effects of updating itself\n// due to it's nature as a getter function. Do not remove or cues will\n// stop updating!\n/* eslint-disable no-unused-expressions */this.activeCues;/* eslint-enable no-unused-expressions */if(changed){this.trigger('cuechange');changed=false;}});if(mode!=='disabled'){tt.tech_.ready(function(){tt.tech_.on('timeupdate',timeupdateHandler);},true);}/**\n     * @memberof TextTrack\n     * @member {boolean} default\n     *         If this track was set to be on or off by default. Cannot be changed after\n     *         creation.\n     * @instance\n     *\n     * @readonly\n     */Object.defineProperty(tt,'default',{get:function get$$1(){return default_;},set:function set$$1(){}});/**\n     * @memberof TextTrack\n     * @member {string} mode\n     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n     *         not be set if setting to an invalid mode.\n     * @instance\n     *\n     * @fires TextTrack#modechange\n     */Object.defineProperty(tt,'mode',{get:function get$$1(){return mode;},set:function set$$1(newMode){var _this2=this;if(!TextTrackMode[newMode]){return;}mode=newMode;if(mode==='showing'){this.tech_.ready(function(){_this2.tech_.on('timeupdate',timeupdateHandler);},true);}/**\n         * An event that fires when mode changes on this track. This allows\n         * the TextTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec!\n         *\n         * @event TextTrack#modechange\n         * @type {EventTarget~Event}\n         */this.trigger('modechange');}});/**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} cues\n     *         The text track cue list for this TextTrack.\n     * @instance\n     */Object.defineProperty(tt,'cues',{get:function get$$1(){if(!this.loaded_){return null;}return cues;},set:function set$$1(){}});/**\n     * @memberof TextTrack\n     * @member {TextTrackCueList} activeCues\n     *         The list text track cues that are currently active for this TextTrack.\n     * @instance\n     */Object.defineProperty(tt,'activeCues',{get:function get$$1(){if(!this.loaded_){return null;}// nothing to do\nif(this.cues.length===0){return activeCues;}var ct=this.tech_.currentTime();var active=[];for(var i=0,l=this.cues.length;i<l;i++){var cue=this.cues[i];if(cue.startTime<=ct&&cue.endTime>=ct){active.push(cue);}else if(cue.startTime===cue.endTime&&cue.startTime<=ct&&cue.startTime+0.5>=ct){active.push(cue);}}changed=false;if(active.length!==this.activeCues_.length){changed=true;}else{for(var _i=0;_i<active.length;_i++){if(this.activeCues_.indexOf(active[_i])===-1){changed=true;}}}this.activeCues_=active;activeCues.setCues_(this.activeCues_);return activeCues;},set:function set$$1(){}});if(settings.src){tt.src=settings.src;loadTrack(settings.src,tt);}else{tt.loaded_=true;}return _ret=tt,possibleConstructorReturn(_this,_ret);}/**\n   * Add a cue to the internal list of cues.\n   *\n   * @param {TextTrack~Cue} cue\n   *        The cue to add to our internal list\n   */TextTrack.prototype.addCue=function addCue(originalCue){var cue=originalCue;if(window.vttjs&&!(originalCue instanceof window.vttjs.VTTCue)){cue=new window.vttjs.VTTCue(originalCue.startTime,originalCue.endTime,originalCue.text);for(var prop in originalCue){if(!(prop in cue)){cue[prop]=originalCue[prop];}}// make sure that `id` is copied over\ncue.id=originalCue.id;cue.originalCue_=originalCue;}var tracks=this.tech_.textTracks();for(var i=0;i<tracks.length;i++){if(tracks[i]!==this){tracks[i].removeCue(cue);}}this.cues_.push(cue);this.cues.setCues_(this.cues_);};/**\n   * Remove a cue from our internal list\n   *\n   * @param {TextTrack~Cue} removeCue\n   *        The cue to remove from our internal list\n   */TextTrack.prototype.removeCue=function removeCue(_removeCue){var i=this.cues_.length;while(i--){var cue=this.cues_[i];if(cue===_removeCue||cue.originalCue_&&cue.originalCue_===_removeCue){this.cues_.splice(i,1);this.cues.setCues_(this.cues_);break;}}};return TextTrack;}(Track);/**\n * cuechange - One or more cues in the track have become active or stopped being active.\n */TextTrack.prototype.allowedEvents_={cuechange:'cuechange'};/**\n * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n * only one `AudioTrack` in the list will be enabled at a time.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n * @extends Track\n */var AudioTrack=function(_Track){inherits(AudioTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {AudioTrack~Kind} [options.kind='']\n   *        A valid audio track kind\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.enabled]\n   *        If this track is the one that is currently playing. If this track is part of\n   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n   */function AudioTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,AudioTrack);var settings=mergeOptions(options,{kind:AudioTrackKind[options.kind]||''});// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar track=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);var enabled=false;if(IS_IE8){for(var prop in AudioTrack.prototype){if(prop!=='constructor'){track[prop]=AudioTrack.prototype[prop];}}}/**\n     * @memberof AudioTrack\n     * @member {boolean} enabled\n     *         If this `AudioTrack` is enabled or not. When setting this will\n     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */Object.defineProperty(track,'enabled',{get:function get$$1(){return enabled;},set:function set$$1(newEnabled){// an invalid or unchanged value\nif(typeof newEnabled!=='boolean'||newEnabled===enabled){return;}enabled=newEnabled;/**\n         * An event that fires when enabled changes on this track. This allows\n         * the AudioTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event AudioTrack#enabledchange\n         * @type {EventTarget~Event}\n         */this.trigger('enabledchange');}});// if the user sets this track to selected then\n// set selected to that true value otherwise\n// we keep it false\nif(settings.enabled){track.enabled=settings.enabled;}track.loaded_=true;return _ret=track,possibleConstructorReturn(_this,_ret);}return AudioTrack;}(Track);/**\n * A representation of a single `VideoTrack`.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n * @extends Track\n */var VideoTrack=function(_Track){inherits(VideoTrack,_Track);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} [options={}]\n   *        Object of option names and values\n   *\n   * @param {string} [options.kind='']\n   *        A valid {@link VideoTrack~Kind}\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this AudioTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {boolean} [options.selected]\n   *        If this track is the one that is currently playing.\n   */function VideoTrack(){var _this,_ret;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,VideoTrack);var settings=mergeOptions(options,{kind:VideoTrackKind[options.kind]||''});// on IE8 this will be a document element\n// for every other browser this will be a normal object\nvar track=(_this=possibleConstructorReturn(this,_Track.call(this,settings)),_this);var selected=false;if(IS_IE8){for(var prop in VideoTrack.prototype){if(prop!=='constructor'){track[prop]=VideoTrack.prototype[prop];}}}/**\n     * @memberof VideoTrack\n     * @member {boolean} selected\n     *         If this `VideoTrack` is selected or not. When setting this will\n     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n     * @instance\n     *\n     * @fires VideoTrack#selectedchange\n     */Object.defineProperty(track,'selected',{get:function get$$1(){return selected;},set:function set$$1(newSelected){// an invalid or unchanged value\nif(typeof newSelected!=='boolean'||newSelected===selected){return;}selected=newSelected;/**\n         * An event that fires when selected changes on this track. This allows\n         * the VideoTrackList that holds this track to act accordingly.\n         *\n         * > Note: This is not part of the spec! Native tracks will do\n         *         this internally without an event.\n         *\n         * @event VideoTrack#selectedchange\n         * @type {EventTarget~Event}\n         */this.trigger('selectedchange');}});// if the user sets this track to selected then\n// set selected to that true value otherwise\n// we keep it false\nif(settings.selected){track.selected=settings.selected;}return _ret=track,possibleConstructorReturn(_this,_ret);}return VideoTrack;}(Track);/**\n * @file html-track-element.js\n *//**\n * @memberof HTMLTrackElement\n * @typedef {HTMLTrackElement~ReadyState}\n * @enum {number}\n */var NONE=0;var LOADING=1;var LOADED=2;var ERROR=3;/**\n * A single track represented in the DOM.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n * @extends EventTarget\n */var HTMLTrackElement=function(_EventTarget){inherits(HTMLTrackElement,_EventTarget);/**\n   * Create an instance of this class.\n   *\n   * @param {Object} options={}\n   *        Object of option names and values\n   *\n   * @param {Tech} options.tech\n   *        A reference to the tech that owns this HTMLTrackElement.\n   *\n   * @param {TextTrack~Kind} [options.kind='subtitles']\n   *        A valid text track kind.\n   *\n   * @param {TextTrack~Mode} [options.mode='disabled']\n   *        A valid text track mode.\n   *\n   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n   *        A unique id for this TextTrack.\n   *\n   * @param {string} [options.label='']\n   *        The menu label for this track.\n   *\n   * @param {string} [options.language='']\n   *        A valid two character language code.\n   *\n   * @param {string} [options.srclang='']\n   *        A valid two character language code. An alternative, but deprioritized\n   *        vesion of `options.language`\n   *\n   * @param {string} [options.src]\n   *        A url to TextTrack cues.\n   *\n   * @param {boolean} [options.default]\n   *        If this track should default to on or off.\n   */function HTMLTrackElement(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,HTMLTrackElement);var _this=possibleConstructorReturn(this,_EventTarget.call(this));var readyState=void 0;var trackElement=_this;// eslint-disable-line\nif(IS_IE8){trackElement=document.createElement('custom');for(var prop in HTMLTrackElement.prototype){if(prop!=='constructor'){trackElement[prop]=HTMLTrackElement.prototype[prop];}}}var track=new TextTrack(options);trackElement.kind=track.kind;trackElement.src=track.src;trackElement.srclang=track.language;trackElement.label=track.label;trackElement['default']=track['default'];/**\n     * @memberof HTMLTrackElement\n     * @member {HTMLTrackElement~ReadyState} readyState\n     *         The current ready state of the track element.\n     * @instance\n     */Object.defineProperty(trackElement,'readyState',{get:function get$$1(){return readyState;}});/**\n     * @memberof HTMLTrackElement\n     * @member {TextTrack} track\n     *         The underlying TextTrack object.\n     * @instance\n     *\n     */Object.defineProperty(trackElement,'track',{get:function get$$1(){return track;}});readyState=NONE;/**\n     * @listens TextTrack#loadeddata\n     * @fires HTMLTrackElement#load\n     */track.addEventListener('loadeddata',function(){readyState=LOADED;trackElement.trigger({type:'load',target:trackElement});});if(IS_IE8){var _ret;return _ret=trackElement,possibleConstructorReturn(_this,_ret);}return _this;}return HTMLTrackElement;}(EventTarget);HTMLTrackElement.prototype.allowedEvents_={load:'load'};HTMLTrackElement.NONE=NONE;HTMLTrackElement.LOADING=LOADING;HTMLTrackElement.LOADED=LOADED;HTMLTrackElement.ERROR=ERROR;/*\n * This file contains all track properties that are used in\n * player.js, tech.js, html5.js and possibly other techs in the future.\n */var NORMAL={audio:{ListClass:AudioTrackList,TrackClass:AudioTrack,capitalName:'Audio'},video:{ListClass:VideoTrackList,TrackClass:VideoTrack,capitalName:'Video'},text:{ListClass:TextTrackList,TrackClass:TextTrack,capitalName:'Text'}};Object.keys(NORMAL).forEach(function(type){NORMAL[type].getterName=type+'Tracks';NORMAL[type].privateName=type+'Tracks_';});var REMOTE={remoteText:{ListClass:TextTrackList,TrackClass:TextTrack,capitalName:'RemoteText',getterName:'remoteTextTracks',privateName:'remoteTextTracks_'},remoteTextEl:{ListClass:HtmlTrackElementList,TrackClass:HTMLTrackElement,capitalName:'RemoteTextTrackEls',getterName:'remoteTextTrackEls',privateName:'remoteTextTrackEls_'}};var ALL=mergeOptions(NORMAL,REMOTE);REMOTE.names=Object.keys(REMOTE);NORMAL.names=Object.keys(NORMAL);ALL.names=[].concat(REMOTE.names).concat(NORMAL.names);/**\n * @file tech.js\n *//**\n * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n * that just contains the src url alone.\n * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n   * `var SourceString = 'http://example.com/some-video.mp4';`\n *\n * @typedef {Object|string} Tech~SourceObject\n *\n * @property {string} src\n *           The url to the source\n *\n * @property {string} type\n *           The mime type of the source\n *//**\n * A function used by {@link Tech} to create a new {@link TextTrack}.\n *\n * @private\n *\n * @param {Tech} self\n *        An instance of the Tech class.\n *\n * @param {string} kind\n *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n *\n * @param {string} [label]\n *        Label to identify the text track\n *\n * @param {string} [language]\n *        Two letter language abbreviation\n *\n * @param {Object} [options={}]\n *        An object with additional text track options\n *\n * @return {TextTrack}\n *          The text track that was created.\n */function createTrackHelper(self,kind,label,language){var options=arguments.length>4&&arguments[4]!==undefined?arguments[4]:{};var tracks=self.textTracks();options.kind=kind;if(label){options.label=label;}if(language){options.language=language;}options.tech=self;var track=new ALL.text.TrackClass(options);tracks.addTrack(track);return track;}/**\n * This is the base class for media playback technology controllers, such as\n * {@link Flash} and {@link HTML5}\n *\n * @extends Component\n */var Tech=function(_Component){inherits(Tech,_Component);/**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */function Tech(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var ready=arguments.length>1&&arguments[1]!==undefined?arguments[1]:function(){};classCallCheck(this,Tech);// we don't want the tech to report user activity automatically.\n// This is done manually in addControlsListeners\noptions.reportTouchActivity=false;// keep track of whether the current source has played at all to\n// implement a very limited played()\nvar _this=possibleConstructorReturn(this,_Component.call(this,null,options,ready));_this.hasStarted_=false;_this.on('playing',function(){this.hasStarted_=true;});_this.on('loadstart',function(){this.hasStarted_=false;});ALL.names.forEach(function(name){var props=ALL[name];if(options&&options[props.getterName]){_this[props.privateName]=options[props.getterName];}});// Manually track progress in cases where the browser/flash player doesn't report it.\nif(!_this.featuresProgressEvents){_this.manualProgressOn();}// Manually track timeupdates in cases where the browser/flash player doesn't report it.\nif(!_this.featuresTimeupdateEvents){_this.manualTimeUpdatesOn();}['Text','Audio','Video'].forEach(function(track){if(options['native'+track+'Tracks']===false){_this['featuresNative'+track+'Tracks']=false;}});if(options.nativeCaptions===false||options.nativeTextTracks===false){_this.featuresNativeTextTracks=false;}else if(options.nativeCaptions===true||options.nativeTextTracks===true){_this.featuresNativeTextTracks=true;}if(!_this.featuresNativeTextTracks){_this.emulateTextTracks();}_this.autoRemoteTextTracks_=new ALL.text.ListClass();_this.initTrackListeners();// Turn on component tap events only if not using native controls\nif(!options.nativeControlsForTouch){_this.emitTapEvents();}if(_this.constructor){_this.name_=_this.constructor.name||'Unknown Tech';}return _this;}/* Fallbacks for unsupported event types\n  ================================================================================ *//**\n   * Polyfill the `progress` event for browsers that don't support it natively.\n   *\n   * @see {@link Tech#trackProgress}\n   */Tech.prototype.manualProgressOn=function manualProgressOn(){this.on('durationchange',this.onDurationChange);this.manualProgress=true;// Trigger progress watching when a source begins loading\nthis.one('ready',this.trackProgress);};/**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   */Tech.prototype.manualProgressOff=function manualProgressOff(){this.manualProgress=false;this.stopTrackingProgress();this.off('durationchange',this.onDurationChange);};/**\n   * This is used to trigger a `progress` event when the buffered percent changes. It\n   * sets an interval function that will be called every 500 milliseconds to check if the\n   * buffer end percent has changed.\n   *\n   * > This function is called by {@link Tech#manualProgressOn}\n   *\n   * @param {EventTarget~Event} event\n   *        The `ready` event that caused this to run.\n   *\n   * @listens Tech#ready\n   * @fires Tech#progress\n   */Tech.prototype.trackProgress=function trackProgress(event){this.stopTrackingProgress();this.progressInterval=this.setInterval(bind(this,function(){// Don't trigger unless buffered amount is greater than last time\nvar numBufferedPercent=this.bufferedPercent();if(this.bufferedPercent_!==numBufferedPercent){/**\n         * See {@link Player#progress}\n         *\n         * @event Tech#progress\n         * @type {EventTarget~Event}\n         */this.trigger('progress');}this.bufferedPercent_=numBufferedPercent;if(numBufferedPercent===1){this.stopTrackingProgress();}}),500);};/**\n   * Update our internal duration on a `durationchange` event by calling\n   * {@link Tech#duration}.\n   *\n   * @param {EventTarget~Event} event\n   *        The `durationchange` event that caused this to run.\n   *\n   * @listens Tech#durationchange\n   */Tech.prototype.onDurationChange=function onDurationChange(event){this.duration_=this.duration();};/**\n   * Get and create a `TimeRange` object for buffering.\n   *\n   * @return {TimeRange}\n   *         The time range object that was created.\n   */Tech.prototype.buffered=function buffered(){return createTimeRanges(0,0);};/**\n   * Get the percentage of the current video that is currently buffered.\n   *\n   * @return {number}\n   *         A number from 0 to 1 that represents the decimal percentage of the\n   *         video that is buffered.\n   *\n   */Tech.prototype.bufferedPercent=function bufferedPercent$$1(){return bufferedPercent(this.buffered(),this.duration_);};/**\n   * Turn off the polyfill for `progress` events that was created in\n   * {@link Tech#manualProgressOn}\n   * Stop manually tracking progress events by clearing the interval that was set in\n   * {@link Tech#trackProgress}.\n   */Tech.prototype.stopTrackingProgress=function stopTrackingProgress(){this.clearInterval(this.progressInterval);};/**\n   * Polyfill the `timeupdate` event for browsers that don't support it.\n   *\n   * @see {@link Tech#trackCurrentTime}\n   */Tech.prototype.manualTimeUpdatesOn=function manualTimeUpdatesOn(){this.manualTimeUpdates=true;this.on('play',this.trackCurrentTime);this.on('pause',this.stopTrackingCurrentTime);};/**\n   * Turn off the polyfill for `timeupdate` events that was created in\n   * {@link Tech#manualTimeUpdatesOn}\n   */Tech.prototype.manualTimeUpdatesOff=function manualTimeUpdatesOff(){this.manualTimeUpdates=false;this.stopTrackingCurrentTime();this.off('play',this.trackCurrentTime);this.off('pause',this.stopTrackingCurrentTime);};/**\n   * Sets up an interval function to track current time and trigger `timeupdate` every\n   * 250 milliseconds.\n   *\n   * @listens Tech#play\n   * @triggers Tech#timeupdate\n   */Tech.prototype.trackCurrentTime=function trackCurrentTime(){if(this.currentTimeInterval){this.stopTrackingCurrentTime();}this.currentTimeInterval=this.setInterval(function(){/**\n       * Triggered at an interval of 250ms to indicated that time is passing in the video.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */this.trigger({type:'timeupdate',target:this,manuallyTriggered:true});// 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n},250);};/**\n   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n   * `timeupdate` event is no longer triggered.\n   *\n   * @listens {Tech#pause}\n   */Tech.prototype.stopTrackingCurrentTime=function stopTrackingCurrentTime(){this.clearInterval(this.currentTimeInterval);// #1002 - if the video ends right before the next timeupdate would happen,\n// the progress bar won't make it all the way to the end\nthis.trigger({type:'timeupdate',target:this,manuallyTriggered:true});};/**\n   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n   *\n   * @fires Component#dispose\n   */Tech.prototype.dispose=function dispose(){// clear out all tracks because we can't reuse them between techs\nthis.clearTracks(NORMAL.names);// Turn off any manual progress or timeupdate tracking\nif(this.manualProgress){this.manualProgressOff();}if(this.manualTimeUpdates){this.manualTimeUpdatesOff();}_Component.prototype.dispose.call(this);};/**\n   * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n   *\n   * > Note: Techs without source handlers should call this between sources for `video`\n   *         & `audio` tracks. You don't want to use them between tracks!\n   *\n   * @param {string[]|string} types\n   *        TrackList names to clear, valid names are `video`, `audio`, and\n   *        `text`.\n   */Tech.prototype.clearTracks=function clearTracks(types){var _this2=this;types=[].concat(types);// clear out all tracks because we can't reuse them between techs\ntypes.forEach(function(type){var list=_this2[type+'Tracks']()||[];var i=list.length;while(i--){var track=list[i];if(type==='text'){_this2.removeRemoteTextTrack(track);}list.removeTrack(track);}});};/**\n   * Remove any TextTracks added via addRemoteTextTrack that are\n   * flagged for automatic garbage collection\n   */Tech.prototype.cleanupAutoTextTracks=function cleanupAutoTextTracks(){var list=this.autoRemoteTextTracks_||[];var i=list.length;while(i--){var track=list[i];this.removeRemoteTextTrack(track);}};/**\n   * Reset the tech, which will removes all sources and reset the internal readyState.\n   *\n   * @abstract\n   */Tech.prototype.reset=function reset(){};/**\n   * Get or set an error on the Tech.\n   *\n   * @param {MediaError} [err]\n   *        Error to set on the Tech\n   *\n   * @return {MediaError|null}\n   *         The current error object on the tech, or null if there isn't one.\n   */Tech.prototype.error=function error(err){if(err!==undefined){this.error_=new MediaError(err);this.trigger('error');}return this.error_;};/**\n   * Returns the `TimeRange`s that have been played through for the current source.\n   *\n   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n   *         It only checks wether the source has played at all or not.\n   *\n   * @return {TimeRange}\n   *         - A single time range if this video has played\n   *         - An empty set of ranges if not.\n   */Tech.prototype.played=function played(){if(this.hasStarted_){return createTimeRanges(0,0);}return createTimeRanges();};/**\n   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n   * previously called.\n   *\n   * @fires Tech#timeupdate\n   */Tech.prototype.setCurrentTime=function setCurrentTime(){// improve the accuracy of manual timeupdates\nif(this.manualTimeUpdates){/**\n       * A manual `timeupdate` event.\n       *\n       * @event Tech#timeupdate\n       * @type {EventTarget~Event}\n       */this.trigger({type:'timeupdate',target:this,manuallyTriggered:true});}};/**\n   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n   * {@link TextTrackList} events.\n   *\n   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n   *\n   * @fires Tech#audiotrackchange\n   * @fires Tech#videotrackchange\n   * @fires Tech#texttrackchange\n   */Tech.prototype.initTrackListeners=function initTrackListeners(){var _this3=this;/**\n     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n     *\n     * @event Tech#audiotrackchange\n     * @type {EventTarget~Event}\n     *//**\n     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n     *\n     * @event Tech#videotrackchange\n     * @type {EventTarget~Event}\n     *//**\n     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n     *\n     * @event Tech#texttrackchange\n     * @type {EventTarget~Event}\n     */NORMAL.names.forEach(function(name){var props=NORMAL[name];var trackListChanges=function trackListChanges(){_this3.trigger(name+'trackchange');};var tracks=_this3[props.getterName]();tracks.addEventListener('removetrack',trackListChanges);tracks.addEventListener('addtrack',trackListChanges);_this3.on('dispose',function(){tracks.removeEventListener('removetrack',trackListChanges);tracks.removeEventListener('addtrack',trackListChanges);});});};/**\n   * Emulate TextTracks using vtt.js if necessary\n   *\n   * @fires Tech#vttjsloaded\n   * @fires Tech#vttjserror\n   */Tech.prototype.addWebVttScript_=function addWebVttScript_(){var _this4=this;if(window.WebVTT){return;}// Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n// signals that the Tech is ready at which point Tech.el_ is part of the DOM\n// before inserting the WebVTT script\nif(document.body.contains(this.el())){// load via require if available and vtt.js script location was not passed in\n// as an option. novtt builds will turn the above require call into an empty object\n// which will cause this if check to always fail.\nif(!this.options_['vtt.js']&&isPlain(vtt)&&Object.keys(vtt).length>0){this.trigger('vttjsloaded');return;}// load vtt.js via the script location option or the cdn of no location was\n// passed in\nvar script=document.createElement('script');script.src=this.options_['vtt.js']||'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';script.onload=function(){/**\n         * Fired when vtt.js is loaded.\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */_this4.trigger('vttjsloaded');};script.onerror=function(){/**\n         * Fired when vtt.js was not loaded due to an error\n         *\n         * @event Tech#vttjsloaded\n         * @type {EventTarget~Event}\n         */_this4.trigger('vttjserror');};this.on('dispose',function(){script.onload=null;script.onerror=null;});// but have not loaded yet and we set it to true before the inject so that\n// we don't overwrite the injected window.WebVTT if it loads right away\nwindow.WebVTT=true;this.el().parentNode.appendChild(script);}else{this.ready(this.addWebVttScript_);}};/**\n   * Emulate texttracks\n   *\n   */Tech.prototype.emulateTextTracks=function emulateTextTracks(){var _this5=this;var tracks=this.textTracks();var remoteTracks=this.remoteTextTracks();var handleAddTrack=function handleAddTrack(e){return tracks.addTrack(e.track);};var handleRemoveTrack=function handleRemoveTrack(e){return tracks.removeTrack(e.track);};remoteTracks.on('addtrack',handleAddTrack);remoteTracks.on('removetrack',handleRemoveTrack);this.addWebVttScript_();var updateDisplay=function updateDisplay(){return _this5.trigger('texttrackchange');};var textTracksChanges=function textTracksChanges(){updateDisplay();for(var i=0;i<tracks.length;i++){var track=tracks[i];track.removeEventListener('cuechange',updateDisplay);if(track.mode==='showing'){track.addEventListener('cuechange',updateDisplay);}}};textTracksChanges();tracks.addEventListener('change',textTracksChanges);tracks.addEventListener('addtrack',textTracksChanges);tracks.addEventListener('removetrack',textTracksChanges);this.on('dispose',function(){remoteTracks.off('addtrack',handleAddTrack);remoteTracks.off('removetrack',handleRemoveTrack);tracks.removeEventListener('change',textTracksChanges);tracks.removeEventListener('addtrack',textTracksChanges);tracks.removeEventListener('removetrack',textTracksChanges);for(var i=0;i<tracks.length;i++){var track=tracks[i];track.removeEventListener('cuechange',updateDisplay);}});};/**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */Tech.prototype.addTextTrack=function addTextTrack(kind,label,language){if(!kind){throw new Error('TextTrack kind is required but was not provided');}return createTrackHelper(this,kind,label,language);};/**\n   * Create an emulated TextTrack for use by addRemoteTextTrack\n   *\n   * This is intended to be overridden by classes that inherit from\n   * Tech in order to create native or custom TextTracks.\n   *\n   * @param {Object} options\n   *        The object should contain the options to initialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */Tech.prototype.createRemoteTextTrack=function createRemoteTextTrack(options){var track=mergeOptions(options,{tech:this});return new REMOTE.remoteTextEl.TrackClass(track);};/**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n   *\n   * @param {Object} options\n   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n   *\n   * @param {boolean} [manualCleanup=true]\n   *        - When false: the TextTrack will be automatically removed from the video\n   *          element whenever the source changes\n   *        - When True: The TextTrack will have to be cleaned up manually\n   *\n   * @return {HTMLTrackElement}\n   *         An Html Track Element.\n   *\n   * @deprecated The default functionality for this function will be equivalent\n   *             to \"manualCleanup=false\" in the future. The manualCleanup parameter will\n   *             also be removed.\n   */Tech.prototype.addRemoteTextTrack=function addRemoteTextTrack(){var _this6=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var manualCleanup=arguments[1];var htmlTrackElement=this.createRemoteTextTrack(options);if(manualCleanup!==true&&manualCleanup!==false){// deprecation warning\nlog$1.warn('Calling addRemoteTextTrack without explicitly setting the \"manualCleanup\" parameter to `true` is deprecated and default to `false` in future version of video.js');manualCleanup=true;}// store HTMLTrackElement and TextTrack to remote list\nthis.remoteTextTrackEls().addTrackElement_(htmlTrackElement);this.remoteTextTracks().addTrack(htmlTrackElement.track);if(manualCleanup!==true){// create the TextTrackList if it doesn't exist\nthis.ready(function(){return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);});}return htmlTrackElement;};/**\n   * Remove a remote text track from the remote `TextTrackList`.\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` to remove from the `TextTrackList`\n   */Tech.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(track){var trackElement=this.remoteTextTrackEls().getTrackElementByTrack_(track);// remove HTMLTrackElement and TextTrack from remote list\nthis.remoteTextTrackEls().removeTrackElement_(trackElement);this.remoteTextTracks().removeTrack(track);this.autoRemoteTextTracks_.removeTrack(track);};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   *\n   * @abstract\n   */Tech.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){return{};};/**\n   * A method to set a poster from a `Tech`.\n   *\n   * @abstract\n   */Tech.prototype.setPoster=function setPoster(){};/**\n   * A method to check for the presence of the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */Tech.prototype.playsinline=function playsinline(){};/**\n   * A method to set or unset the 'playsinine' <video> attribute.\n   *\n   * @abstract\n   */Tech.prototype.setPlaysinline=function setPlaysinline(){};/*\n   * Check if the tech can support the given mime-type.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param  {string} type\n   *         The mimetype to check for support\n   *\n   * @return {string}\n   *         'probably', 'maybe', or empty string\n   *\n   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n   *\n   * @abstract\n   */Tech.prototype.canPlayType=function canPlayType(){return'';};/**\n   * Check if the type is supported by this tech.\n   *\n   * The base tech does not support any type, but source handlers might\n   * overwrite this.\n   *\n   * @param {string} type\n   *        The media type to check\n   * @return {string} Returns the native video element's response\n   */Tech.canPlayType=function canPlayType(){return'';};/**\n   * Check if the tech can support the given source\n   * @param {Object} srcObj\n   *        The source object\n   * @param {Object} options\n   *        The options passed to the tech\n   * @return {string} 'probably', 'maybe', or '' (empty string)\n   */Tech.canPlaySource=function canPlaySource(srcObj,options){return Tech.canPlayType(srcObj.type);};/*\n   * Return whether the argument is a Tech or not.\n   * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n   *\n   * @param {Object} component\n   *        The item to check\n   *\n   * @return {boolean}\n   *         Whether it is a tech or not\n   *         - True if it is a tech\n   *         - False if it is not\n   */Tech.isTech=function isTech(component){return component.prototype instanceof Tech||component instanceof Tech||component===Tech;};/**\n   * Registers a `Tech` into a shared list for videojs.\n   *\n   * @param {string} name\n   *        Name of the `Tech` to register.\n   *\n   * @param {Object} tech\n   *        The `Tech` class to register.\n   */Tech.registerTech=function registerTech(name,tech){if(!Tech.techs_){Tech.techs_={};}if(!Tech.isTech(tech)){throw new Error('Tech '+name+' must be a Tech');}if(!Tech.canPlayType){throw new Error('Techs must have a static canPlayType method on them');}if(!Tech.canPlaySource){throw new Error('Techs must have a static canPlaySource method on them');}name=toTitleCase(name);Tech.techs_[name]=tech;if(name!=='Tech'){// camel case the techName for use in techOrder\nTech.defaultTechOrder_.push(name);}return tech;};/**\n   * Get a `Tech` from the shared list by name.\n   *\n   * @param {string} name\n   *        `camelCase` or `TitleCase` name of the Tech to get\n   *\n   * @return {Tech|undefined}\n   *         The `Tech` or undefined if there was no tech with the name requsted.\n   */Tech.getTech=function getTech(name){if(!name){return;}name=toTitleCase(name);if(Tech.techs_&&Tech.techs_[name]){return Tech.techs_[name];}if(window&&window.videojs&&window.videojs[name]){log$1.warn('The '+name+' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');return window.videojs[name];}};return Tech;}(Component);/**\n * Get the {@link VideoTrackList}\n *\n * @returns {VideoTrackList}\n * @method Tech.prototype.videoTracks\n *//**\n * Get the {@link AudioTrackList}\n *\n * @returns {AudioTrackList}\n * @method Tech.prototype.audioTracks\n *//**\n * Get the {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.textTracks\n *//**\n * Get the remote element {@link TextTrackList}\n *\n * @returns {TextTrackList}\n * @method Tech.prototype.remoteTextTracks\n *//**\n * Get the remote element {@link HtmlTrackElementList}\n *\n * @returns {HtmlTrackElementList}\n * @method Tech.prototype.remoteTextTrackEls\n */ALL.names.forEach(function(name){var props=ALL[name];Tech.prototype[props.getterName]=function(){this[props.privateName]=this[props.privateName]||new props.ListClass();return this[props.privateName];};});/**\n * List of associated text tracks\n *\n * @type {TextTrackList}\n * @private\n * @property Tech#textTracks_\n *//**\n * List of associated audio tracks.\n *\n * @type {AudioTrackList}\n * @private\n * @property Tech#audioTracks_\n *//**\n * List of associated video tracks.\n *\n * @type {VideoTrackList}\n * @private\n * @property Tech#videoTracks_\n *//**\n * Boolean indicating wether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresVolumeControl=true;/**\n * Boolean indicating wether the `Tech` support fullscreen resize control.\n * Resizing plugins using request fullscreen reloads the plugin\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresFullscreenResize=false;/**\n * Boolean indicating wether the `Tech` supports changing the speed at which the video\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresPlaybackRate=false;/**\n * Boolean indicating wether the `Tech` supports the `progress` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualProgressOn} should be called.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresProgressEvents=false;/**\n * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently\n * not triggered by video-js-swf. This will be used to determine if\n * {@link Tech#manualTimeUpdates} should be called.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresTimeupdateEvents=false;/**\n * Boolean indicating wether the `Tech` supports the native `TextTrack`s.\n * This will help us integrate with native `TextTrack`s if the browser supports them.\n *\n * @type {boolean}\n * @default\n */Tech.prototype.featuresNativeTextTracks=false;/**\n * A functional mixin for techs that want to use the Source Handler pattern.\n * Source handlers are scripts for handling specific formats.\n * The source handler pattern is used for adaptive formats (HLS, DASH) that\n * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n * Example: `Tech.withSourceHandlers.call(MyTech);`\n *\n * @param {Tech} _Tech\n *        The tech to add source handler functions to.\n *\n * @mixes Tech~SourceHandlerAdditions\n */Tech.withSourceHandlers=function(_Tech){/**\n   * Register a source handler\n   *\n   * @param {Function} handler\n   *        The source handler class\n   *\n   * @param {number} [index]\n   *        Register it at the following index\n   */_Tech.registerSourceHandler=function(handler,index){var handlers=_Tech.sourceHandlers;if(!handlers){handlers=_Tech.sourceHandlers=[];}if(index===undefined){// add to the end of the list\nindex=handlers.length;}handlers.splice(index,0,handler);};/**\n   * Check if the tech can support the given type. Also checks the\n   * Techs sourceHandlers.\n   *\n   * @param {string} type\n   *         The mimetype to check.\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */_Tech.canPlayType=function(type){var handlers=_Tech.sourceHandlers||[];var can=void 0;for(var i=0;i<handlers.length;i++){can=handlers[i].canPlayType(type);if(can){return can;}}return'';};/**\n   * Returns the first source handler that supports the source.\n   *\n   * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {SourceHandler|null}\n   *          The first source handler that supports the source or null if\n   *          no SourceHandler supports the source\n   */_Tech.selectSourceHandler=function(source,options){var handlers=_Tech.sourceHandlers||[];var can=void 0;for(var i=0;i<handlers.length;i++){can=handlers[i].canHandleSource(source,options);if(can){return handlers[i];}}return null;};/**\n   * Check if the tech can support the given source.\n   *\n   * @param {Tech~SourceObject} srcObj\n   *        The source object\n   *\n   * @param {Object} options\n   *        The options passed to the tech\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */_Tech.canPlaySource=function(srcObj,options){var sh=_Tech.selectSourceHandler(srcObj,options);if(sh){return sh.canHandleSource(srcObj,options);}return'';};/**\n   * When using a source handler, prefer its implementation of\n   * any function normally provided by the tech.\n   */var deferrable=['seekable','duration'];/**\n   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n   * function if it exists, with a fallback to the Techs seekable function.\n   *\n   * @method _Tech.seekable\n   *//**\n   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n   * function if it exists, otherwise it will fallback to the techs duration function.\n   *\n   * @method _Tech.duration\n   */deferrable.forEach(function(fnName){var originalFn=this[fnName];if(typeof originalFn!=='function'){return;}this[fnName]=function(){if(this.sourceHandler_&&this.sourceHandler_[fnName]){return this.sourceHandler_[fnName].apply(this.sourceHandler_,arguments);}return originalFn.apply(this,arguments);};},_Tech.prototype);/**\n   * Create a function for setting the source using a source object\n   * and source handlers.\n   * Should never be called unless a source handler was found.\n   *\n   * @param {Tech~SourceObject} source\n   *        A source object with src and type keys\n   */_Tech.prototype.setSource=function(source){var sh=_Tech.selectSourceHandler(source,this.options_);if(!sh){// Fall back to a native source hander when unsupported sources are\n// deliberately set\nif(_Tech.nativeSourceHandler){sh=_Tech.nativeSourceHandler;}else{log$1.error('No source hander found for the current source.');}}// Dispose any existing source handler\nthis.disposeSourceHandler();this.off('dispose',this.disposeSourceHandler);if(sh!==_Tech.nativeSourceHandler){this.currentSource_=source;}this.sourceHandler_=sh.handleSource(source,this,this.options_);this.on('dispose',this.disposeSourceHandler);};/**\n   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n   *\n   * @listens Tech#dispose\n   */_Tech.prototype.disposeSourceHandler=function(){// if we have a source and get another one\n// then we are loading something new\n// than clear all of our current tracks\nif(this.currentSource_){this.clearTracks(['audio','video']);this.currentSource_=null;}// always clean up auto-text tracks\nthis.cleanupAutoTextTracks();if(this.sourceHandler_){if(this.sourceHandler_.dispose){this.sourceHandler_.dispose();}this.sourceHandler_=null;}};};// The base Tech class needs to be registered as a Component. It is the only\n// Tech that can be registered as a Component.\nComponent.registerComponent('Tech',Tech);Tech.registerTech('Tech',Tech);/**\n * A list of techs that should be added to techOrder on Players\n *\n * @private\n */Tech.defaultTechOrder_=[];var middlewares={};function use(type,middleware){middlewares[type]=middlewares[type]||[];middlewares[type].push(middleware);}function setSource(player,src,next){player.setTimeout(function(){return setSourceHelper(src,middlewares[src.type],next,player);},1);}function setTech(middleware,tech){middleware.forEach(function(mw){return mw.setTech&&mw.setTech(tech);});}function get$1(middleware,tech,method){return middleware.reduceRight(middlewareIterator(method),tech[method]());}function set$1(middleware,tech,method,arg){return tech[method](middleware.reduce(middlewareIterator(method),arg));}var allowedGetters={buffered:1,currentTime:1,duration:1,seekable:1,played:1};var allowedSetters={setCurrentTime:1};function middlewareIterator(method){return function(value,mw){if(mw[method]){return mw[method](value);}return value;};}function setSourceHelper(){var src=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var middleware=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var next=arguments[2];var player=arguments[3];var acc=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];var lastRun=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var mwFactory=middleware[0],mwrest=middleware.slice(1);// if mwFactory is a string, then we're at a fork in the road\nif(typeof mwFactory==='string'){setSourceHelper(src,middlewares[mwFactory],next,player,acc,lastRun);// if we have an mwFactory, call it with the player to get the mw,\n// then call the mw's setSource method\n}else if(mwFactory){var mw=mwFactory(player);mw.setSource(assign({},src),function(err,_src){// something happened, try the next middleware on the current level\n// make sure to use the old src\nif(err){return setSourceHelper(src,mwrest,next,player,acc,lastRun);}// we've succeeded, now we need to go deeper\nacc.push(mw);// if it's the same time, continue does the current chain\n// otherwise, we want to go down the new chain\nsetSourceHelper(_src,src.type===_src.type?mwrest:middlewares[_src.type],next,player,acc,lastRun);});}else if(mwrest.length){setSourceHelper(src,mwrest,next,player,acc,lastRun);}else if(lastRun){next(src,acc);}else{setSourceHelper(src,middlewares['*'],next,player,acc,true);}}/**\n * @module filter-source\n *//**\n * Filter out single bad source objects or multiple source objects in an\n * array. Also flattens nested source object arrays into a 1 dimensional\n * array of source objects.\n *\n * @param {Tech~SourceObject|Tech~SourceObject[]} src\n *        The src object to filter\n *\n * @return {Tech~SourceObject[]}\n *         An array of sourceobjects containing only valid sources\n *\n * @private\n */var filterSource=function filterSource(src){// traverse array\nif(Array.isArray(src)){var newsrc=[];src.forEach(function(srcobj){srcobj=filterSource(srcobj);if(Array.isArray(srcobj)){newsrc=newsrc.concat(srcobj);}else if(isObject(srcobj)){newsrc.push(srcobj);}});src=newsrc;}else if(typeof src==='string'&&src.trim()){// convert string into object\nsrc=[{src:src}];}else if(isObject(src)&&typeof src.src==='string'&&src.src&&src.src.trim()){// src is already valid\nsrc=[src];}else{// invalid source, turn it into an empty array\nsrc=[];}return src;};/**\n * @file loader.js\n *//**\n * The `MediaLoader` is the `Component` that decides which playback technology to load\n * when a player is initialized.\n *\n * @extends Component\n */var MediaLoader=function(_Component){inherits(MediaLoader,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value stroe of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function that is run when this component is ready.\n   */function MediaLoader(player,options,ready){classCallCheck(this,MediaLoader);// MediaLoader has no element\nvar options_=mergeOptions({createEl:false},options);// If there are no sources when the player is initialized,\n// load the first supported playback technology.\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options_,ready));if(!options.playerOptions.sources||options.playerOptions.sources.length===0){for(var i=0,j=options.playerOptions.techOrder;i<j.length;i++){var techName=toTitleCase(j[i]);var tech=Tech.getTech(techName);// Support old behavior of techs being registered as components.\n// Remove once that deprecated behavior is removed.\nif(!techName){tech=Component.getComponent(techName);}// Check if the browser supports this technology\nif(tech&&tech.isSupported()){player.loadTech_(techName);break;}}}else{// Loop through playback technologies (HTML5, Flash) and check for support.\n// Then load the best source.\n// A few assumptions here:\n//   All playback technologies respect preload false.\nplayer.src(options.playerOptions.sources);}return _this;}return MediaLoader;}(Component);Component.registerComponent('MediaLoader',MediaLoader);/**\n * @file button.js\n *//**\n * Clickable Component which is clickable or keyboard actionable,\n * but is not a native HTML button.\n *\n * @extends Component\n */var ClickableComponent=function(_Component){inherits(ClickableComponent,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function ClickableComponent(player,options){classCallCheck(this,ClickableComponent);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.emitTapEvents();_this.enable();return _this;}/**\n   * Create the `Component`s DOM element.\n   *\n   * @param {string} [tag=div]\n   *        The element's node type.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */ClickableComponent.prototype.createEl=function createEl$$1(){var tag=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'div';var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};props=assign({innerHTML:'<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',className:this.buildCSSClass(),tabIndex:0},props);if(tag==='button'){log$1.error('Creating a ClickableComponent with an HTML element of '+tag+' is not supported; use a Button instead.');}// Add ARIA attributes for clickable element which is not a native HTML button\nattributes=assign({'role':'button',// let the screen reader user know that the text of the element may change\n'aria-live':'polite'},attributes);this.tabIndex_=props.tabIndex;var el=_Component.prototype.createEl.call(this,tag,props,attributes);this.createControlTextEl(el);return el;};ClickableComponent.prototype.dispose=function dispose(){// remove controlTextEl_ on dipose\nthis.controlTextEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Create a control text element on this `Component`\n   *\n   * @param {Element} [el]\n   *        Parent element for the control text.\n   *\n   * @return {Element}\n   *         The control text element that gets created.\n   */ClickableComponent.prototype.createControlTextEl=function createControlTextEl(el){this.controlTextEl_=createEl('span',{className:'vjs-control-text'});if(el){el.appendChild(this.controlTextEl_);}this.controlText(this.controlText_,el);return this.controlTextEl_;};/**\n   * Get or set the localize text to use for the controls on the `Component`.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */ClickableComponent.prototype.controlText=function controlText(text){var el=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.el();if(text===undefined){return this.controlText_||'Need Text';}var localizedText=this.localize(text);this.controlText_=text;textContent(this.controlTextEl_,localizedText);if(!this.nonIconControl){// Set title attribute if only an icon is shown\nel.setAttribute('title',localizedText);}};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ClickableComponent.prototype.buildCSSClass=function buildCSSClass(){return'vjs-control vjs-button '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Enable this `Component`s element.\n   */ClickableComponent.prototype.enable=function enable(){if(!this.enabled_){this.enabled_=true;this.removeClass('vjs-disabled');this.el_.setAttribute('aria-disabled','false');if(typeof this.tabIndex_!=='undefined'){this.el_.setAttribute('tabIndex',this.tabIndex_);}this.on(['tap','click'],this.handleClick);this.on('focus',this.handleFocus);this.on('blur',this.handleBlur);}};/**\n   * Disable this `Component`s element.\n   */ClickableComponent.prototype.disable=function disable(){this.enabled_=false;this.addClass('vjs-disabled');this.el_.setAttribute('aria-disabled','true');if(typeof this.tabIndex_!=='undefined'){this.el_.removeAttribute('tabIndex');}this.off(['tap','click'],this.handleClick);this.off('focus',this.handleFocus);this.off('blur',this.handleBlur);};/**\n   * This gets called when a `ClickableComponent` gets:\n   * - Clicked (via the `click` event, listening starts in the constructor)\n   * - Tapped (via the `tap` event, listening starts in the constructor)\n   * - The following things happen in order:\n   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the\n   *      `ClickableComponent`.\n   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using\n   *      {@link ClickableComponent#handleKeyPress}.\n   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses\n   *      the space or enter key.\n   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`\n   *      event as a parameter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @abstract\n   */ClickableComponent.prototype.handleClick=function handleClick(event){};/**\n   * This gets called when a `ClickableComponent` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */ClickableComponent.prototype.handleFocus=function handleFocus(event){on(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Called when this ClickableComponent has focus and a key gets pressed down. By\n   * default it will call `this.handleClick` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */ClickableComponent.prototype.handleKeyPress=function handleKeyPress(event){// Support Space (32) or Enter (13) key operation to fire a click event\nif(event.which===32||event.which===13){event.preventDefault();this.trigger('click');}else if(_Component.prototype.handleKeyPress){// Pass keypress handling up for unsupported keys\n_Component.prototype.handleKeyPress.call(this,event);}};/**\n   * Called when a `ClickableComponent` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */ClickableComponent.prototype.handleBlur=function handleBlur(event){off(document,'keydown',bind(this,this.handleKeyPress));};return ClickableComponent;}(Component);Component.registerComponent('ClickableComponent',ClickableComponent);/**\n * @file poster-image.js\n *//**\n * A `ClickableComponent` that handles showing the poster image for the player.\n *\n * @extends ClickableComponent\n */var PosterImage=function(_ClickableComponent){inherits(PosterImage,_ClickableComponent);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should attach to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PosterImage(player,options){classCallCheck(this,PosterImage);var _this=possibleConstructorReturn(this,_ClickableComponent.call(this,player,options));_this.update();player.on('posterchange',bind(_this,_this.update));return _this;}/**\n   * Clean up and dispose of the `PosterImage`.\n   */PosterImage.prototype.dispose=function dispose(){this.player().off('posterchange',this.update);_ClickableComponent.prototype.dispose.call(this);};/**\n   * Create the `PosterImage`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */PosterImage.prototype.createEl=function createEl$$1(){var el=createEl('div',{className:'vjs-poster',// Don't want poster to be tabbable.\ntabIndex:-1});// To ensure the poster image resizes while maintaining its original aspect\n// ratio, use a div with `background-size` when available. For browsers that\n// do not support `background-size` (e.g. IE8), fall back on using a regular\n// img element.\nif(!BACKGROUND_SIZE_SUPPORTED){this.fallbackImg_=createEl('img');el.appendChild(this.fallbackImg_);}return el;};/**\n   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n   *\n   * @listens Player#posterchange\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `Player#posterchange` event that triggered this function.\n   */PosterImage.prototype.update=function update(event){var url=this.player().poster();this.setSrc(url);// If there's no poster source we should display:none on this component\n// so it's not still clickable or right-clickable\nif(url){this.show();}else{this.hide();}};/**\n   * Set the source of the `PosterImage` depending on the display method.\n   *\n   * @param {string} url\n   *        The URL to the source for the `PosterImage`.\n   */PosterImage.prototype.setSrc=function setSrc(url){if(this.fallbackImg_){this.fallbackImg_.src=url;}else{var backgroundImage='';// Any falsey values should stay as an empty string, otherwise\n// this will throw an extra error\nif(url){backgroundImage='url(\"'+url+'\")';}this.el_.style.backgroundImage=backgroundImage;}};/**\n   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n   * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n   *\n   * @listens tap\n   * @listens click\n   * @listens keydown\n   *\n   * @param {EventTarget~Event} event\n   +        The `click`, `tap` or `keydown` event that caused this function to be called.\n   */PosterImage.prototype.handleClick=function handleClick(event){// We don't want a click to trigger playback when controls are disabled\nif(!this.player_.controls()){return;}if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};return PosterImage;}(ClickableComponent);Component.registerComponent('PosterImage',PosterImage);/**\n * @file text-track-display.js\n */var darkGray='#222';var lightGray='#ccc';var fontMap={monospace:'monospace',sansSerif:'sans-serif',serif:'serif',monospaceSansSerif:'\"Andale Mono\", \"Lucida Console\", monospace',monospaceSerif:'\"Courier New\", monospace',proportionalSansSerif:'sans-serif',proportionalSerif:'serif',casual:'\"Comic Sans MS\", Impact, fantasy',script:'\"Monotype Corsiva\", cursive',smallcaps:'\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'};/**\n * Construct an rgba color from a given hex color code.\n *\n * @param {number} color\n *        Hex number for color, like #f0e.\n *\n * @param {number} opacity\n *        Value for opacity, 0.0 - 1.0.\n *\n * @return {string}\n *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n *\n * @private\n */function constructColor(color,opacity){return'rgba('+// color looks like \"#f0e\"\nparseInt(color[1]+color[1],16)+','+parseInt(color[2]+color[2],16)+','+parseInt(color[3]+color[3],16)+','+opacity+')';}/**\n * Try to update the style of a DOM element. Some style changes will throw an error,\n * particularly in IE8. Those should be noops.\n *\n * @param {Element} el\n *        The DOM element to be styled.\n *\n * @param {string} style\n *        The CSS property on the element that should be styled.\n *\n * @param {string} rule\n *        The style rule that should be applied to the property.\n *\n * @private\n */function tryUpdateStyle(el,style,rule){try{el.style[style]=rule;}catch(e){// Satisfies linter.\nreturn;}}/**\n * The component for displaying text track cues.\n *\n * @extends Component\n */var TextTrackDisplay=function(_Component){inherits(TextTrackDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when `TextTrackDisplay` is ready.\n   */function TextTrackDisplay(player,options,ready){classCallCheck(this,TextTrackDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options,ready));player.on('loadstart',bind(_this,_this.toggleDisplay));player.on('texttrackchange',bind(_this,_this.updateDisplay));player.on('loadstart',bind(_this,_this.preselectTrack));// This used to be called during player init, but was causing an error\n// if a track should show by default and the display hadn't loaded yet.\n// Should probably be moved to an external track loader when we support\n// tracks that don't need a display.\nplayer.ready(bind(_this,function(){if(player.tech_&&player.tech_.featuresNativeTextTracks){this.hide();return;}player.on('fullscreenchange',bind(this,this.updateDisplay));var tracks=this.options_.playerOptions.tracks||[];for(var i=0;i<tracks.length;i++){this.player_.addRemoteTextTrack(tracks[i],true);}this.preselectTrack();}));return _this;}/**\n  * Preselect a track following this precedence:\n  * - matches the previously selected {@link TextTrack}'s language and kind\n  * - matches the previously selected {@link TextTrack}'s language only\n  * - is the first default captions track\n  * - is the first default descriptions track\n  *\n  * @listens Player#loadstart\n  */TextTrackDisplay.prototype.preselectTrack=function preselectTrack(){var modes={captions:1,subtitles:1};var trackList=this.player_.textTracks();var userPref=this.player_.cache_.selectedLanguage;var firstDesc=void 0;var firstCaptions=void 0;var preferredTrack=void 0;for(var i=0;i<trackList.length;i++){var track=trackList[i];if(userPref&&userPref.enabled&&userPref.language===track.language){// Always choose the track that matches both language and kind\nif(track.kind===userPref.kind){preferredTrack=track;// or choose the first track that matches language\n}else if(!preferredTrack){preferredTrack=track;}// clear everything if offTextTrackMenuItem was clicked\n}else if(userPref&&!userPref.enabled){preferredTrack=null;firstDesc=null;firstCaptions=null;}else if(track['default']){if(track.kind==='descriptions'&&!firstDesc){firstDesc=track;}else if(track.kind in modes&&!firstCaptions){firstCaptions=track;}}}// The preferredTrack matches the user preference and takes\n// precendence over all the other tracks.\n// So, display the preferredTrack before the first default track\n// and the subtitles/captions track before the descriptions track\nif(preferredTrack){preferredTrack.mode='showing';}else if(firstCaptions){firstCaptions.mode='showing';}else if(firstDesc){firstDesc.mode='showing';}};/**\n   * Turn display of {@link TextTrack}'s from the current state into the other state.\n   * There are only two states:\n   * - 'shown'\n   * - 'hidden'\n   *\n   * @listens Player#loadstart\n   */TextTrackDisplay.prototype.toggleDisplay=function toggleDisplay(){if(this.player_.tech_&&this.player_.tech_.featuresNativeTextTracks){this.hide();}else{this.show();}};/**\n   * Create the {@link Component}'s DOM element.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TextTrackDisplay.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-text-track-display'},{'aria-live':'off','aria-atomic':'true'});};/**\n   * Clear all displayed {@link TextTrack}s.\n   */TextTrackDisplay.prototype.clearDisplay=function clearDisplay(){if(typeof window.WebVTT==='function'){window.WebVTT.processCues(window,[],this.el_);}};/**\n   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n   * a {@link Player#fullscreenchange} is fired.\n   *\n   * @listens Player#texttrackchange\n   * @listens Player#fullscreenchange\n   */TextTrackDisplay.prototype.updateDisplay=function updateDisplay(){var tracks=this.player_.textTracks();this.clearDisplay();// Track display prioritization model: if multiple tracks are 'showing',\n//  display the first 'subtitles' or 'captions' track which is 'showing',\n//  otherwise display the first 'descriptions' track which is 'showing'\nvar descriptionsTrack=null;var captionsSubtitlesTrack=null;var i=tracks.length;while(i--){var track=tracks[i];if(track.mode==='showing'){if(track.kind==='descriptions'){descriptionsTrack=track;}else{captionsSubtitlesTrack=track;}}}if(captionsSubtitlesTrack){if(this.getAttribute('aria-live')!=='off'){this.setAttribute('aria-live','off');}this.updateForTrack(captionsSubtitlesTrack);}else if(descriptionsTrack){if(this.getAttribute('aria-live')!=='assertive'){this.setAttribute('aria-live','assertive');}this.updateForTrack(descriptionsTrack);}};/**\n   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.\n   *\n   * @param {TextTrack} track\n   *        Text track object to be added to the list.\n   */TextTrackDisplay.prototype.updateForTrack=function updateForTrack(track){if(typeof window.WebVTT!=='function'||!track.activeCues){return;}var overrides=this.player_.textTrackSettings.getValues();var cues=[];for(var _i=0;_i<track.activeCues.length;_i++){cues.push(track.activeCues[_i]);}window.WebVTT.processCues(window,cues,this.el_);var i=cues.length;while(i--){var cue=cues[i];if(!cue){continue;}var cueDiv=cue.displayState;if(overrides.color){cueDiv.firstChild.style.color=overrides.color;}if(overrides.textOpacity){tryUpdateStyle(cueDiv.firstChild,'color',constructColor(overrides.color||'#fff',overrides.textOpacity));}if(overrides.backgroundColor){cueDiv.firstChild.style.backgroundColor=overrides.backgroundColor;}if(overrides.backgroundOpacity){tryUpdateStyle(cueDiv.firstChild,'backgroundColor',constructColor(overrides.backgroundColor||'#000',overrides.backgroundOpacity));}if(overrides.windowColor){if(overrides.windowOpacity){tryUpdateStyle(cueDiv,'backgroundColor',constructColor(overrides.windowColor,overrides.windowOpacity));}else{cueDiv.style.backgroundColor=overrides.windowColor;}}if(overrides.edgeStyle){if(overrides.edgeStyle==='dropshadow'){cueDiv.firstChild.style.textShadow='2px 2px 3px '+darkGray+', 2px 2px 4px '+darkGray+', 2px 2px 5px '+darkGray;}else if(overrides.edgeStyle==='raised'){cueDiv.firstChild.style.textShadow='1px 1px '+darkGray+', 2px 2px '+darkGray+', 3px 3px '+darkGray;}else if(overrides.edgeStyle==='depressed'){cueDiv.firstChild.style.textShadow='1px 1px '+lightGray+', 0 1px '+lightGray+', -1px -1px '+darkGray+', 0 -1px '+darkGray;}else if(overrides.edgeStyle==='uniform'){cueDiv.firstChild.style.textShadow='0 0 4px '+darkGray+', 0 0 4px '+darkGray+', 0 0 4px '+darkGray+', 0 0 4px '+darkGray;}}if(overrides.fontPercent&&overrides.fontPercent!==1){var fontSize=window.parseFloat(cueDiv.style.fontSize);cueDiv.style.fontSize=fontSize*overrides.fontPercent+'px';cueDiv.style.height='auto';cueDiv.style.top='auto';cueDiv.style.bottom='2px';}if(overrides.fontFamily&&overrides.fontFamily!=='default'){if(overrides.fontFamily==='small-caps'){cueDiv.firstChild.style.fontVariant='small-caps';}else{cueDiv.firstChild.style.fontFamily=fontMap[overrides.fontFamily];}}}};return TextTrackDisplay;}(Component);Component.registerComponent('TextTrackDisplay',TextTrackDisplay);/**\n * @file loading-spinner.js\n *//**\n * A loading spinner for use during waiting/loading events.\n *\n * @extends Component\n */var LoadingSpinner=function(_Component){inherits(LoadingSpinner,_Component);function LoadingSpinner(){classCallCheck(this,LoadingSpinner);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `LoadingSpinner`s DOM element.\n   *\n   * @return {Element}\n   *         The dom element that gets created.\n   */LoadingSpinner.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-loading-spinner',dir:'ltr'});};return LoadingSpinner;}(Component);Component.registerComponent('LoadingSpinner',LoadingSpinner);/**\n * @file button.js\n *//**\n * Base class for all buttons.\n *\n * @extends ClickableComponent\n */var Button=function(_ClickableComponent){inherits(Button,_ClickableComponent);function Button(){classCallCheck(this,Button);return possibleConstructorReturn(this,_ClickableComponent.apply(this,arguments));}/**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} [tag=\"button\"]\n   *        The element's node type. This argument is IGNORED: no matter what\n   *        is passed, it will always create a `button` element.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element.\n   *\n   * @param {Object} [attributes={}]\n   *        An object of attributes that should be set on the element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Button.prototype.createEl=function createEl(tag){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};tag='button';props=assign({innerHTML:'<span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>',className:this.buildCSSClass()},props);// Add attributes for button element\nattributes=assign({// Necessary since the default button type is \"submit\"\n'type':'button',// let the screen reader user know that the text of the button may change\n'aria-live':'polite'},attributes);var el=Component.prototype.createEl.call(this,tag,props,attributes);this.createControlTextEl(el);return el;};/**\n   * Add a child `Component` inside of this `Button`.\n   *\n   * @param {string|Component} child\n   *        The name or instance of a child to add.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of options that will get passed to children of\n   *        the child.\n   *\n   * @return {Component}\n   *         The `Component` that gets added as a child. When using a string the\n   *         `Component` will get created by this process.\n   *\n   * @deprecated since version 5\n   */Button.prototype.addChild=function addChild(child){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var className=this.constructor.name;log$1.warn('Adding an actionable (user controllable) child to a Button ('+className+') is not supported; use a ClickableComponent instead.');// Avoid the error message generated by ClickableComponent's addChild method\nreturn Component.prototype.addChild.call(this,child,options);};/**\n   * Enable the `Button` element so that it can be activated or clicked. Use this with\n   * {@link Button#disable}.\n   */Button.prototype.enable=function enable(){_ClickableComponent.prototype.enable.call(this);this.el_.removeAttribute('disabled');};/**\n   * Enable the `Button` element so that it cannot be activated or clicked. Use this with\n   * {@link Button#enable}.\n   */Button.prototype.disable=function disable(){_ClickableComponent.prototype.disable.call(this);this.el_.setAttribute('disabled','disabled');};/**\n   * This gets called when a `Button` has focus and `keydown` is triggered via a key\n   * press.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to get called.\n   *\n   * @listens keydown\n   */Button.prototype.handleKeyPress=function handleKeyPress(event){// Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.\nif(event.which===32||event.which===13){return;}// Pass keypress handling up for unsupported keys\n_ClickableComponent.prototype.handleKeyPress.call(this,event);};return Button;}(ClickableComponent);Component.registerComponent('Button',Button);/**\n * @file big-play-button.js\n *//**\n * The initial play button that shows before the video has played. The hiding of the\n * `BigPlayButton` get done via CSS and `Player` states.\n *\n * @extends Button\n */var BigPlayButton=function(_Button){inherits(BigPlayButton,_Button);function BigPlayButton(player,options){classCallCheck(this,BigPlayButton);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.mouseused_=false;_this.on('mousedown',_this.handleMouseDown);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n   */BigPlayButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-big-play-button';};/**\n   * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */BigPlayButton.prototype.handleClick=function handleClick(event){var playPromise=this.player_.play();// exit early if clicked via the mouse\nif(this.mouseused_&&event.clientX&&event.clientY){return;}var cb=this.player_.getChild('controlBar');var playToggle=cb&&cb.getChild('playToggle');if(!playToggle){this.player_.focus();return;}var playFocus=function playFocus(){return playToggle.focus();};if(isPromise(playPromise)){playPromise.then(playFocus,function(){});}else{this.setTimeout(playFocus,1);}};BigPlayButton.prototype.handleKeyPress=function handleKeyPress(event){this.mouseused_=false;_Button.prototype.handleKeyPress.call(this,event);};BigPlayButton.prototype.handleMouseDown=function handleMouseDown(event){this.mouseused_=true;};return BigPlayButton;}(Button);/**\n * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */BigPlayButton.prototype.controlText_='Play Video';Component.registerComponent('BigPlayButton',BigPlayButton);/**\n * @file close-button.js\n *//**\n * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n * it gets clicked.\n *\n * @extends Button\n */var CloseButton=function(_Button){inherits(CloseButton,_Button);/**\n   * Creates an instance of the this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function CloseButton(player,options){classCallCheck(this,CloseButton);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.controlText(options&&options.controlText||_this.localize('Close'));return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CloseButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-close-button '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when a `CloseButton` gets clicked. See\n   * {@link ClickableComponent#handleClick} for more information on when this will be\n   * triggered\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   * @fires CloseButton#close\n   */CloseButton.prototype.handleClick=function handleClick(event){/**\n     * Triggered when the a `CloseButton` is clicked.\n     *\n     * @event CloseButton#close\n     * @type {EventTarget~Event}\n     *\n     * @property {boolean} [bubbles=false]\n     *           set to false so that the close event does not\n     *           bubble up to parents if there is no listener\n     */this.trigger({type:'close',bubbles:false});};return CloseButton;}(Button);Component.registerComponent('CloseButton',CloseButton);/**\n * @file play-toggle.js\n *//**\n * Button to toggle between play and pause.\n *\n * @extends Button\n */var PlayToggle=function(_Button){inherits(PlayToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlayToggle(player,options){classCallCheck(this,PlayToggle);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.on(player,'play',_this.handlePlay);_this.on(player,'pause',_this.handlePause);_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */PlayToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-play-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when an `PlayToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlayToggle.prototype.handleClick=function handleClick(event){if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};/**\n   * This gets called once after the video has ended and the user seeks so that\n   * we can change the replay button back to a play button.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#seeked\n   */PlayToggle.prototype.handleSeeked=function handleSeeked(event){this.removeClass('vjs-ended');if(this.player_.paused()){this.handlePause(event);}else{this.handlePlay(event);}};/**\n   * Add the vjs-playing class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#play\n   */PlayToggle.prototype.handlePlay=function handlePlay(event){this.removeClass('vjs-ended');this.removeClass('vjs-paused');this.addClass('vjs-playing');// change the button text to \"Pause\"\nthis.controlText('Pause');};/**\n   * Add the vjs-paused class to the element so it can change appearance.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#pause\n   */PlayToggle.prototype.handlePause=function handlePause(event){this.removeClass('vjs-playing');this.addClass('vjs-paused');// change the button text to \"Play\"\nthis.controlText('Play');};/**\n   * Add the vjs-ended class to the element so it can change appearance\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ended\n   */PlayToggle.prototype.handleEnded=function handleEnded(event){this.removeClass('vjs-playing');this.addClass('vjs-ended');// change the button text to \"Replay\"\nthis.controlText('Replay');// on the next seek remove the replay button\nthis.one(this.player_,'seeked',this.handleSeeked);};return PlayToggle;}(Button);/**\n * The text that should display over the `PlayToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlayToggle.prototype.controlText_='Play';Component.registerComponent('PlayToggle',PlayToggle);/**\n * @file format-time.js\n * @module Format-time\n *//**\n * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)\n * will force a number of leading zeros to cover the length of the guide.\n *\n * @param {number} seconds\n *        Number of seconds to be turned into a string\n *\n * @param {number} guide\n *        Number (in seconds) to model the string after\n *\n * @return {string}\n *         Time formatted as H:MM:SS or M:SS\n */function formatTime(seconds){var guide=arguments.length>1&&arguments[1]!==undefined?arguments[1]:seconds;seconds=seconds<0?0:seconds;var s=Math.floor(seconds%60);var m=Math.floor(seconds/60%60);var h=Math.floor(seconds/3600);var gm=Math.floor(guide/60%60);var gh=Math.floor(guide/3600);// handle invalid times\nif(isNaN(seconds)||seconds===Infinity){// '-' is false for all relational operators (e.g. <, >=) so this setting\n// will add the minimum number of fields specified by the guide\nh=m=s='-';}// Check if we need to show hours\nh=h>0||gh>0?h+':':'';// If hours are showing, we may need to add a leading zero.\n// Always show at least one digit of minutes.\nm=((h||gm>=10)&&m<10?'0'+m:m)+':';// Check if leading zero is need for seconds\ns=s<10?'0'+s:s;return h+m+s;}/**\n * @file time-display.js\n *//**\n * Displays the time left in the video\n *\n * @extends Component\n */var TimeDisplay=function(_Component){inherits(TimeDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TimeDisplay(player,options){classCallCheck(this,TimeDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.throttledUpdateContent=throttle(bind(_this,_this.updateContent),25);_this.on(player,'timeupdate',_this.throttledUpdateContent);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeDisplay.prototype.createEl=function createEl$$1(plainName){var className=this.buildCSSClass();var el=_Component.prototype.createEl.call(this,'div',{className:className+' vjs-time-control vjs-control'});this.contentEl_=createEl('div',{className:className+'-display'},{// tell screen readers not to automatically read the time as it changes\n'aria-live':'off'},createEl('span',{className:'vjs-control-text',textContent:this.localize(this.controlText_)}));this.updateTextNode_();el.appendChild(this.contentEl_);return el;};TimeDisplay.prototype.dispose=function dispose(){this.contentEl_=null;this.textNode_=null;_Component.prototype.dispose.call(this);};/**\n   * Updates the \"remaining time\" text node with new content using the\n   * contents of the `formattedTime_` property.\n   *\n   * @private\n   */TimeDisplay.prototype.updateTextNode_=function updateTextNode_(){if(!this.contentEl_){return;}while(this.contentEl_.firstChild){this.contentEl_.removeChild(this.contentEl_.firstChild);}this.textNode_=document.createTextNode(this.formattedTime_||'0:00');this.contentEl_.appendChild(this.textNode_);};/**\n   * Generates a formatted time for this component to use in display.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */TimeDisplay.prototype.formatTime_=function formatTime_(time){return formatTime(time);};/**\n   * Updates the time display text node if it has what was passed in changed\n   * the formatted time.\n   *\n   * @param {number} time\n   *        The time to update to\n   *\n   * @private\n   */TimeDisplay.prototype.updateFormattedTime_=function updateFormattedTime_(time){var formattedTime=this.formatTime_(time);if(formattedTime===this.formattedTime_){return;}this.formattedTime_=formattedTime;this.requestAnimationFrame(this.updateTextNode_);};/**\n   * To be filled out in the child class, should update the displayed time\n   * in accordance with the fact that the current time has changed.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate`  event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   */TimeDisplay.prototype.updateContent=function updateContent(event){};return TimeDisplay;}(Component);/**\n * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */TimeDisplay.prototype.controlText_='Time';Component.registerComponent('TimeDisplay',TimeDisplay);/**\n * @file current-time-display.js\n *//**\n * Displays the current time\n *\n * @extends Component\n */var CurrentTimeDisplay=function(_TimeDisplay){inherits(CurrentTimeDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function CurrentTimeDisplay(player,options){classCallCheck(this,CurrentTimeDisplay);var _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CurrentTimeDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-current-time';};/**\n   * Update current time display\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` event that caused this function to run.\n   *\n   * @listens Player#timeupdate\n   */CurrentTimeDisplay.prototype.updateContent=function updateContent(event){// Allows for smooth scrubbing, when player can't keep up.\nvar time=this.player_.scrubbing()?this.player_.getCache().currentTime:this.player_.currentTime();this.updateFormattedTime_(time);};/**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */CurrentTimeDisplay.prototype.handleEnded=function handleEnded(event){if(!this.player_.duration()){return;}this.updateFormattedTime_(this.player_.duration());};return CurrentTimeDisplay;}(TimeDisplay);/**\n * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */CurrentTimeDisplay.prototype.controlText_='Current Time';Component.registerComponent('CurrentTimeDisplay',CurrentTimeDisplay);/**\n * @file duration-display.js\n *//**\n * Displays the duration\n *\n * @extends Component\n */var DurationDisplay=function(_TimeDisplay){inherits(DurationDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function DurationDisplay(player,options){classCallCheck(this,DurationDisplay);// we do not want to/need to throttle duration changes,\n// as they should always display the changed duration as\n// it has changed\nvar _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'durationchange',_this.updateContent);// Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n// listeners could have broken dependent applications/libraries. These\n// can likely be removed for 7.0.\n_this.on(player,'loadedmetadata',_this.throttledUpdateContent);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */DurationDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-duration';};/**\n   * Update duration time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n   *        this function to be called.\n   *\n   * @listens Player#durationchange\n   * @listens Player#timeupdate\n   * @listens Player#loadedmetadata\n   */DurationDisplay.prototype.updateContent=function updateContent(event){var duration=this.player_.duration();if(duration&&this.duration_!==duration){this.duration_=duration;this.updateFormattedTime_(duration);}};return DurationDisplay;}(TimeDisplay);/**\n * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */DurationDisplay.prototype.controlText_='Duration Time';Component.registerComponent('DurationDisplay',DurationDisplay);/**\n * @file time-divider.js\n *//**\n * The separator between the current time and duration.\n * Can be hidden if it's not needed in the design.\n *\n * @extends Component\n */var TimeDivider=function(_Component){inherits(TimeDivider,_Component);function TimeDivider(){classCallCheck(this,TimeDivider);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the component's DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeDivider.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-time-control vjs-time-divider',innerHTML:'<div><span>/</span></div>'});};return TimeDivider;}(Component);Component.registerComponent('TimeDivider',TimeDivider);/**\n * @file remaining-time-display.js\n *//**\n * Displays the time left in the video\n *\n * @extends Component\n */var RemainingTimeDisplay=function(_TimeDisplay){inherits(RemainingTimeDisplay,_TimeDisplay);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function RemainingTimeDisplay(player,options){classCallCheck(this,RemainingTimeDisplay);var _this=possibleConstructorReturn(this,_TimeDisplay.call(this,player,options));_this.on(player,'durationchange',_this.throttledUpdateContent);_this.on(player,'ended',_this.handleEnded);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */RemainingTimeDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-remaining-time';};/**\n   * The remaining time display prefixes numbers with a \"minus\" character.\n   *\n   * @param  {number} time\n   *         A numeric time, in seconds.\n   *\n   * @return {string}\n   *         A formatted time\n   *\n   * @private\n   */RemainingTimeDisplay.prototype.formatTime_=function formatTime_(time){return'-'+_TimeDisplay.prototype.formatTime_.call(this,time);};/**\n   * Update remaining time display.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `durationchange` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   * @listens Player#durationchange\n   */RemainingTimeDisplay.prototype.updateContent=function updateContent(event){if(!this.player_.duration()){return;}// @deprecated We should only use remainingTimeDisplay\n// as of video.js 7\nif(this.player_.remainingTimeDisplay){this.updateFormattedTime_(this.player_.remainingTimeDisplay());}else{this.updateFormattedTime_(this.player_.remainingTime());}};/**\n   * When the player fires ended there should be no time left. Sadly\n   * this is not always the case, lets make it seem like that is the case\n   * for users.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */RemainingTimeDisplay.prototype.handleEnded=function handleEnded(event){if(!this.player_.duration()){return;}this.updateFormattedTime_(0);};return RemainingTimeDisplay;}(TimeDisplay);/**\n * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n *\n * @type {string}\n * @private\n */RemainingTimeDisplay.prototype.controlText_='Remaining Time';Component.registerComponent('RemainingTimeDisplay',RemainingTimeDisplay);/**\n * @file live-display.js\n */// TODO - Future make it click to snap to live\n/**\n * Displays the live indicator when duration is Infinity.\n *\n * @extends Component\n */var LiveDisplay=function(_Component){inherits(LiveDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function LiveDisplay(player,options){classCallCheck(this,LiveDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.updateShowing();_this.on(_this.player(),'durationchange',_this.updateShowing);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */LiveDisplay.prototype.createEl=function createEl$$1(){var el=_Component.prototype.createEl.call(this,'div',{className:'vjs-live-control vjs-control'});this.contentEl_=createEl('div',{className:'vjs-live-display',innerHTML:'<span class=\"vjs-control-text\">'+this.localize('Stream Type')+'</span>'+this.localize('LIVE')},{'aria-live':'off'});el.appendChild(this.contentEl_);return el;};LiveDisplay.prototype.dispose=function dispose(){this.contentEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n   * it accordingly\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#durationchange} event that caused this function to run.\n   *\n   * @listens Player#durationchange\n   */LiveDisplay.prototype.updateShowing=function updateShowing(event){if(this.player().duration()===Infinity){this.show();}else{this.hide();}};return LiveDisplay;}(Component);Component.registerComponent('LiveDisplay',LiveDisplay);/**\n * @file slider.js\n *//**\n * The base functionality for a slider. Can be vertical or horizontal.\n * For instance the volume bar or the seek bar on a video is a slider.\n *\n * @extends Component\n */var Slider=function(_Component){inherits(Slider,_Component);/**\n   * Create an instance of this class\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function Slider(player,options){classCallCheck(this,Slider);// Set property names to bar to match with the child Slider class is looking for\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.bar=_this.getChild(_this.options_.barName);// Set a horizontal or vertical class on the slider depending on the slider type\n_this.vertical(!!_this.options_.vertical);_this.enable();return _this;}/**\n   * Are controls are currently enabled for this slider or not.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */Slider.prototype.enabled=function enabled(){return this.enabled_;};/**\n   * Enable controls for this slider if they are disabled\n   */Slider.prototype.enable=function enable(){if(this.enabled()){return;}this.on('mousedown',this.handleMouseDown);this.on('touchstart',this.handleMouseDown);this.on('focus',this.handleFocus);this.on('blur',this.handleBlur);this.on('click',this.handleClick);this.on(this.player_,'controlsvisible',this.update);if(this.playerEvent){this.on(this.player_,this.playerEvent,this.update);}this.removeClass('disabled');this.setAttribute('tabindex',0);this.enabled_=true;};/**\n   * Disable controls for this slider if they are enabled\n   */Slider.prototype.disable=function disable(){if(!this.enabled()){return;}var doc=this.bar.el_.ownerDocument;this.off('mousedown',this.handleMouseDown);this.off('touchstart',this.handleMouseDown);this.off('focus',this.handleFocus);this.off('blur',this.handleBlur);this.off('click',this.handleClick);this.off(this.player_,'controlsvisible',this.update);this.off(doc,'mousemove',this.handleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchmove',this.handleMouseMove);this.off(doc,'touchend',this.handleMouseUp);this.removeAttribute('tabindex');this.addClass('disabled');if(this.playerEvent){this.off(this.player_,this.playerEvent,this.update);}this.enabled_=false;};/**\n   * Create the `Button`s DOM element.\n   *\n   * @param {string} type\n   *        Type of element to create.\n   *\n   * @param {Object} [props={}]\n   *        List of properties in Object form.\n   *\n   * @param {Object} [attributes={}]\n   *        list of attributes in Object form.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Slider.prototype.createEl=function createEl$$1(type){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var attributes=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};// Add the slider element class to all sub classes\nprops.className=props.className+' vjs-slider';props=assign({tabIndex:0},props);attributes=assign({'role':'slider','aria-valuenow':0,'aria-valuemin':0,'aria-valuemax':100,'tabIndex':0},attributes);return _Component.prototype.createEl.call(this,type,props,attributes);};/**\n   * Handle `mousedown` or `touchstart` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   * @fires Slider#slideractive\n   */Slider.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.bar.el_.ownerDocument;event.preventDefault();blockTextSelection();this.addClass('vjs-sliding');/**\n     * Triggered when the slider is in an active state\n     *\n     * @event Slider#slideractive\n     * @type {EventTarget~Event}\n     */this.trigger('slideractive');this.on(doc,'mousemove',this.handleMouseMove);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchmove',this.handleMouseMove);this.on(doc,'touchend',this.handleMouseUp);this.handleMouseMove(event);};/**\n   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n   * The `mousemove` and `touchmove` events will only only trigger this function during\n   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n   * {@link Slider#handleMouseUp}.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n   *        this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */Slider.prototype.handleMouseMove=function handleMouseMove(event){};/**\n   * Handle `mouseup` or `touchend` events on the `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   * @fires Slider#sliderinactive\n   */Slider.prototype.handleMouseUp=function handleMouseUp(){var doc=this.bar.el_.ownerDocument;unblockTextSelection();this.removeClass('vjs-sliding');/**\n     * Triggered when the slider is no longer in an active state.\n     *\n     * @event Slider#sliderinactive\n     * @type {EventTarget~Event}\n     */this.trigger('sliderinactive');this.off(doc,'mousemove',this.handleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchmove',this.handleMouseMove);this.off(doc,'touchend',this.handleMouseUp);this.update();};/**\n   * Update the progress bar of the `Slider`.\n   *\n   * @returns {number}\n   *          The percentage of progress the progress bar represents as a\n   *          number from 0 to 1.\n   */Slider.prototype.update=function update(){// In VolumeBar init we have a setTimeout for update that pops and update\n// to the end of the execution stack. The player is destroyed before then\n// update will cause an error\nif(!this.el_){return;}// If scrubbing, we could use a cached value to make the handle keep up\n// with the user's mouse. On HTML5 browsers scrubbing is really smooth, but\n// some flash players are slow, so we might want to utilize this later.\n// var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\nvar progress=this.getPercent();var bar=this.bar;// If there's no bar...\nif(!bar){return;}// Protect against no duration and other division issues\nif(typeof progress!=='number'||progress!==progress||progress<0||progress===Infinity){progress=0;}// Convert to a percentage for setting\nvar percentage=(progress*100).toFixed(2)+'%';var style=bar.el().style;// Set the new bar width or height\nif(this.vertical()){style.height=percentage;}else{style.width=percentage;}return progress;};/**\n   * Calculate distance for slider\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @return {number}\n   *         The current position of the Slider.\n   *         - postition.x for vertical `Slider`s\n   *         - postition.y for horizontal `Slider`s\n   */Slider.prototype.calculateDistance=function calculateDistance(event){var position=getPointerPosition(this.el_,event);if(this.vertical()){return position.y;}return position.x;};/**\n   * Handle a `focus` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to run.\n   *\n   * @listens focus\n   */Slider.prototype.handleFocus=function handleFocus(){this.on(this.bar.el_.ownerDocument,'keydown',this.handleKeyPress);};/**\n   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down\n   * arrow keys. This function will only be called when the slider has focus. See\n   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n   *\n   * @param {EventTarget~Event} event\n   *        the `keydown` event that caused this function to run.\n   *\n   * @listens keydown\n   */Slider.prototype.handleKeyPress=function handleKeyPress(event){// Left and Down Arrows\nif(event.which===37||event.which===40){event.preventDefault();this.stepBack();// Up and Right Arrows\n}else if(event.which===38||event.which===39){event.preventDefault();this.stepForward();}};/**\n   * Handle a `blur` event on this `Slider`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to run.\n   *\n   * @listens blur\n   */Slider.prototype.handleBlur=function handleBlur(){this.off(this.bar.el_.ownerDocument,'keydown',this.handleKeyPress);};/**\n   * Listener for click events on slider, used to prevent clicks\n   *   from bubbling up to parent elements like button menus.\n   *\n   * @param {Object} event\n   *        Event that caused this object to run\n   */Slider.prototype.handleClick=function handleClick(event){event.stopImmediatePropagation();event.preventDefault();};/**\n   * Get/set if slider is horizontal for vertical\n   *\n   * @param {boolean} [bool]\n   *        - true if slider is vertical,\n   *        - false is horizontal\n   *\n   * @return {boolean}\n   *         - true if slider is vertical, and getting\n   *         - false if the slider is horizontal, and getting\n   */Slider.prototype.vertical=function vertical(bool){if(bool===undefined){return this.vertical_||false;}this.vertical_=!!bool;if(this.vertical_){this.addClass('vjs-slider-vertical');}else{this.addClass('vjs-slider-horizontal');}};return Slider;}(Component);Component.registerComponent('Slider',Slider);/**\n * @file load-progress-bar.js\n *//**\n * Shows loading progress\n *\n * @extends Component\n */var LoadProgressBar=function(_Component){inherits(LoadProgressBar,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function LoadProgressBar(player,options){classCallCheck(this,LoadProgressBar);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.partEls_=[];_this.on(player,'progress',_this.update);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */LoadProgressBar.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-load-progress',innerHTML:'<span class=\"vjs-control-text\"><span>'+this.localize('Loaded')+'</span>: 0%</span>'});};LoadProgressBar.prototype.dispose=function dispose(){this.partEls_=null;_Component.prototype.dispose.call(this);};/**\n   * Update progress bar\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `progress` event that caused this function to run.\n   *\n   * @listens Player#progress\n   */LoadProgressBar.prototype.update=function update(event){var buffered=this.player_.buffered();var duration=this.player_.duration();var bufferedEnd=this.player_.bufferedEnd();var children=this.partEls_;// get the percent width of a time compared to the total end\nvar percentify=function percentify(time,end){// no NaN\nvar percent=time/end||0;return(percent>=1?1:percent)*100+'%';};// update the width of the progress bar\nthis.el_.style.width=percentify(bufferedEnd,duration);// add child elements to represent the individual buffered time ranges\nfor(var i=0;i<buffered.length;i++){var start=buffered.start(i);var end=buffered.end(i);var part=children[i];if(!part){part=this.el_.appendChild(createEl());children[i]=part;}// set the percent based on the width of the progress bar (bufferedEnd)\npart.style.left=percentify(start,bufferedEnd);part.style.width=percentify(end-start,bufferedEnd);}// remove unused buffered range elements\nfor(var _i=children.length;_i>buffered.length;_i--){this.el_.removeChild(children[_i-1]);}children.length=buffered.length;};return LoadProgressBar;}(Component);Component.registerComponent('LoadProgressBar',LoadProgressBar);/**\n * @file time-tooltip.js\n *//**\n * Time tooltips display a time above the progress bar.\n *\n * @extends Component\n */var TimeTooltip=function(_Component){inherits(TimeTooltip,_Component);function TimeTooltip(){classCallCheck(this,TimeTooltip);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the time tooltip DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */TimeTooltip.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-time-tooltip'});};/**\n   * Updates the position of the time tooltip relative to the `SeekBar`.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */TimeTooltip.prototype.update=function update(seekBarRect,seekBarPoint,content){var tooltipRect=getBoundingClientRect(this.el_);var playerRect=getBoundingClientRect(this.player_.el());var seekBarPointPx=seekBarRect.width*seekBarPoint;// do nothing if either rect isn't available\n// for example, if the player isn't in the DOM for testing\nif(!playerRect||!tooltipRect){return;}// This is the space left of the `seekBarPoint` available within the bounds\n// of the player. We calculate any gap between the left edge of the player\n// and the left edge of the `SeekBar` and add the number of pixels in the\n// `SeekBar` before hitting the `seekBarPoint`\nvar spaceLeftOfPoint=seekBarRect.left-playerRect.left+seekBarPointPx;// This is the space right of the `seekBarPoint` available within the bounds\n// of the player. We calculate the number of pixels from the `seekBarPoint`\n// to the right edge of the `SeekBar` and add to that any gap between the\n// right edge of the `SeekBar` and the player.\nvar spaceRightOfPoint=seekBarRect.width-seekBarPointPx+(playerRect.right-seekBarRect.right);// This is the number of pixels by which the tooltip will need to be pulled\n// further to the right to center it over the `seekBarPoint`.\nvar pullTooltipBy=tooltipRect.width/2;// Adjust the `pullTooltipBy` distance to the left or right depending on\n// the results of the space calculations above.\nif(spaceLeftOfPoint<pullTooltipBy){pullTooltipBy+=pullTooltipBy-spaceLeftOfPoint;}else if(spaceRightOfPoint<pullTooltipBy){pullTooltipBy=spaceRightOfPoint;}// Due to the imprecision of decimal/ratio based calculations and varying\n// rounding behaviors, there are cases where the spacing adjustment is off\n// by a pixel or two. This adds insurance to these calculations.\nif(pullTooltipBy<0){pullTooltipBy=0;}else if(pullTooltipBy>tooltipRect.width){pullTooltipBy=tooltipRect.width;}this.el_.style.right='-'+pullTooltipBy+'px';textContent(this.el_,content);};return TimeTooltip;}(Component);Component.registerComponent('TimeTooltip',TimeTooltip);/**\n * @file play-progress-bar.js\n *//**\n * Used by {@link SeekBar} to display media playback progress as part of the\n * {@link ProgressControl}.\n *\n * @extends Component\n */var PlayProgressBar=function(_Component){inherits(PlayProgressBar,_Component);function PlayProgressBar(){classCallCheck(this,PlayProgressBar);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */PlayProgressBar.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-play-progress vjs-slider-bar',innerHTML:'<span class=\"vjs-control-text\"><span>'+this.localize('Progress')+'</span>: 0%</span>'});};/**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */PlayProgressBar.prototype.update=function update(seekBarRect,seekBarPoint){var _this2=this;// If there is an existing rAF ID, cancel it so we don't over-queue.\nif(this.rafId_){this.cancelAnimationFrame(this.rafId_);}this.rafId_=this.requestAnimationFrame(function(){var time=_this2.player_.scrubbing()?_this2.player_.getCache().currentTime:_this2.player_.currentTime();var content=formatTime(time,_this2.player_.duration());var timeTooltip=_this2.getChild('timeTooltip');if(timeTooltip){timeTooltip.update(seekBarRect,seekBarPoint,content);}});};return PlayProgressBar;}(Component);/**\n * Default options for {@link PlayProgressBar}.\n *\n * @type {Object}\n * @private\n */PlayProgressBar.prototype.options_={children:[]};// Time tooltips should not be added to a player on mobile devices or IE8\nif((!IE_VERSION||IE_VERSION>8)&&!IS_IOS&&!IS_ANDROID){PlayProgressBar.prototype.options_.children.push('timeTooltip');}Component.registerComponent('PlayProgressBar',PlayProgressBar);/**\n * @file mouse-time-display.js\n *//**\n * The {@link MouseTimeDisplay} component tracks mouse movement over the\n * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n * indicating the time which is represented by a given point in the\n * {@link ProgressControl}.\n *\n * @extends Component\n */var MouseTimeDisplay=function(_Component){inherits(MouseTimeDisplay,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The {@link Player} that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function MouseTimeDisplay(player,options){classCallCheck(this,MouseTimeDisplay);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.update=throttle(bind(_this,_this.update),25);return _this;}/**\n   * Create the DOM element for this class.\n   *\n   * @return {Element}\n   *         The element that was created.\n   */MouseTimeDisplay.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-mouse-display'});};/**\n   * Enqueues updates to its own DOM as well as the DOM of its\n   * {@link TimeTooltip} child.\n   *\n   * @param {Object} seekBarRect\n   *        The `ClientRect` for the {@link SeekBar} element.\n   *\n   * @param {number} seekBarPoint\n   *        A number from 0 to 1, representing a horizontal reference point\n   *        from the left edge of the {@link SeekBar}\n   */MouseTimeDisplay.prototype.update=function update(seekBarRect,seekBarPoint){var _this2=this;// If there is an existing rAF ID, cancel it so we don't over-queue.\nif(this.rafId_){this.cancelAnimationFrame(this.rafId_);}this.rafId_=this.requestAnimationFrame(function(){var duration=_this2.player_.duration();var content=formatTime(seekBarPoint*duration,duration);_this2.el_.style.left=seekBarRect.width*seekBarPoint+'px';_this2.getChild('timeTooltip').update(seekBarRect,seekBarPoint,content);});};return MouseTimeDisplay;}(Component);/**\n * Default options for `MouseTimeDisplay`\n *\n * @type {Object}\n * @private\n */MouseTimeDisplay.prototype.options_={children:['timeTooltip']};Component.registerComponent('MouseTimeDisplay',MouseTimeDisplay);/**\n * @file seek-bar.js\n */// The number of seconds the `step*` functions move the timeline.\nvar STEP_SECONDS=5;// The interval at which the bar should update as it progresses.\nvar UPDATE_REFRESH_INTERVAL=30;/**\n * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n * as its `bar`.\n *\n * @extends Slider\n */var SeekBar=function(_Slider){inherits(SeekBar,_Slider);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function SeekBar(player,options){classCallCheck(this,SeekBar);var _this=possibleConstructorReturn(this,_Slider.call(this,player,options));_this.update=throttle(bind(_this,_this.update),UPDATE_REFRESH_INTERVAL);_this.on(player,'timeupdate',_this.update);_this.on(player,'ended',_this.handleEnded);// when playing, let's ensure we smoothly update the play progress bar\n// via an interval\n_this.updateInterval=null;_this.on(player,['playing'],function(){_this.clearInterval(_this.updateInterval);_this.updateInterval=_this.setInterval(function(){_this.requestAnimationFrame(function(){_this.update();});},UPDATE_REFRESH_INTERVAL);});_this.on(player,['ended','pause','waiting'],function(){_this.clearInterval(_this.updateInterval);});_this.on(player,['timeupdate','ended'],_this.update);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */SeekBar.prototype.createEl=function createEl$$1(){return _Slider.prototype.createEl.call(this,'div',{className:'vjs-progress-holder'},{'aria-label':this.localize('Progress Bar')});};/**\n   * This function updates the play progress bar and accessiblity\n   * attributes to whatever is passed in.\n   *\n   * @param {number} currentTime\n   *        The currentTime value that should be used for accessiblity\n   *\n   * @param {number} percent\n   *        The percentage as a decimal that the bar should be filled from 0-1.\n   *\n   * @private\n   */SeekBar.prototype.update_=function update_(currentTime,percent){var duration=this.player_.duration();// machine readable value of progress bar (percentage complete)\nthis.el_.setAttribute('aria-valuenow',(percent*100).toFixed(2));// human readable value of progress bar (time complete)\nthis.el_.setAttribute('aria-valuetext',this.localize('progress bar timing: currentTime={1} duration={2}',[formatTime(currentTime,duration),formatTime(duration,duration)],'{1} of {2}'));// Update the `PlayProgressBar`.\nthis.bar.update(getBoundingClientRect(this.el_),percent);};/**\n   * Update the seek bar's UI.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#timeupdate\n   *\n   * @returns {number}\n   *          The current percent at a number from 0-1\n   */SeekBar.prototype.update=function update(event){var percent=_Slider.prototype.update.call(this);this.update_(this.getCurrentTime_(),percent);return percent;};/**\n   * Get the value of current time but allows for smooth scrubbing,\n   * when player can't keep up.\n   *\n   * @return {number}\n   *         The current time value to display\n   *\n   * @private\n   */SeekBar.prototype.getCurrentTime_=function getCurrentTime_(){return this.player_.scrubbing()?this.player_.getCache().currentTime:this.player_.currentTime();};/**\n   * We want the seek bar to be full on ended\n   * no matter what the actual internal values are. so we force it.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `timeupdate` or `ended` event that caused this to run.\n   *\n   * @listens Player#ended\n   */SeekBar.prototype.handleEnded=function handleEnded(event){this.update_(this.player_.duration(),1);};/**\n   * Get the percentage of media played so far.\n   *\n   * @return {number}\n   *         The percentage of media played so far (0 to 1).\n   */SeekBar.prototype.getPercent=function getPercent(){var percent=this.getCurrentTime_()/this.player_.duration();return percent>=1?1:percent;};/**\n   * Handle mouse down on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */SeekBar.prototype.handleMouseDown=function handleMouseDown(event){if(!isSingleLeftClick(event)){return;}this.player_.scrubbing(true);this.videoWasPlaying=!this.player_.paused();this.player_.pause();_Slider.prototype.handleMouseDown.call(this,event);};/**\n   * Handle mouse move on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this to run.\n   *\n   * @listens mousemove\n   */SeekBar.prototype.handleMouseMove=function handleMouseMove(event){if(!isSingleLeftClick(event)){return;}var newTime=this.calculateDistance(event)*this.player_.duration();// Don't let video end while scrubbing.\nif(newTime===this.player_.duration()){newTime=newTime-0.1;}// Set new time (tell player to seek to new time)\nthis.player_.currentTime(newTime);};SeekBar.prototype.enable=function enable(){_Slider.prototype.enable.call(this);var mouseTimeDisplay=this.getChild('mouseTimeDisplay');if(!mouseTimeDisplay){return;}mouseTimeDisplay.show();};SeekBar.prototype.disable=function disable(){_Slider.prototype.disable.call(this);var mouseTimeDisplay=this.getChild('mouseTimeDisplay');if(!mouseTimeDisplay){return;}mouseTimeDisplay.hide();};/**\n   * Handle mouse up on seek bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mouseup` event that caused this to run.\n   *\n   * @listens mouseup\n   */SeekBar.prototype.handleMouseUp=function handleMouseUp(event){_Slider.prototype.handleMouseUp.call(this,event);this.player_.scrubbing(false);/**\n     * Trigger timeupdate because we're done seeking and the time has changed.\n     * This is particularly useful for if the player is paused to time the time displays.\n     *\n     * @event Tech#timeupdate\n     * @type {EventTarget~Event}\n     */this.player_.trigger({type:'timeupdate',target:this,manuallyTriggered:true});if(this.videoWasPlaying){this.player_.play();}};/**\n   * Move more quickly fast forward for keyboard-only users\n   */SeekBar.prototype.stepForward=function stepForward(){this.player_.currentTime(this.player_.currentTime()+STEP_SECONDS);};/**\n   * Move more quickly rewind for keyboard-only users\n   */SeekBar.prototype.stepBack=function stepBack(){this.player_.currentTime(this.player_.currentTime()-STEP_SECONDS);};/**\n   * Toggles the playback state of the player\n   * This gets called when enter or space is used on the seekbar\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called\n   *\n   */SeekBar.prototype.handleAction=function handleAction(event){if(this.player_.paused()){this.player_.play();}else{this.player_.pause();}};/**\n   * Called when this SeekBar has focus and a key gets pressed down. By\n   * default it will call `this.handleAction` when the key is space or enter.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */SeekBar.prototype.handleKeyPress=function handleKeyPress(event){// Support Space (32) or Enter (13) key operation to fire a click event\nif(event.which===32||event.which===13){event.preventDefault();this.handleAction(event);}else if(_Slider.prototype.handleKeyPress){// Pass keypress handling up for unsupported keys\n_Slider.prototype.handleKeyPress.call(this,event);}};return SeekBar;}(Slider);/**\n * Default options for the `SeekBar`\n *\n * @type {Object}\n * @private\n */SeekBar.prototype.options_={children:['loadProgressBar','playProgressBar'],barName:'playProgressBar'};// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8\nif((!IE_VERSION||IE_VERSION>8)&&!IS_IOS&&!IS_ANDROID){SeekBar.prototype.options_.children.splice(1,0,'mouseTimeDisplay');}/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */SeekBar.prototype.playerEvent='timeupdate';Component.registerComponent('SeekBar',SeekBar);/**\n * @file progress-control.js\n *//**\n * The Progress Control component contains the seek bar, load progress,\n * and play progress.\n *\n * @extends Component\n */var ProgressControl=function(_Component){inherits(ProgressControl,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function ProgressControl(player,options){classCallCheck(this,ProgressControl);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.handleMouseMove=throttle(bind(_this,_this.handleMouseMove),25);_this.throttledHandleMouseSeek=throttle(bind(_this,_this.handleMouseSeek),25);_this.enable();return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */ProgressControl.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-progress-control vjs-control'});};/**\n   * When the mouse moves over the `ProgressControl`, the pointer position\n   * gets passed down to the `MouseTimeDisplay` component.\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   */ProgressControl.prototype.handleMouseMove=function handleMouseMove(event){var seekBar=this.getChild('seekBar');var mouseTimeDisplay=seekBar.getChild('mouseTimeDisplay');var seekBarEl=seekBar.el();var seekBarRect=getBoundingClientRect(seekBarEl);var seekBarPoint=getPointerPosition(seekBarEl,event).x;// The default skin has a gap on either side of the `SeekBar`. This means\n// that it's possible to trigger this behavior outside the boundaries of\n// the `SeekBar`. This ensures we stay within it at all times.\nif(seekBarPoint>1){seekBarPoint=1;}else if(seekBarPoint<0){seekBarPoint=0;}if(mouseTimeDisplay){mouseTimeDisplay.update(seekBarRect,seekBarPoint);}};/**\n   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n   *\n   * @method ProgressControl#throttledHandleMouseSeek\n   * @param {EventTarget~Event} event\n   *        The `mousemove` event that caused this function to run.\n   *\n   * @listen mousemove\n   * @listen touchmove\n   *//**\n   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousemove\n   * @listens touchmove\n   */ProgressControl.prototype.handleMouseSeek=function handleMouseSeek(event){var seekBar=this.getChild('seekBar');seekBar.handleMouseMove(event);};/**\n   * Are controls are currently enabled for this progress control.\n   *\n   * @return {boolean}\n   *         true if controls are enabled, false otherwise\n   */ProgressControl.prototype.enabled=function enabled(){return this.enabled_;};/**\n   * Disable all controls on the progress control and its children\n   */ProgressControl.prototype.disable=function disable(){this.children().forEach(function(child){return child.disable&&child.disable();});if(!this.enabled()){return;}this.off(['mousedown','touchstart'],this.handleMouseDown);this.off(this.el_,'mousemove',this.handleMouseMove);this.handleMouseUp();this.addClass('disabled');this.enabled_=false;};/**\n   * Enable all controls on the progress control and its children\n   */ProgressControl.prototype.enable=function enable(){this.children().forEach(function(child){return child.enable&&child.enable();});if(this.enabled()){return;}this.on(['mousedown','touchstart'],this.handleMouseDown);this.on(this.el_,'mousemove',this.handleMouseMove);this.removeClass('disabled');this.enabled_=true;};/**\n   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */ProgressControl.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.el_.ownerDocument;this.on(doc,'mousemove',this.throttledHandleMouseSeek);this.on(doc,'touchmove',this.throttledHandleMouseSeek);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */ProgressControl.prototype.handleMouseUp=function handleMouseUp(event){var doc=this.el_.ownerDocument;this.off(doc,'mousemove',this.throttledHandleMouseSeek);this.off(doc,'touchmove',this.throttledHandleMouseSeek);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchend',this.handleMouseUp);};return ProgressControl;}(Component);/**\n * Default options for `ProgressControl`\n *\n * @type {Object}\n * @private\n */ProgressControl.prototype.options_={children:['seekBar']};Component.registerComponent('ProgressControl',ProgressControl);/**\n * @file fullscreen-toggle.js\n *//**\n * Toggle fullscreen video\n *\n * @extends Button\n */var FullscreenToggle=function(_Button){inherits(FullscreenToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function FullscreenToggle(player,options){classCallCheck(this,FullscreenToggle);var _this=possibleConstructorReturn(this,_Button.call(this,player,options));_this.on(player,'fullscreenchange',_this.handleFullscreenChange);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */FullscreenToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-fullscreen-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * Handles fullscreenchange on the player and change control text accordingly.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#fullscreenchange} event that caused this function to be\n   *        called.\n   *\n   * @listens Player#fullscreenchange\n   */FullscreenToggle.prototype.handleFullscreenChange=function handleFullscreenChange(event){if(this.player_.isFullscreen()){this.controlText('Non-Fullscreen');}else{this.controlText('Fullscreen');}};/**\n   * This gets called when an `FullscreenToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */FullscreenToggle.prototype.handleClick=function handleClick(event){if(!this.player_.isFullscreen()){this.player_.requestFullscreen();}else{this.player_.exitFullscreen();}};return FullscreenToggle;}(Button);/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */FullscreenToggle.prototype.controlText_='Fullscreen';Component.registerComponent('FullscreenToggle',FullscreenToggle);/**\n * Check if volume control is supported and if it isn't hide the\n * `Component` that was passed  using the `vjs-hidden` class.\n *\n * @param {Component} self\n *        The component that should be hidden if volume is unsupported\n *\n * @param {Player} player\n *        A reference to the player\n *\n * @private\n */var checkVolumeSupport=function checkVolumeSupport(self,player){// hide volume controls when they're not supported by the current tech\nif(player.tech_&&!player.tech_.featuresVolumeControl){self.addClass('vjs-hidden');}self.on(player,'loadstart',function(){if(!player.tech_.featuresVolumeControl){self.addClass('vjs-hidden');}else{self.removeClass('vjs-hidden');}});};/**\n * @file volume-level.js\n *//**\n * Shows volume level\n *\n * @extends Component\n */var VolumeLevel=function(_Component){inherits(VolumeLevel,_Component);function VolumeLevel(){classCallCheck(this,VolumeLevel);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeLevel.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-level',innerHTML:'<span class=\"vjs-control-text\"></span>'});};return VolumeLevel;}(Component);Component.registerComponent('VolumeLevel',VolumeLevel);/**\n * @file volume-bar.js\n */// Required children\n/**\n * The bar that contains the volume level and can be clicked on to adjust the level\n *\n * @extends Slider\n */var VolumeBar=function(_Slider){inherits(VolumeBar,_Slider);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function VolumeBar(player,options){classCallCheck(this,VolumeBar);var _this=possibleConstructorReturn(this,_Slider.call(this,player,options));_this.on('slideractive',_this.updateLastVolume_);_this.on(player,'volumechange',_this.updateARIAAttributes);player.ready(function(){return _this.updateARIAAttributes();});return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeBar.prototype.createEl=function createEl$$1(){return _Slider.prototype.createEl.call(this,'div',{className:'vjs-volume-bar vjs-slider-bar'},{'aria-label':this.localize('Volume Level'),'aria-live':'polite'});};/**\n   * Handle mouse down on volume bar\n   *\n   * @param {EventTarget~Event} event\n   *        The `mousedown` event that caused this to run.\n   *\n   * @listens mousedown\n   */VolumeBar.prototype.handleMouseDown=function handleMouseDown(event){if(!isSingleLeftClick(event)){return;}_Slider.prototype.handleMouseDown.call(this,event);};/**\n   * Handle movement events on the {@link VolumeMenuButton}.\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run.\n   *\n   * @listens mousemove\n   */VolumeBar.prototype.handleMouseMove=function handleMouseMove(event){if(!isSingleLeftClick(event)){return;}this.checkMuted();this.player_.volume(this.calculateDistance(event));};/**\n   * If the player is muted unmute it.\n   */VolumeBar.prototype.checkMuted=function checkMuted(){if(this.player_.muted()){this.player_.muted(false);}};/**\n   * Get percent of volume level\n   *\n   * @return {number}\n   *         Volume level percent as a decimal number.\n   */VolumeBar.prototype.getPercent=function getPercent(){if(this.player_.muted()){return 0;}return this.player_.volume();};/**\n   * Increase volume level for keyboard users\n   */VolumeBar.prototype.stepForward=function stepForward(){this.checkMuted();this.player_.volume(this.player_.volume()+0.1);};/**\n   * Decrease volume level for keyboard users\n   */VolumeBar.prototype.stepBack=function stepBack(){this.checkMuted();this.player_.volume(this.player_.volume()-0.1);};/**\n   * Update ARIA accessibility attributes\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `volumechange` event that caused this function to run.\n   *\n   * @listens Player#volumechange\n   */VolumeBar.prototype.updateARIAAttributes=function updateARIAAttributes(event){var ariaValue=this.player_.muted()?0:this.volumeAsPercentage_();this.el_.setAttribute('aria-valuenow',ariaValue);this.el_.setAttribute('aria-valuetext',ariaValue+'%');};/**\n   * Returns the current value of the player volume as a percentage\n   *\n   * @private\n   */VolumeBar.prototype.volumeAsPercentage_=function volumeAsPercentage_(){return Math.round(this.player_.volume()*100);};/**\n   * When user starts dragging the VolumeBar, store the volume and listen for\n   * the end of the drag. When the drag ends, if the volume was set to zero,\n   * set lastVolume to the stored volume.\n   *\n   * @listens slideractive\n   * @private\n   */VolumeBar.prototype.updateLastVolume_=function updateLastVolume_(){var _this2=this;var volumeBeforeDrag=this.player_.volume();this.one('sliderinactive',function(){if(_this2.player_.volume()===0){_this2.player_.lastVolume_(volumeBeforeDrag);}});};return VolumeBar;}(Slider);/**\n * Default options for the `VolumeBar`\n *\n * @type {Object}\n * @private\n */VolumeBar.prototype.options_={children:['volumeLevel'],barName:'volumeLevel'};/**\n * Call the update event for this Slider when this event happens on the player.\n *\n * @type {string}\n */VolumeBar.prototype.playerEvent='volumechange';Component.registerComponent('VolumeBar',VolumeBar);/**\n * @file volume-control.js\n */// Required children\n/**\n * The component for controlling the volume level\n *\n * @extends Component\n */var VolumeControl=function(_Component){inherits(VolumeControl,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function VolumeControl(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,VolumeControl);options.vertical=options.vertical||false;// Pass the vertical option down to the VolumeBar if\n// the VolumeBar is turned on.\nif(typeof options.volumeBar==='undefined'||isPlain(options.volumeBar)){options.volumeBar=options.volumeBar||{};options.volumeBar.vertical=options.vertical;}// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));checkVolumeSupport(_this,player);_this.throttledHandleMouseMove=throttle(bind(_this,_this.handleMouseMove),25);_this.on('mousedown',_this.handleMouseDown);_this.on('touchstart',_this.handleMouseDown);// while the slider is active (the mouse has been pressed down and\n// is dragging) or in focus we do not want to hide the VolumeBar\n_this.on(_this.volumeBar,['focus','slideractive'],function(){_this.volumeBar.addClass('vjs-slider-active');_this.addClass('vjs-slider-active');_this.trigger('slideractive');});_this.on(_this.volumeBar,['blur','sliderinactive'],function(){_this.volumeBar.removeClass('vjs-slider-active');_this.removeClass('vjs-slider-active');_this.trigger('sliderinactive');});return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumeControl.prototype.createEl=function createEl(){var orientationClass='vjs-volume-horizontal';if(this.options_.vertical){orientationClass='vjs-volume-vertical';}return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-control vjs-control '+orientationClass});};/**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */VolumeControl.prototype.handleMouseDown=function handleMouseDown(event){var doc=this.el_.ownerDocument;this.on(doc,'mousemove',this.throttledHandleMouseMove);this.on(doc,'touchmove',this.throttledHandleMouseMove);this.on(doc,'mouseup',this.handleMouseUp);this.on(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mouseup` or `touchend` event that triggered this function.\n   *\n   * @listens touchend\n   * @listens mouseup\n   */VolumeControl.prototype.handleMouseUp=function handleMouseUp(event){var doc=this.el_.ownerDocument;this.off(doc,'mousemove',this.throttledHandleMouseMove);this.off(doc,'touchmove',this.throttledHandleMouseMove);this.off(doc,'mouseup',this.handleMouseUp);this.off(doc,'touchend',this.handleMouseUp);};/**\n   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n   *\n   * @param {EventTarget~Event} event\n   *        `mousedown` or `touchstart` event that triggered this function\n   *\n   * @listens mousedown\n   * @listens touchstart\n   */VolumeControl.prototype.handleMouseMove=function handleMouseMove(event){this.volumeBar.handleMouseMove(event);};return VolumeControl;}(Component);/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */VolumeControl.prototype.options_={children:['volumeBar']};Component.registerComponent('VolumeControl',VolumeControl);/**\n * @file mute-toggle.js\n *//**\n * A button component for muting the audio.\n *\n * @extends Button\n */var MuteToggle=function(_Button){inherits(MuteToggle,_Button);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function MuteToggle(player,options){classCallCheck(this,MuteToggle);// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Button.call(this,player,options));checkVolumeSupport(_this,player);_this.on(player,['loadstart','volumechange'],_this.update);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */MuteToggle.prototype.buildCSSClass=function buildCSSClass(){return'vjs-mute-control '+_Button.prototype.buildCSSClass.call(this);};/**\n   * This gets called when an `MuteToggle` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MuteToggle.prototype.handleClick=function handleClick(event){var vol=this.player_.volume();var lastVolume=this.player_.lastVolume_();if(vol===0){var volumeToSet=lastVolume<0.1?0.1:lastVolume;this.player_.volume(volumeToSet);this.player_.muted(false);}else{this.player_.muted(this.player_.muted()?false:true);}};/**\n   * Update the `MuteToggle` button based on the state of `volume` and `muted`\n   * on the player.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link Player#loadstart} event if this function was called\n   *        through an event.\n   *\n   * @listens Player#loadstart\n   * @listens Player#volumechange\n   */MuteToggle.prototype.update=function update(event){this.updateIcon_();this.updateControlText_();};/**\n   * Update the appearance of the `MuteToggle` icon.\n   *\n   * Possible states (given `level` variable below):\n   * - 0: crossed out\n   * - 1: zero bars of volume\n   * - 2: one bar of volume\n   * - 3: two bars of volume\n   *\n   * @private\n   */MuteToggle.prototype.updateIcon_=function updateIcon_(){var vol=this.player_.volume();var level=3;if(vol===0||this.player_.muted()){level=0;}else if(vol<0.33){level=1;}else if(vol<0.67){level=2;}// TODO improve muted icon classes\nfor(var i=0;i<4;i++){removeClass(this.el_,'vjs-vol-'+i);}addClass(this.el_,'vjs-vol-'+level);};/**\n   * If `muted` has changed on the player, update the control text\n   * (`title` attribute on `vjs-mute-control` element and content of\n   * `vjs-control-text` element).\n   *\n   * @private\n   */MuteToggle.prototype.updateControlText_=function updateControlText_(){var soundOff=this.player_.muted()||this.player_.volume()===0;var text=soundOff?'Unmute':'Mute';if(this.controlText()!==text){this.controlText(text);}};return MuteToggle;}(Button);/**\n * The text that should display over the `MuteToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */MuteToggle.prototype.controlText_='Mute';Component.registerComponent('MuteToggle',MuteToggle);/**\n * @file volume-control.js\n */// Required children\n/**\n * A Component to contain the MuteToggle and VolumeControl so that\n * they can work together.\n *\n * @extends Component\n */var VolumePanel=function(_Component){inherits(VolumePanel,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function VolumePanel(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,VolumePanel);if(typeof options.inline!=='undefined'){options.inline=options.inline;}else{options.inline=true;}// pass the inline option down to the VolumeControl as vertical if\n// the VolumeControl is on.\nif(typeof options.volumeControl==='undefined'||isPlain(options.volumeControl)){options.volumeControl=options.volumeControl||{};options.volumeControl.vertical=!options.inline;}// hide this control if volume support is missing\nvar _this=possibleConstructorReturn(this,_Component.call(this,player,options));checkVolumeSupport(_this,player);// while the slider is active (the mouse has been pressed down and\n// is dragging) or in focus we do not want to hide the VolumeBar\n_this.on(_this.volumeControl,['slideractive'],_this.sliderActive_);_this.on(_this.muteToggle,'focus',_this.sliderActive_);_this.on(_this.volumeControl,['sliderinactive'],_this.sliderInactive_);_this.on(_this.muteToggle,'blur',_this.sliderInactive_);return _this;}/**\n   * Add vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#slideractive\n   * @private\n   */VolumePanel.prototype.sliderActive_=function sliderActive_(){this.addClass('vjs-slider-active');};/**\n   * Removes vjs-slider-active class to the VolumePanel\n   *\n   * @listens VolumeControl#sliderinactive\n   * @private\n   */VolumePanel.prototype.sliderInactive_=function sliderInactive_(){this.removeClass('vjs-slider-active');};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */VolumePanel.prototype.createEl=function createEl(){var orientationClass='vjs-volume-panel-horizontal';if(!this.options_.inline){orientationClass='vjs-volume-panel-vertical';}return _Component.prototype.createEl.call(this,'div',{className:'vjs-volume-panel vjs-control '+orientationClass});};return VolumePanel;}(Component);/**\n * Default options for the `VolumeControl`\n *\n * @type {Object}\n * @private\n */VolumePanel.prototype.options_={children:['muteToggle','volumeControl']};Component.registerComponent('VolumePanel',VolumePanel);/**\n * @file menu.js\n *//**\n * The Menu component is used to build popup menus, including subtitle and\n * captions selection menus.\n *\n * @extends Component\n */var Menu=function(_Component){inherits(Menu,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Player} player\n   *        the player that this component should attach to\n   *\n   * @param {Object} [options]\n   *        Object of option names and values\n   *\n   */function Menu(player,options){classCallCheck(this,Menu);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));if(options){_this.menuButton_=options.menuButton;}_this.focusedChild_=-1;_this.on('keydown',_this.handleKeyPress);return _this;}/**\n   * Add a {@link MenuItem} to the menu.\n   *\n   * @param {Object|string} component\n   *        The name or instance of the `MenuItem` to add.\n   *\n   */Menu.prototype.addItem=function addItem(component){this.addChild(component);component.on('click',bind(this,function(event){// Unpress the associated MenuButton, and move focus back to it\nif(this.menuButton_){this.menuButton_.unpressButton();// don't focus menu button if item is a caption settings item\n// because focus will move elsewhere and it logs an error on IE8\nif(component.name()!=='CaptionSettingsMenuItem'){this.menuButton_.focus();}}}));};/**\n   * Create the `Menu`s DOM element.\n   *\n   * @return {Element}\n   *         the element that was created\n   */Menu.prototype.createEl=function createEl$$1(){var contentElType=this.options_.contentElType||'ul';this.contentEl_=createEl(contentElType,{className:'vjs-menu-content'});this.contentEl_.setAttribute('role','menu');var el=_Component.prototype.createEl.call(this,'div',{append:this.contentEl_,className:'vjs-menu'});el.appendChild(this.contentEl_);// Prevent clicks from bubbling up. Needed for Menu Buttons,\n// where a click on the parent is significant\non(el,'click',function(event){event.preventDefault();event.stopImmediatePropagation();});return el;};Menu.prototype.dispose=function dispose(){this.contentEl_=null;_Component.prototype.dispose.call(this);};/**\n   * Handle a `keydown` event on this menu. This listener is added in the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        A `keydown` event that happened on the menu.\n   *\n   * @listens keydown\n   */Menu.prototype.handleKeyPress=function handleKeyPress(event){// Left and Down Arrows\nif(event.which===37||event.which===40){event.preventDefault();this.stepForward();// Up and Right Arrows\n}else if(event.which===38||event.which===39){event.preventDefault();this.stepBack();}};/**\n   * Move to next (lower) menu item for keyboard users.\n   */Menu.prototype.stepForward=function stepForward(){var stepChild=0;if(this.focusedChild_!==undefined){stepChild=this.focusedChild_+1;}this.focus(stepChild);};/**\n   * Move to previous (higher) menu item for keyboard users.\n   */Menu.prototype.stepBack=function stepBack(){var stepChild=0;if(this.focusedChild_!==undefined){stepChild=this.focusedChild_-1;}this.focus(stepChild);};/**\n   * Set focus on a {@link MenuItem} in the `Menu`.\n   *\n   * @param {Object|string} [item=0]\n   *        Index of child item set focus on.\n   */Menu.prototype.focus=function focus(){var item=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var children=this.children().slice();var haveTitle=children.length&&children[0].className&&/vjs-menu-title/.test(children[0].className);if(haveTitle){children.shift();}if(children.length>0){if(item<0){item=0;}else if(item>=children.length){item=children.length-1;}this.focusedChild_=item;children[item].el_.focus();}};return Menu;}(Component);Component.registerComponent('Menu',Menu);/**\n * @file menu-button.js\n *//**\n * A `MenuButton` class for any popup {@link Menu}.\n *\n * @extends Component\n */var MenuButton=function(_Component){inherits(MenuButton,_Component);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function MenuButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,MenuButton);var _this=possibleConstructorReturn(this,_Component.call(this,player,options));_this.menuButton_=new Button(player,options);_this.menuButton_.controlText(_this.controlText_);_this.menuButton_.el_.setAttribute('aria-haspopup','true');// Add buildCSSClass values to the button, not the wrapper\nvar buttonClass=Button.prototype.buildCSSClass();_this.menuButton_.el_.className=_this.buildCSSClass()+' '+buttonClass;_this.menuButton_.removeClass('vjs-control');_this.addChild(_this.menuButton_);_this.update();_this.enabled_=true;_this.on(_this.menuButton_,'tap',_this.handleClick);_this.on(_this.menuButton_,'click',_this.handleClick);_this.on(_this.menuButton_,'focus',_this.handleFocus);_this.on(_this.menuButton_,'blur',_this.handleBlur);_this.on('keydown',_this.handleSubmenuKeyPress);return _this;}/**\n   * Update the menu based on the current state of its items.\n   */MenuButton.prototype.update=function update(){var menu=this.createMenu();if(this.menu){this.menu.dispose();this.removeChild(this.menu);}this.menu=menu;this.addChild(menu);/**\n     * Track the state of the menu button\n     *\n     * @type {Boolean}\n     * @private\n     */this.buttonPressed_=false;this.menuButton_.el_.setAttribute('aria-expanded','false');if(this.items&&this.items.length<=this.hideThreshold_){this.hide();}else{this.show();}};/**\n   * Create the menu and add all items to it.\n   *\n   * @return {Menu}\n   *         The constructed menu\n   */MenuButton.prototype.createMenu=function createMenu(){var menu=new Menu(this.player_,{menuButton:this});/**\n     * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n     * it here because every time we run `createMenu` we need to reset the value.\n     *\n     * @protected\n     * @type {Number}\n     */this.hideThreshold_=0;// Add a title list item to the top\nif(this.options_.title){var title=createEl('li',{className:'vjs-menu-title',innerHTML:toTitleCase(this.options_.title),tabIndex:-1});this.hideThreshold_+=1;menu.children_.unshift(title);prependTo(title,menu.contentEl());}this.items=this.createItems();if(this.items){// Add menu items to the menu\nfor(var i=0;i<this.items.length;i++){menu.addItem(this.items[i]);}}return menu;};/**\n   * Create the list of menu items. Specific to each subclass.\n   *\n   * @abstract\n   */MenuButton.prototype.createItems=function createItems(){};/**\n   * Create the `MenuButtons`s DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */MenuButton.prototype.createEl=function createEl$$1(){return _Component.prototype.createEl.call(this,'div',{className:this.buildWrapperCSSClass()},{});};/**\n   * Allow sub components to stack CSS class names for the wrapper element\n   *\n   * @return {string}\n   *         The constructed wrapper DOM `className`\n   */MenuButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){var menuButtonClass='vjs-menu-button';// If the inline option is passed, we want to use different styles altogether.\nif(this.options_.inline===true){menuButtonClass+='-inline';}else{menuButtonClass+='-popup';}// TODO: Fix the CSS so that this isn't necessary\nvar buttonClass=Button.prototype.buildCSSClass();return'vjs-menu-button '+menuButtonClass+' '+buttonClass+' '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */MenuButton.prototype.buildCSSClass=function buildCSSClass(){var menuButtonClass='vjs-menu-button';// If the inline option is passed, we want to use different styles altogether.\nif(this.options_.inline===true){menuButtonClass+='-inline';}else{menuButtonClass+='-popup';}return'vjs-menu-button '+menuButtonClass+' '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Get or set the localized control text that will be used for accessibility.\n   *\n   * > NOTE: This will come from the internal `menuButton_` element.\n   *\n   * @param {string} [text]\n   *        Control text for element.\n   *\n   * @param {Element} [el=this.menuButton_.el()]\n   *        Element to set the title on.\n   *\n   * @return {string}\n   *         - The control text when getting\n   */MenuButton.prototype.controlText=function controlText(text){var el=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.menuButton_.el();return this.menuButton_.controlText(text,el);};/**\n   * Handle a click on a `MenuButton`.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MenuButton.prototype.handleClick=function handleClick(event){// When you click the button it adds focus, which will show the menu.\n// So we'll remove focus when the mouse leaves the button. Focus is needed\n// for tab navigation.\nthis.one(this.menu.contentEl(),'mouseleave',bind(this,function(e){this.unpressButton();this.el_.blur();}));if(this.buttonPressed_){this.unpressButton();}else{this.pressButton();}};/**\n   * Set the focus to the actual button, not to this element\n   */MenuButton.prototype.focus=function focus(){this.menuButton_.focus();};/**\n   * Remove the focus from the actual button, not this element\n   */MenuButton.prototype.blur=function blur(){this.menuButton_.blur();};/**\n   * This gets called when a `MenuButton` gains focus via a `focus` event.\n   * Turns on listening for `keydown` events. When they happen it\n   * calls `this.handleKeyPress`.\n   *\n   * @param {EventTarget~Event} event\n   *        The `focus` event that caused this function to be called.\n   *\n   * @listens focus\n   */MenuButton.prototype.handleFocus=function handleFocus(){on(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Called when a `MenuButton` loses focus. Turns off the listener for\n   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `blur` event that caused this function to be called.\n   *\n   * @listens blur\n   */MenuButton.prototype.handleBlur=function handleBlur(){off(document,'keydown',bind(this,this.handleKeyPress));};/**\n   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n   * {@link ClickableComponent#handleKeyPress} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown` event that caused this function to be called.\n   *\n   * @listens keydown\n   */MenuButton.prototype.handleKeyPress=function handleKeyPress(event){// Escape (27) key or Tab (9) key unpress the 'button'\nif(event.which===27||event.which===9){if(this.buttonPressed_){this.unpressButton();}// Don't preventDefault for Tab key - we still want to lose focus\nif(event.which!==9){event.preventDefault();// Set focus back to the menu button's button\nthis.menuButton_.el_.focus();}// Up (38) key or Down (40) key press the 'button'\n}else if(event.which===38||event.which===40){if(!this.buttonPressed_){this.pressButton();event.preventDefault();}}};/**\n   * Handle a `keydown` event on a sub-menu. The listener for this is added in\n   * the constructor.\n   *\n   * @param {EventTarget~Event} event\n   *        Key press event\n   *\n   * @listens keydown\n   */MenuButton.prototype.handleSubmenuKeyPress=function handleSubmenuKeyPress(event){// Escape (27) key or Tab (9) key unpress the 'button'\nif(event.which===27||event.which===9){if(this.buttonPressed_){this.unpressButton();}// Don't preventDefault for Tab key - we still want to lose focus\nif(event.which!==9){event.preventDefault();// Set focus back to the menu button's button\nthis.menuButton_.el_.focus();}}};/**\n   * Put the current `MenuButton` into a pressed state.\n   */MenuButton.prototype.pressButton=function pressButton(){if(this.enabled_){this.buttonPressed_=true;this.menu.lockShowing();this.menuButton_.el_.setAttribute('aria-expanded','true');// set the focus into the submenu, except on iOS where it is resulting in\n// undesired scrolling behavior when the player is in an iframe\nif(IS_IOS&&isInFrame()){// Return early so that the menu isn't focused\nreturn;}this.menu.focus();}};/**\n   * Take the current `MenuButton` out of a pressed state.\n   */MenuButton.prototype.unpressButton=function unpressButton(){if(this.enabled_){this.buttonPressed_=false;this.menu.unlockShowing();this.menuButton_.el_.setAttribute('aria-expanded','false');}};/**\n   * Disable the `MenuButton`. Don't allow it to be clicked.\n   */MenuButton.prototype.disable=function disable(){this.unpressButton();this.enabled_=false;this.addClass('vjs-disabled');this.menuButton_.disable();};/**\n   * Enable the `MenuButton`. Allow it to be clicked.\n   */MenuButton.prototype.enable=function enable(){this.enabled_=true;this.removeClass('vjs-disabled');this.menuButton_.enable();};return MenuButton;}(Component);Component.registerComponent('MenuButton',MenuButton);/**\n * @file track-button.js\n *//**\n * The base class for buttons that toggle specific  track types (e.g. subtitles).\n *\n * @extends MenuButton\n */var TrackButton=function(_MenuButton){inherits(TrackButton,_MenuButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TrackButton(player,options){classCallCheck(this,TrackButton);var tracks=options.tracks;var _this=possibleConstructorReturn(this,_MenuButton.call(this,player,options));if(_this.items.length<=1){_this.hide();}if(!tracks){return possibleConstructorReturn(_this);}var updateHandler=bind(_this,_this.update);tracks.addEventListener('removetrack',updateHandler);tracks.addEventListener('addtrack',updateHandler);_this.player_.on('ready',updateHandler);_this.player_.on('dispose',function(){tracks.removeEventListener('removetrack',updateHandler);tracks.removeEventListener('addtrack',updateHandler);});return _this;}return TrackButton;}(MenuButton);Component.registerComponent('TrackButton',TrackButton);/**\n * @file menu-item.js\n *//**\n * The component for a menu item. `<li>`\n *\n * @extends ClickableComponent\n */var MenuItem=function(_ClickableComponent){inherits(MenuItem,_ClickableComponent);/**\n   * Creates an instance of the this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   *\n   */function MenuItem(player,options){classCallCheck(this,MenuItem);var _this=possibleConstructorReturn(this,_ClickableComponent.call(this,player,options));_this.selectable=options.selectable;_this.selected(options.selected);if(_this.selectable){// TODO: May need to be either menuitemcheckbox or menuitemradio,\n//       and may need logical grouping of menu items.\n_this.el_.setAttribute('role','menuitemcheckbox');}else{_this.el_.setAttribute('role','menuitem');}return _this;}/**\n   * Create the `MenuItem's DOM element\n   *\n   * @param {string} [type=li]\n   *        Element's node type, not actually used, always set to `li`.\n   *\n   * @param {Object} [props={}]\n   *        An object of properties that should be set on the element\n   *\n   * @param {Object} [attrs={}]\n   *        An object of attributes that should be set on the element\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */MenuItem.prototype.createEl=function createEl(type,props,attrs){// The control is textual, not just an icon\nthis.nonIconControl=true;return _ClickableComponent.prototype.createEl.call(this,'li',assign({className:'vjs-menu-item',innerHTML:'<span class=\"vjs-menu-item-text\">'+this.localize(this.options_.label)+'</span>',tabIndex:-1},props),attrs);};/**\n   * Any click on a `MenuItem` puts int into the selected state.\n   * See {@link ClickableComponent#handleClick} for instances where this is called.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */MenuItem.prototype.handleClick=function handleClick(event){this.selected(true);};/**\n   * Set the state for this menu item as selected or not.\n   *\n   * @param {boolean} selected\n   *        if the menu item is selected or not\n   */MenuItem.prototype.selected=function selected(_selected){if(this.selectable){if(_selected){this.addClass('vjs-selected');this.el_.setAttribute('aria-checked','true');// aria-checked isn't fully supported by browsers/screen readers,\n// so indicate selected state to screen reader in the control text.\nthis.controlText(', selected');}else{this.removeClass('vjs-selected');this.el_.setAttribute('aria-checked','false');// Indicate un-selected state to screen reader\nthis.controlText('');}}};return MenuItem;}(ClickableComponent);Component.registerComponent('MenuItem',MenuItem);/**\n * @file text-track-menu-item.js\n *//**\n * The specific menu item type for selecting a language within a text track kind\n *\n * @extends MenuItem\n */var TextTrackMenuItem=function(_MenuItem){inherits(TextTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function TextTrackMenuItem(player,options){classCallCheck(this,TextTrackMenuItem);var track=options.track;var tracks=player.textTracks();// Modify options for parent MenuItem class's init.\noptions.label=track.label||track.language||'Unknown';options.selected=track.mode==='showing';var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;var changeHandler=function changeHandler(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this.handleTracksChange.apply(_this,args);};var selectedLanguageChangeHandler=function selectedLanguageChangeHandler(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}_this.handleSelectedLanguageChange.apply(_this,args);};player.on(['loadstart','texttrackchange'],changeHandler);tracks.addEventListener('change',changeHandler);tracks.addEventListener('selectedlanguagechange',selectedLanguageChangeHandler);_this.on('dispose',function(){player.off(['loadstart','texttrackchange'],changeHandler);tracks.removeEventListener('change',changeHandler);tracks.removeEventListener('selectedlanguagechange',selectedLanguageChangeHandler);});// iOS7 doesn't dispatch change events to TextTrackLists when an\n// associated track's mode changes. Without something like\n// Object.observe() (also not present on iOS7), it's not\n// possible to detect changes to the mode attribute and polyfill\n// the change event. As a poor substitute, we manually dispatch\n// change events whenever the controls modify the mode.\nif(tracks.onchange===undefined){var event=void 0;_this.on(['tap','click'],function(){if(_typeof(window.Event)!=='object'){// Android 2.3 throws an Illegal Constructor error for window.Event\ntry{event=new window.Event('change');}catch(err){// continue regardless of error\n}}if(!event){event=document.createEvent('Event');event.initEvent('change',true,true);}tracks.dispatchEvent(event);});}// set the default state based on current tracks\n_this.handleTracksChange();return _this;}/**\n   * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} event\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */TextTrackMenuItem.prototype.handleClick=function handleClick(event){var kind=this.track.kind;var kinds=this.track.kinds;var tracks=this.player_.textTracks();if(!kinds){kinds=[kind];}_MenuItem.prototype.handleClick.call(this,event);if(!tracks){return;}for(var i=0;i<tracks.length;i++){var track=tracks[i];if(track===this.track&&kinds.indexOf(track.kind)>-1){if(track.mode!=='showing'){track.mode='showing';}}else if(track.mode!=='disabled'){track.mode='disabled';}}};/**\n   * Handle text track list change\n   *\n   * @param {EventTarget~Event} event\n   *        The `change` event that caused this function to be called.\n   *\n   * @listens TextTrackList#change\n   */TextTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){this.selected(this.track.mode==='showing');};TextTrackMenuItem.prototype.handleSelectedLanguageChange=function handleSelectedLanguageChange(event){if(this.track.mode==='showing'){var selectedLanguage=this.player_.cache_.selectedLanguage;// Don't replace the kind of track across the same language\nif(selectedLanguage&&selectedLanguage.enabled&&selectedLanguage.language===this.track.language&&selectedLanguage.kind!==this.track.kind){return;}this.player_.cache_.selectedLanguage={enabled:true,language:this.track.language,kind:this.track.kind};}};TextTrackMenuItem.prototype.dispose=function dispose(){// remove reference to track object on dispose\nthis.track=null;_MenuItem.prototype.dispose.call(this);};return TextTrackMenuItem;}(MenuItem);Component.registerComponent('TextTrackMenuItem',TextTrackMenuItem);/**\n * @file off-text-track-menu-item.js\n *//**\n * A special menu item for turning of a specific type of text track\n *\n * @extends TextTrackMenuItem\n */var OffTextTrackMenuItem=function(_TextTrackMenuItem){inherits(OffTextTrackMenuItem,_TextTrackMenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function OffTextTrackMenuItem(player,options){classCallCheck(this,OffTextTrackMenuItem);// Create pseudo track info\n// Requires options['kind']\noptions.track={player:player,kind:options.kind,kinds:options.kinds,'default':false,mode:'disabled'};if(!options.kinds){options.kinds=[options.kind];}if(options.label){options.track.label=options.label;}else{options.track.label=options.kinds.join(' and ')+' off';}// MenuItem is selectable\noptions.selectable=true;return possibleConstructorReturn(this,_TextTrackMenuItem.call(this,player,options));}/**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   */OffTextTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){var tracks=this.player().textTracks();var selected=true;for(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(this.options_.kinds.indexOf(track.kind)>-1&&track.mode==='showing'){selected=false;break;}}this.selected(selected);};OffTextTrackMenuItem.prototype.handleSelectedLanguageChange=function handleSelectedLanguageChange(event){var tracks=this.player().textTracks();var allHidden=true;for(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(['captions','descriptions','subtitles'].indexOf(track.kind)>-1&&track.mode==='showing'){allHidden=false;break;}}if(allHidden){this.player_.cache_.selectedLanguage={enabled:false};}};return OffTextTrackMenuItem;}(TextTrackMenuItem);Component.registerComponent('OffTextTrackMenuItem',OffTextTrackMenuItem);/**\n * @file text-track-button.js\n *//**\n * The base class for buttons that toggle specific text track types (e.g. subtitles)\n *\n * @extends MenuButton\n */var TextTrackButton=function(_TrackButton){inherits(TextTrackButton,_TrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function TextTrackButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,TextTrackButton);options.tracks=player.textTracks();return possibleConstructorReturn(this,_TrackButton.call(this,player,options));}/**\n   * Create a menu item for each text track\n   *\n   * @param {TextTrackMenuItem[]} [items=[]]\n   *        Existing array of items to use during creation\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items that were created\n   */TextTrackButton.prototype.createItems=function createItems(){var items=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var TrackMenuItem=arguments.length>1&&arguments[1]!==undefined?arguments[1]:TextTrackMenuItem;// Label is an overide for the [track] off label\n// USed to localise captions/subtitles\nvar label=void 0;if(this.label_){label=this.label_+' off';}// Add an OFF menu item to turn all tracks off\nitems.push(new OffTextTrackMenuItem(this.player_,{kinds:this.kinds_,kind:this.kind_,label:label}));this.hideThreshold_+=1;var tracks=this.player_.textTracks();if(!Array.isArray(this.kinds_)){this.kinds_=[this.kind_];}for(var i=0;i<tracks.length;i++){var track=tracks[i];// only add tracks that are of an appropriate kind and have a label\nif(this.kinds_.indexOf(track.kind)>-1){var item=new TrackMenuItem(this.player_,{track:track,// MenuItem is selectable\nselectable:true});item.addClass('vjs-'+track.kind+'-menu-item');items.push(item);}}return items;};return TextTrackButton;}(TrackButton);Component.registerComponent('TextTrackButton',TextTrackButton);/**\n * @file chapters-track-menu-item.js\n *//**\n * The chapter track menu item\n *\n * @extends MenuItem\n */var ChaptersTrackMenuItem=function(_MenuItem){inherits(ChaptersTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function ChaptersTrackMenuItem(player,options){classCallCheck(this,ChaptersTrackMenuItem);var track=options.track;var cue=options.cue;var currentTime=player.currentTime();// Modify options for parent MenuItem class's init.\noptions.selectable=true;options.label=cue.text;options.selected=cue.startTime<=currentTime&&currentTime<cue.endTime;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;_this.cue=cue;track.addEventListener('cuechange',bind(_this,_this.update));return _this;}/**\n   * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */ChaptersTrackMenuItem.prototype.handleClick=function handleClick(event){_MenuItem.prototype.handleClick.call(this);this.player_.currentTime(this.cue.startTime);this.update(this.cue.startTime);};/**\n   * Update chapter menu item\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `cuechange` event that caused this function to run.\n   *\n   * @listens TextTrack#cuechange\n   */ChaptersTrackMenuItem.prototype.update=function update(event){var cue=this.cue;var currentTime=this.player_.currentTime();// vjs.log(currentTime, cue.startTime);\nthis.selected(cue.startTime<=currentTime&&currentTime<cue.endTime);};return ChaptersTrackMenuItem;}(MenuItem);Component.registerComponent('ChaptersTrackMenuItem',ChaptersTrackMenuItem);/**\n * @file chapters-button.js\n *//**\n * The button component for toggling and selecting chapters\n * Chapters act much differently than other text tracks\n * Cues are navigation vs. other tracks of alternative languages\n *\n * @extends TextTrackButton\n */var ChaptersButton=function(_TextTrackButton){inherits(ChaptersButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this function is ready.\n   */function ChaptersButton(player,options,ready){classCallCheck(this,ChaptersButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */ChaptersButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-chapters-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};ChaptersButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-chapters-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Update the menu based on the current state of its items.\n   *\n   * @param {EventTarget~Event} [event]\n   *        An event that triggered this function to run.\n   *\n   * @listens TextTrackList#addtrack\n   * @listens TextTrackList#removetrack\n   * @listens TextTrackList#change\n   */ChaptersButton.prototype.update=function update(event){if(!this.track_||event&&(event.type==='addtrack'||event.type==='removetrack')){this.setTrack(this.findChaptersTrack());}_TextTrackButton.prototype.update.call(this);};/**\n   * Set the currently selected track for the chapters button.\n   *\n   * @param {TextTrack} track\n   *        The new track to select. Nothing will change if this is the currently selected\n   *        track.\n   */ChaptersButton.prototype.setTrack=function setTrack(track){if(this.track_===track){return;}if(!this.updateHandler_){this.updateHandler_=this.update.bind(this);}// here this.track_ refers to the old track instance\nif(this.track_){var remoteTextTrackEl=this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);if(remoteTextTrackEl){remoteTextTrackEl.removeEventListener('load',this.updateHandler_);}this.track_=null;}this.track_=track;// here this.track_ refers to the new track instance\nif(this.track_){this.track_.mode='hidden';var _remoteTextTrackEl=this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);if(_remoteTextTrackEl){_remoteTextTrackEl.addEventListener('load',this.updateHandler_);}}};/**\n   * Find the track object that is currently in use by this ChaptersButton\n   *\n   * @return {TextTrack|undefined}\n   *         The current track or undefined if none was found.\n   */ChaptersButton.prototype.findChaptersTrack=function findChaptersTrack(){var tracks=this.player_.textTracks()||[];for(var i=tracks.length-1;i>=0;i--){// We will always choose the last track as our chaptersTrack\nvar track=tracks[i];if(track.kind===this.kind_){return track;}}};/**\n   * Get the caption for the ChaptersButton based on the track label. This will also\n   * use the current tracks localized kind as a fallback if a label does not exist.\n   *\n   * @return {string}\n   *         The tracks current label or the localized track kind.\n   */ChaptersButton.prototype.getMenuCaption=function getMenuCaption(){if(this.track_&&this.track_.label){return this.track_.label;}return this.localize(toTitleCase(this.kind_));};/**\n   * Create menu from chapter track\n   *\n   * @return {Menu}\n   *         New menu for the chapter buttons\n   */ChaptersButton.prototype.createMenu=function createMenu(){this.options_.title=this.getMenuCaption();return _TextTrackButton.prototype.createMenu.call(this);};/**\n   * Create a menu item for each text track\n   *\n   * @return {TextTrackMenuItem[]}\n   *         Array of menu items\n   */ChaptersButton.prototype.createItems=function createItems(){var items=[];if(!this.track_){return items;}var cues=this.track_.cues;if(!cues){return items;}for(var i=0,l=cues.length;i<l;i++){var cue=cues[i];var mi=new ChaptersTrackMenuItem(this.player_,{track:this.track_,cue:cue});items.push(mi);}return items;};return ChaptersButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */ChaptersButton.prototype.kind_='chapters';/**\n * The text that should display over the `ChaptersButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */ChaptersButton.prototype.controlText_='Chapters';Component.registerComponent('ChaptersButton',ChaptersButton);/**\n * @file descriptions-button.js\n *//**\n * The button component for toggling and selecting descriptions\n *\n * @extends TextTrackButton\n */var DescriptionsButton=function(_TextTrackButton){inherits(DescriptionsButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function DescriptionsButton(player,options,ready){classCallCheck(this,DescriptionsButton);var _this=possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));var tracks=player.textTracks();var changeHandler=bind(_this,_this.handleTracksChange);tracks.addEventListener('change',changeHandler);_this.on('dispose',function(){tracks.removeEventListener('change',changeHandler);});return _this;}/**\n   * Handle text track change\n   *\n   * @param {EventTarget~Event} event\n   *        The event that caused this function to run\n   *\n   * @listens TextTrackList#change\n   */DescriptionsButton.prototype.handleTracksChange=function handleTracksChange(event){var tracks=this.player().textTracks();var disabled=false;// Check whether a track of a different kind is showing\nfor(var i=0,l=tracks.length;i<l;i++){var track=tracks[i];if(track.kind!==this.kind_&&track.mode==='showing'){disabled=true;break;}}// If another track is showing, disable this menu button\nif(disabled){this.disable();}else{this.enable();}};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */DescriptionsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-descriptions-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};DescriptionsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-descriptions-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};return DescriptionsButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */DescriptionsButton.prototype.kind_='descriptions';/**\n * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */DescriptionsButton.prototype.controlText_='Descriptions';Component.registerComponent('DescriptionsButton',DescriptionsButton);/**\n * @file subtitles-button.js\n *//**\n * The button component for toggling and selecting subtitles\n *\n * @extends TextTrackButton\n */var SubtitlesButton=function(_TextTrackButton){inherits(SubtitlesButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function SubtitlesButton(player,options,ready){classCallCheck(this,SubtitlesButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */SubtitlesButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-subtitles-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};SubtitlesButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-subtitles-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};return SubtitlesButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */SubtitlesButton.prototype.kind_='subtitles';/**\n * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */SubtitlesButton.prototype.controlText_='Subtitles';Component.registerComponent('SubtitlesButton',SubtitlesButton);/**\n * @file caption-settings-menu-item.js\n *//**\n * The menu item for caption track settings menu\n *\n * @extends TextTrackMenuItem\n */var CaptionSettingsMenuItem=function(_TextTrackMenuItem){inherits(CaptionSettingsMenuItem,_TextTrackMenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function CaptionSettingsMenuItem(player,options){classCallCheck(this,CaptionSettingsMenuItem);options.track={player:player,kind:options.kind,label:options.kind+' settings',selectable:false,'default':false,mode:'disabled'};// CaptionSettingsMenuItem has no concept of 'selected'\noptions.selectable=false;options.name='CaptionSettingsMenuItem';var _this=possibleConstructorReturn(this,_TextTrackMenuItem.call(this,player,options));_this.addClass('vjs-texttrack-settings');_this.controlText(', opens '+options.kind+' settings dialog');return _this;}/**\n   * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */CaptionSettingsMenuItem.prototype.handleClick=function handleClick(event){this.player().getChild('textTrackSettings').open();};return CaptionSettingsMenuItem;}(TextTrackMenuItem);Component.registerComponent('CaptionSettingsMenuItem',CaptionSettingsMenuItem);/**\n * @file captions-button.js\n *//**\n * The button component for toggling and selecting captions\n *\n * @extends TextTrackButton\n */var CaptionsButton=function(_TextTrackButton){inherits(CaptionsButton,_TextTrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        The function to call when this component is ready.\n   */function CaptionsButton(player,options,ready){classCallCheck(this,CaptionsButton);return possibleConstructorReturn(this,_TextTrackButton.call(this,player,options,ready));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CaptionsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-captions-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};CaptionsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-captions-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create caption menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */CaptionsButton.prototype.createItems=function createItems(){var items=[];if(!(this.player().tech_&&this.player().tech_.featuresNativeTextTracks)){items.push(new CaptionSettingsMenuItem(this.player_,{kind:this.kind_}));this.hideThreshold_+=1;}return _TextTrackButton.prototype.createItems.call(this,items);};return CaptionsButton;}(TextTrackButton);/**\n * `kind` of TextTrack to look for to associate it with this menu.\n *\n * @type {string}\n * @private\n */CaptionsButton.prototype.kind_='captions';/**\n * The text that should display over the `CaptionsButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */CaptionsButton.prototype.controlText_='Captions';Component.registerComponent('CaptionsButton',CaptionsButton);/**\n * @file subs-caps-menu-item.js\n *//**\n * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n * in the SubsCapsMenu.\n *\n * @extends TextTrackMenuItem\n */var SubsCapsMenuItem=function(_TextTrackMenuItem){inherits(SubsCapsMenuItem,_TextTrackMenuItem);function SubsCapsMenuItem(){classCallCheck(this,SubsCapsMenuItem);return possibleConstructorReturn(this,_TextTrackMenuItem.apply(this,arguments));}SubsCapsMenuItem.prototype.createEl=function createEl(type,props,attrs){var innerHTML='<span class=\"vjs-menu-item-text\">'+this.localize(this.options_.label);if(this.options_.track.kind==='captions'){innerHTML+='\\n        <span aria-hidden=\"true\" class=\"vjs-icon-placeholder\"></span>\\n        <span class=\"vjs-control-text\"> '+this.localize('Captions')+'</span>\\n      ';}innerHTML+='</span>';var el=_TextTrackMenuItem.prototype.createEl.call(this,type,assign({innerHTML:innerHTML},props),attrs);return el;};return SubsCapsMenuItem;}(TextTrackMenuItem);Component.registerComponent('SubsCapsMenuItem',SubsCapsMenuItem);/**\n * @file sub-caps-button.js\n *//**\n * The button component for toggling and selecting captions and/or subtitles\n *\n * @extends TextTrackButton\n */var SubsCapsButton=function(_TextTrackButton){inherits(SubsCapsButton,_TextTrackButton);function SubsCapsButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,SubsCapsButton);// Although North America uses \"captions\" in most cases for\n// \"captions and subtitles\" other locales use \"subtitles\"\nvar _this=possibleConstructorReturn(this,_TextTrackButton.call(this,player,options));_this.label_='subtitles';if(['en','en-us','en-ca','fr-ca'].indexOf(_this.player_.language_)>-1){_this.label_='captions';}_this.menuButton_.controlText(toTitleCase(_this.label_));return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */SubsCapsButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-subs-caps-button '+_TextTrackButton.prototype.buildCSSClass.call(this);};SubsCapsButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-subs-caps-button '+_TextTrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create caption/subtitles menu items\n   *\n   * @return {CaptionSettingsMenuItem[]}\n   *         The array of current menu items.\n   */SubsCapsButton.prototype.createItems=function createItems(){var items=[];if(!(this.player().tech_&&this.player().tech_.featuresNativeTextTracks)){items.push(new CaptionSettingsMenuItem(this.player_,{kind:this.label_}));this.hideThreshold_+=1;}items=_TextTrackButton.prototype.createItems.call(this,items,SubsCapsMenuItem);return items;};return SubsCapsButton;}(TextTrackButton);/**\n * `kind`s of TextTrack to look for to associate it with this menu.\n *\n * @type {array}\n * @private\n */SubsCapsButton.prototype.kinds_=['captions','subtitles'];/**\n * The text that should display over the `SubsCapsButton`s controls.\n *\n *\n * @type {string}\n * @private\n */SubsCapsButton.prototype.controlText_='Subtitles';Component.registerComponent('SubsCapsButton',SubsCapsButton);/**\n * @file audio-track-menu-item.js\n *//**\n * An {@link AudioTrack} {@link MenuItem}\n *\n * @extends MenuItem\n */var AudioTrackMenuItem=function(_MenuItem){inherits(AudioTrackMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function AudioTrackMenuItem(player,options){classCallCheck(this,AudioTrackMenuItem);var track=options.track;var tracks=player.audioTracks();// Modify options for parent MenuItem class's init.\noptions.label=track.label||track.language||'Unknown';options.selected=track.enabled;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.track=track;var changeHandler=bind(_this,_this.handleTracksChange);tracks.addEventListener('change',changeHandler);_this.on('dispose',function(){tracks.removeEventListener('change',changeHandler);});return _this;}/**\n   * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n   * for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */AudioTrackMenuItem.prototype.handleClick=function handleClick(event){var tracks=this.player_.audioTracks();_MenuItem.prototype.handleClick.call(this,event);for(var i=0;i<tracks.length;i++){var track=tracks[i];track.enabled=track===this.track;}};/**\n   * Handle any {@link AudioTrack} change.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The {@link AudioTrackList#change} event that caused this to run.\n   *\n   * @listens AudioTrackList#change\n   */AudioTrackMenuItem.prototype.handleTracksChange=function handleTracksChange(event){this.selected(this.track.enabled);};return AudioTrackMenuItem;}(MenuItem);Component.registerComponent('AudioTrackMenuItem',AudioTrackMenuItem);/**\n * @file audio-track-button.js\n *//**\n * The base class for buttons that toggle specific {@link AudioTrack} types.\n *\n * @extends TrackButton\n */var AudioTrackButton=function(_TrackButton){inherits(AudioTrackButton,_TrackButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options={}]\n   *        The key/value store of player options.\n   */function AudioTrackButton(player){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,AudioTrackButton);options.tracks=player.audioTracks();return possibleConstructorReturn(this,_TrackButton.call(this,player,options));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */AudioTrackButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-audio-button '+_TrackButton.prototype.buildCSSClass.call(this);};AudioTrackButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-audio-button '+_TrackButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create a menu item for each audio track\n   *\n   * @param {AudioTrackMenuItem[]} [items=[]]\n   *        An array of existing menu items to use.\n   *\n   * @return {AudioTrackMenuItem[]}\n   *         An array of menu items\n   */AudioTrackButton.prototype.createItems=function createItems(){var items=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];// if there's only one audio track, there no point in showing it\nthis.hideThreshold_=1;var tracks=this.player_.audioTracks();for(var i=0;i<tracks.length;i++){var track=tracks[i];items.push(new AudioTrackMenuItem(this.player_,{track:track,// MenuItem is selectable\nselectable:true}));}return items;};return AudioTrackButton;}(TrackButton);/**\n * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */AudioTrackButton.prototype.controlText_='Audio Track';Component.registerComponent('AudioTrackButton',AudioTrackButton);/**\n * @file playback-rate-menu-item.js\n *//**\n * The specific menu item type for selecting a playback rate.\n *\n * @extends MenuItem\n */var PlaybackRateMenuItem=function(_MenuItem){inherits(PlaybackRateMenuItem,_MenuItem);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlaybackRateMenuItem(player,options){classCallCheck(this,PlaybackRateMenuItem);var label=options.rate;var rate=parseFloat(label,10);// Modify options for parent MenuItem class's init.\noptions.label=label;options.selected=rate===1;options.selectable=true;var _this=possibleConstructorReturn(this,_MenuItem.call(this,player,options));_this.label=label;_this.rate=rate;_this.on(player,'ratechange',_this.update);return _this;}/**\n   * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlaybackRateMenuItem.prototype.handleClick=function handleClick(event){_MenuItem.prototype.handleClick.call(this);this.player().playbackRate(this.rate);};/**\n   * Update the PlaybackRateMenuItem when the playbackrate changes.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `ratechange` event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */PlaybackRateMenuItem.prototype.update=function update(event){this.selected(this.player().playbackRate()===this.rate);};return PlaybackRateMenuItem;}(MenuItem);/**\n * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlaybackRateMenuItem.prototype.contentElType='button';Component.registerComponent('PlaybackRateMenuItem',PlaybackRateMenuItem);/**\n * @file playback-rate-menu-button.js\n *//**\n * The component for controlling the playback rate.\n *\n * @extends MenuButton\n */var PlaybackRateMenuButton=function(_MenuButton){inherits(PlaybackRateMenuButton,_MenuButton);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *        The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   */function PlaybackRateMenuButton(player,options){classCallCheck(this,PlaybackRateMenuButton);var _this=possibleConstructorReturn(this,_MenuButton.call(this,player,options));_this.updateVisibility();_this.updateLabel();_this.on(player,'loadstart',_this.updateVisibility);_this.on(player,'ratechange',_this.updateLabel);return _this;}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */PlaybackRateMenuButton.prototype.createEl=function createEl$$1(){var el=_MenuButton.prototype.createEl.call(this);this.labelEl_=createEl('div',{className:'vjs-playback-rate-value',innerHTML:'1x'});el.appendChild(this.labelEl_);return el;};PlaybackRateMenuButton.prototype.dispose=function dispose(){this.labelEl_=null;_MenuButton.prototype.dispose.call(this);};/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */PlaybackRateMenuButton.prototype.buildCSSClass=function buildCSSClass(){return'vjs-playback-rate '+_MenuButton.prototype.buildCSSClass.call(this);};PlaybackRateMenuButton.prototype.buildWrapperCSSClass=function buildWrapperCSSClass(){return'vjs-playback-rate '+_MenuButton.prototype.buildWrapperCSSClass.call(this);};/**\n   * Create the playback rate menu\n   *\n   * @return {Menu}\n   *         Menu object populated with {@link PlaybackRateMenuItem}s\n   */PlaybackRateMenuButton.prototype.createMenu=function createMenu(){var menu=new Menu(this.player());var rates=this.playbackRates();if(rates){for(var i=rates.length-1;i>=0;i--){menu.addChild(new PlaybackRateMenuItem(this.player(),{rate:rates[i]+'x'}));}}return menu;};/**\n   * Updates ARIA accessibility attributes\n   */PlaybackRateMenuButton.prototype.updateARIAAttributes=function updateARIAAttributes(){// Current playback rate\nthis.el().setAttribute('aria-valuenow',this.player().playbackRate());};/**\n   * This gets called when an `PlaybackRateMenuButton` is \"clicked\". See\n   * {@link ClickableComponent} for more detailed information on what a click can be.\n   *\n   * @param {EventTarget~Event} [event]\n   *        The `keydown`, `tap`, or `click` event that caused this function to be\n   *        called.\n   *\n   * @listens tap\n   * @listens click\n   */PlaybackRateMenuButton.prototype.handleClick=function handleClick(event){// select next rate option\nvar currentRate=this.player().playbackRate();var rates=this.playbackRates();// this will select first one if the last one currently selected\nvar newRate=rates[0];for(var i=0;i<rates.length;i++){if(rates[i]>currentRate){newRate=rates[i];break;}}this.player().playbackRate(newRate);};/**\n   * Get possible playback rates\n   *\n   * @return {Array}\n   *         All possible playback rates\n   */PlaybackRateMenuButton.prototype.playbackRates=function playbackRates(){return this.options_.playbackRates||this.options_.playerOptions&&this.options_.playerOptions.playbackRates;};/**\n   * Get whether playback rates is supported by the tech\n   * and an array of playback rates exists\n   *\n   * @return {boolean}\n   *         Whether changing playback rate is supported\n   */PlaybackRateMenuButton.prototype.playbackRateSupported=function playbackRateSupported(){return this.player().tech_&&this.player().tech_.featuresPlaybackRate&&this.playbackRates()&&this.playbackRates().length>0;};/**\n   * Hide playback rate controls when they're no playback rate options to select\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#loadstart\n   */PlaybackRateMenuButton.prototype.updateVisibility=function updateVisibility(event){if(this.playbackRateSupported()){this.removeClass('vjs-hidden');}else{this.addClass('vjs-hidden');}};/**\n   * Update button label when rate changed\n   *\n   * @param {EventTarget~Event} [event]\n   *        The event that caused this function to run.\n   *\n   * @listens Player#ratechange\n   */PlaybackRateMenuButton.prototype.updateLabel=function updateLabel(event){if(this.playbackRateSupported()){this.labelEl_.innerHTML=this.player().playbackRate()+'x';}};return PlaybackRateMenuButton;}(MenuButton);/**\n * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n *\n * @type {string}\n * @private\n */PlaybackRateMenuButton.prototype.controlText_='Playback Rate';Component.registerComponent('PlaybackRateMenuButton',PlaybackRateMenuButton);/**\n * @file spacer.js\n *//**\n * Just an empty spacer element that can be used as an append point for plugins, etc.\n * Also can be used to create space between elements when necessary.\n *\n * @extends Component\n */var Spacer=function(_Component){inherits(Spacer,_Component);function Spacer(){classCallCheck(this,Spacer);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */Spacer.prototype.buildCSSClass=function buildCSSClass(){return'vjs-spacer '+_Component.prototype.buildCSSClass.call(this);};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */Spacer.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:this.buildCSSClass()});};return Spacer;}(Component);Component.registerComponent('Spacer',Spacer);/**\n * @file custom-control-spacer.js\n *//**\n * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n *\n * @extends Spacer\n */var CustomControlSpacer=function(_Spacer){inherits(CustomControlSpacer,_Spacer);function CustomControlSpacer(){classCallCheck(this,CustomControlSpacer);return possibleConstructorReturn(this,_Spacer.apply(this,arguments));}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   */CustomControlSpacer.prototype.buildCSSClass=function buildCSSClass(){return'vjs-custom-control-spacer '+_Spacer.prototype.buildCSSClass.call(this);};/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */CustomControlSpacer.prototype.createEl=function createEl(){var el=_Spacer.prototype.createEl.call(this,{className:this.buildCSSClass()});// No-flex/table-cell mode requires there be some content\n// in the cell to fill the remaining space of the table.\nel.innerHTML='&nbsp;';return el;};return CustomControlSpacer;}(Spacer);Component.registerComponent('CustomControlSpacer',CustomControlSpacer);/**\n * @file control-bar.js\n */// Required children\n/**\n * Container of main controls.\n *\n * @extends Component\n */var ControlBar=function(_Component){inherits(ControlBar,_Component);function ControlBar(){classCallCheck(this,ControlBar);return possibleConstructorReturn(this,_Component.apply(this,arguments));}/**\n   * Create the `Component`'s DOM element\n   *\n   * @return {Element}\n   *         The element that was created.\n   */ControlBar.prototype.createEl=function createEl(){return _Component.prototype.createEl.call(this,'div',{className:'vjs-control-bar',dir:'ltr'},{// The control bar is a group, but we don't aria-label it to avoid\n//  over-announcing by JAWS\nrole:'group'});};return ControlBar;}(Component);/**\n * Default options for `ControlBar`\n *\n * @type {Object}\n * @private\n */ControlBar.prototype.options_={children:['playToggle','volumePanel','currentTimeDisplay','timeDivider','durationDisplay','progressControl','liveDisplay','remainingTimeDisplay','customControlSpacer','playbackRateMenuButton','chaptersButton','descriptionsButton','subsCapsButton','audioTrackButton','fullscreenToggle']};Component.registerComponent('ControlBar',ControlBar);/**\n * @file error-display.js\n *//**\n * A display that indicates an error has occurred. This means that the video\n * is unplayable.\n *\n * @extends ModalDialog\n */var ErrorDisplay=function(_ModalDialog){inherits(ErrorDisplay,_ModalDialog);/**\n   * Creates an instance of this class.\n   *\n   * @param  {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param  {Object} [options]\n   *         The key/value store of player options.\n   */function ErrorDisplay(player,options){classCallCheck(this,ErrorDisplay);var _this=possibleConstructorReturn(this,_ModalDialog.call(this,player,options));_this.on(player,'error',_this.open);return _this;}/**\n   * Builds the default DOM `className`.\n   *\n   * @return {string}\n   *         The DOM `className` for this object.\n   *\n   * @deprecated Since version 5.\n   */ErrorDisplay.prototype.buildCSSClass=function buildCSSClass(){return'vjs-error-display '+_ModalDialog.prototype.buildCSSClass.call(this);};/**\n   * Gets the localized error message based on the `Player`s error.\n   *\n   * @return {string}\n   *         The `Player`s error message localized or an empty string.\n   */ErrorDisplay.prototype.content=function content(){var error=this.player().error();return error?this.localize(error.message):'';};return ErrorDisplay;}(ModalDialog);/**\n * The default options for an `ErrorDisplay`.\n *\n * @private\n */ErrorDisplay.prototype.options_=mergeOptions(ModalDialog.prototype.options_,{pauseOnOpen:false,fillAlways:true,temporary:false,uncloseable:true});Component.registerComponent('ErrorDisplay',ErrorDisplay);/**\n * @file text-track-settings.js\n */var LOCAL_STORAGE_KEY='vjs-text-track-settings';var COLOR_BLACK=['#000','Black'];var COLOR_BLUE=['#00F','Blue'];var COLOR_CYAN=['#0FF','Cyan'];var COLOR_GREEN=['#0F0','Green'];var COLOR_MAGENTA=['#F0F','Magenta'];var COLOR_RED=['#F00','Red'];var COLOR_WHITE=['#FFF','White'];var COLOR_YELLOW=['#FF0','Yellow'];var OPACITY_OPAQUE=['1','Opaque'];var OPACITY_SEMI=['0.5','Semi-Transparent'];var OPACITY_TRANS=['0','Transparent'];// Configuration for the various <select> elements in the DOM of this component.\n//\n// Possible keys include:\n//\n// `default`:\n//   The default option index. Only needs to be provided if not zero.\n// `parser`:\n//   A function which is used to parse the value from the selected option in\n//   a customized way.\n// `selector`:\n//   The selector used to find the associated <select> element.\nvar selectConfigs={backgroundColor:{selector:'.vjs-bg-color > select',id:'captions-background-color-%s',label:'Color',options:[COLOR_BLACK,COLOR_WHITE,COLOR_RED,COLOR_GREEN,COLOR_BLUE,COLOR_YELLOW,COLOR_MAGENTA,COLOR_CYAN]},backgroundOpacity:{selector:'.vjs-bg-opacity > select',id:'captions-background-opacity-%s',label:'Transparency',options:[OPACITY_OPAQUE,OPACITY_SEMI,OPACITY_TRANS]},color:{selector:'.vjs-fg-color > select',id:'captions-foreground-color-%s',label:'Color',options:[COLOR_WHITE,COLOR_BLACK,COLOR_RED,COLOR_GREEN,COLOR_BLUE,COLOR_YELLOW,COLOR_MAGENTA,COLOR_CYAN]},edgeStyle:{selector:'.vjs-edge-style > select',id:'%s',label:'Text Edge Style',options:[['none','None'],['raised','Raised'],['depressed','Depressed'],['uniform','Uniform'],['dropshadow','Dropshadow']]},fontFamily:{selector:'.vjs-font-family > select',id:'captions-font-family-%s',label:'Font Family',options:[['proportionalSansSerif','Proportional Sans-Serif'],['monospaceSansSerif','Monospace Sans-Serif'],['proportionalSerif','Proportional Serif'],['monospaceSerif','Monospace Serif'],['casual','Casual'],['script','Script'],['small-caps','Small Caps']]},fontPercent:{selector:'.vjs-font-percent > select',id:'captions-font-size-%s',label:'Font Size',options:[['0.50','50%'],['0.75','75%'],['1.00','100%'],['1.25','125%'],['1.50','150%'],['1.75','175%'],['2.00','200%'],['3.00','300%'],['4.00','400%']],'default':2,parser:function parser(v){return v==='1.00'?null:Number(v);}},textOpacity:{selector:'.vjs-text-opacity > select',id:'captions-foreground-opacity-%s',label:'Transparency',options:[OPACITY_OPAQUE,OPACITY_SEMI]},// Options for this object are defined below.\nwindowColor:{selector:'.vjs-window-color > select',id:'captions-window-color-%s',label:'Color'},// Options for this object are defined below.\nwindowOpacity:{selector:'.vjs-window-opacity > select',id:'captions-window-opacity-%s',label:'Transparency',options:[OPACITY_TRANS,OPACITY_SEMI,OPACITY_OPAQUE]}};selectConfigs.windowColor.options=selectConfigs.backgroundColor.options;/**\n * Get the actual value of an option.\n *\n * @param  {string} value\n *         The value to get\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */function parseOptionValue(value,parser){if(parser){value=parser(value);}if(value&&value!=='none'){return value;}}/**\n * Gets the value of the selected <option> element within a <select> element.\n *\n * @param  {Element} el\n *         the element to look in\n *\n * @param  {Function} [parser]\n *         Optional function to adjust the value.\n *\n * @return {Mixed}\n *         - Will be `undefined` if no value exists\n *         - Will be `undefined` if the given value is \"none\".\n *         - Will be the actual value otherwise.\n *\n * @private\n */function getSelectedOptionValue(el,parser){var value=el.options[el.options.selectedIndex].value;return parseOptionValue(value,parser);}/**\n * Sets the selected <option> element within a <select> element based on a\n * given value.\n *\n * @param {Element} el\n *        The element to look in.\n *\n * @param {string} value\n *        the property to look on.\n *\n * @param {Function} [parser]\n *        Optional function to adjust the value before comparing.\n *\n * @private\n */function setSelectedOption(el,value,parser){if(!value){return;}for(var i=0;i<el.options.length;i++){if(parseOptionValue(el.options[i].value,parser)===value){el.selectedIndex=i;break;}}}/**\n * Manipulate Text Tracks settings.\n *\n * @extends ModalDialog\n */var TextTrackSettings=function(_ModalDialog){inherits(TextTrackSettings,_ModalDialog);/**\n   * Creates an instance of this class.\n   *\n   * @param {Player} player\n   *         The `Player` that this class should be attached to.\n   *\n   * @param {Object} [options]\n   *         The key/value store of player options.\n   */function TextTrackSettings(player,options){classCallCheck(this,TextTrackSettings);options.temporary=false;var _this=possibleConstructorReturn(this,_ModalDialog.call(this,player,options));_this.updateDisplay=bind(_this,_this.updateDisplay);// fill the modal and pretend we have opened it\n_this.fill();_this.hasBeenOpened_=_this.hasBeenFilled_=true;_this.endDialog=createEl('p',{className:'vjs-control-text',textContent:_this.localize('End of dialog window.')});_this.el().appendChild(_this.endDialog);_this.setDefaults();// Grab `persistTextTrackSettings` from the player options if not passed in child options\nif(options.persistTextTrackSettings===undefined){_this.options_.persistTextTrackSettings=_this.options_.playerOptions.persistTextTrackSettings;}_this.on(_this.$('.vjs-done-button'),'click',function(){_this.saveSettings();_this.close();});_this.on(_this.$('.vjs-default-button'),'click',function(){_this.setDefaults();_this.updateDisplay();});each(selectConfigs,function(config){_this.on(_this.$(config.selector),'change',_this.updateDisplay);});if(_this.options_.persistTextTrackSettings){_this.restoreSettings();}return _this;}TextTrackSettings.prototype.dispose=function dispose(){this.endDialog=null;_ModalDialog.prototype.dispose.call(this);};/**\n   * Create a <select> element with configured options.\n   *\n   * @param {string} key\n   *        Configuration key to use during creation.\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElSelect_=function createElSelect_(key){var _this2=this;var legendId=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';var type=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'label';var config=selectConfigs[key];var id=config.id.replace('%s',this.id_);return['<'+type+' id=\"'+id+'\" class=\"'+(type==='label'?'vjs-label':'')+'\">',this.localize(config.label),'</'+type+'>','<select aria-labelledby=\"'+(legendId!==''?legendId+' ':'')+id+'\">'].concat(config.options.map(function(o){var optionId=id+'-'+o[1];return['<option id=\"'+optionId+'\" value=\"'+o[0]+'\" ','aria-labelledby=\"'+(legendId!==''?legendId+' ':'')+id+' '+optionId+'\">',_this2.localize(o[1]),'</option>'].join('');})).concat('</select>').join('');};/**\n   * Create foreground color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElFgColor_=function createElFgColor_(){var legendId='captions-text-legend-'+this.id_;return['<fieldset class=\"vjs-fg-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Text'),'</legend>',this.createElSelect_('color',legendId),'<span class=\"vjs-text-opacity vjs-opacity\">',this.createElSelect_('textOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create background color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElBgColor_=function createElBgColor_(){var legendId='captions-background-'+this.id_;return['<fieldset class=\"vjs-bg-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Background'),'</legend>',this.createElSelect_('backgroundColor',legendId),'<span class=\"vjs-bg-opacity vjs-opacity\">',this.createElSelect_('backgroundOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create window color element for the component\n   *\n   * @return {string}\n   *         An HTML string.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElWinColor_=function createElWinColor_(){var legendId='captions-window-'+this.id_;return['<fieldset class=\"vjs-window-color vjs-track-setting\">','<legend id=\"'+legendId+'\">',this.localize('Window'),'</legend>',this.createElSelect_('windowColor',legendId),'<span class=\"vjs-window-opacity vjs-opacity\">',this.createElSelect_('windowOpacity',legendId),'</span>','</fieldset>'].join('');};/**\n   * Create color elements for the component\n   *\n   * @return {Element}\n   *         The element that was created\n   *\n   * @private\n   */TextTrackSettings.prototype.createElColors_=function createElColors_(){return createEl('div',{className:'vjs-track-settings-colors',innerHTML:[this.createElFgColor_(),this.createElBgColor_(),this.createElWinColor_()].join('')});};/**\n   * Create font elements for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElFont_=function createElFont_(){return createEl('div',{className:'vjs-track-settings-font\">',innerHTML:['<fieldset class=\"vjs-font-percent vjs-track-setting\">',this.createElSelect_('fontPercent','','legend'),'</fieldset>','<fieldset class=\"vjs-edge-style vjs-track-setting\">',this.createElSelect_('edgeStyle','','legend'),'</fieldset>','<fieldset class=\"vjs-font-family vjs-track-setting\">',this.createElSelect_('fontFamily','','legend'),'</fieldset>'].join('')});};/**\n   * Create controls for the component\n   *\n   * @return {Element}\n   *         The element that was created.\n   *\n   * @private\n   */TextTrackSettings.prototype.createElControls_=function createElControls_(){var defaultsDescription=this.localize('restore all settings to the default values');return createEl('div',{className:'vjs-track-settings-controls',innerHTML:['<button class=\"vjs-default-button\" title=\"'+defaultsDescription+'\">',this.localize('Reset'),'<span class=\"vjs-control-text\"> '+defaultsDescription+'</span>','</button>','<button class=\"vjs-done-button\">'+this.localize('Done')+'</button>'].join('')});};TextTrackSettings.prototype.content=function content(){return[this.createElColors_(),this.createElFont_(),this.createElControls_()];};TextTrackSettings.prototype.label=function label(){return this.localize('Caption Settings Dialog');};TextTrackSettings.prototype.description=function description(){return this.localize('Beginning of dialog window. Escape will cancel and close the window.');};TextTrackSettings.prototype.buildCSSClass=function buildCSSClass(){return _ModalDialog.prototype.buildCSSClass.call(this)+' vjs-text-track-settings';};/**\n   * Gets an object of text track settings (or null).\n   *\n   * @return {Object}\n   *         An object with config values parsed from the DOM or localStorage.\n   */TextTrackSettings.prototype.getValues=function getValues(){var _this3=this;return reduce(selectConfigs,function(accum,config,key){var value=getSelectedOptionValue(_this3.$(config.selector),config.parser);if(value!==undefined){accum[key]=value;}return accum;},{});};/**\n   * Sets text track settings from an object of values.\n   *\n   * @param {Object} values\n   *        An object with config values parsed from the DOM or localStorage.\n   */TextTrackSettings.prototype.setValues=function setValues(values){var _this4=this;each(selectConfigs,function(config,key){setSelectedOption(_this4.$(config.selector),values[key],config.parser);});};/**\n   * Sets all `<select>` elements to their default values.\n   */TextTrackSettings.prototype.setDefaults=function setDefaults(){var _this5=this;each(selectConfigs,function(config){var index=config.hasOwnProperty('default')?config['default']:0;_this5.$(config.selector).selectedIndex=index;});};/**\n   * Restore texttrack settings from localStorage\n   */TextTrackSettings.prototype.restoreSettings=function restoreSettings(){var values=void 0;try{values=JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));}catch(err){log$1.warn(err);}if(values){this.setValues(values);}};/**\n   * Save text track settings to localStorage\n   */TextTrackSettings.prototype.saveSettings=function saveSettings(){if(!this.options_.persistTextTrackSettings){return;}var values=this.getValues();try{if(Object.keys(values).length){window.localStorage.setItem(LOCAL_STORAGE_KEY,JSON.stringify(values));}else{window.localStorage.removeItem(LOCAL_STORAGE_KEY);}}catch(err){log$1.warn(err);}};/**\n   * Update display of text track settings\n   */TextTrackSettings.prototype.updateDisplay=function updateDisplay(){var ttDisplay=this.player_.getChild('textTrackDisplay');if(ttDisplay){ttDisplay.updateDisplay();}};/**\n   * conditionally blur the element and refocus the captions button\n   *\n   * @private\n   */TextTrackSettings.prototype.conditionalBlur_=function conditionalBlur_(){this.previouslyActiveEl_=null;this.off(document,'keydown',this.handleKeyDown);var cb=this.player_.controlBar;var subsCapsBtn=cb&&cb.subsCapsButton;var ccBtn=cb&&cb.captionsButton;if(subsCapsBtn){subsCapsBtn.focus();}else if(ccBtn){ccBtn.focus();}};return TextTrackSettings;}(ModalDialog);Component.registerComponent('TextTrackSettings',TextTrackSettings);var _templateObject$2=taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.'],['Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n            This may prevent text tracks from loading.']);/**\n * @file html5.js\n *//**\n * HTML5 Media Controller - Wrapper for HTML5 Media API\n *\n * @mixes Tech~SouceHandlerAdditions\n * @extends Tech\n */var Html5=function(_Tech){inherits(Html5,_Tech);/**\n   * Create an instance of this Tech.\n   *\n   * @param {Object} [options]\n   *        The key/value store of player options.\n   *\n   * @param {Component~ReadyCallback} ready\n   *        Callback function to call when the `HTML5` Tech is ready.\n   */function Html5(options,ready){classCallCheck(this,Html5);var _this=possibleConstructorReturn(this,_Tech.call(this,options,ready));var source=options.source;var crossoriginTracks=false;// Set the source if one is provided\n// 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n// 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n// anyway so the error gets fired.\nif(source&&(_this.el_.currentSrc!==source.src||options.tag&&options.tag.initNetworkState_===3)){_this.setSource(source);}else{_this.handleLateInit_(_this.el_);}if(_this.el_.hasChildNodes()){var nodes=_this.el_.childNodes;var nodesLength=nodes.length;var removeNodes=[];while(nodesLength--){var node=nodes[nodesLength];var nodeName=node.nodeName.toLowerCase();if(nodeName==='track'){if(!_this.featuresNativeTextTracks){// Empty video tag tracks so the built-in player doesn't use them also.\n// This may not be fast enough to stop HTML5 browsers from reading the tags\n// so we'll need to turn off any default tracks if we're manually doing\n// captions and subtitles. videoElement.textTracks\nremoveNodes.push(node);}else{// store HTMLTrackElement and TextTrack to remote list\n_this.remoteTextTrackEls().addTrackElement_(node);_this.remoteTextTracks().addTrack(node.track);_this.textTracks().addTrack(node.track);if(!crossoriginTracks&&!_this.el_.hasAttribute('crossorigin')&&isCrossOrigin(node.src)){crossoriginTracks=true;}}}}for(var i=0;i<removeNodes.length;i++){_this.el_.removeChild(removeNodes[i]);}}_this.proxyNativeTracks_();if(_this.featuresNativeTextTracks&&crossoriginTracks){log$1.warn(tsml(_templateObject$2));}// prevent iOS Safari from disabling metadata text tracks during native playback\n_this.restoreMetadataTracksInIOSNativePlayer_();// Determine if native controls should be used\n// Our goal should be to get the custom controls on mobile solid everywhere\n// so we can remove this all together. Right now this will block custom\n// controls on touch enabled laptops like the Chrome Pixel\nif((TOUCH_ENABLED||IS_IPHONE||IS_NATIVE_ANDROID)&&options.nativeControlsForTouch===true){_this.setControls(true);}// on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n// into a `fullscreenchange` event\n_this.proxyWebkitFullscreen_();_this.triggerReady();return _this;}/**\n   * Dispose of `HTML5` media element and remove all tracks.\n   */Html5.prototype.dispose=function dispose(){Html5.disposeMediaElement(this.el_);this.options_=null;// tech will handle clearing of the emulated track list\n_Tech.prototype.dispose.call(this);};/**\n   * When a captions track is enabled in the iOS Safari native player, all other\n   * tracks are disabled (including metadata tracks), which nulls all of their\n   * associated cue points. This will restore metadata tracks to their pre-fullscreen\n   * state in those cases so that cue points are not needlessly lost.\n   *\n   * @private\n   */Html5.prototype.restoreMetadataTracksInIOSNativePlayer_=function restoreMetadataTracksInIOSNativePlayer_(){var textTracks=this.textTracks();var metadataTracksPreFullscreenState=void 0;// captures a snapshot of every metadata track's current state\nvar takeMetadataTrackSnapshot=function takeMetadataTrackSnapshot(){metadataTracksPreFullscreenState=[];for(var i=0;i<textTracks.length;i++){var track=textTracks[i];if(track.kind==='metadata'){metadataTracksPreFullscreenState.push({track:track,storedMode:track.mode});}}};// snapshot each metadata track's initial state, and update the snapshot\n// each time there is a track 'change' event\ntakeMetadataTrackSnapshot();textTracks.addEventListener('change',takeMetadataTrackSnapshot);this.on('dispose',function(){return textTracks.removeEventListener('change',takeMetadataTrackSnapshot);});var restoreTrackMode=function restoreTrackMode(){for(var i=0;i<metadataTracksPreFullscreenState.length;i++){var storedTrack=metadataTracksPreFullscreenState[i];if(storedTrack.track.mode==='disabled'&&storedTrack.track.mode!==storedTrack.storedMode){storedTrack.track.mode=storedTrack.storedMode;}}// we only want this handler to be executed on the first 'change' event\ntextTracks.removeEventListener('change',restoreTrackMode);};// when we enter fullscreen playback, stop updating the snapshot and\n// restore all track modes to their pre-fullscreen state\nthis.on('webkitbeginfullscreen',function(){textTracks.removeEventListener('change',takeMetadataTrackSnapshot);// remove the listener before adding it just in case it wasn't previously removed\ntextTracks.removeEventListener('change',restoreTrackMode);textTracks.addEventListener('change',restoreTrackMode);});// start updating the snapshot again after leaving fullscreen\nthis.on('webkitendfullscreen',function(){// remove the listener before adding it just in case it wasn't previously removed\ntextTracks.removeEventListener('change',takeMetadataTrackSnapshot);textTracks.addEventListener('change',takeMetadataTrackSnapshot);// remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\ntextTracks.removeEventListener('change',restoreTrackMode);});};/**\n   * Proxy all native track list events to our track lists if the browser we are playing\n   * in supports that type of track list.\n   *\n   * @private\n   */Html5.prototype.proxyNativeTracks_=function proxyNativeTracks_(){var _this2=this;NORMAL.names.forEach(function(name){var props=NORMAL[name];var elTracks=_this2.el()[props.getterName];var techTracks=_this2[props.getterName]();if(!_this2['featuresNative'+props.capitalName+'Tracks']||!elTracks||!elTracks.addEventListener){return;}var listeners={change:function change(e){techTracks.trigger({type:'change',target:techTracks,currentTarget:techTracks,srcElement:techTracks});},addtrack:function addtrack(e){techTracks.addTrack(e.track);},removetrack:function removetrack(e){techTracks.removeTrack(e.track);}};var removeOldTracks=function removeOldTracks(){var removeTracks=[];for(var i=0;i<techTracks.length;i++){var found=false;for(var j=0;j<elTracks.length;j++){if(elTracks[j]===techTracks[i]){found=true;break;}}if(!found){removeTracks.push(techTracks[i]);}}while(removeTracks.length){techTracks.removeTrack(removeTracks.shift());}};Object.keys(listeners).forEach(function(eventName){var listener=listeners[eventName];elTracks.addEventListener(eventName,listener);_this2.on('dispose',function(e){return elTracks.removeEventListener(eventName,listener);});});// Remove (native) tracks that are not used anymore\n_this2.on('loadstart',removeOldTracks);_this2.on('dispose',function(e){return _this2.off('loadstart',removeOldTracks);});});};/**\n   * Create the `Html5` Tech's DOM element.\n   *\n   * @return {Element}\n   *         The element that gets created.\n   */Html5.prototype.createEl=function createEl$$1(){var el=this.options_.tag;// Check if this browser supports moving the element into the box.\n// On the iPhone video will break if you move the element,\n// So we have to create a brand new element.\n// If we ingested the player div, we do not need to move the media element.\nif(!el||!(this.options_.playerElIngest||this.movingMediaElementInDOM)){// If the original tag is still there, clone and remove it.\nif(el){var clone=el.cloneNode(true);if(el.parentNode){el.parentNode.insertBefore(clone,el);}Html5.disposeMediaElement(el);el=clone;}else{el=document.createElement('video');// determine if native controls should be used\nvar tagAttributes=this.options_.tag&&getAttributes(this.options_.tag);var attributes=mergeOptions({},tagAttributes);if(!TOUCH_ENABLED||this.options_.nativeControlsForTouch!==true){delete attributes.controls;}setAttributes(el,assign(attributes,{id:this.options_.techId,'class':'vjs-tech'}));}el.playerId=this.options_.playerId;}if(typeof this.options_.preload!=='undefined'){setAttribute(el,'preload',this.options_.preload);}// Update specific tag settings, in case they were overridden\n// `autoplay` has to be *last* so that `muted` and `playsinline` are present\n// when iOS/Safari or other browsers attempt to autoplay.\nvar settingsAttrs=['loop','muted','playsinline','autoplay'];for(var i=0;i<settingsAttrs.length;i++){var attr=settingsAttrs[i];var value=this.options_[attr];if(typeof value!=='undefined'){if(value){setAttribute(el,attr,attr);}else{removeAttribute(el,attr);}el[attr]=value;}}return el;};/**\n   * This will be triggered if the loadstart event has already fired, before videojs was\n   * ready. Two known examples of when this can happen are:\n   * 1. If we're loading the playback object after it has started loading\n   * 2. The media is already playing the (often with autoplay on) then\n   *\n   * This function will fire another loadstart so that videojs can catchup.\n   *\n   * @fires Tech#loadstart\n   *\n   * @return {undefined}\n   *         returns nothing.\n   */Html5.prototype.handleLateInit_=function handleLateInit_(el){if(el.networkState===0||el.networkState===3){// The video element hasn't started loading the source yet\n// or didn't find a source\nreturn;}if(el.readyState===0){// NetworkState is set synchronously BUT loadstart is fired at the\n// end of the current stack, usually before setInterval(fn, 0).\n// So at this point we know loadstart may have already fired or is\n// about to fire, and either way the player hasn't seen it yet.\n// We don't want to fire loadstart prematurely here and cause a\n// double loadstart so we'll wait and see if it happens between now\n// and the next loop, and fire it if not.\n// HOWEVER, we also want to make sure it fires before loadedmetadata\n// which could also happen between now and the next loop, so we'll\n// watch for that also.\nvar loadstartFired=false;var setLoadstartFired=function setLoadstartFired(){loadstartFired=true;};this.on('loadstart',setLoadstartFired);var triggerLoadstart=function triggerLoadstart(){// We did miss the original loadstart. Make sure the player\n// sees loadstart before loadedmetadata\nif(!loadstartFired){this.trigger('loadstart');}};this.on('loadedmetadata',triggerLoadstart);this.ready(function(){this.off('loadstart',setLoadstartFired);this.off('loadedmetadata',triggerLoadstart);if(!loadstartFired){// We did miss the original native loadstart. Fire it now.\nthis.trigger('loadstart');}});return;}// From here on we know that loadstart already fired and we missed it.\n// The other readyState events aren't as much of a problem if we double\n// them, so not going to go to as much trouble as loadstart to prevent\n// that unless we find reason to.\nvar eventsToTrigger=['loadstart'];// loadedmetadata: newly equal to HAVE_METADATA (1) or greater\neventsToTrigger.push('loadedmetadata');// loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\nif(el.readyState>=2){eventsToTrigger.push('loadeddata');}// canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\nif(el.readyState>=3){eventsToTrigger.push('canplay');}// canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\nif(el.readyState>=4){eventsToTrigger.push('canplaythrough');}// We still need to give the player time to add event listeners\nthis.ready(function(){eventsToTrigger.forEach(function(type){this.trigger(type);},this);});};/**\n   * Set current time for the `HTML5` tech.\n   *\n   * @param {number} seconds\n   *        Set the current time of the media to this.\n   */Html5.prototype.setCurrentTime=function setCurrentTime(seconds){try{this.el_.currentTime=seconds;}catch(e){log$1(e,'Video is not ready. (Video.js)');// this.warning(VideoJS.warnings.videoNotReady);\n}};/**\n   * Get the current duration of the HTML5 media element.\n   *\n   * @return {number}\n   *         The duration of the media or 0 if there is no duration.\n   */Html5.prototype.duration=function duration(){var _this3=this;// Android Chrome will report duration as Infinity for VOD HLS until after\n// playback has started, which triggers the live display erroneously.\n// Return NaN if playback has not started and trigger a durationupdate once\n// the duration can be reliably known.\nif(this.el_.duration===Infinity&&IS_ANDROID&&IS_CHROME&&this.el_.currentTime===0){// Wait for the first `timeupdate` with currentTime > 0 - there may be\n// several with 0\nvar checkProgress=function checkProgress(){if(_this3.el_.currentTime>0){// Trigger durationchange for genuinely live video\nif(_this3.el_.duration===Infinity){_this3.trigger('durationchange');}_this3.off('timeupdate',checkProgress);}};this.on('timeupdate',checkProgress);return NaN;}return this.el_.duration||NaN;};/**\n   * Get the current width of the HTML5 media element.\n   *\n   * @return {number}\n   *         The width of the HTML5 media element.\n   */Html5.prototype.width=function width(){return this.el_.offsetWidth;};/**\n   * Get the current height of the HTML5 media element.\n   *\n   * @return {number}\n   *         The heigth of the HTML5 media element.\n   */Html5.prototype.height=function height(){return this.el_.offsetHeight;};/**\n   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n   * `fullscreenchange` event.\n   *\n   * @private\n   * @fires fullscreenchange\n   * @listens webkitendfullscreen\n   * @listens webkitbeginfullscreen\n   * @listens webkitbeginfullscreen\n   */Html5.prototype.proxyWebkitFullscreen_=function proxyWebkitFullscreen_(){var _this4=this;if(!('webkitDisplayingFullscreen'in this.el_)){return;}var endFn=function endFn(){this.trigger('fullscreenchange',{isFullscreen:false});};var beginFn=function beginFn(){if('webkitPresentationMode'in this.el_&&this.el_.webkitPresentationMode!=='picture-in-picture'){this.one('webkitendfullscreen',endFn);this.trigger('fullscreenchange',{isFullscreen:true});}};this.on('webkitbeginfullscreen',beginFn);this.on('dispose',function(){_this4.off('webkitbeginfullscreen',beginFn);_this4.off('webkitendfullscreen',endFn);});};/**\n   * Check if fullscreen is supported on the current playback device.\n   *\n   * @return {boolean}\n   *         - True if fullscreen is supported.\n   *         - False if fullscreen is not supported.\n   */Html5.prototype.supportsFullScreen=function supportsFullScreen(){if(typeof this.el_.webkitEnterFullScreen==='function'){var userAgent=window.navigator&&window.navigator.userAgent||'';// Seems to be broken in Chromium/Chrome && Safari in Leopard\nif(/Android/.test(userAgent)||!/Chrome|Mac OS X 10.5/.test(userAgent)){return true;}}return false;};/**\n   * Request that the `HTML5` Tech enter fullscreen.\n   */Html5.prototype.enterFullScreen=function enterFullScreen(){var video=this.el_;if(video.paused&&video.networkState<=video.HAVE_METADATA){// attempt to prime the video element for programmatic access\n// this isn't necessary on the desktop but shouldn't hurt\nthis.el_.play();// playing and pausing synchronously during the transition to fullscreen\n// can get iOS ~6.1 devices into a play/pause loop\nthis.setTimeout(function(){video.pause();video.webkitEnterFullScreen();},0);}else{video.webkitEnterFullScreen();}};/**\n   * Request that the `HTML5` Tech exit fullscreen.\n   */Html5.prototype.exitFullScreen=function exitFullScreen(){this.el_.webkitExitFullScreen();};/**\n   * A getter/setter for the `Html5` Tech's source object.\n   * > Note: Please use {@link Html5#setSource}\n   *\n   * @param {Tech~SourceObject} [src]\n   *        The source object you want to set on the `HTML5` techs element.\n   *\n   * @return {Tech~SourceObject|undefined}\n   *         - The current source object when a source is not passed in.\n   *         - undefined when setting\n   *\n   * @deprecated Since version 5.\n   */Html5.prototype.src=function src(_src){if(_src===undefined){return this.el_.src;}// Setting src through `src` instead of `setSrc` will be deprecated\nthis.setSrc(_src);};/**\n   * Reset the tech by removing all sources and then calling\n   * {@link Html5.resetMediaElement}.\n   */Html5.prototype.reset=function reset(){Html5.resetMediaElement(this.el_);};/**\n   * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n   * the HTML5 media element.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object from the HTML5 tech. With a fallback to the\n   *         elements source.\n   */Html5.prototype.currentSrc=function currentSrc(){if(this.currentSource_){return this.currentSource_.src;}return this.el_.currentSrc;};/**\n   * Set controls attribute for the HTML5 media Element.\n   *\n   * @param {string} val\n   *        Value to set the controls attribute to\n   */Html5.prototype.setControls=function setControls(val){this.el_.controls=!!val;};/**\n   * Create and returns a remote {@link TextTrack} object.\n   *\n   * @param {string} kind\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n   *\n   * @param {string} [label]\n   *        Label to identify the text track\n   *\n   * @param {string} [language]\n   *        Two letter language abbreviation\n   *\n   * @return {TextTrack}\n   *         The TextTrack that gets created.\n   */Html5.prototype.addTextTrack=function addTextTrack(kind,label,language){if(!this.featuresNativeTextTracks){return _Tech.prototype.addTextTrack.call(this,kind,label,language);}return this.el_.addTextTrack(kind,label,language);};/**\n   * Creates either native TextTrack or an emulated TextTrack depending\n   * on the value of `featuresNativeTextTracks`\n   *\n   * @param {Object} options\n   *        The object should contain the options to intialize the TextTrack with.\n   *\n   * @param {string} [options.kind]\n   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n   *\n   * @param {string} [options.label].\n   *        Label to identify the text track\n   *\n   * @param {string} [options.language]\n   *        Two letter language abbreviation.\n   *\n   * @param {boolean} [options.default]\n   *        Default this track to on.\n   *\n   * @param {string} [options.id]\n   *        The internal id to assign this track.\n   *\n   * @param {string} [options.src]\n   *        A source url for the track.\n   *\n   * @return {HTMLTrackElement}\n   *         The track element that gets created.\n   */Html5.prototype.createRemoteTextTrack=function createRemoteTextTrack(options){if(!this.featuresNativeTextTracks){return _Tech.prototype.createRemoteTextTrack.call(this,options);}var htmlTrackElement=document.createElement('track');if(options.kind){htmlTrackElement.kind=options.kind;}if(options.label){htmlTrackElement.label=options.label;}if(options.language||options.srclang){htmlTrackElement.srclang=options.language||options.srclang;}if(options['default']){htmlTrackElement['default']=options['default'];}if(options.id){htmlTrackElement.id=options.id;}if(options.src){htmlTrackElement.src=options.src;}return htmlTrackElement;};/**\n   * Creates a remote text track object and returns an html track element.\n   *\n   * @param {Object} options The object should contain values for\n   * kind, language, label, and src (location of the WebVTT file)\n   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   * automatically removed from the video element whenever the source changes\n   * @return {HTMLTrackElement} An Html Track Element.\n   * This can be an emulated {@link HTMLTrackElement} or a native one.\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   * to \"false\" in upcoming versions of Video.js\n   */Html5.prototype.addRemoteTextTrack=function addRemoteTextTrack(options,manualCleanup){var htmlTrackElement=_Tech.prototype.addRemoteTextTrack.call(this,options,manualCleanup);if(this.featuresNativeTextTracks){this.el().appendChild(htmlTrackElement);}return htmlTrackElement;};/**\n   * Remove remote `TextTrack` from `TextTrackList` object\n   *\n   * @param {TextTrack} track\n   *        `TextTrack` object to remove\n   */Html5.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(track){_Tech.prototype.removeRemoteTextTrack.call(this,track);if(this.featuresNativeTextTracks){var tracks=this.$$('track');var i=tracks.length;while(i--){if(track===tracks[i]||track===tracks[i].track){this.el().removeChild(tracks[i]);}}}};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object}\n   *         An object with supported media playback quality metrics\n   */Html5.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){if(typeof this.el().getVideoPlaybackQuality==='function'){return this.el().getVideoPlaybackQuality();}var videoPlaybackQuality={};if(typeof this.el().webkitDroppedFrameCount!=='undefined'&&typeof this.el().webkitDecodedFrameCount!=='undefined'){videoPlaybackQuality.droppedVideoFrames=this.el().webkitDroppedFrameCount;videoPlaybackQuality.totalVideoFrames=this.el().webkitDecodedFrameCount;}if(window.performance&&typeof window.performance.now==='function'){videoPlaybackQuality.creationTime=window.performance.now();}else if(window.performance&&window.performance.timing&&typeof window.performance.timing.navigationStart==='number'){videoPlaybackQuality.creationTime=window.Date.now()-window.performance.timing.navigationStart;}return videoPlaybackQuality;};return Html5;}(Tech);/* HTML5 Support Testing ---------------------------------------------------- */if(isReal()){/**\n   * Element for testing browser HTML5 media capabilities\n   *\n   * @type {Element}\n   * @constant\n   * @private\n   */Html5.TEST_VID=document.createElement('video');var track=document.createElement('track');track.kind='captions';track.srclang='en';track.label='English';Html5.TEST_VID.appendChild(track);}/**\n * Check if HTML5 media is supported by this browser/device.\n *\n * @return {boolean}\n *         - True if HTML5 media is supported.\n *         - False if HTML5 media is not supported.\n */Html5.isSupported=function(){// IE9 with no Media Player is a LIAR! (#984)\ntry{Html5.TEST_VID.volume=0.5;}catch(e){return false;}return!!(Html5.TEST_VID&&Html5.TEST_VID.canPlayType);};/**\n * Check if the tech can support the given type\n *\n * @param {string} type\n *        The mimetype to check\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */Html5.canPlayType=function(type){return Html5.TEST_VID.canPlayType(type);};/**\n * Check if the tech can support the given source\n * @param {Object} srcObj\n *        The source object\n * @param {Object} options\n *        The options passed to the tech\n * @return {string} 'probably', 'maybe', or '' (empty string)\n */Html5.canPlaySource=function(srcObj,options){return Html5.canPlayType(srcObj.type);};/**\n * Check if the volume can be changed in this browser/device.\n * Volume cannot be changed in a lot of mobile devices.\n * Specifically, it can't be changed from 1 on iOS.\n *\n * @return {boolean}\n *         - True if volume can be controlled\n *         - False otherwise\n */Html5.canControlVolume=function(){// IE will error if Windows Media Player not installed #3315\ntry{var volume=Html5.TEST_VID.volume;Html5.TEST_VID.volume=volume/2+0.1;return volume!==Html5.TEST_VID.volume;}catch(e){return false;}};/**\n * Check if the playback rate can be changed in this browser/device.\n *\n * @return {boolean}\n *         - True if playback rate can be controlled\n *         - False otherwise\n */Html5.canControlPlaybackRate=function(){// Playback rate API is implemented in Android Chrome, but doesn't do anything\n// https://github.com/videojs/video.js/issues/3180\nif(IS_ANDROID&&IS_CHROME&&CHROME_VERSION<58){return false;}// IE will error if Windows Media Player not installed #3315\ntry{var playbackRate=Html5.TEST_VID.playbackRate;Html5.TEST_VID.playbackRate=playbackRate/2+0.1;return playbackRate!==Html5.TEST_VID.playbackRate;}catch(e){return false;}};/**\n * Check to see if native `TextTrack`s are supported by this browser/device.\n *\n * @return {boolean}\n *         - True if native `TextTrack`s are supported.\n *         - False otherwise\n */Html5.supportsNativeTextTracks=function(){return IS_ANY_SAFARI;};/**\n * Check to see if native `VideoTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `VideoTrack`s are supported.\n *        - False otherwise\n */Html5.supportsNativeVideoTracks=function(){return!!(Html5.TEST_VID&&Html5.TEST_VID.videoTracks);};/**\n * Check to see if native `AudioTrack`s are supported by this browser/device\n *\n * @return {boolean}\n *        - True if native `AudioTrack`s are supported.\n *        - False otherwise\n */Html5.supportsNativeAudioTracks=function(){return!!(Html5.TEST_VID&&Html5.TEST_VID.audioTracks);};/**\n * An array of events available on the Html5 tech.\n *\n * @private\n * @type {Array}\n */Html5.Events=['loadstart','suspend','abort','error','emptied','stalled','loadedmetadata','loadeddata','canplay','canplaythrough','playing','waiting','seeking','seeked','ended','durationchange','timeupdate','progress','play','pause','ratechange','resize','volumechange'];/**\n * Boolean indicating whether the `Tech` supports volume control.\n *\n * @type {boolean}\n * @default {@link Html5.canControlVolume}\n */Html5.prototype.featuresVolumeControl=Html5.canControlVolume();/**\n * Boolean indicating whether the `Tech` supports changing the speed at which the media\n * plays. Examples:\n *   - Set player to play 2x (twice) as fast\n *   - Set player to play 0.5x (half) as fast\n *\n * @type {boolean}\n * @default {@link Html5.canControlPlaybackRate}\n */Html5.prototype.featuresPlaybackRate=Html5.canControlPlaybackRate();/**\n * Boolean indicating whether the `HTML5` tech currently supports the media element\n * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n * false there. Everywhere else this should be true.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.movingMediaElementInDOM=!IS_IOS;// TODO: Previous comment: No longer appears to be used. Can probably be removed.\n//       Is this true?\n/**\n * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n * when going into fullscreen.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.featuresFullscreenResize=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n * If this is false, manual `progress` events will be triggred instead.\n *\n * @type {boolean}\n * @default\n */Html5.prototype.featuresProgressEvents=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n * If this is false, manual `timeupdate` events will be triggred instead.\n *\n * @default\n */Html5.prototype.featuresTimeupdateEvents=true;/**\n * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeTextTracks}\n */Html5.prototype.featuresNativeTextTracks=Html5.supportsNativeTextTracks();/**\n * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeVideoTracks}\n */Html5.prototype.featuresNativeVideoTracks=Html5.supportsNativeVideoTracks();/**\n * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n *\n * @type {boolean}\n * @default {@link Html5.supportsNativeAudioTracks}\n */Html5.prototype.featuresNativeAudioTracks=Html5.supportsNativeAudioTracks();// HTML5 Feature detection and Device Fixes --------------------------------- //\nvar canPlayType=Html5.TEST_VID&&Html5.TEST_VID.constructor.prototype.canPlayType;var mpegurlRE=/^application\\/(?:x-|vnd\\.apple\\.)mpegurl/i;var mp4RE=/^video\\/mp4/i;Html5.patchCanPlayType=function(){// Android 4.0 and above can play HLS to some extent but it reports being unable to do so\nif(ANDROID_VERSION>=4.0&&!IS_FIREFOX){Html5.TEST_VID.constructor.prototype.canPlayType=function(type){if(type&&mpegurlRE.test(type)){return'maybe';}return canPlayType.call(this,type);};// Override Android 2.2 and less canPlayType method which is broken\n}else if(IS_OLD_ANDROID){Html5.TEST_VID.constructor.prototype.canPlayType=function(type){if(type&&mp4RE.test(type)){return'maybe';}return canPlayType.call(this,type);};}};Html5.unpatchCanPlayType=function(){var r=Html5.TEST_VID.constructor.prototype.canPlayType;Html5.TEST_VID.constructor.prototype.canPlayType=canPlayType;return r;};// by default, patch the media element\nHtml5.patchCanPlayType();Html5.disposeMediaElement=function(el){if(!el){return;}if(el.parentNode){el.parentNode.removeChild(el);}// remove any child track or source nodes to prevent their loading\nwhile(el.hasChildNodes()){el.removeChild(el.firstChild);}// remove any src reference. not setting `src=''` because that causes a warning\n// in firefox\nel.removeAttribute('src');// force the media element to update its loading state by calling load()\n// however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\nif(typeof el.load==='function'){// wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n(function(){try{el.load();}catch(e){// not supported\n}})();}};Html5.resetMediaElement=function(el){if(!el){return;}var sources=el.querySelectorAll('source');var i=sources.length;while(i--){el.removeChild(sources[i]);}// remove any src reference.\n// not setting `src=''` because that throws an error\nel.removeAttribute('src');if(typeof el.load==='function'){// wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n(function(){try{el.load();}catch(e){// satisfy linter\n}})();}};/* Native HTML5 element property wrapping ----------------------------------- */// Wrap native boolean attributes with getters that check both property and attribute\n// The list is as followed:\n// muted, defaultMuted, autoplay, controls, loop, playsinline\n[/**\n * Get the value of `muted` from the media element. `muted` indicates\n * that the volume for the media should be set to silent. This does not actually change\n * the `volume` attribute.\n *\n * @method Html5#muted\n * @return {boolean}\n *         - True if the value of `volume` should be ignored and the audio set to silent.\n *         - False if the value of `volume` should be used.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */'muted',/**\n * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n * whether the media should start muted or not. Only changes the default state of the\n * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n * current state.\n *\n * @method Html5#defaultMuted\n * @return {boolean}\n *         - The value of `defaultMuted` from the media element.\n *         - True indicates that the media should start muted.\n *         - False indicates that the media should not start muted\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */'defaultMuted',/**\n * Get the value of `autoplay` from the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#autoplay\n * @return {boolean}\n *         - The value of `autoplay` from the media element.\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */'autoplay',/**\n * Get the value of `controls` from the media element. `controls` indicates\n * whether the native media controls should be shown or hidden.\n *\n * @method Html5#controls\n * @return {boolean}\n *         - The value of `controls` from the media element.\n *         - True indicates that native controls should be showing.\n *         - False indicates that native controls should be hidden.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n */'controls',/**\n * Get the value of `loop` from the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#loop\n * @return {boolean}\n *         - The value of `loop` from the media element.\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */'loop',/**\n * Get the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#playsinline\n * @return {boolean}\n *         - The value of `playsinline` from the media element.\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */'playsinline'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop]||this.el_.hasAttribute(prop);};});// Wrap native boolean attributes with setters that set both property and attribute\n// The list is as followed:\n// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n// setControls is special-cased above\n[/**\n * Set the value of `muted` on the media element. `muted` indicates that the current\n * audio level should be silent.\n *\n * @method Html5#setMuted\n * @param {boolean} muted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n */'muted',/**\n * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n * audio level should be silent, but will only effect the muted level on intial playback..\n *\n * @method Html5.prototype.setDefaultMuted\n * @param {boolean} defaultMuted\n *        - True if the audio should be set to silent\n *        - False otherwise\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n */'defaultMuted',/**\n * Set the value of `autoplay` on the media element. `autoplay` indicates\n * that the media should start to play as soon as the page is ready.\n *\n * @method Html5#setAutoplay\n * @param {boolean} autoplay\n *         - True indicates that the media should start as soon as the page loads.\n *         - False indicates that the media should not start as soon as the page loads.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n */'autoplay',/**\n * Set the value of `loop` on the media element. `loop` indicates\n * that the media should return to the start of the media and continue playing once\n * it reaches the end.\n *\n * @method Html5#setLoop\n * @param {boolean} loop\n *         - True indicates that playback should seek back to start once\n *           the end of a media is reached.\n *         - False indicates that playback should not loop back to the start when the\n *           end of the media is reached.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n */'loop',/**\n * Set the value of `playsinline` from the media element. `playsinline` indicates\n * to the browser that non-fullscreen playback is preferred when fullscreen\n * playback is the native default, such as in iOS Safari.\n *\n * @method Html5#setPlaysinline\n * @param {boolean} playsinline\n *         - True indicates that the media should play inline.\n *         - False indicates that the media should not play inline.\n *\n * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n */'playsinline'].forEach(function(prop){Html5.prototype['set'+toTitleCase(prop)]=function(v){this.el_[prop]=v;if(v){this.el_.setAttribute(prop,prop);}else{this.el_.removeAttribute(prop);}};});// Wrap native properties with a getter\n// The list is as followed\n// paused, currentTime, buffered, volume, poster, preload, error, seeking\n// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState\n// readyState, videoWidth, videoHeight\n[/**\n * Get the value of `paused` from the media element. `paused` indicates whether the media element\n * is currently paused or not.\n *\n * @method Html5#paused\n * @return {boolean}\n *         The value of `paused` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n */'paused',/**\n * Get the value of `currentTime` from the media element. `currentTime` indicates\n * the current second that the media is at in playback.\n *\n * @method Html5#currentTime\n * @return {number}\n *         The value of `currentTime` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n */'currentTime',/**\n * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n * object that represents the parts of the media that are already downloaded and\n * available for playback.\n *\n * @method Html5#buffered\n * @return {TimeRange}\n *         The value of `buffered` from the media element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n */'buffered',/**\n * Get the value of `volume` from the media element. `volume` indicates\n * the current playback volume of audio for a media. `volume` will be a value from 0\n * (silent) to 1 (loudest and default).\n *\n * @method Html5#volume\n * @return {number}\n *         The value of `volume` from the media element. Value will be between 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */'volume',/**\n * Get the value of `poster` from the media element. `poster` indicates\n * that the url of an image file that can/will be shown when no media data is available.\n *\n * @method Html5#poster\n * @return {string}\n *         The value of `poster` from the media element. Value will be a url to an\n *         image.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n */'poster',/**\n * Get the value of `preload` from the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#preload\n * @return {string}\n *         The value of `preload` from the media element. Will be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */'preload',/**\n * Get the value of the `error` from the media element. `error` indicates any\n * MediaError that may have occured during playback. If error returns null there is no\n * current error.\n *\n * @method Html5#error\n * @return {MediaError|null}\n *         The value of `error` from the media element. Will be `MediaError` if there\n *         is a current error and null otherwise.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n */'error',/**\n * Get the value of `seeking` from the media element. `seeking` indicates whether the\n * media is currently seeking to a new position or not.\n *\n * @method Html5#seeking\n * @return {boolean}\n *         - The value of `seeking` from the media element.\n *         - True indicates that the media is currently seeking to a new position.\n *         - Flase indicates that the media is not seeking to a new position at this time.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n */'seeking',/**\n * Get the value of `seekable` from the media element. `seekable` returns a\n * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n *\n * @method Html5#seekable\n * @return {TimeRange}\n *         The value of `seekable` from the media element. A `TimeRange` object\n *         indicating the current ranges of time that can be seeked to.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n */'seekable',/**\n * Get the value of `ended` from the media element. `ended` indicates whether\n * the media has reached the end or not.\n *\n * @method Html5#ended\n * @return {boolean}\n *         - The value of `ended` from the media element.\n *         - True indicates that the media has ended.\n *         - False indicates that the media has not ended.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n */'ended',/**\n * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n * the rate at which the media is currently playing back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#playbackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'playbackRate',/**\n * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n * the rate at which the media is currently playing back. This value will not indicate the current\n * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n *\n * Examples:\n *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.defaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'defaultPlaybackRate',/**\n * Get the value of `played` from the media element. `played` returns a `TimeRange`\n * object representing points in the media timeline that have been played.\n *\n * @method Html5#played\n * @return {TimeRange}\n *         The value of `played` from the media element. A `TimeRange` object indicating\n *         the ranges of time that have been played.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n */'played',/**\n * Get the value of `networkState` from the media element. `networkState` indicates\n * the current network state. It returns an enumeration from the following list:\n * - 0: NETWORK_EMPTY\n * - 1: NEWORK_IDLE\n * - 2: NETWORK_LOADING\n * - 3: NETWORK_NO_SOURCE\n *\n * @method Html5#networkState\n * @return {number}\n *         The value of `networkState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n */'networkState',/**\n * Get the value of `readyState` from the media element. `readyState` indicates\n * the current state of the media element. It returns an enumeration from the\n * following list:\n * - 0: HAVE_NOTHING\n * - 1: HAVE_METADATA\n * - 2: HAVE_CURRENT_DATA\n * - 3: HAVE_FUTURE_DATA\n * - 4: HAVE_ENOUGH_DATA\n *\n * @method Html5#readyState\n * @return {number}\n *         The value of `readyState` from the media element. This will be a number\n *         from the list in the description.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n */'readyState',/**\n * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n * the current width of the video in css pixels.\n *\n * @method Html5#videoWidth\n * @return {number}\n *         The value of `videoWidth` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */'videoWidth',/**\n * Get the value of `videoHeight` from the video element. `videoHeigth` indicates\n * the current height of the video in css pixels.\n *\n * @method Html5#videoHeight\n * @return {number}\n *         The value of `videoHeight` from the video element. This will be a number\n *         in css pixels.\n *\n * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n */'videoHeight'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop];};});// Wrap native properties with a setter in this format:\n// set + toTitleCase(name)\n// The list is as follows:\n// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate\n[/**\n * Set the value of `volume` on the media element. `volume` indicates the current\n * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n * so on.\n *\n * @method Html5#setVolume\n * @param {number} percentAsDecimal\n *        The volume percent as a decimal. Valid range is from 0-1.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n */'volume',/**\n * Set the value of `src` on the media element. `src` indicates the current\n * {@link Tech~SourceObject} for the media.\n *\n * @method Html5#setSrc\n * @param {Tech~SourceObject} src\n *        The source object to set as the current source.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n */'src',/**\n * Set the value of `poster` on the media element. `poster` is the url to\n * an image file that can/will be shown when no media data is available.\n *\n * @method Html5#setPoster\n * @param {string} poster\n *        The url to an image that should be used as the `poster` for the media\n *        element.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n */'poster',/**\n * Set the value of `preload` on the media element. `preload` indicates\n * what should download before the media is interacted with. It can have the following\n * values:\n * - none: nothing should be downloaded\n * - metadata: poster and the first few frames of the media may be downloaded to get\n *   media dimensions and other metadata\n * - auto: allow the media and metadata for the media to be downloaded before\n *    interaction\n *\n * @method Html5#setPreload\n * @param {string} preload\n *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n *         or 'auto'.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n */'preload',/**\n * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n * the rate at which the media should play back. Examples:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5#setPlaybackRate\n * @return {number}\n *         The value of `playbackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n */'playbackRate',/**\n * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n * the rate at which the media should play back upon initial startup. Changing this value\n * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n *\n * Example Values:\n *   - if playbackRate is set to 2, media will play twice as fast.\n *   - if playbackRate is set to 0.5, media will play half as fast.\n *\n * @method Html5.prototype.setDefaultPlaybackRate\n * @return {number}\n *         The value of `defaultPlaybackRate` from the media element. A number indicating\n *         the current playback speed of the media, where 1 is normal speed.\n *\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n */'defaultPlaybackRate'].forEach(function(prop){Html5.prototype['set'+toTitleCase(prop)]=function(v){this.el_[prop]=v;};});// wrap native functions with a function\n// The list is as follows:\n// pause, load play\n[/**\n * A wrapper around the media elements `pause` function. This will call the `HTML5`\n * media elements `pause` function.\n *\n * @method Html5#pause\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n */'pause',/**\n * A wrapper around the media elements `load` function. This will call the `HTML5`s\n * media element `load` function.\n *\n * @method Html5#load\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n */'load',/**\n * A wrapper around the media elements `play` function. This will call the `HTML5`s\n * media element `play` function.\n *\n * @method Html5#play\n * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n */'play'].forEach(function(prop){Html5.prototype[prop]=function(){return this.el_[prop]();};});Tech.withSourceHandlers(Html5);/**\n * Native source handler for Html5, simply passes the source to the media element.\n *\n * @proprety {Tech~SourceObject} source\n *        The source object\n *\n * @proprety {Html5} tech\n *        The instance of the HTML5 tech.\n */Html5.nativeSourceHandler={};/**\n * Check if the media element can play the given mime type.\n *\n * @param {string} type\n *        The mimetype to check\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string)\n */Html5.nativeSourceHandler.canPlayType=function(type){// IE9 on Windows 7 without MediaPlayer throws an error here\n// https://github.com/videojs/video.js/issues/519\ntry{return Html5.TEST_VID.canPlayType(type);}catch(e){return'';}};/**\n * Check if the media element can handle a source natively.\n *\n * @param {Tech~SourceObject} source\n *         The source object\n *\n * @param {Object} [options]\n *         Options to be passed to the tech.\n *\n * @return {string}\n *         'probably', 'maybe', or '' (empty string).\n */Html5.nativeSourceHandler.canHandleSource=function(source,options){// If a type was provided we should rely on that\nif(source.type){return Html5.nativeSourceHandler.canPlayType(source.type);// If no type, fall back to checking 'video/[EXTENSION]'\n}else if(source.src){var ext=getFileExtension(source.src);return Html5.nativeSourceHandler.canPlayType('video/'+ext);}return'';};/**\n * Pass the source to the native media element.\n *\n * @param {Tech~SourceObject} source\n *        The source object\n *\n * @param {Html5} tech\n *        The instance of the Html5 tech\n *\n * @param {Object} [options]\n *        The options to pass to the source\n */Html5.nativeSourceHandler.handleSource=function(source,tech,options){tech.setSrc(source.src);};/**\n * A noop for the native dispose function, as cleanup is not needed.\n */Html5.nativeSourceHandler.dispose=function(){};// Register the native source handler\nHtml5.registerSourceHandler(Html5.nativeSourceHandler);Tech.registerTech('Html5',Html5);var _templateObject$1=taggedTemplateLiteralLoose(['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      '],['\\n        Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n        See https://github.com/videojs/video.js/issues/2617 for more info.\\n      ']);/**\n * @file player.js\n */// Subclasses Component\n// The following imports are used only to ensure that the corresponding modules\n// are always included in the video.js package. Importing the modules will\n// execute them and they will register themselves with video.js.\n// Import Html5 tech, at least for disposing the original video tag.\n// The following tech events are simply re-triggered\n// on the player when they happen\nvar TECH_EVENTS_RETRIGGER=[/**\n * Fired while the user agent is downloading media data.\n *\n * @event Player#progress\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `progress` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechProgress_\n * @fires Player#progress\n * @listens Tech#progress\n */'progress',/**\n * Fires when the loading of an audio/video is aborted.\n *\n * @event Player#abort\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `abort` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechAbort_\n * @fires Player#abort\n * @listens Tech#abort\n */'abort',/**\n * Fires when the browser is intentionally not getting media data.\n *\n * @event Player#suspend\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechSuspend_\n * @fires Player#suspend\n * @listens Tech#suspend\n */'suspend',/**\n * Fires when the current playlist is empty.\n *\n * @event Player#emptied\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechEmptied_\n * @fires Player#emptied\n * @listens Tech#emptied\n */'emptied',/**\n * Fires when the browser is trying to get media data, but data is not available.\n *\n * @event Player#stalled\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechStalled_\n * @fires Player#stalled\n * @listens Tech#stalled\n */'stalled',/**\n * Fires when the browser has loaded meta data for the audio/video.\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n *//**\n * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoadedmetadata_\n * @fires Player#loadedmetadata\n * @listens Tech#loadedmetadata\n */'loadedmetadata',/**\n * Fires when the browser has loaded the current frame of the audio/video.\n *\n * @event Player#loadeddata\n * @type {event}\n *//**\n * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechLoaddeddata_\n * @fires Player#loadeddata\n * @listens Tech#loadeddata\n */'loadeddata',/**\n * Fires when the current playback position has changed.\n *\n * @event Player#timeupdate\n * @type {event}\n *//**\n * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTimeUpdate_\n * @fires Player#timeupdate\n * @listens Tech#timeupdate\n */'timeupdate',/**\n * Fires when the playing speed of the audio/video is changed\n *\n * @event Player#ratechange\n * @type {event}\n *//**\n * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechRatechange_\n * @fires Player#ratechange\n * @listens Tech#ratechange\n */'ratechange',/**\n * Fires when the video's intrinsic dimensions change\n *\n * @event Player#resize\n * @type {event}\n *//**\n * Retrigger the `resize` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechResize_\n * @fires Player#resize\n * @listens Tech#resize\n */'resize',/**\n * Fires when the volume has been changed\n *\n * @event Player#volumechange\n * @type {event}\n *//**\n * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechVolumechange_\n * @fires Player#volumechange\n * @listens Tech#volumechange\n */'volumechange',/**\n * Fires when the text track has been changed\n *\n * @event Player#texttrackchange\n * @type {event}\n *//**\n * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n *\n * @private\n * @method Player#handleTechTexttrackchange_\n * @fires Player#texttrackchange\n * @listens Tech#texttrackchange\n */'texttrackchange'];/**\n * An instance of the `Player` class is created when any of the Video.js setup methods\n * are used to initialize a video.\n *\n * After an instance has been created it can be accessed globally in two ways:\n * 1. By calling `videojs('example_video_1');`\n * 2. By using it directly via  `videojs.players.example_video_1;`\n *\n * @extends Component\n */var Player=function(_Component){inherits(Player,_Component);/**\n   * Create an instance of this class.\n   *\n   * @param {Element} tag\n   *        The original video DOM element used for configuring options.\n   *\n   * @param {Object} [options]\n   *        Object of option names and values.\n   *\n   * @param {Component~ReadyCallback} [ready]\n   *        Ready callback function.\n   */function Player(tag,options,ready){classCallCheck(this,Player);// Make sure tag ID exists\ntag.id=tag.id||'vjs_video_'+newGUID();// Set Options\n// The options argument overrides options set in the video tag\n// which overrides globally set options.\n// This latter part coincides with the load order\n// (tag must exist before Player)\noptions=assign(Player.getTagSettings(tag),options);// Delay the initialization of children because we need to set up\n// player properties first, and can't use `this` before `super()`\noptions.initChildren=false;// Same with creating the element\noptions.createEl=false;// don't auto mixin the evented mixin\noptions.evented=false;// we don't want the player to report touch activity on itself\n// see enableTouchActivity in Component\noptions.reportTouchActivity=false;// If language is not set, get the closest lang attribute\nif(!options.language){if(typeof tag.closest==='function'){var closest=tag.closest('[lang]');if(closest&&closest.getAttribute){options.language=closest.getAttribute('lang');}}else{var element=tag;while(element&&element.nodeType===1){if(getAttributes(element).hasOwnProperty('lang')){options.language=element.getAttribute('lang');break;}element=element.parentNode;}}}// Run base component initializing with new options\n// Turn off API access because we're loading a new tech that might load asynchronously\nvar _this=possibleConstructorReturn(this,_Component.call(this,null,options,ready));_this.isReady_=false;// Init state hasStarted_\n_this.hasStarted_=false;// Init state userActive_\n_this.userActive_=false;// if the global option object was accidentally blown away by\n// someone, bail early with an informative error\nif(!_this.options_||!_this.options_.techOrder||!_this.options_.techOrder.length){throw new Error('No techOrder specified. Did you overwrite '+'videojs.options instead of just changing the '+'properties you want to override?');}// Store the original tag used to set options\n_this.tag=tag;// Store the tag attributes used to restore html5 element\n_this.tagAttributes=tag&&getAttributes(tag);// Update current language\n_this.language(_this.options_.language);// Update Supported Languages\nif(options.languages){// Normalise player option languages to lowercase\nvar languagesToLower={};Object.getOwnPropertyNames(options.languages).forEach(function(name$$1){languagesToLower[name$$1.toLowerCase()]=options.languages[name$$1];});_this.languages_=languagesToLower;}else{_this.languages_=Player.prototype.options_.languages;}// Cache for video property values.\n_this.cache_={};// Set poster\n_this.poster_=options.poster||'';// Set controls\n_this.controls_=!!options.controls;// Set default values for lastVolume\n_this.cache_.lastVolume=1;// Original tag settings stored in options\n// now remove immediately so native controls don't flash.\n// May be turned back on by HTML5 tech if nativeControlsForTouch is true\ntag.controls=false;tag.removeAttribute('controls');/*\n     * Store the internal state of scrubbing\n     *\n     * @private\n     * @return {Boolean} True if the user is scrubbing\n     */_this.scrubbing_=false;_this.el_=_this.createEl();// Make this an evented object and use `el_` as its event bus.\nevented(_this,{eventBusKey:'el_'});// We also want to pass the original player options to each component and plugin\n// as well so they don't need to reach back into the player for options later.\n// We also need to do another copy of this.options_ so we don't end up with\n// an infinite loop.\nvar playerOptionsCopy=mergeOptions(_this.options_);// Load plugins\nif(options.plugins){var plugins=options.plugins;Object.keys(plugins).forEach(function(name$$1){if(typeof this[name$$1]==='function'){this[name$$1](plugins[name$$1]);}else{throw new Error('plugin \"'+name$$1+'\" does not exist');}},_this);}_this.options_.playerOptions=playerOptionsCopy;_this.middleware_=[];_this.initChildren();// Set isAudio based on whether or not an audio tag was used\n_this.isAudio(tag.nodeName.toLowerCase()==='audio');// Update controls className. Can't do this when the controls are initially\n// set because the element doesn't exist yet.\nif(_this.controls()){_this.addClass('vjs-controls-enabled');}else{_this.addClass('vjs-controls-disabled');}// Set ARIA label and region role depending on player type\n_this.el_.setAttribute('role','region');if(_this.isAudio()){_this.el_.setAttribute('aria-label',_this.localize('Audio Player'));}else{_this.el_.setAttribute('aria-label',_this.localize('Video Player'));}if(_this.isAudio()){_this.addClass('vjs-audio');}if(_this.flexNotSupported_()){_this.addClass('vjs-no-flex');}// TODO: Make this smarter. Toggle user state between touching/mousing\n// using events, since devices can have both touch and mouse events.\n// if (browser.TOUCH_ENABLED) {\n//   this.addClass('vjs-touch-enabled');\n// }\n// iOS Safari has broken hover handling\nif(!IS_IOS){_this.addClass('vjs-workinghover');}// Make player easily findable by ID\nPlayer.players[_this.id_]=_this;// Add a major version class to aid css in plugins\nvar majorVersion=version.split('.')[0];_this.addClass('vjs-v'+majorVersion);// When the player is first initialized, trigger activity so components\n// like the control bar show themselves if needed\n_this.userActive(true);_this.reportUserActivity();_this.listenForUserActivity_();_this.on('fullscreenchange',_this.handleFullscreenChange_);_this.on('stageclick',_this.handleStageClick_);_this.changingSrc_=false;_this.playWaitingForReady_=false;_this.playOnLoadstart_=null;_this.forceAutoplayInChrome_();return _this;}/**\n   * Destroys the video player and does any necessary cleanup.\n   *\n   * This is especially helpful if you are dynamically adding and removing videos\n   * to/from the DOM.\n   *\n   * @fires Player#dispose\n   */Player.prototype.dispose=function dispose(){/**\n     * Called when the player is being disposed of.\n     *\n     * @event Player#dispose\n     * @type {EventTarget~Event}\n     */this.trigger('dispose');// prevent dispose from being called twice\nthis.off('dispose');if(this.styleEl_&&this.styleEl_.parentNode){this.styleEl_.parentNode.removeChild(this.styleEl_);this.styleEl_=null;}// Kill reference to this player\nPlayer.players[this.id_]=null;if(this.tag&&this.tag.player){this.tag.player=null;}if(this.el_&&this.el_.player){this.el_.player=null;}if(this.tech_){this.tech_.dispose();}if(this.playerElIngest_){this.playerElIngest_=null;}if(this.tag){this.tag=null;}// the actual .el_ is removed here\n_Component.prototype.dispose.call(this);};/**\n   * Create the `Player`'s DOM element.\n   *\n   * @return {Element}\n   *         The DOM element that gets created.\n   */Player.prototype.createEl=function createEl$$1(){var tag=this.tag;var el=void 0;var playerElIngest=this.playerElIngest_=tag.parentNode&&tag.parentNode.hasAttribute&&tag.parentNode.hasAttribute('data-vjs-player');var divEmbed=this.tag.tagName.toLowerCase()==='video-js';if(playerElIngest){el=this.el_=tag.parentNode;}else if(!divEmbed){el=this.el_=_Component.prototype.createEl.call(this,'div');}// Copy over all the attributes from the tag, including ID and class\n// ID will now reference player box, not the video tag\nvar attrs=getAttributes(tag);if(divEmbed){el=this.el_=tag;tag=this.tag=document.createElement('video');while(el.children.length){tag.appendChild(el.firstChild);}if(!hasClass(el,'video-js')){addClass(el,'video-js');}el.appendChild(tag);playerElIngest=this.playerElIngest_=el;}// set tabindex to -1 so we could focus on the player element\ntag.setAttribute('tabindex','-1');// Remove width/height attrs from tag so CSS can make it 100% width/height\ntag.removeAttribute('width');tag.removeAttribute('height');Object.getOwnPropertyNames(attrs).forEach(function(attr){// workaround so we don't totally break IE7\n// http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7\nif(attr==='class'){el.className+=' '+attrs[attr];if(divEmbed){tag.className+=' '+attrs[attr];}}else{el.setAttribute(attr,attrs[attr]);if(divEmbed){tag.setAttribute(attr,attrs[attr]);}}});// Update tag id/class for use as HTML5 playback tech\n// Might think we should do this after embedding in container so .vjs-tech class\n// doesn't flash 100% width/height, but class only applies with .video-js parent\ntag.playerId=tag.id;tag.id+='_html5_api';tag.className='vjs-tech';// Make player findable on elements\ntag.player=el.player=this;// Default state of video is paused\nthis.addClass('vjs-paused');// Add a style element in the player that we'll use to set the width/height\n// of the player in a way that's still overrideable by CSS, just like the\n// video element\nif(window.VIDEOJS_NO_DYNAMIC_STYLE!==true){this.styleEl_=createStyleElement('vjs-styles-dimensions');var defaultsStyleEl=$('.vjs-styles-defaults');var head=$('head');head.insertBefore(this.styleEl_,defaultsStyleEl?defaultsStyleEl.nextSibling:head.firstChild);}// Pass in the width/height/aspectRatio options which will update the style el\nthis.width(this.options_.width);this.height(this.options_.height);this.fluid(this.options_.fluid);this.aspectRatio(this.options_.aspectRatio);// Hide any links within the video/audio tag, because IE doesn't hide them completely.\nvar links=tag.getElementsByTagName('a');for(var i=0;i<links.length;i++){var linkEl=links.item(i);addClass(linkEl,'vjs-hidden');linkEl.setAttribute('hidden','hidden');}// insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n// keep track of the original for later so we can know if the source originally failed\ntag.initNetworkState_=tag.networkState;// Wrap video tag in div (el/box) container\nif(tag.parentNode&&!playerElIngest){tag.parentNode.insertBefore(el,tag);}// insert the tag as the first child of the player element\n// then manually add it to the children array so that this.addChild\n// will work properly for other components\n//\n// Breaks iPhone, fixed in HTML5 setup.\nprependTo(tag,el);this.children_.unshift(tag);// Set lang attr on player to ensure CSS :lang() in consistent with player\n// if it's been set to something different to the doc\nthis.el_.setAttribute('lang',this.language_);this.el_=el;return el;};/**\n   * A getter/setter for the `Player`'s width. Returns the player's configured value.\n   * To get the current width use `currentWidth()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s width to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current width of the `Player` when getting.\n   */Player.prototype.width=function width(value,skipListeners){return this.dimension('width',value,skipListeners);};/**\n   * A getter/setter for the `Player`'s height. Returns the player's configured value.\n   * To get the current height use `currentheight()`.\n   *\n   * @param {number} [value]\n   *        The value to set the `Player`'s heigth to.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The current height of the `Player` when getting.\n   */Player.prototype.height=function height(value,skipListeners){return this.dimension('height',value,skipListeners);};/**\n   * A getter/setter for the `Player`'s width & height.\n   *\n   * @fires Player#playerresize\n   *\n   * @param {string} dimension\n   *        This string can be:\n   *        - 'width'\n   *        - 'height'\n   *\n   * @param {number} [value]\n   *        Value for dimension specified in the first argument.\n   *\n   * @param {boolean} [skipListeners]\n   *        Skip the playerresize event trigger\n   *\n   * @return {number}\n   *         The dimension arguments value when getting (width/height).\n   */Player.prototype.dimension=function dimension(_dimension,value,skipListeners){var privDimension=_dimension+'_';if(value===undefined){return this[privDimension]||0;}if(value===''){// If an empty string is given, reset the dimension to be automatic\nthis[privDimension]=undefined;this.updateStyleEl_();return;}var parsedVal=parseFloat(value);if(isNaN(parsedVal)){log$1.error('Improper value \"'+value+'\" supplied for for '+_dimension);return;}this[privDimension]=parsedVal;this.updateStyleEl_();// skipListeners allows us to avoid triggering the resize event when setting both width and height\nif(this.isReady_&&!skipListeners){/**\n       * Triggered when the player is resized.\n       *\n       * @event Player#playerresize\n       * @type {EventTarget~Event}\n       */this.trigger('playerresize');}};/**\n   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n   *\n   * @param {boolean} [bool]\n   *        - A value of true adds the class.\n   *        - A value of false removes the class.\n   *        - No value will toggle the fluid class.\n   *\n   * @return {boolean|undefined}\n   *         - The value of fluid when getting.\n   *         - `undefined` when setting.\n   */Player.prototype.fluid=function fluid(bool){if(bool===undefined){return!!this.fluid_;}this.fluid_=!!bool;if(bool){this.addClass('vjs-fluid');}else{this.removeClass('vjs-fluid');}this.updateStyleEl_();};/**\n   * Get/Set the aspect ratio\n   *\n   * @param {string} [ratio]\n   *        Aspect ratio for player\n   *\n   * @return {string|undefined}\n   *         returns the current aspect ratio when getting\n   *//**\n   * A getter/setter for the `Player`'s aspect ratio.\n   *\n   * @param {string} [ratio]\n   *        The value to set the `Player's aspect ratio to.\n   *\n   * @return {string|undefined}\n   *         - The current aspect ratio of the `Player` when getting.\n   *         - undefined when setting\n   */Player.prototype.aspectRatio=function aspectRatio(ratio){if(ratio===undefined){return this.aspectRatio_;}// Check for width:height format\nif(!/^\\d+\\:\\d+$/.test(ratio)){throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');}this.aspectRatio_=ratio;// We're assuming if you set an aspect ratio you want fluid mode,\n// because in fixed mode you could calculate width and height yourself.\nthis.fluid(true);this.updateStyleEl_();};/**\n   * Update styles of the `Player` element (height, width and aspect ratio).\n   *\n   * @private\n   * @listens Tech#loadedmetadata\n   */Player.prototype.updateStyleEl_=function updateStyleEl_(){if(window.VIDEOJS_NO_DYNAMIC_STYLE===true){var _width=typeof this.width_==='number'?this.width_:this.options_.width;var _height=typeof this.height_==='number'?this.height_:this.options_.height;var techEl=this.tech_&&this.tech_.el();if(techEl){if(_width>=0){techEl.width=_width;}if(_height>=0){techEl.height=_height;}}return;}var width=void 0;var height=void 0;var aspectRatio=void 0;var idClass=void 0;// The aspect ratio is either used directly or to calculate width and height.\nif(this.aspectRatio_!==undefined&&this.aspectRatio_!=='auto'){// Use any aspectRatio that's been specifically set\naspectRatio=this.aspectRatio_;}else if(this.videoWidth()>0){// Otherwise try to get the aspect ratio from the video metadata\naspectRatio=this.videoWidth()+':'+this.videoHeight();}else{// Or use a default. The video element's is 2:1, but 16:9 is more common.\naspectRatio='16:9';}// Get the ratio as a decimal we can use to calculate dimensions\nvar ratioParts=aspectRatio.split(':');var ratioMultiplier=ratioParts[1]/ratioParts[0];if(this.width_!==undefined){// Use any width that's been specifically set\nwidth=this.width_;}else if(this.height_!==undefined){// Or calulate the width from the aspect ratio if a height has been set\nwidth=this.height_/ratioMultiplier;}else{// Or use the video's metadata, or use the video el's default of 300\nwidth=this.videoWidth()||300;}if(this.height_!==undefined){// Use any height that's been specifically set\nheight=this.height_;}else{// Otherwise calculate the height from the ratio and the width\nheight=width*ratioMultiplier;}// Ensure the CSS class is valid by starting with an alpha character\nif(/^[^a-zA-Z]/.test(this.id())){idClass='dimensions-'+this.id();}else{idClass=this.id()+'-dimensions';}// Ensure the right class is still on the player for the style element\nthis.addClass(idClass);setTextContent(this.styleEl_,'\\n      .'+idClass+' {\\n        width: '+width+'px;\\n        height: '+height+'px;\\n      }\\n\\n      .'+idClass+'.vjs-fluid {\\n        padding-top: '+ratioMultiplier*100+'%;\\n      }\\n    ');};/**\n   * Load/Create an instance of playback {@link Tech} including element\n   * and API methods. Then append the `Tech` element in `Player` as a child.\n   *\n   * @param {string} techName\n   *        name of the playback technology\n   *\n   * @param {string} source\n   *        video source\n   *\n   * @private\n   */Player.prototype.loadTech_=function loadTech_(techName,source){var _this2=this;// Pause and remove current playback technology\nif(this.tech_){this.unloadTech_();}var titleTechName=toTitleCase(techName);var camelTechName=techName.charAt(0).toLowerCase()+techName.slice(1);// get rid of the HTML5 video tag as soon as we are using another tech\nif(titleTechName!=='Html5'&&this.tag){Tech.getTech('Html5').disposeMediaElement(this.tag);this.tag.player=null;this.tag=null;}this.techName_=titleTechName;// Turn off API access because we're loading a new tech that might load asynchronously\nthis.isReady_=false;// Grab tech-specific options from player options and add source and parent element to use.\nvar techOptions={source:source,'nativeControlsForTouch':this.options_.nativeControlsForTouch,'playerId':this.id(),'techId':this.id()+'_'+titleTechName+'_api','autoplay':this.options_.autoplay,'playsinline':this.options_.playsinline,'preload':this.options_.preload,'loop':this.options_.loop,'muted':this.options_.muted,'poster':this.poster(),'language':this.language(),'playerElIngest':this.playerElIngest_||false,'vtt.js':this.options_['vtt.js']};ALL.names.forEach(function(name$$1){var props=ALL[name$$1];techOptions[props.getterName]=_this2[props.privateName];});assign(techOptions,this.options_[titleTechName]);assign(techOptions,this.options_[camelTechName]);assign(techOptions,this.options_[techName.toLowerCase()]);if(this.tag){techOptions.tag=this.tag;}if(source&&source.src===this.cache_.src&&this.cache_.currentTime>0){techOptions.startTime=this.cache_.currentTime;}// Initialize tech instance\nvar TechClass=Tech.getTech(techName);if(!TechClass){throw new Error('No Tech named \\''+titleTechName+'\\' exists! \\''+titleTechName+'\\' should be registered using videojs.registerTech()\\'');}this.tech_=new TechClass(techOptions);// player.triggerReady is always async, so don't need this to be async\nthis.tech_.ready(bind(this,this.handleTechReady_),true);textTrackConverter.jsonToTextTracks(this.textTracksJson_||[],this.tech_);// Listen to all HTML5-defined events and trigger them on the player\nTECH_EVENTS_RETRIGGER.forEach(function(event){_this2.on(_this2.tech_,event,_this2['handleTech'+toTitleCase(event)+'_']);});this.on(this.tech_,'loadstart',this.handleTechLoadStart_);this.on(this.tech_,'waiting',this.handleTechWaiting_);this.on(this.tech_,'canplay',this.handleTechCanPlay_);this.on(this.tech_,'canplaythrough',this.handleTechCanPlayThrough_);this.on(this.tech_,'playing',this.handleTechPlaying_);this.on(this.tech_,'ended',this.handleTechEnded_);this.on(this.tech_,'seeking',this.handleTechSeeking_);this.on(this.tech_,'seeked',this.handleTechSeeked_);this.on(this.tech_,'play',this.handleTechPlay_);this.on(this.tech_,'firstplay',this.handleTechFirstPlay_);this.on(this.tech_,'pause',this.handleTechPause_);this.on(this.tech_,'durationchange',this.handleTechDurationChange_);this.on(this.tech_,'fullscreenchange',this.handleTechFullscreenChange_);this.on(this.tech_,'error',this.handleTechError_);this.on(this.tech_,'loadedmetadata',this.updateStyleEl_);this.on(this.tech_,'posterchange',this.handleTechPosterChange_);this.on(this.tech_,'textdata',this.handleTechTextData_);this.usingNativeControls(this.techGet_('controls'));if(this.controls()&&!this.usingNativeControls()){this.addTechControlsListeners_();}// Add the tech element in the DOM if it was not already there\n// Make sure to not insert the original video element if using Html5\nif(this.tech_.el().parentNode!==this.el()&&(titleTechName!=='Html5'||!this.tag)){prependTo(this.tech_.el(),this.el());}// Get rid of the original video tag reference after the first tech is loaded\nif(this.tag){this.tag.player=null;this.tag=null;}};/**\n   * Unload and dispose of the current playback {@link Tech}.\n   *\n   * @private\n   */Player.prototype.unloadTech_=function unloadTech_(){var _this3=this;// Save the current text tracks so that we can reuse the same text tracks with the next tech\nALL.names.forEach(function(name$$1){var props=ALL[name$$1];_this3[props.privateName]=_this3[props.getterName]();});this.textTracksJson_=textTrackConverter.textTracksToJson(this.tech_);this.isReady_=false;this.tech_.dispose();this.tech_=false;};/**\n   * Return a reference to the current {@link Tech}.\n   * It will print a warning by default about the danger of using the tech directly\n   * but any argument that is passed in will silence the warning.\n   *\n   * @param {*} [safety]\n   *        Anything passed in to silence the warning\n   *\n   * @return {Tech}\n   *         The Tech\n   */Player.prototype.tech=function tech(safety){if(safety===undefined){log$1.warn(tsml(_templateObject$1));}return this.tech_;};/**\n   * Set up click and touch listeners for the playback element\n   *\n   * - On desktops: a click on the video itself will toggle playback\n   * - On mobile devices: a click on the video toggles controls\n   *   which is done by toggling the user state between active and\n   *   inactive\n   * - A tap can signal that a user has become active or has become inactive\n   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n   *   quick tap should hide them again (signaling the user is in an inactive\n   *   viewing state)\n   * - In addition to this, we still want the user to be considered inactive after\n   *   a few seconds of inactivity.\n   *\n   * > Note: the only part of iOS interaction we can't mimic with this setup\n   * is a touch and hold on the video element counting as activity in order to\n   * keep the controls showing, but that shouldn't be an issue. A touch and hold\n   * on any controls will still keep the user active\n   *\n   * @private\n   */Player.prototype.addTechControlsListeners_=function addTechControlsListeners_(){// Make sure to remove all the previous listeners in case we are called multiple times.\nthis.removeTechControlsListeners_();// Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do\n// trigger mousedown/up.\n// http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object\n// Any touch events are set to block the mousedown event from happening\nthis.on(this.tech_,'mousedown',this.handleTechClick_);// If the controls were hidden we don't want that to change without a tap event\n// so we'll check if the controls were already showing before reporting user\n// activity\nthis.on(this.tech_,'touchstart',this.handleTechTouchStart_);this.on(this.tech_,'touchmove',this.handleTechTouchMove_);this.on(this.tech_,'touchend',this.handleTechTouchEnd_);// The tap listener needs to come after the touchend listener because the tap\n// listener cancels out any reportedUserActivity when setting userActive(false)\nthis.on(this.tech_,'tap',this.handleTechTap_);};/**\n   * Remove the listeners used for click and tap controls. This is needed for\n   * toggling to controls disabled, where a tap/touch should do nothing.\n   *\n   * @private\n   */Player.prototype.removeTechControlsListeners_=function removeTechControlsListeners_(){// We don't want to just use `this.off()` because there might be other needed\n// listeners added by techs that extend this.\nthis.off(this.tech_,'tap',this.handleTechTap_);this.off(this.tech_,'touchstart',this.handleTechTouchStart_);this.off(this.tech_,'touchmove',this.handleTechTouchMove_);this.off(this.tech_,'touchend',this.handleTechTouchEnd_);this.off(this.tech_,'mousedown',this.handleTechClick_);};/**\n   * Player waits for the tech to be ready\n   *\n   * @private\n   */Player.prototype.handleTechReady_=function handleTechReady_(){this.triggerReady();// Keep the same volume as before\nif(this.cache_.volume){this.techCall_('setVolume',this.cache_.volume);}// Look if the tech found a higher resolution poster while loading\nthis.handleTechPosterChange_();// Update the duration if available\nthis.handleTechDurationChange_();// Chrome and Safari both have issues with autoplay.\n// In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.\n// In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)\n// This fixes both issues. Need to wait for API, so it updates displays correctly\nif((this.src()||this.currentSrc())&&this.tag&&this.options_.autoplay&&this.paused()){try{// Chrome Fix. Fixed in Chrome v16.\ndelete this.tag.poster;}catch(e){log$1('deleting tag.poster throws in some browsers',e);}}};/**\n   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This\n   * function will also trigger {@link Player#firstplay} if it is the first loadstart\n   * for a video.\n   *\n   * @fires Player#loadstart\n   * @fires Player#firstplay\n   * @listens Tech#loadstart\n   * @private\n   */Player.prototype.handleTechLoadStart_=function handleTechLoadStart_(){// TODO: Update to use `emptied` event instead. See #1277.\nthis.removeClass('vjs-ended');this.removeClass('vjs-seeking');// reset the error state\nthis.error(null);// If it's already playing we want to trigger a firstplay event now.\n// The firstplay event relies on both the play and loadstart events\n// which can happen in any order for a new source\nif(!this.paused()){/**\n       * Fired when the user agent begins looking for media data\n       *\n       * @event Player#loadstart\n       * @type {EventTarget~Event}\n       */this.trigger('loadstart');this.trigger('firstplay');}else{// reset the hasStarted state\nthis.hasStarted(false);this.trigger('loadstart');}};/**\n   * Add/remove the vjs-has-started class\n   *\n   * @fires Player#firstplay\n   *\n   * @param {boolean} request\n   *        - true: adds the class\n   *        - false: remove the class\n   *\n   * @return {boolean}\n   *         the boolean value of hasStarted_\n   */Player.prototype.hasStarted=function hasStarted(request){if(request===undefined){// act as getter, if we have no request to change\nreturn this.hasStarted_;}if(request===this.hasStarted_){return;}this.hasStarted_=request;if(this.hasStarted_){this.addClass('vjs-has-started');this.trigger('firstplay');}else{this.removeClass('vjs-has-started');}};/**\n   * Fired whenever the media begins or resumes playback\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n   * @fires Player#play\n   * @listens Tech#play\n   * @private\n   */Player.prototype.handleTechPlay_=function handleTechPlay_(){this.removeClass('vjs-ended');this.removeClass('vjs-paused');this.addClass('vjs-playing');// hide the poster when the user hits play\nthis.hasStarted(true);/**\n     * Triggered whenever an {@link Tech#play} event happens. Indicates that\n     * playback has started or resumed.\n     *\n     * @event Player#play\n     * @type {EventTarget~Event}\n     */this.trigger('play');};/**\n   * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#waiting\n   * @listens Tech#waiting\n   * @private\n   */Player.prototype.handleTechWaiting_=function handleTechWaiting_(){var _this4=this;this.addClass('vjs-waiting');/**\n     * A readyState change on the DOM element has caused playback to stop.\n     *\n     * @event Player#waiting\n     * @type {EventTarget~Event}\n     */this.trigger('waiting');this.one('timeupdate',function(){return _this4.removeClass('vjs-waiting');});};/**\n   * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n   * > Note: This is not consistent between browsers. See #1351\n   *\n   * @fires Player#canplay\n   * @listens Tech#canplay\n   * @private\n   */Player.prototype.handleTechCanPlay_=function handleTechCanPlay_(){this.removeClass('vjs-waiting');/**\n     * The media has a readyState of HAVE_FUTURE_DATA or greater.\n     *\n     * @event Player#canplay\n     * @type {EventTarget~Event}\n     */this.trigger('canplay');};/**\n   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#canplaythrough\n   * @listens Tech#canplaythrough\n   * @private\n   */Player.prototype.handleTechCanPlayThrough_=function handleTechCanPlayThrough_(){this.removeClass('vjs-waiting');/**\n     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n     * entire media file can be played without buffering.\n     *\n     * @event Player#canplaythrough\n     * @type {EventTarget~Event}\n     */this.trigger('canplaythrough');};/**\n   * Retrigger the `playing` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#playing\n   * @listens Tech#playing\n   * @private\n   */Player.prototype.handleTechPlaying_=function handleTechPlaying_(){this.removeClass('vjs-waiting');/**\n     * The media is no longer blocked from playback, and has started playing.\n     *\n     * @event Player#playing\n     * @type {EventTarget~Event}\n     */this.trigger('playing');};/**\n   * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeking\n   * @listens Tech#seeking\n   * @private\n   */Player.prototype.handleTechSeeking_=function handleTechSeeking_(){this.addClass('vjs-seeking');/**\n     * Fired whenever the player is jumping to a new time\n     *\n     * @event Player#seeking\n     * @type {EventTarget~Event}\n     */this.trigger('seeking');};/**\n   * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#seeked\n   * @listens Tech#seeked\n   * @private\n   */Player.prototype.handleTechSeeked_=function handleTechSeeked_(){this.removeClass('vjs-seeking');/**\n     * Fired when the player has finished jumping to a new time\n     *\n     * @event Player#seeked\n     * @type {EventTarget~Event}\n     */this.trigger('seeked');};/**\n   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#firstplay\n   * @listens Tech#firstplay\n   * @deprecated As of 6.0 firstplay event is deprecated.\n   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.\n   * @private\n   */Player.prototype.handleTechFirstPlay_=function handleTechFirstPlay_(){// If the first starttime attribute is specified\n// then we will start at the given offset in seconds\nif(this.options_.starttime){log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');this.currentTime(this.options_.starttime);}this.addClass('vjs-has-started');/**\n     * Fired the first time a video is played. Not part of the HLS spec, and this is\n     * probably not the best implementation yet, so use sparingly. If you don't have a\n     * reason to prevent playback, use `myPlayer.one('play');` instead.\n     *\n     * @event Player#firstplay\n     * @deprecated As of 6.0 firstplay event is deprecated.\n     * @type {EventTarget~Event}\n     */this.trigger('firstplay');};/**\n   * Retrigger the `pause` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#pause\n   * @listens Tech#pause\n   * @private\n   */Player.prototype.handleTechPause_=function handleTechPause_(){this.removeClass('vjs-playing');this.addClass('vjs-paused');/**\n     * Fired whenever the media has been paused\n     *\n     * @event Player#pause\n     * @type {EventTarget~Event}\n     */this.trigger('pause');};/**\n   * Retrigger the `ended` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#ended\n   * @listens Tech#ended\n   * @private\n   */Player.prototype.handleTechEnded_=function handleTechEnded_(){this.addClass('vjs-ended');if(this.options_.loop){this.currentTime(0);this.play();}else if(!this.paused()){this.pause();}/**\n     * Fired when the end of the media resource is reached (currentTime == duration)\n     *\n     * @event Player#ended\n     * @type {EventTarget~Event}\n     */this.trigger('ended');};/**\n   * Fired when the duration of the media resource is first known or changed\n   *\n   * @listens Tech#durationchange\n   * @private\n   */Player.prototype.handleTechDurationChange_=function handleTechDurationChange_(){this.duration(this.techGet_('duration'));};/**\n   * Handle a click on the media element to play/pause\n   *\n   * @param {EventTarget~Event} event\n   *        the event that caused this function to trigger\n   *\n   * @listens Tech#mousedown\n   * @private\n   */Player.prototype.handleTechClick_=function handleTechClick_(event){if(!isSingleLeftClick(event)){return;}// When controls are disabled a click should not toggle playback because\n// the click is considered a control\nif(!this.controls_){return;}if(this.paused()){this.play();}else{this.pause();}};/**\n   * Handle a tap on the media element. It will toggle the user\n   * activity state, which hides and shows the controls.\n   *\n   * @listens Tech#tap\n   * @private\n   */Player.prototype.handleTechTap_=function handleTechTap_(){this.userActive(!this.userActive());};/**\n   * Handle touch to start\n   *\n   * @listens Tech#touchstart\n   * @private\n   */Player.prototype.handleTechTouchStart_=function handleTechTouchStart_(){this.userWasActive=this.userActive();};/**\n   * Handle touch to move\n   *\n   * @listens Tech#touchmove\n   * @private\n   */Player.prototype.handleTechTouchMove_=function handleTechTouchMove_(){if(this.userWasActive){this.reportUserActivity();}};/**\n   * Handle touch to end\n   *\n   * @param {EventTarget~Event} event\n   *        the touchend event that triggered\n   *        this function\n   *\n   * @listens Tech#touchend\n   * @private\n   */Player.prototype.handleTechTouchEnd_=function handleTechTouchEnd_(event){// Stop the mouse events from also happening\nevent.preventDefault();};/**\n   * Fired when the player switches in or out of fullscreen mode\n   *\n   * @private\n   * @listens Player#fullscreenchange\n   */Player.prototype.handleFullscreenChange_=function handleFullscreenChange_(){if(this.isFullscreen()){this.addClass('vjs-fullscreen');}else{this.removeClass('vjs-fullscreen');}};/**\n   * native click events on the SWF aren't triggered on IE11, Win8.1RT\n   * use stageclick events triggered from inside the SWF instead\n   *\n   * @private\n   * @listens stageclick\n   */Player.prototype.handleStageClick_=function handleStageClick_(){this.reportUserActivity();};/**\n   * Handle Tech Fullscreen Change\n   *\n   * @param {EventTarget~Event} event\n   *        the fullscreenchange event that triggered this function\n   *\n   * @param {Object} data\n   *        the data that was sent with the event\n   *\n   * @private\n   * @listens Tech#fullscreenchange\n   * @fires Player#fullscreenchange\n   */Player.prototype.handleTechFullscreenChange_=function handleTechFullscreenChange_(event,data){if(data){this.isFullscreen(data.isFullscreen);}/**\n     * Fired when going in and out of fullscreen.\n     *\n     * @event Player#fullscreenchange\n     * @type {EventTarget~Event}\n     */this.trigger('fullscreenchange');};/**\n   * Fires when an error occurred during the loading of an audio/video.\n   *\n   * @private\n   * @listens Tech#error\n   */Player.prototype.handleTechError_=function handleTechError_(){var error=this.tech_.error();this.error(error);};/**\n   * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n   *\n   * @fires Player#textdata\n   * @listens Tech#textdata\n   * @private\n   */Player.prototype.handleTechTextData_=function handleTechTextData_(){var data=null;if(arguments.length>1){data=arguments[1];}/**\n     * Fires when we get a textdata event from tech\n     *\n     * @event Player#textdata\n     * @type {EventTarget~Event}\n     */this.trigger('textdata',data);};/**\n   * Get object for cached values.\n   *\n   * @return {Object}\n   *         get the current object cache\n   */Player.prototype.getCache=function getCache(){return this.cache_;};/**\n   * Pass values to the playback tech\n   *\n   * @param {string} [method]\n   *        the method to call\n   *\n   * @param {Object} arg\n   *        the argument to pass\n   *\n   * @private\n   */Player.prototype.techCall_=function techCall_(method,arg){// If it's not ready yet, call method when it is\nthis.ready(function(){if(method in allowedSetters){return set$1(this.middleware_,this.tech_,method,arg);}try{if(this.tech_){this.tech_[method](arg);}}catch(e){log$1(e);throw e;}},true);};/**\n   * Get calls can't wait for the tech, and sometimes don't need to.\n   *\n   * @param {string} method\n   *        Tech method\n   *\n   * @return {Function|undefined}\n   *         the method or undefined\n   *\n   * @private\n   */Player.prototype.techGet_=function techGet_(method){if(!this.tech_||!this.tech_.isReady_){return;}if(method in allowedGetters){return get$1(this.middleware_,this.tech_,method);}// Flash likes to die and reload when you hide or reposition it.\n// In these cases the object methods go away and we get errors.\n// When that happens we'll catch the errors and inform tech that it's not ready any more.\ntry{return this.tech_[method]();}catch(e){// When building additional tech libs, an expected method may not be defined yet\nif(this.tech_[method]===undefined){log$1('Video.js: '+method+' method not defined for '+this.techName_+' playback technology.',e);throw e;}// When a method isn't available on the object it throws a TypeError\nif(e.name==='TypeError'){log$1('Video.js: '+method+' unavailable on '+this.techName_+' playback technology element.',e);this.tech_.isReady_=false;throw e;}// If error unknown, just log and throw\nlog$1(e);throw e;}};/**\n   * Attempt to begin playback at the first opportunity.\n   *\n   * @return {Promise|undefined}\n   *         Returns a `Promise` only if the browser returns one and the player\n   *         is ready to begin playback. For some browsers and all non-ready\n   *         situations, this will return `undefined`.\n   */Player.prototype.play=function play(){var _this5=this;// If this is called while we have a play queued up on a loadstart, remove\n// that listener to avoid getting in a potentially bad state.\nif(this.playOnLoadstart_){this.off('loadstart',this.playOnLoadstart_);}// If the player/tech is not ready, queue up another call to `play()` for\n// when it is. This will loop back into this method for another attempt at\n// playback when the tech is ready.\nif(!this.isReady_){// Bail out if we're already waiting for `ready`!\nif(this.playWaitingForReady_){return;}this.playWaitingForReady_=true;this.ready(function(){_this5.playWaitingForReady_=false;silencePromise(_this5.play());});// If the player/tech is ready and we have a source, we can attempt playback.\n}else if(!this.changingSrc_&&(this.src()||this.currentSrc())){return this.techGet_('play');// If the tech is ready, but we do not have a source, we'll need to wait\n// for both the `ready` and a `loadstart` when the source is finally\n// resolved by middleware and set on the player.\n//\n// This can happen if `play()` is called while changing sources or before\n// one has been set on the player.\n}else{this.playOnLoadstart_=function(){_this5.playOnLoadstart_=null;silencePromise(_this5.play());};this.one('loadstart',this.playOnLoadstart_);}};/**\n   * Pause the video playback\n   *\n   * @return {Player}\n   *         A reference to the player object this function was called on\n   */Player.prototype.pause=function pause(){this.techCall_('pause');};/**\n   * Check if the player is paused or has yet to play\n   *\n   * @return {boolean}\n   *         - false: if the media is currently playing\n   *         - true: if media is not currently playing\n   */Player.prototype.paused=function paused(){// The initial state of paused should be true (in Safari it's actually false)\nreturn this.techGet_('paused')===false?false:true;};/**\n   * Get a TimeRange object representing the current ranges of time that the user\n   * has played.\n   *\n   * @return {TimeRange}\n   *         A time range object that represents all the increments of time that have\n   *         been played.\n   */Player.prototype.played=function played(){return this.techGet_('played')||createTimeRanges(0,0);};/**\n   * Returns whether or not the user is \"scrubbing\". Scrubbing is\n   * when the user has clicked the progress bar handle and is\n   * dragging it along the progress bar.\n   *\n   * @param {boolean} [isScrubbing]\n   *        wether the user is or is not scrubbing\n   *\n   * @return {boolean}\n   *         The value of scrubbing when getting\n   */Player.prototype.scrubbing=function scrubbing(isScrubbing){if(typeof isScrubbing==='undefined'){return this.scrubbing_;}this.scrubbing_=!!isScrubbing;if(isScrubbing){this.addClass('vjs-scrubbing');}else{this.removeClass('vjs-scrubbing');}};/**\n   * Get or set the current time (in seconds)\n   *\n   * @param {number|string} [seconds]\n   *        The time to seek to in seconds\n   *\n   * @return {number}\n   *         - the current time in seconds when getting\n   */Player.prototype.currentTime=function currentTime(seconds){if(typeof seconds!=='undefined'){if(seconds<0){seconds=0;}this.techCall_('setCurrentTime',seconds);return;}// cache last currentTime and return. default to 0 seconds\n//\n// Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n// currentTime when scrubbing, but may not provide much performance benefit afterall.\n// Should be tested. Also something has to read the actual current time or the cache will\n// never get updated.\nthis.cache_.currentTime=this.techGet_('currentTime')||0;return this.cache_.currentTime;};/**\n   * Normally gets the length in time of the video in seconds;\n   * in all but the rarest use cases an argument will NOT be passed to the method\n   *\n   * > **NOTE**: The video must have started loading before the duration can be\n   * known, and in the case of Flash, may not be known until the video starts\n   * playing.\n   *\n   * @fires Player#durationchange\n   *\n   * @param {number} [seconds]\n   *        The duration of the video to set in seconds\n   *\n   * @return {number}\n   *         - The duration of the video in seconds when getting\n   */Player.prototype.duration=function duration(seconds){if(seconds===undefined){// return NaN if the duration is not known\nreturn this.cache_.duration!==undefined?this.cache_.duration:NaN;}seconds=parseFloat(seconds);// Standardize on Inifity for signaling video is live\nif(seconds<0){seconds=Infinity;}if(seconds!==this.cache_.duration){// Cache the last set value for optimized scrubbing (esp. Flash)\nthis.cache_.duration=seconds;if(seconds===Infinity){this.addClass('vjs-live');}else{this.removeClass('vjs-live');}/**\n       * @event Player#durationchange\n       * @type {EventTarget~Event}\n       */this.trigger('durationchange');}};/**\n   * Calculates how much time is left in the video. Not part\n   * of the native video API.\n   *\n   * @return {number}\n   *         The time remaining in seconds\n   */Player.prototype.remainingTime=function remainingTime(){return this.duration()-this.currentTime();};/**\n   * A remaining time function that is intented to be used when\n   * the time is to be displayed directly to the user.\n   *\n   * @return {number}\n   *         The rounded time remaining in seconds\n   */Player.prototype.remainingTimeDisplay=function remainingTimeDisplay(){return Math.floor(this.duration())-Math.floor(this.currentTime());};//\n// Kind of like an array of portions of the video that have been downloaded.\n/**\n   * Get a TimeRange object with an array of the times of the video\n   * that have been downloaded. If you just want the percent of the\n   * video that's been downloaded, use bufferedPercent.\n   *\n   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n   *\n   * @return {TimeRange}\n   *         A mock TimeRange object (following HTML spec)\n   */Player.prototype.buffered=function buffered(){var buffered=this.techGet_('buffered');if(!buffered||!buffered.length){buffered=createTimeRanges(0,0);}return buffered;};/**\n   * Get the percent (as a decimal) of the video that's been downloaded.\n   * This method is not a part of the native HTML video API.\n   *\n   * @return {number}\n   *         A decimal between 0 and 1 representing the percent\n   *         that is bufferred 0 being 0% and 1 being 100%\n   */Player.prototype.bufferedPercent=function bufferedPercent$$1(){return bufferedPercent(this.buffered(),this.duration());};/**\n   * Get the ending time of the last buffered time range\n   * This is used in the progress bar to encapsulate all time ranges.\n   *\n   * @return {number}\n   *         The end of the last buffered time range\n   */Player.prototype.bufferedEnd=function bufferedEnd(){var buffered=this.buffered();var duration=this.duration();var end=buffered.end(buffered.length-1);if(end>duration){end=duration;}return end;};/**\n   * Get or set the current volume of the media\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         The current volume as a percent when getting\n   */Player.prototype.volume=function volume(percentAsDecimal){var vol=void 0;if(percentAsDecimal!==undefined){// Force value to between 0 and 1\nvol=Math.max(0,Math.min(1,parseFloat(percentAsDecimal)));this.cache_.volume=vol;this.techCall_('setVolume',vol);if(vol>0){this.lastVolume_(vol);}return;}// Default to 1 when returning current volume.\nvol=parseFloat(this.techGet_('volume'));return isNaN(vol)?1:vol;};/**\n   * Get the current muted state, or turn mute on or off\n   *\n   * @param {boolean} [muted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean}\n   *         - true if mute is on and getting\n   *         - false if mute is off and getting\n   */Player.prototype.muted=function muted(_muted){if(_muted!==undefined){this.techCall_('setMuted',_muted);return;}return this.techGet_('muted')||false;};/**\n   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n   * indicates the state of muted on intial playback.\n   *\n   * ```js\n   *   var myPlayer = videojs('some-player-id');\n   *\n   *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n   *\n   *   // get, should be false\n   *   console.log(myPlayer.defaultMuted());\n   *   // set to true\n   *   myPlayer.defaultMuted(true);\n   *   // get should be true\n   *   console.log(myPlayer.defaultMuted());\n   * ```\n   *\n   * @param {boolean} [defaultMuted]\n   *        - true to mute\n   *        - false to unmute\n   *\n   * @return {boolean|Player}\n   *         - true if defaultMuted is on and getting\n   *         - false if defaultMuted is off and getting\n   *         - A reference to the current player when setting\n   */Player.prototype.defaultMuted=function defaultMuted(_defaultMuted){if(_defaultMuted!==undefined){return this.techCall_('setDefaultMuted',_defaultMuted);}return this.techGet_('defaultMuted')||false;};/**\n   * Get the last volume, or set it\n   *\n   * @param  {number} [percentAsDecimal]\n   *         The new last volume as a decimal percent:\n   *         - 0 is muted/0%/off\n   *         - 1.0 is 100%/full\n   *         - 0.5 is half volume or 50%\n   *\n   * @return {number}\n   *         the current value of lastVolume as a percent when getting\n   *\n   * @private\n   */Player.prototype.lastVolume_=function lastVolume_(percentAsDecimal){if(percentAsDecimal!==undefined&&percentAsDecimal!==0){this.cache_.lastVolume=percentAsDecimal;return;}return this.cache_.lastVolume;};/**\n   * Check if current tech can support native fullscreen\n   * (e.g. with built in controls like iOS, so not our flash swf)\n   *\n   * @return {boolean}\n   *         if native fullscreen is supported\n   */Player.prototype.supportsFullScreen=function supportsFullScreen(){return this.techGet_('supportsFullScreen')||false;};/**\n   * Check if the player is in fullscreen mode or tell the player that it\n   * is or is not in fullscreen mode.\n   *\n   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n   * property and instead document.fullscreenElement is used. But isFullscreen is\n   * still a valuable property for internal player workings.\n   *\n   * @param  {boolean} [isFS]\n   *         Set the players current fullscreen state\n   *\n   * @return {boolean}\n   *         - true if fullscreen is on and getting\n   *         - false if fullscreen is off and getting\n   */Player.prototype.isFullscreen=function isFullscreen(isFS){if(isFS!==undefined){this.isFullscreen_=!!isFS;return;}return!!this.isFullscreen_;};/**\n   * Increase the size of the video to full screen\n   * In some browsers, full screen is not supported natively, so it enters\n   * \"full window mode\", where the video fills the browser window.\n   * In browsers and devices that support native full screen, sometimes the\n   * browser's default controls will be shown, and not the Video.js custom skin.\n   * This includes most mobile devices (iOS, Android) and older versions of\n   * Safari.\n   *\n   * @fires Player#fullscreenchange\n   */Player.prototype.requestFullscreen=function requestFullscreen(){var fsApi=FullscreenApi;this.isFullscreen(true);if(fsApi.requestFullscreen){// the browser supports going fullscreen at the element level so we can\n// take the controls fullscreen as well as the video\n// Trigger fullscreenchange event after change\n// We have to specifically add this each time, and remove\n// when canceling fullscreen. Otherwise if there's multiple\n// players on a page, they would all be reacting to the same fullscreen\n// events\non(document,fsApi.fullscreenchange,bind(this,function documentFullscreenChange(e){this.isFullscreen(document[fsApi.fullscreenElement]);// If cancelling fullscreen, remove event listener.\nif(this.isFullscreen()===false){off(document,fsApi.fullscreenchange,documentFullscreenChange);}/**\n         * @event Player#fullscreenchange\n         * @type {EventTarget~Event}\n         */this.trigger('fullscreenchange');}));this.el_[fsApi.requestFullscreen]();}else if(this.tech_.supportsFullScreen()){// we can't take the video.js controls fullscreen but we can go fullscreen\n// with native controls\nthis.techCall_('enterFullScreen');}else{// fullscreen isn't supported so we'll just stretch the video element to\n// fill the viewport\nthis.enterFullWindow();/**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */this.trigger('fullscreenchange');}};/**\n   * Return the video to its normal size after having been in full screen mode\n   *\n   * @fires Player#fullscreenchange\n   */Player.prototype.exitFullscreen=function exitFullscreen(){var fsApi=FullscreenApi;this.isFullscreen(false);// Check for browser element fullscreen support\nif(fsApi.requestFullscreen){document[fsApi.exitFullscreen]();}else if(this.tech_.supportsFullScreen()){this.techCall_('exitFullScreen');}else{this.exitFullWindow();/**\n       * @event Player#fullscreenchange\n       * @type {EventTarget~Event}\n       */this.trigger('fullscreenchange');}};/**\n   * When fullscreen isn't supported we can stretch the\n   * video container to as wide as the browser will let us.\n   *\n   * @fires Player#enterFullWindow\n   */Player.prototype.enterFullWindow=function enterFullWindow(){this.isFullWindow=true;// Storing original doc overflow value to return to when fullscreen is off\nthis.docOrigOverflow=document.documentElement.style.overflow;// Add listener for esc key to exit fullscreen\non(document,'keydown',bind(this,this.fullWindowOnEscKey));// Hide any scroll bars\ndocument.documentElement.style.overflow='hidden';// Apply fullscreen styles\naddClass(document.body,'vjs-full-window');/**\n     * @event Player#enterFullWindow\n     * @type {EventTarget~Event}\n     */this.trigger('enterFullWindow');};/**\n   * Check for call to either exit full window or\n   * full screen on ESC key\n   *\n   * @param {string} event\n   *        Event to check for key press\n   */Player.prototype.fullWindowOnEscKey=function fullWindowOnEscKey(event){if(event.keyCode===27){if(this.isFullscreen()===true){this.exitFullscreen();}else{this.exitFullWindow();}}};/**\n   * Exit full window\n   *\n   * @fires Player#exitFullWindow\n   */Player.prototype.exitFullWindow=function exitFullWindow(){this.isFullWindow=false;off(document,'keydown',this.fullWindowOnEscKey);// Unhide scroll bars.\ndocument.documentElement.style.overflow=this.docOrigOverflow;// Remove fullscreen styles\nremoveClass(document.body,'vjs-full-window');// Resize the box, controller, and poster to original sizes\n// this.positionAll();\n/**\n     * @event Player#exitFullWindow\n     * @type {EventTarget~Event}\n     */this.trigger('exitFullWindow');};/**\n   * Check whether the player can play a given mimetype\n   *\n   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n   *\n   * @param {string} type\n   *        The mimetype to check\n   *\n   * @return {string}\n   *         'probably', 'maybe', or '' (empty string)\n   */Player.prototype.canPlayType=function canPlayType(type){var can=void 0;// Loop through each playback technology in the options order\nfor(var i=0,j=this.options_.techOrder;i<j.length;i++){var techName=j[i];var tech=Tech.getTech(techName);// Support old behavior of techs being registered as components.\n// Remove once that deprecated behavior is removed.\nif(!tech){tech=Component.getComponent(techName);}// Check if the current tech is defined before continuing\nif(!tech){log$1.error('The \"'+techName+'\" tech is undefined. Skipped browser support check for that tech.');continue;}// Check if the browser supports this technology\nif(tech.isSupported()){can=tech.canPlayType(type);if(can){return can;}}}return'';};/**\n   * Select source based on tech-order or source-order\n   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n   * defaults to tech-order selection\n   *\n   * @param {Array} sources\n   *        The sources for a media asset\n   *\n   * @return {Object|boolean}\n   *         Object of source and tech order or false\n   */Player.prototype.selectSource=function selectSource(sources){var _this6=this;// Get only the techs specified in `techOrder` that exist and are supported by the\n// current platform\nvar techs=this.options_.techOrder.map(function(techName){return[techName,Tech.getTech(techName)];}).filter(function(_ref){var techName=_ref[0],tech=_ref[1];// Check if the current tech is defined before continuing\nif(tech){// Check if the browser supports this technology\nreturn tech.isSupported();}log$1.error('The \"'+techName+'\" tech is undefined. Skipped browser support check for that tech.');return false;});// Iterate over each `innerArray` element once per `outerArray` element and execute\n// `tester` with both. If `tester` returns a non-falsy value, exit early and return\n// that value.\nvar findFirstPassingTechSourcePair=function findFirstPassingTechSourcePair(outerArray,innerArray,tester){var found=void 0;outerArray.some(function(outerChoice){return innerArray.some(function(innerChoice){found=tester(outerChoice,innerChoice);if(found){return true;}});});return found;};var foundSourceAndTech=void 0;var flip=function flip(fn){return function(a,b){return fn(b,a);};};var finder=function finder(_ref2,source){var techName=_ref2[0],tech=_ref2[1];if(tech.canPlaySource(source,_this6.options_[techName.toLowerCase()])){return{source:source,tech:techName};}};// Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n// to select from them based on their priority.\nif(this.options_.sourceOrder){// Source-first ordering\nfoundSourceAndTech=findFirstPassingTechSourcePair(sources,techs,flip(finder));}else{// Tech-first ordering\nfoundSourceAndTech=findFirstPassingTechSourcePair(techs,sources,finder);}return foundSourceAndTech||false;};/**\n   * Get or set the video source.\n   *\n   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n   *        A SourceObject, an array of SourceObjects, or a string referencing\n   *        a URL to a media source. It is _highly recommended_ that an object\n   *        or array of objects is used here, so that source selection\n   *        algorithms can take the `type` into account.\n   *\n   *        If not provided, this method acts as a getter.\n   *\n   * @return {string|undefined}\n   *         If the `source` argument is missing, returns the current source\n   *         URL. Otherwise, returns nothing/undefined.\n   */Player.prototype.src=function src(source){var _this7=this;// getter usage\nif(typeof source==='undefined'){return this.cache_.src||'';}// filter out invalid sources and turn our source into\n// an array of source objects\nvar sources=filterSource(source);// if a source was passed in then it is invalid because\n// it was filtered to a zero length Array. So we have to\n// show an error\nif(!sources.length){this.setTimeout(function(){this.error({code:4,message:this.localize(this.options_.notSupportedMessage)});},0);return;}// intial sources\nthis.cache_.sources=sources;this.changingSrc_=true;// intial source\nthis.cache_.source=sources[0];// middlewareSource is the source after it has been changed by middleware\nsetSource(this,sources[0],function(middlewareSource,mws){_this7.middleware_=mws;var err=_this7.src_(middlewareSource);if(err){if(sources.length>1){return _this7.src(sources.slice(1));}// We need to wrap this in a timeout to give folks a chance to add error event handlers\n_this7.setTimeout(function(){this.error({code:4,message:this.localize(this.options_.notSupportedMessage)});},0);// we could not find an appropriate tech, but let's still notify the delegate that this is it\n// this needs a better comment about why this is needed\n_this7.triggerReady();return;}_this7.changingSrc_=false;// video element listed source\n_this7.cache_.src=middlewareSource.src;setTech(mws,_this7.tech_);});};/**\n   * Set the source object on the tech, returns a boolean that indicates wether\n   * there is a tech that can play the source or not\n   *\n   * @param {Tech~SourceObject} source\n   *        The source object to set on the Tech\n   *\n   * @return {Boolean}\n   *         - True if there is no Tech to playback this source\n   *         - False otherwise\n   *\n   * @private\n   */Player.prototype.src_=function src_(source){var sourceTech=this.selectSource([source]);if(!sourceTech){return true;}if(!titleCaseEquals(sourceTech.tech,this.techName_)){this.changingSrc_=true;// load this technology with the chosen source\nthis.loadTech_(sourceTech.tech,sourceTech.source);return false;}// wait until the tech is ready to set the source\nthis.ready(function(){// The setSource tech method was added with source handlers\n// so older techs won't support it\n// We need to check the direct prototype for the case where subclasses\n// of the tech do not support source handlers\nif(this.tech_.constructor.prototype.hasOwnProperty('setSource')){this.techCall_('setSource',source);}else{this.techCall_('src',source.src);}if(this.options_.preload==='auto'){this.load();}// Set the source synchronously if possible (#2326)\n},true);return false;};/**\n   * Begin loading the src data.\n   */Player.prototype.load=function load(){this.techCall_('load');};/**\n   * Reset the player. Loads the first tech in the techOrder,\n   * and calls `reset` on the tech`.\n   */Player.prototype.reset=function reset(){this.loadTech_(this.options_.techOrder[0],null);this.techCall_('reset');};/**\n   * Returns all of the current source objects.\n   *\n   * @return {Tech~SourceObject[]}\n   *         The current source objects\n   */Player.prototype.currentSources=function currentSources(){var source=this.currentSource();var sources=[];// assume `{}` or `{ src }`\nif(Object.keys(source).length!==0){sources.push(source);}return this.cache_.sources||sources;};/**\n   * Returns the current source object.\n   *\n   * @return {Tech~SourceObject}\n   *         The current source object\n   */Player.prototype.currentSource=function currentSource(){return this.cache_.source||{};};/**\n   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.\n   *\n   * @return {string}\n   *         The current source\n   */Player.prototype.currentSrc=function currentSrc(){return this.currentSource()&&this.currentSource().src||'';};/**\n   * Get the current source type e.g. video/mp4\n   * This can allow you rebuild the current source object so that you could load the same\n   * source and tech later\n   *\n   * @return {string}\n   *         The source MIME type\n   */Player.prototype.currentType=function currentType(){return this.currentSource()&&this.currentSource().type||'';};/**\n   * Get or set the preload attribute\n   *\n   * @param {boolean} [value]\n   *        - true means that we should preload\n   *        - false maens that we should not preload\n   *\n   * @return {string}\n   *         The preload attribute value when getting\n   */Player.prototype.preload=function preload(value){if(value!==undefined){this.techCall_('setPreload',value);this.options_.preload=value;return;}return this.techGet_('preload');};/**\n   * Get or set the autoplay attribute.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should autoplay\n   *        - false means that we should not autoplay\n   *\n   * @return {string}\n   *         The current value of autoplay when getting\n   */Player.prototype.autoplay=function autoplay(value){if(value!==undefined){this.techCall_('setAutoplay',value);this.options_.autoplay=value;this.ready(this.forceAutoplayInChrome_);return;}return this.techGet_('autoplay',value);};/**\n   * chrome started pausing the video when moving in the DOM\n   * causing autoplay to not continue due to how Video.js functions.\n   * See #4720 for more info.\n   *\n   * @private\n   */Player.prototype.forceAutoplayInChrome_=function forceAutoplayInChrome_(){if(this.paused()&&(// read from the video element or options\nthis.autoplay()||this.options_.autoplay)&&// only target desktop chrome\nIS_CHROME&&!IS_ANDROID){this.play();}};/**\n   * Set or unset the playsinline attribute.\n   * Playsinline tells the browser that non-fullscreen playback is preferred.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should try to play inline by default\n   *        - false means that we should use the browser's default playback mode,\n   *          which in most cases is inline. iOS Safari is a notable exception\n   *          and plays fullscreen by default.\n   *\n   * @return {string|Player}\n   *         - the current value of playsinline\n   *         - the player when setting\n   *\n   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n   */Player.prototype.playsinline=function playsinline(value){if(value!==undefined){this.techCall_('setPlaysinline',value);this.options_.playsinline=value;return this;}return this.techGet_('playsinline');};/**\n   * Get or set the loop attribute on the video element.\n   *\n   * @param {boolean} [value]\n   *        - true means that we should loop the video\n   *        - false means that we should not loop the video\n   *\n   * @return {string}\n   *         The current value of loop when getting\n   */Player.prototype.loop=function loop(value){if(value!==undefined){this.techCall_('setLoop',value);this.options_.loop=value;return;}return this.techGet_('loop');};/**\n   * Get or set the poster image source url\n   *\n   * @fires Player#posterchange\n   *\n   * @param {string} [src]\n   *        Poster image source URL\n   *\n   * @return {string}\n   *         The current value of poster when getting\n   */Player.prototype.poster=function poster(src){if(src===undefined){return this.poster_;}// The correct way to remove a poster is to set as an empty string\n// other falsey values will throw errors\nif(!src){src='';}// update the internal poster variable\nthis.poster_=src;// update the tech's poster\nthis.techCall_('setPoster',src);// alert components that the poster has been set\n/**\n     * This event fires when the poster image is changed on the player.\n     *\n     * @event Player#posterchange\n     * @type {EventTarget~Event}\n     */this.trigger('posterchange');};/**\n   * Some techs (e.g. YouTube) can provide a poster source in an\n   * asynchronous way. We want the poster component to use this\n   * poster source so that it covers up the tech's controls.\n   * (YouTube's play button). However we only want to use this\n   * source if the player user hasn't set a poster through\n   * the normal APIs.\n   *\n   * @fires Player#posterchange\n   * @listens Tech#posterchange\n   * @private\n   */Player.prototype.handleTechPosterChange_=function handleTechPosterChange_(){if(!this.poster_&&this.tech_&&this.tech_.poster){this.poster_=this.tech_.poster()||'';// Let components know the poster has changed\nthis.trigger('posterchange');}};/**\n   * Get or set whether or not the controls are showing.\n   *\n   * @fires Player#controlsenabled\n   *\n   * @param {boolean} [bool]\n   *        - true to turn controls on\n   *        - false to turn controls off\n   *\n   * @return {boolean}\n   *         The current value of controls when getting\n   */Player.prototype.controls=function controls(bool){if(bool===undefined){return!!this.controls_;}bool=!!bool;// Don't trigger a change event unless it actually changed\nif(this.controls_===bool){return;}this.controls_=bool;if(this.usingNativeControls()){this.techCall_('setControls',bool);}if(this.controls_){this.removeClass('vjs-controls-disabled');this.addClass('vjs-controls-enabled');/**\n       * @event Player#controlsenabled\n       * @type {EventTarget~Event}\n       */this.trigger('controlsenabled');if(!this.usingNativeControls()){this.addTechControlsListeners_();}}else{this.removeClass('vjs-controls-enabled');this.addClass('vjs-controls-disabled');/**\n       * @event Player#controlsdisabled\n       * @type {EventTarget~Event}\n       */this.trigger('controlsdisabled');if(!this.usingNativeControls()){this.removeTechControlsListeners_();}}};/**\n   * Toggle native controls on/off. Native controls are the controls built into\n   * devices (e.g. default iPhone controls), Flash, or other techs\n   * (e.g. Vimeo Controls)\n   * **This should only be set by the current tech, because only the tech knows\n   * if it can support native controls**\n   *\n   * @fires Player#usingnativecontrols\n   * @fires Player#usingcustomcontrols\n   *\n   * @param {boolean} [bool]\n   *        - true to turn native controls on\n   *        - false to turn native controls off\n   *\n   * @return {boolean}\n   *         The current value of native controls when getting\n   */Player.prototype.usingNativeControls=function usingNativeControls(bool){if(bool===undefined){return!!this.usingNativeControls_;}bool=!!bool;// Don't trigger a change event unless it actually changed\nif(this.usingNativeControls_===bool){return;}this.usingNativeControls_=bool;if(this.usingNativeControls_){this.addClass('vjs-using-native-controls');/**\n       * player is using the native device controls\n       *\n       * @event Player#usingnativecontrols\n       * @type {EventTarget~Event}\n       */this.trigger('usingnativecontrols');}else{this.removeClass('vjs-using-native-controls');/**\n       * player is using the custom HTML controls\n       *\n       * @event Player#usingcustomcontrols\n       * @type {EventTarget~Event}\n       */this.trigger('usingcustomcontrols');}};/**\n   * Set or get the current MediaError\n   *\n   * @fires Player#error\n   *\n   * @param  {MediaError|string|number} [err]\n   *         A MediaError or a string/number to be turned\n   *         into a MediaError\n   *\n   * @return {MediaError|null}\n   *         The current MediaError when getting (or null)\n   */Player.prototype.error=function error(err){if(err===undefined){return this.error_||null;}// restoring to default\nif(err===null){this.error_=err;this.removeClass('vjs-error');if(this.errorDisplay){this.errorDisplay.close();}return;}this.error_=new MediaError(err);// add the vjs-error classname to the player\nthis.addClass('vjs-error');// log the name of the error type and any message\n// ie8 just logs \"[object object]\" if you just log the error object\nlog$1.error('(CODE:'+this.error_.code+' '+MediaError.errorTypes[this.error_.code]+')',this.error_.message,this.error_);/**\n     * @event Player#error\n     * @type {EventTarget~Event}\n     */this.trigger('error');return;};/**\n   * Report user activity\n   *\n   * @param {Object} event\n   *        Event object\n   */Player.prototype.reportUserActivity=function reportUserActivity(event){this.userActivity_=true;};/**\n   * Get/set if user is active\n   *\n   * @fires Player#useractive\n   * @fires Player#userinactive\n   *\n   * @param {boolean} [bool]\n   *        - true if the user is active\n   *        - false if the user is inactive\n   *\n   * @return {boolean}\n   *         The current value of userActive when getting\n   */Player.prototype.userActive=function userActive(bool){if(bool===undefined){return this.userActive_;}bool=!!bool;if(bool===this.userActive_){return;}this.userActive_=bool;if(this.userActive_){this.userActivity_=true;this.removeClass('vjs-user-inactive');this.addClass('vjs-user-active');/**\n       * @event Player#useractive\n       * @type {EventTarget~Event}\n       */this.trigger('useractive');return;}// Chrome/Safari/IE have bugs where when you change the cursor it can\n// trigger a mousemove event. This causes an issue when you're hiding\n// the cursor when the user is inactive, and a mousemove signals user\n// activity. Making it impossible to go into inactive mode. Specifically\n// this happens in fullscreen when we really need to hide the cursor.\n//\n// When this gets resolved in ALL browsers it can be removed\n// https://code.google.com/p/chromium/issues/detail?id=103041\nif(this.tech_){this.tech_.one('mousemove',function(e){e.stopPropagation();e.preventDefault();});}this.userActivity_=false;this.removeClass('vjs-user-active');this.addClass('vjs-user-inactive');/**\n     * @event Player#userinactive\n     * @type {EventTarget~Event}\n     */this.trigger('userinactive');};/**\n   * Listen for user activity based on timeout value\n   *\n   * @private\n   */Player.prototype.listenForUserActivity_=function listenForUserActivity_(){var mouseInProgress=void 0;var lastMoveX=void 0;var lastMoveY=void 0;var handleActivity=bind(this,this.reportUserActivity);var handleMouseMove=function handleMouseMove(e){// #1068 - Prevent mousemove spamming\n// Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\nif(e.screenX!==lastMoveX||e.screenY!==lastMoveY){lastMoveX=e.screenX;lastMoveY=e.screenY;handleActivity();}};var handleMouseDown=function handleMouseDown(){handleActivity();// For as long as the they are touching the device or have their mouse down,\n// we consider them active even if they're not moving their finger or mouse.\n// So we want to continue to update that they are active\nthis.clearInterval(mouseInProgress);// Setting userActivity=true now and setting the interval to the same time\n// as the activityCheck interval (250) should ensure we never miss the\n// next activityCheck\nmouseInProgress=this.setInterval(handleActivity,250);};var handleMouseUp=function handleMouseUp(event){handleActivity();// Stop the interval that maintains activity if the mouse/touch is down\nthis.clearInterval(mouseInProgress);};// Any mouse movement will be considered user activity\nthis.on('mousedown',handleMouseDown);this.on('mousemove',handleMouseMove);this.on('mouseup',handleMouseUp);// Listen for keyboard navigation\n// Shouldn't need to use inProgress interval because of key repeat\nthis.on('keydown',handleActivity);this.on('keyup',handleActivity);// Run an interval every 250 milliseconds instead of stuffing everything into\n// the mousemove/touchmove function itself, to prevent performance degradation.\n// `this.reportUserActivity` simply sets this.userActivity_ to true, which\n// then gets picked up by this loop\n// http://ejohn.org/blog/learning-from-twitter/\nvar inactivityTimeout=void 0;this.setInterval(function(){// Check to see if mouse/touch activity has happened\nif(!this.userActivity_){return;}// Reset the activity tracker\nthis.userActivity_=false;// If the user state was inactive, set the state to active\nthis.userActive(true);// Clear any existing inactivity timeout to start the timer over\nthis.clearTimeout(inactivityTimeout);var timeout=this.options_.inactivityTimeout;if(timeout<=0){return;}// In <timeout> milliseconds, if no more activity has occurred the\n// user will be considered inactive\ninactivityTimeout=this.setTimeout(function(){// Protect against the case where the inactivityTimeout can trigger just\n// before the next user activity is picked up by the activity check loop\n// causing a flicker\nif(!this.userActivity_){this.userActive(false);}},timeout);},250);};/**\n   * Gets or sets the current playback rate. A playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed\n   * playback, for instance.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n   *\n   * @param {number} [rate]\n   *       New playback rate to set.\n   *\n   * @return {number}\n   *         The current playback rate when getting or 1.0\n   */Player.prototype.playbackRate=function playbackRate(rate){if(rate!==undefined){this.techCall_('setPlaybackRate',rate);return;}if(this.tech_&&this.tech_.featuresPlaybackRate){return this.techGet_('playbackRate');}return 1.0;};/**\n   * Gets or sets the current default playback rate. A default playback rate of\n   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not\n   * not the current playbackRate.\n   *\n   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n   *\n   * @param {number} [rate]\n   *       New default playback rate to set.\n   *\n   * @return {number|Player}\n   *         - The default playback rate when getting or 1.0\n   *         - the player when setting\n   */Player.prototype.defaultPlaybackRate=function defaultPlaybackRate(rate){if(rate!==undefined){return this.techCall_('setDefaultPlaybackRate',rate);}if(this.tech_&&this.tech_.featuresPlaybackRate){return this.techGet_('defaultPlaybackRate');}return 1.0;};/**\n   * Gets or sets the audio flag\n   *\n   * @param {boolean} bool\n   *        - true signals that this is an audio player\n   *        - false signals that this is not an audio player\n   *\n   * @return {boolean}\n   *         The current value of isAudio when getting\n   */Player.prototype.isAudio=function isAudio(bool){if(bool!==undefined){this.isAudio_=!!bool;return;}return!!this.isAudio_;};/**\n   * A helper method for adding a {@link TextTrack} to our\n   * {@link TextTrackList}.\n   *\n   * In addition to the W3C settings we allow adding additional info through options.\n   *\n   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n   *\n   * @param {string} [kind]\n   *        the kind of TextTrack you are adding\n   *\n   * @param {string} [label]\n   *        the label to give the TextTrack label\n   *\n   * @param {string} [language]\n   *        the language to set on the TextTrack\n   *\n   * @return {TextTrack|undefined}\n   *         the TextTrack that was added or undefined\n   *         if there is no tech\n   */Player.prototype.addTextTrack=function addTextTrack(kind,label,language){if(this.tech_){return this.tech_.addTextTrack(kind,label,language);}};/**\n   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will\n   * automatically removed from the video element whenever the source changes, unless\n   * manualCleanup is set to false.\n   *\n   * @param {Object} options\n   *        Options to pass to {@link HTMLTrackElement} during creation. See\n   *        {@link HTMLTrackElement} for object properties that you should use.\n   *\n   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be\n   *\n   * @return {HtmlTrackElement}\n   *         the HTMLTrackElement that was created and added\n   *         to the HtmlTrackElementList and the remote\n   *         TextTrackList\n   *\n   * @deprecated The default value of the \"manualCleanup\" parameter will default\n   *             to \"false\" in upcoming versions of Video.js\n   */Player.prototype.addRemoteTextTrack=function addRemoteTextTrack(options,manualCleanup){if(this.tech_){return this.tech_.addRemoteTextTrack(options,manualCleanup);}};/**\n   * Remove a remote {@link TextTrack} from the respective\n   * {@link TextTrackList} and {@link HtmlTrackElementList}.\n   *\n   * @param {Object} track\n   *        Remote {@link TextTrack} to remove\n   *\n   * @return {undefined}\n   *         does not return anything\n   */Player.prototype.removeRemoteTextTrack=function removeRemoteTextTrack(){var _ref3=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},_ref3$track=_ref3.track,track=_ref3$track===undefined?arguments[0]:_ref3$track;// destructure the input into an object with a track argument, defaulting to arguments[0]\n// default the whole argument to an empty object if nothing was passed in\nif(this.tech_){return this.tech_.removeRemoteTextTrack(track);}};/**\n   * Gets available media playback quality metrics as specified by the W3C's Media\n   * Playback Quality API.\n   *\n   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n   *\n   * @return {Object|undefined}\n   *         An object with supported media playback quality metrics or undefined if there\n   *         is no tech or the tech does not support it.\n   */Player.prototype.getVideoPlaybackQuality=function getVideoPlaybackQuality(){return this.techGet_('getVideoPlaybackQuality');};/**\n   * Get video width\n   *\n   * @return {number}\n   *         current video width\n   */Player.prototype.videoWidth=function videoWidth(){return this.tech_&&this.tech_.videoWidth&&this.tech_.videoWidth()||0;};/**\n   * Get video height\n   *\n   * @return {number}\n   *         current video height\n   */Player.prototype.videoHeight=function videoHeight(){return this.tech_&&this.tech_.videoHeight&&this.tech_.videoHeight()||0;};/**\n   * The player's language code\n   * NOTE: The language should be set in the player options if you want the\n   * the controls to be built with a specific language. Changing the lanugage\n   * later will not update controls text.\n   *\n   * @param {string} [code]\n   *        the language code to set the player to\n   *\n   * @return {string}\n   *         The current language code when getting\n   */Player.prototype.language=function language(code){if(code===undefined){return this.language_;}this.language_=String(code).toLowerCase();};/**\n   * Get the player's language dictionary\n   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n   * Languages specified directly in the player options have precedence\n   *\n   * @return {Array}\n   *         An array of of supported languages\n   */Player.prototype.languages=function languages(){return mergeOptions(Player.prototype.options_.languages,this.languages_);};/**\n   * returns a JavaScript object reperesenting the current track\n   * information. **DOES not return it as JSON**\n   *\n   * @return {Object}\n   *         Object representing the current of track info\n   */Player.prototype.toJSON=function toJSON(){var options=mergeOptions(this.options_);var tracks=options.tracks;options.tracks=[];for(var i=0;i<tracks.length;i++){var track=tracks[i];// deep merge tracks and null out player so no circular references\ntrack=mergeOptions(track);track.player=undefined;options.tracks[i]=track;}return options;};/**\n   * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n   * component) that immediately overlays the player with arbitrary\n   * content and removes itself when closed.\n   *\n   * @param {string|Function|Element|Array|null} content\n   *        Same as {@link ModalDialog#content}'s param of the same name.\n   *        The most straight-forward usage is to provide a string or DOM\n   *        element.\n   *\n   * @param {Object} [options]\n   *        Extra options which will be passed on to the {@link ModalDialog}.\n   *\n   * @return {ModalDialog}\n   *         the {@link ModalDialog} that was created\n   */Player.prototype.createModal=function createModal(content,options){var _this8=this;options=options||{};options.content=content||'';var modal=new ModalDialog(this,options);this.addChild(modal);modal.on('dispose',function(){_this8.removeChild(modal);});modal.open();return modal;};/**\n   * Gets tag settings\n   *\n   * @param {Element} tag\n   *        The player tag\n   *\n   * @return {Object}\n   *         An object containing all of the settings\n   *         for a player tag\n   */Player.getTagSettings=function getTagSettings(tag){var baseOptions={sources:[],tracks:[]};var tagOptions=getAttributes(tag);var dataSetup=tagOptions['data-setup'];if(hasClass(tag,'vjs-fluid')){tagOptions.fluid=true;}// Check if data-setup attr exists.\nif(dataSetup!==null){// Parse options JSON\n// If empty string, make it a parsable json object.\nvar _safeParseTuple=safeParseTuple(dataSetup||'{}'),err=_safeParseTuple[0],data=_safeParseTuple[1];if(err){log$1.error(err);}assign(tagOptions,data);}assign(baseOptions,tagOptions);// Get tag children settings\nif(tag.hasChildNodes()){var children=tag.childNodes;for(var i=0,j=children.length;i<j;i++){var child=children[i];// Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\nvar childName=child.nodeName.toLowerCase();if(childName==='source'){baseOptions.sources.push(getAttributes(child));}else if(childName==='track'){baseOptions.tracks.push(getAttributes(child));}}}return baseOptions;};/**\n   * Determine wether or not flexbox is supported\n   *\n   * @return {boolean}\n   *         - true if flexbox is supported\n   *         - false if flexbox is not supported\n   */Player.prototype.flexNotSupported_=function flexNotSupported_(){var elem=document.createElement('i');// Note: We don't actually use flexBasis (or flexOrder), but it's one of the more\n// common flex features that we can rely on when checking for flex support.\nreturn!('flexBasis'in elem.style||'webkitFlexBasis'in elem.style||'mozFlexBasis'in elem.style||'msFlexBasis'in elem.style||// IE10-specific (2012 flex spec)\n'msFlexOrder'in elem.style);};return Player;}(Component);/**\n * Get the {@link VideoTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n *\n * @return {VideoTrackList}\n *         the current video track list\n *\n * @method Player.prototype.videoTracks\n *//**\n * Get the {@link AudioTrackList}\n * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n *\n * @return {AudioTrackList}\n *         the current audio track list\n *\n * @method Player.prototype.audioTracks\n *//**\n * Get the {@link TextTrackList}\n *\n * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n *\n * @return {TextTrackList}\n *         the current text track list\n *\n * @method Player.prototype.textTracks\n *//**\n * Get the remote {@link TextTrackList}\n *\n * @return {TextTrackList}\n *         The current remote text track list\n *\n * @method Player.prototype.remoteTextTracks\n *//**\n * Get the remote {@link HtmlTrackElementList} tracks.\n *\n * @return {HtmlTrackElementList}\n *         The current remote text track element list\n *\n * @method Player.prototype.remoteTextTrackEls\n */ALL.names.forEach(function(name$$1){var props=ALL[name$$1];Player.prototype[props.getterName]=function(){if(this.tech_){return this.tech_[props.getterName]();}// if we have not yet loadTech_, we create {video,audio,text}Tracks_\n// these will be passed to the tech during loading\nthis[props.privateName]=this[props.privateName]||new props.ListClass();return this[props.privateName];};});/**\n * Global player list\n *\n * @type {Object}\n */Player.players={};var navigator=window.navigator;/*\n * Player instance options, surfaced using options\n * options = Player.prototype.options_\n * Make changes in options, not here.\n *\n * @type {Object}\n * @private\n */Player.prototype.options_={// Default order of fallback technology\ntechOrder:Tech.defaultTechOrder_,html5:{},flash:{},// default inactivity timeout\ninactivityTimeout:2000,// default playback rates\nplaybackRates:[],// Add playback rate selection by adding rates\n// 'playbackRates': [0.5, 1, 1.5, 2],\n// Included control sets\nchildren:['mediaLoader','posterImage','textTrackDisplay','loadingSpinner','bigPlayButton','controlBar','errorDisplay','textTrackSettings'],language:navigator&&(navigator.languages&&navigator.languages[0]||navigator.userLanguage||navigator.language)||'en',// locales and their language translations\nlanguages:{},// Default message to show when a video cannot be played.\nnotSupportedMessage:'No compatible source was found for this media.'};[/**\n * Returns whether or not the player is in the \"ended\" state.\n *\n * @return {Boolean} True if the player is in the ended state, false if not.\n * @method Player#ended\n */'ended',/**\n * Returns whether or not the player is in the \"seeking\" state.\n *\n * @return {Boolean} True if the player is in the seeking state, false if not.\n * @method Player#seeking\n */'seeking',/**\n * Returns the TimeRanges of the media that are currently available\n * for seeking to.\n *\n * @return {TimeRanges} the seekable intervals of the media timeline\n * @method Player#seekable\n */'seekable',/**\n * Returns the current state of network activity for the element, from\n * the codes in the list below.\n * - NETWORK_EMPTY (numeric value 0)\n *   The element has not yet been initialised. All attributes are in\n *   their initial states.\n * - NETWORK_IDLE (numeric value 1)\n *   The element's resource selection algorithm is active and has\n *   selected a resource, but it is not actually using the network at\n *   this time.\n * - NETWORK_LOADING (numeric value 2)\n *   The user agent is actively trying to download data.\n * - NETWORK_NO_SOURCE (numeric value 3)\n *   The element's resource selection algorithm is active, but it has\n *   not yet found a resource to use.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n * @return {number} the current network activity state\n * @method Player#networkState\n */'networkState',/**\n * Returns a value that expresses the current state of the element\n * with respect to rendering the current playback position, from the\n * codes in the list below.\n * - HAVE_NOTHING (numeric value 0)\n *   No information regarding the media resource is available.\n * - HAVE_METADATA (numeric value 1)\n *   Enough of the resource has been obtained that the duration of the\n *   resource is available.\n * - HAVE_CURRENT_DATA (numeric value 2)\n *   Data for the immediate current playback position is available.\n * - HAVE_FUTURE_DATA (numeric value 3)\n *   Data for the immediate current playback position is available, as\n *   well as enough data for the user agent to advance the current\n *   playback position in the direction of playback.\n * - HAVE_ENOUGH_DATA (numeric value 4)\n *   The user agent estimates that enough data is available for\n *   playback to proceed uninterrupted.\n *\n * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n * @return {number} the current playback rendering state\n * @method Player#readyState\n */'readyState'].forEach(function(fn){Player.prototype[fn]=function(){return this.techGet_(fn);};});TECH_EVENTS_RETRIGGER.forEach(function(event){Player.prototype['handleTech'+toTitleCase(event)+'_']=function(){return this.trigger(event);};});/**\n * Fired when the player has initial duration and dimension information\n *\n * @event Player#loadedmetadata\n * @type {EventTarget~Event}\n *//**\n * Fired when the player has downloaded data at the current playback position\n *\n * @event Player#loadeddata\n * @type {EventTarget~Event}\n *//**\n * Fired when the current playback position has changed *\n * During playback this is fired every 15-250 milliseconds, depending on the\n * playback technology in use.\n *\n * @event Player#timeupdate\n * @type {EventTarget~Event}\n *//**\n * Fired when the volume changes\n *\n * @event Player#volumechange\n * @type {EventTarget~Event}\n *//**\n * Reports whether or not a player has a plugin available.\n *\n * This does not report whether or not the plugin has ever been initialized\n * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n *\n * @method Player#hasPlugin\n * @param  {string}  name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player has the requested plugin available.\n *//**\n * Reports whether or not a player is using a plugin by name.\n *\n * For basic plugins, this only reports whether the plugin has _ever_ been\n * initialized on this player.\n *\n * @method Player#usingPlugin\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {boolean}\n *         Whether or not this player is using the requested plugin.\n */Component.registerComponent('Player',Player);/**\n * @file plugin.js\n *//**\n * The base plugin name.\n *\n * @private\n * @constant\n * @type {string}\n */var BASE_PLUGIN_NAME='plugin';/**\n * The key on which a player's active plugins cache is stored.\n *\n * @private\n * @constant\n * @type     {string}\n */var PLUGIN_CACHE_KEY='activePlugins_';/**\n * Stores registered plugins in a private space.\n *\n * @private\n * @type    {Object}\n */var pluginStorage={};/**\n * Reports whether or not a plugin has been registered.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {boolean}\n *          Whether or not the plugin has been registered.\n */var pluginExists=function pluginExists(name){return pluginStorage.hasOwnProperty(name);};/**\n * Get a single registered plugin by name.\n *\n * @private\n * @param   {string} name\n *          The name of a plugin.\n *\n * @returns {Function|undefined}\n *          The plugin (or undefined).\n */var getPlugin=function getPlugin(name){return pluginExists(name)?pluginStorage[name]:undefined;};/**\n * Marks a plugin as \"active\" on a player.\n *\n * Also, ensures that the player has an object for tracking active plugins.\n *\n * @private\n * @param   {Player} player\n *          A Video.js player instance.\n *\n * @param   {string} name\n *          The name of a plugin.\n */var markPluginAsActive=function markPluginAsActive(player,name){player[PLUGIN_CACHE_KEY]=player[PLUGIN_CACHE_KEY]||{};player[PLUGIN_CACHE_KEY][name]=true;};/**\n * Triggers a pair of plugin setup events.\n *\n * @private\n * @param  {Player} player\n *         A Video.js player instance.\n *\n * @param  {Plugin~PluginEventHash} hash\n *         A plugin event hash.\n *\n * @param  {Boolean} [before]\n *         If true, prefixes the event name with \"before\". In other words,\n *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n */var triggerSetupEvent=function triggerSetupEvent(player,hash,before){var eventName=(before?'before':'')+'pluginsetup';player.trigger(eventName,hash);player.trigger(eventName+':'+hash.name,hash);};/**\n * Takes a basic plugin function and returns a wrapper function which marks\n * on the player that the plugin has been activated.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Function} plugin\n *          The basic plugin.\n *\n * @returns {Function}\n *          A wrapper function for the given plugin.\n */var createBasicPlugin=function createBasicPlugin(name,plugin){var basicPluginWrapper=function basicPluginWrapper(){// We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n// regardless, but we want the hash to be consistent with the hash provided\n// for advanced plugins.\n//\n// The only potentially counter-intuitive thing here is the `instance` in\n// the \"pluginsetup\" event is the value returned by the `plugin` function.\ntriggerSetupEvent(this,{name:name,plugin:plugin,instance:null},true);var instance=plugin.apply(this,arguments);markPluginAsActive(this,name);triggerSetupEvent(this,{name:name,plugin:plugin,instance:instance});return instance;};Object.keys(plugin).forEach(function(prop){basicPluginWrapper[prop]=plugin[prop];});return basicPluginWrapper;};/**\n * Takes a plugin sub-class and returns a factory function for generating\n * instances of it.\n *\n * This factory function will replace itself with an instance of the requested\n * sub-class of Plugin.\n *\n * @private\n * @param   {string} name\n *          The name of the plugin.\n *\n * @param   {Plugin} PluginSubClass\n *          The advanced plugin.\n *\n * @returns {Function}\n */var createPluginFactory=function createPluginFactory(name,PluginSubClass){// Add a `name` property to the plugin prototype so that each plugin can\n// refer to itself by name.\nPluginSubClass.prototype.name=name;return function(){triggerSetupEvent(this,{name:name,plugin:PluginSubClass,instance:null},true);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var instance=new(Function.prototype.bind.apply(PluginSubClass,[null].concat([this].concat(args))))();// The plugin is replaced by a function that returns the current instance.\nthis[name]=function(){return instance;};triggerSetupEvent(this,instance.getEventHash());return instance;};};/**\n * Parent class for all advanced plugins.\n *\n * @mixes   module:evented~EventedMixin\n * @mixes   module:stateful~StatefulMixin\n * @fires   Player#beforepluginsetup\n * @fires   Player#beforepluginsetup:$name\n * @fires   Player#pluginsetup\n * @fires   Player#pluginsetup:$name\n * @listens Player#dispose\n * @throws  {Error}\n *          If attempting to instantiate the base {@link Plugin} class\n *          directly instead of via a sub-class.\n */var Plugin=function(){/**\n   * Creates an instance of this class.\n   *\n   * Sub-classes should call `super` to ensure plugins are properly initialized.\n   *\n   * @param {Player} player\n   *        A Video.js player instance.\n   */function Plugin(player){classCallCheck(this,Plugin);if(this.constructor===Plugin){throw new Error('Plugin must be sub-classed; not directly instantiated.');}this.player=player;// Make this object evented, but remove the added `trigger` method so we\n// use the prototype version instead.\nevented(this);delete this.trigger;stateful(this,this.constructor.defaultState);markPluginAsActive(player,this.name);// Auto-bind the dispose method so we can use it as a listener and unbind\n// it later easily.\nthis.dispose=bind(this,this.dispose);// If the player is disposed, dispose the plugin.\nplayer.on('dispose',this.dispose);}/**\n   * Get the version of the plugin that was set on <pluginName>.VERSION\n   */Plugin.prototype.version=function version(){return this.constructor.VERSION;};/**\n   * Each event triggered by plugins includes a hash of additional data with\n   * conventional properties.\n   *\n   * This returns that object or mutates an existing hash.\n   *\n   * @param   {Object} [hash={}]\n   *          An object to be used as event an event hash.\n   *\n   * @returns {Plugin~PluginEventHash}\n   *          An event hash object with provided properties mixed-in.\n   */Plugin.prototype.getEventHash=function getEventHash(){var hash=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};hash.name=this.name;hash.plugin=this.constructor;hash.instance=this;return hash;};/**\n   * Triggers an event on the plugin object and overrides\n   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n   *\n   * @param   {string|Object} event\n   *          An event type or an object with a type property.\n   *\n   * @param   {Object} [hash={}]\n   *          Additional data hash to merge with a\n   *          {@link Plugin~PluginEventHash|PluginEventHash}.\n   *\n   * @returns {boolean}\n   *          Whether or not default was prevented.\n   */Plugin.prototype.trigger=function trigger$$1(event){var hash=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return trigger(this.eventBusEl_,event,this.getEventHash(hash));};/**\n   * Handles \"statechanged\" events on the plugin. No-op by default, override by\n   * subclassing.\n   *\n   * @abstract\n   * @param    {Event} e\n   *           An event object provided by a \"statechanged\" event.\n   *\n   * @param    {Object} e.changes\n   *           An object describing changes that occurred with the \"statechanged\"\n   *           event.\n   */Plugin.prototype.handleStateChanged=function handleStateChanged(e){};/**\n   * Disposes a plugin.\n   *\n   * Subclasses can override this if they want, but for the sake of safety,\n   * it's probably best to subscribe the \"dispose\" event.\n   *\n   * @fires Plugin#dispose\n   */Plugin.prototype.dispose=function dispose(){var name=this.name,player=this.player;/**\n     * Signals that a advanced plugin is about to be disposed.\n     *\n     * @event Plugin#dispose\n     * @type  {EventTarget~Event}\n     */this.trigger('dispose');this.off();player.off('dispose',this.dispose);// Eliminate any possible sources of leaking memory by clearing up\n// references between the player and the plugin instance and nulling out\n// the plugin's state and replacing methods with a function that throws.\nplayer[PLUGIN_CACHE_KEY][name]=false;this.player=this.state=null;// Finally, replace the plugin name on the player with a new factory\n// function, so that the plugin is ready to be set up again.\nplayer[name]=createPluginFactory(name,pluginStorage[name]);};/**\n   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n   *\n   * @param   {string|Function} plugin\n   *          If a string, matches the name of a plugin. If a function, will be\n   *          tested directly.\n   *\n   * @returns {boolean}\n   *          Whether or not a plugin is a basic plugin.\n   */Plugin.isBasic=function isBasic(plugin){var p=typeof plugin==='string'?getPlugin(plugin):plugin;return typeof p==='function'&&!Plugin.prototype.isPrototypeOf(p.prototype);};/**\n   * Register a Video.js plugin.\n   *\n   * @param   {string} name\n   *          The name of the plugin to be registered. Must be a string and\n   *          must not match an existing plugin or a method on the `Player`\n   *          prototype.\n   *\n   * @param   {Function} plugin\n   *          A sub-class of `Plugin` or a function for basic plugins.\n   *\n   * @returns {Function}\n   *          For advanced plugins, a factory function for that plugin. For\n   *          basic plugins, a wrapper function that initializes the plugin.\n   */Plugin.registerPlugin=function registerPlugin(name,plugin){if(typeof name!=='string'){throw new Error('Illegal plugin name, \"'+name+'\", must be a string, was '+(typeof name==='undefined'?'undefined':_typeof(name))+'.');}if(pluginExists(name)){log$1.warn('A plugin named \"'+name+'\" already exists. You may want to avoid re-registering plugins!');}else if(Player.prototype.hasOwnProperty(name)){throw new Error('Illegal plugin name, \"'+name+'\", cannot share a name with an existing player method!');}if(typeof plugin!=='function'){throw new Error('Illegal plugin for \"'+name+'\", must be a function, was '+(typeof plugin==='undefined'?'undefined':_typeof(plugin))+'.');}pluginStorage[name]=plugin;// Add a player prototype method for all sub-classed plugins (but not for\n// the base Plugin class).\nif(name!==BASE_PLUGIN_NAME){if(Plugin.isBasic(plugin)){Player.prototype[name]=createBasicPlugin(name,plugin);}else{Player.prototype[name]=createPluginFactory(name,plugin);}}return plugin;};/**\n   * De-register a Video.js plugin.\n   *\n   * @param {string} name\n   *        The name of the plugin to be deregistered.\n   */Plugin.deregisterPlugin=function deregisterPlugin(name){if(name===BASE_PLUGIN_NAME){throw new Error('Cannot de-register base plugin.');}if(pluginExists(name)){delete pluginStorage[name];delete Player.prototype[name];}};/**\n   * Gets an object containing multiple Video.js plugins.\n   *\n   * @param   {Array} [names]\n   *          If provided, should be an array of plugin names. Defaults to _all_\n   *          plugin names.\n   *\n   * @returns {Object|undefined}\n   *          An object containing plugin(s) associated with their name(s) or\n   *          `undefined` if no matching plugins exist).\n   */Plugin.getPlugins=function getPlugins(){var names=arguments.length>0&&arguments[0]!==undefined?arguments[0]:Object.keys(pluginStorage);var result=void 0;names.forEach(function(name){var plugin=getPlugin(name);if(plugin){result=result||{};result[name]=plugin;}});return result;};/**\n   * Gets a plugin's version, if available\n   *\n   * @param   {string} name\n   *          The name of a plugin.\n   *\n   * @returns {string}\n   *          The plugin's version or an empty string.\n   */Plugin.getPluginVersion=function getPluginVersion(name){var plugin=getPlugin(name);return plugin&&plugin.VERSION||'';};return Plugin;}();/**\n * Gets a plugin by name if it exists.\n *\n * @static\n * @method   getPlugin\n * @memberOf Plugin\n * @param    {string} name\n *           The name of a plugin.\n *\n * @returns  {Function|undefined}\n *           The plugin (or `undefined`).\n */Plugin.getPlugin=getPlugin;/**\n * The name of the base plugin class as it is registered.\n *\n * @type {string}\n */Plugin.BASE_PLUGIN_NAME=BASE_PLUGIN_NAME;Plugin.registerPlugin(BASE_PLUGIN_NAME,Plugin);/**\n * Documented in player.js\n *\n * @ignore\n */Player.prototype.usingPlugin=function(name){return!!this[PLUGIN_CACHE_KEY]&&this[PLUGIN_CACHE_KEY][name]===true;};/**\n * Documented in player.js\n *\n * @ignore\n */Player.prototype.hasPlugin=function(name){return!!pluginExists(name);};/**\n * Signals that a plugin is about to be set up on a player.\n *\n * @event    Player#beforepluginsetup\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin is about to be set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#beforepluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin has just been set up on a player.\n *\n * @event    Player#pluginsetup\n * @type     {Plugin~PluginEventHash}\n *//**\n * Signals that a plugin has just been set up on a player - by name. The name\n * is the name of the plugin.\n *\n * @event    Player#pluginsetup:$name\n * @type     {Plugin~PluginEventHash}\n *//**\n * @typedef  {Object} Plugin~PluginEventHash\n *\n * @property {string} instance\n *           For basic plugins, the return value of the plugin function. For\n *           advanced plugins, the plugin instance on which the event is fired.\n *\n * @property {string} name\n *           The name of the plugin.\n *\n * @property {string} plugin\n *           For basic plugins, the plugin function. For advanced plugins, the\n *           plugin class/constructor.\n *//**\n * @file extend.js\n * @module extend\n *//**\n * A combination of node inherits and babel's inherits (after transpile).\n * Both work the same but node adds `super_` to the subClass\n * and Bable adds the superClass as __proto__. Both seem useful.\n *\n * @param {Object} subClass\n *        The class to inherit to\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @private\n */var _inherits=function _inherits(subClass,superClass){if(typeof superClass!=='function'&&superClass!==null){throw new TypeError('Super expression must either be null or a function, not '+(typeof superClass==='undefined'?'undefined':_typeof(superClass)));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass){// node\nsubClass.super_=superClass;}};/**\n * Function for subclassing using the same inheritance that\n * videojs uses internally\n *\n * @static\n * @const\n *\n * @param {Object} superClass\n *        The class to inherit from\n *\n * @param {Object} [subClassMethods={}]\n *        The class to inherit to\n *\n * @return {Object}\n *         The new object with subClassMethods that inherited superClass.\n */var extendFn=function extendFn(superClass){var subClassMethods=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var subClass=function subClass(){superClass.apply(this,arguments);};var methods={};if((typeof subClassMethods==='undefined'?'undefined':_typeof(subClassMethods))==='object'){if(subClassMethods.constructor!==Object.prototype.constructor){subClass=subClassMethods.constructor;}methods=subClassMethods;}else if(typeof subClassMethods==='function'){subClass=subClassMethods;}_inherits(subClass,superClass);// Extend subObj's prototype with functions and other properties from props\nfor(var name in methods){if(methods.hasOwnProperty(name)){subClass.prototype[name]=methods[name];}}return subClass;};/**\n * @file video.js\n * @module videojs\n */// Include the built-in techs\n// HTML5 Element Shim for IE8\nif(typeof HTMLVideoElement==='undefined'&&isReal()){document.createElement('video');document.createElement('audio');document.createElement('track');document.createElement('video-js');}/**\n * Doubles as the main function for users to create a player instance and also\n * the main library object.\n * The `videojs` function can be used to initialize or retrieve a player.\n  *\n * @param {string|Element} id\n *        Video element or video element ID\n *\n * @param {Object} [options]\n *        Optional options object for config/settings\n *\n * @param {Component~ReadyCallback} [ready]\n *        Optional ready callback\n *\n * @return {Player}\n *         A player instance\n */function videojs(id,options,ready){var tag=void 0;// Allow for element or ID to be passed in\n// String ID\nif(typeof id==='string'){var players=videojs.getPlayers();// Adjust for jQuery ID syntax\nif(id.indexOf('#')===0){id=id.slice(1);}// If a player instance has already been created for this ID return it.\nif(players[id]){// If options or ready function are passed, warn\nif(options){log$1.warn('Player \"'+id+'\" is already initialised. Options will not be applied.');}if(ready){players[id].ready(ready);}return players[id];}// Otherwise get element for ID\ntag=$('#'+id);// ID is a media element\n}else{tag=id;}// Check for a useable element\n// re: nodeName, could be a box div also\nif(!tag||!tag.nodeName){throw new TypeError('The element or ID supplied is not valid. (videojs)');}// Element may have a player attr referring to an already created player instance.\n// If so return that otherwise set up a new player below\nif(tag.player||Player.players[tag.playerId]){return tag.player||Player.players[tag.playerId];}// Check if element is included in the DOM\nif(isEl(tag)&&!document.body.contains(tag)){log$1.warn('The element supplied is not included in the DOM');}options=options||{};videojs.hooks('beforesetup').forEach(function(hookFunction){var opts=hookFunction(tag,mergeOptions(options));if(!isObject(opts)||Array.isArray(opts)){log$1.error('please return an object in beforesetup hooks');return;}options=mergeOptions(options,opts);});var PlayerComponent=Component.getComponent('Player');// If not, set up a new player\nvar player=new PlayerComponent(tag,options,ready);videojs.hooks('setup').forEach(function(hookFunction){return hookFunction(player);});return player;}/**\n * An Object that contains lifecycle hooks as keys which point to an array\n * of functions that are run when a lifecycle is triggered\n */videojs.hooks_={};/**\n * Get a list of hooks for a specific lifecycle\n * @function videojs.hooks\n *\n * @param {string} type\n *        the lifecyle to get hooks from\n *\n * @param {Function|Function[]} [fn]\n *        Optionally add a hook (or hooks) to the lifecycle that your are getting.\n *\n * @return {Array}\n *         an array of hooks, or an empty array if there are none.\n */videojs.hooks=function(type,fn){videojs.hooks_[type]=videojs.hooks_[type]||[];if(fn){videojs.hooks_[type]=videojs.hooks_[type].concat(fn);}return videojs.hooks_[type];};/**\n * Add a function hook to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */videojs.hook=function(type,fn){videojs.hooks(type,fn);};/**\n * Add a function hook that will only run once to a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle to hook the function to.\n *\n * @param {Function|Function[]}\n *        The function or array of functions to attach.\n */videojs.hookOnce=function(type,fn){videojs.hooks(type,[].concat(fn).map(function(original){var wrapper=function wrapper(){videojs.removeHook(type,wrapper);original.apply(undefined,arguments);};return wrapper;}));};/**\n * Remove a hook from a specific videojs lifecycle.\n *\n * @param {string} type\n *        the lifecycle that the function hooked to\n *\n * @param {Function} fn\n *        The hooked function to remove\n *\n * @return {boolean}\n *         The function that was removed or undef\n */videojs.removeHook=function(type,fn){var index=videojs.hooks(type).indexOf(fn);if(index<=-1){return false;}videojs.hooks_[type]=videojs.hooks_[type].slice();videojs.hooks_[type].splice(index,1);return true;};// Add default styles\nif(window.VIDEOJS_NO_DYNAMIC_STYLE!==true&&isReal()){var style=$('.vjs-styles-defaults');if(!style){style=createStyleElement('vjs-styles-defaults');var head=$('head');if(head){head.insertBefore(style,head.firstChild);}setTextContent(style,'\\n      .video-js {\\n        width: 300px;\\n        height: 150px;\\n      }\\n\\n      .vjs-fluid {\\n        padding-top: 56.25%\\n      }\\n    ');}}// Run Auto-load players\n// You have to wait at least once in case this script is loaded after your\n// video in the DOM (weird behavior only with minified version)\nautoSetupTimeout(1,videojs);/**\n * Current software version. Follows semver.\n *\n * @type {string}\n */videojs.VERSION=version;/**\n * The global options object. These are the settings that take effect\n * if no overrides are specified when the player is created.\n *\n * @type {Object}\n */videojs.options=Player.prototype.options_;/**\n * Get an object with the currently created players, keyed by player ID\n *\n * @return {Object}\n *         The created players\n */videojs.getPlayers=function(){return Player.players;};/**\n * Expose players object.\n *\n * @memberOf videojs\n * @property {Object} players\n */videojs.players=Player.players;/**\n * Get a component class object by name\n *\n * @borrows Component.getComponent as videojs.getComponent\n */videojs.getComponent=Component.getComponent;/**\n * Register a component so it can referred to by name. Used when adding to other\n * components, either through addChild `component.addChild('myComponent')` or through\n * default children options  `{ children: ['myComponent'] }`.\n *\n * > NOTE: You could also just initialize the component before adding.\n * `component.addChild(new MyComponent());`\n *\n * @param {string} name\n *        The class name of the component\n *\n * @param {Component} comp\n *        The component class\n *\n * @return {Component}\n *         The newly registered component\n */videojs.registerComponent=function(name$$1,comp){if(Tech.isTech(comp)){log$1.warn('The '+name$$1+' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');}Component.registerComponent.call(Component,name$$1,comp);};/**\n * Get a Tech class object by name\n *\n * @borrows Tech.getTech as videojs.getTech\n */videojs.getTech=Tech.getTech;/**\n * Register a Tech so it can referred to by name.\n * This is used in the tech order for the player.\n *\n * @borrows Tech.registerTech as videojs.registerTech\n */videojs.registerTech=Tech.registerTech;videojs.use=use;/**\n * A suite of browser and device tests from {@link browser}.\n *\n * @type {Object}\n * @private\n */videojs.browser=browser;/**\n * Whether or not the browser supports touch events. Included for backward\n * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`\n * instead going forward.\n *\n * @deprecated since version 5.0\n * @type {boolean}\n */videojs.TOUCH_ENABLED=TOUCH_ENABLED;/**\n * Subclass an existing class\n * Mimics ES6 subclassing with the `extend` keyword\n *\n * @borrows extend:extendFn as videojs.extend\n */videojs.extend=extendFn;/**\n * Merge two options objects recursively\n * Performs a deep merge like lodash.merge but **only merges plain objects**\n * (not arrays, elements, anything else)\n * Other values will be copied directly from the second object.\n *\n * @borrows merge-options:mergeOptions as videojs.mergeOptions\n */videojs.mergeOptions=mergeOptions;/**\n * Change the context (this) of a function\n *\n * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native\n * `function() {}.bind(newContext);` instead of this.\n *\n * @borrows fn:bind as videojs.bind\n */videojs.bind=bind;/**\n * Register a Video.js plugin.\n *\n * @borrows plugin:registerPlugin as videojs.registerPlugin\n * @method registerPlugin\n *\n * @param  {string} name\n *         The name of the plugin to be registered. Must be a string and\n *         must not match an existing plugin or a method on the `Player`\n *         prototype.\n *\n * @param  {Function} plugin\n *         A sub-class of `Plugin` or a function for basic plugins.\n *\n * @return {Function}\n *         For advanced plugins, a factory function for that plugin. For\n *         basic plugins, a wrapper function that initializes the plugin.\n */videojs.registerPlugin=Plugin.registerPlugin;/**\n * Deprecated method to register a plugin with Video.js\n *\n * @deprecated\n *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead\n *\n * @param {string} name\n *        The plugin name\n *\n * @param {Plugin|Function} plugin\n *         The plugin sub-class or function\n */videojs.plugin=function(name$$1,plugin){log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');return Plugin.registerPlugin(name$$1,plugin);};/**\n * Gets an object containing multiple Video.js plugins.\n *\n * @param  {Array} [names]\n *         If provided, should be an array of plugin names. Defaults to _all_\n *         plugin names.\n *\n * @return {Object|undefined}\n *         An object containing plugin(s) associated with their name(s) or\n *         `undefined` if no matching plugins exist).\n */videojs.getPlugins=Plugin.getPlugins;/**\n * Gets a plugin by name if it exists.\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {Function|undefined}\n *         The plugin (or `undefined`).\n */videojs.getPlugin=Plugin.getPlugin;/**\n * Gets a plugin's version, if available\n *\n * @param  {string} name\n *         The name of a plugin.\n *\n * @return {string}\n *         The plugin's version or an empty string.\n */videojs.getPluginVersion=Plugin.getPluginVersion;/**\n * Adding languages so that they're available to all players.\n * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n *\n * @param {string} code\n *        The language code or dictionary property\n *\n * @param {Object} data\n *        The data values to be translated\n *\n * @return {Object}\n *         The resulting language dictionary object\n */videojs.addLanguage=function(code,data){var _mergeOptions;code=(''+code).toLowerCase();videojs.options.languages=mergeOptions(videojs.options.languages,(_mergeOptions={},_mergeOptions[code]=data,_mergeOptions));return videojs.options.languages[code];};/**\n * Log messages\n *\n * @borrows log:log as videojs.log\n */videojs.log=log$1;/**\n * Creates an emulated TimeRange object.\n *\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRange\n *//**\n * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges\n */videojs.createTimeRange=videojs.createTimeRanges=createTimeRanges;/**\n * Format seconds as a time string, H:MM:SS or M:SS\n * Supplying a guide (in seconds) will force a number of leading zeros\n * to cover the length of the guide\n *\n * @borrows format-time:formatTime as videojs.formatTime\n */videojs.formatTime=formatTime;/**\n * Resolve and parse the elements of a URL\n *\n * @borrows url:parseUrl as videojs.parseUrl\n */videojs.parseUrl=parseUrl;/**\n * Returns whether the url passed is a cross domain request or not.\n *\n * @borrows url:isCrossOrigin as videojs.isCrossOrigin\n */videojs.isCrossOrigin=isCrossOrigin;/**\n * Event target class.\n *\n * @borrows EventTarget as videojs.EventTarget\n */videojs.EventTarget=EventTarget;/**\n * Add an event listener to element\n * It stores the handler function in a separate cache object\n * and adds a generic handler to the element's event,\n * along with a unique id (guid) to the element.\n *\n * @borrows events:on as videojs.on\n */videojs.on=on;/**\n * Trigger a listener only once for an event\n *\n * @borrows events:one as videojs.one\n */videojs.one=one;/**\n * Removes event listeners from an element\n *\n * @borrows events:off as videojs.off\n */videojs.off=off;/**\n * Trigger an event for an element\n *\n * @borrows events:trigger as videojs.trigger\n */videojs.trigger=trigger;/**\n * A cross-browser XMLHttpRequest wrapper. Here's a simple example:\n *\n * @param {Object} options\n *        settings for the request.\n *\n * @return {XMLHttpRequest|XDomainRequest}\n *         The request object.\n *\n * @see https://github.com/Raynos/xhr\n */videojs.xhr=xhr;/**\n * TextTrack class\n *\n * @borrows TextTrack as videojs.TextTrack\n */videojs.TextTrack=TextTrack;/**\n * export the AudioTrack class so that source handlers can create\n * AudioTracks and then add them to the players AudioTrackList\n *\n * @borrows AudioTrack as videojs.AudioTrack\n */videojs.AudioTrack=AudioTrack;/**\n * export the VideoTrack class so that source handlers can create\n * VideoTracks and then add them to the players VideoTrackList\n *\n * @borrows VideoTrack as videojs.VideoTrack\n */videojs.VideoTrack=VideoTrack;/**\n * Determines, via duck typing, whether or not a value is a DOM element.\n *\n * @borrows dom:isEl as videojs.isEl\n * @deprecated Use videojs.dom.isEl() instead\n *//**\n * Determines, via duck typing, whether or not a value is a text node.\n *\n * @borrows dom:isTextNode as videojs.isTextNode\n * @deprecated Use videojs.dom.isTextNode() instead\n *//**\n * Creates an element and applies properties.\n *\n * @borrows dom:createEl as videojs.createEl\n * @deprecated Use videojs.dom.createEl() instead\n *//**\n * Check if an element has a CSS class\n *\n * @borrows dom:hasElClass as videojs.hasClass\n * @deprecated Use videojs.dom.hasClass() instead\n *//**\n * Add a CSS class name to an element\n *\n * @borrows dom:addElClass as videojs.addClass\n * @deprecated Use videojs.dom.addClass() instead\n *//**\n * Remove a CSS class name from an element\n *\n * @borrows dom:removeElClass as videojs.removeClass\n * @deprecated Use videojs.dom.removeClass() instead\n *//**\n * Adds or removes a CSS class name on an element depending on an optional\n * condition or the presence/absence of the class name.\n *\n * @borrows dom:toggleElClass as videojs.toggleClass\n * @deprecated Use videojs.dom.toggleClass() instead\n *//**\n * Apply attributes to an HTML element.\n *\n * @borrows dom:setElAttributes as videojs.setAttribute\n * @deprecated Use videojs.dom.setAttributes() instead\n *//**\n * Get an element's attribute values, as defined on the HTML tag\n * Attributes are not the same as properties. They're defined on the tag\n * or with setAttribute (which shouldn't be used with HTML)\n * This will return true or false for boolean attributes.\n *\n * @borrows dom:getElAttributes as videojs.getAttributes\n * @deprecated Use videojs.dom.getAttributes() instead\n *//**\n * Empties the contents of an element.\n *\n * @borrows dom:emptyEl as videojs.emptyEl\n * @deprecated Use videojs.dom.emptyEl() instead\n *//**\n * Normalizes and appends content to an element.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:appendContents as videojs.appendContet\n * @deprecated Use videojs.dom.appendContent() instead\n *//**\n * Normalizes and inserts content into an element; this is identical to\n * `appendContent()`, except it empties the element first.\n *\n * The content for an element can be passed in multiple types and\n * combinations, whose behavior is as follows:\n *\n * - String\n *   Normalized into a text node.\n *\n * - Element, TextNode\n *   Passed through.\n *\n * - Array\n *   A one-dimensional array of strings, elements, nodes, or functions (which\n *   return single strings, elements, or nodes).\n *\n * - Function\n *   If the sole argument, is expected to produce a string, element,\n *   node, or array.\n *\n * @borrows dom:insertContent as videojs.insertContent\n * @deprecated Use videojs.dom.insertContent() instead\n */['isEl','isTextNode','createEl','hasClass','addClass','removeClass','toggleClass','setAttributes','getAttributes','emptyEl','appendContent','insertContent'].forEach(function(k){videojs[k]=function(){log$1.warn('videojs.'+k+'() is deprecated; use videojs.dom.'+k+'() instead');return Dom[k].apply(null,arguments);};});/**\n * A safe getComputedStyle with an IE8 fallback.\n *\n * This is because in Firefox, if the player is loaded in an iframe with `display:none`,\n * then `getComputedStyle` returns `null`, so, we do a null-check to make sure\n * that the player doesn't break in these cases.\n * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.\n *\n * @borrows computed-style:computedStyle as videojs.computedStyle\n */videojs.computedStyle=computedStyle;/**\n * Export the Dom utilities for use in external plugins\n * and Tech's\n */videojs.dom=Dom;/**\n * Export the Url utilities for use in external plugins\n * and Tech's\n */videojs.url=Url;module.exports=videojs;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdmlkZW8uanNANi42LjBAdmlkZW8uanMvZGlzdC92aWRlby5janMuanM/ZTNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBWaWRlby5qcyA2LjYuMCA8aHR0cDovL3ZpZGVvanMuY29tLz5cbiAqIENvcHlyaWdodCBCcmlnaHRjb3ZlLCBJbmMuIDxodHRwczovL3d3dy5icmlnaHRjb3ZlLmNvbS8+XG4gKiBBdmFpbGFibGUgdW5kZXIgQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjBcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICpcbiAqIEluY2x1ZGVzIHZ0dC5qcyA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvdnR0LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0U+XG4gKi9cblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciB3aW5kb3cgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpKTtcbnZhciBkb2N1bWVudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKSk7XG52YXIgdHNtbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0c21sJykpO1xudmFyIHNhZmVQYXJzZVR1cGxlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3NhZmUtanNvbi1wYXJzZS90dXBsZScpKTtcbnZhciB4aHIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgneGhyJykpO1xudmFyIHZ0dCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd2aWRlb2pzLXZ0dC5qcycpKTtcblxudmFyIHZlcnNpb24gPSBcIjYuNi4wXCI7XG5cbi8qKlxuICogQGZpbGUgYnJvd3Nlci5qc1xuICogQG1vZHVsZSBicm93c2VyXG4gKi9cbnZhciBVU0VSX0FHRU5UID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbnZhciB3ZWJraXRWZXJzaW9uTWFwID0gL0FwcGxlV2ViS2l0XFwvKFtcXGQuXSspL2kuZXhlYyhVU0VSX0FHRU5UKTtcbnZhciBhcHBsZVdlYmtpdFZlcnNpb24gPSB3ZWJraXRWZXJzaW9uTWFwID8gcGFyc2VGbG9hdCh3ZWJraXRWZXJzaW9uTWFwLnBvcCgpKSA6IG51bGw7XG5cbi8qXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJU19JUEFEID0gL2lQYWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xuXG4vLyBUaGUgRmFjZWJvb2sgYXBwJ3MgVUlXZWJWaWV3IGlkZW50aWZpZXMgYXMgYm90aCBhbiBpUGhvbmUgYW5kIGlQYWQsIHNvXG4vLyB0byBpZGVudGlmeSBpUGhvbmVzLCB3ZSBuZWVkIHRvIGV4Y2x1ZGUgaVBhZHMuXG4vLyBodHRwOi8vYXJ0c3kuZ2l0aHViLmlvL2Jsb2cvMjAxMi8xMC8xOC90aGUtcGVyaWxzLW9mLWlvcy11c2VyLWFnZW50LXNuaWZmaW5nL1xudmFyIElTX0lQSE9ORSA9IC9pUGhvbmUvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19JUEFEO1xudmFyIElTX0lQT0QgPSAvaVBvZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSU9TID0gSVNfSVBIT05FIHx8IElTX0lQQUQgfHwgSVNfSVBPRDtcblxudmFyIElPU19WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9PUyAoXFxkKylfL2kpO1xuXG4gIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxudmFyIElTX0FORFJPSUQgPSAvQW5kcm9pZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgQU5EUk9JRF9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGlzIG1hdGNoZXMgQW5kcm9pZCBNYWpvci5NaW5vci5QYXRjaCB2ZXJzaW9uc1xuICAvLyBBTkRST0lEX1ZFUlNJT04gaXMgTWFqb3IuTWlub3IgYXMgYSBOdW1iZXIsIGlmIE1pbm9yIGlzbid0IGF2YWlsYWJsZSwgdGhlbiBvbmx5IE1ham9yIGlzIHJldHVybmVkXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL0FuZHJvaWQgKFxcZCspKD86XFwuKFxcZCspKT8oPzpcXC4oXFxkKykpKi9pKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWFqb3IgPSBtYXRjaFsxXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIG1pbm9yID0gbWF0Y2hbMl0gJiYgcGFyc2VGbG9hdChtYXRjaFsyXSk7XG5cbiAgaWYgKG1ham9yICYmIG1pbm9yKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0gKyAnLicgKyBtYXRjaFsyXSk7XG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcbiAgICByZXR1cm4gbWFqb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG5cbi8vIE9sZCBBbmRyb2lkIGlzIGRlZmluZWQgYXMgVmVyc2lvbiBvbGRlciB0aGFuIDIuMywgYW5kIHJlcXVpcmluZyBhIHdlYmtpdCB2ZXJzaW9uIG9mIHRoZSBhbmRyb2lkIGJyb3dzZXJcbnZhciBJU19PTERfQU5EUk9JRCA9IElTX0FORFJPSUQgJiYgL3dlYmtpdC9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgQU5EUk9JRF9WRVJTSU9OIDwgMi4zO1xudmFyIElTX05BVElWRV9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiBBTkRST0lEX1ZFUlNJT04gPCA1ICYmIGFwcGxlV2Via2l0VmVyc2lvbiA8IDUzNztcblxudmFyIElTX0ZJUkVGT1ggPSAvRmlyZWZveC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfRURHRSA9IC9FZGdlL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19DSFJPTUUgPSAhSVNfRURHRSAmJiAvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xudmFyIElTX0lFOCA9IC9NU0lFXFxzOFxcLjAvLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IC9NU0lFXFxzKFxcZCspXFwuXFxkLy5leGVjKFVTRVJfQUdFTlQpO1xuICB2YXIgdmVyc2lvbiA9IHJlc3VsdCAmJiBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XG5cbiAgaWYgKCF2ZXJzaW9uICYmIC9UcmlkZW50XFwvNy4wL2kudGVzdChVU0VSX0FHRU5UKSAmJiAvcnY6MTEuMC8udGVzdChVU0VSX0FHRU5UKSkge1xuICAgIC8vIElFIDExIGhhcyBhIGRpZmZlcmVudCB1c2VyIGFnZW50IHN0cmluZyB0aGFuIG90aGVyIElFIHZlcnNpb25zXG4gICAgdmVyc2lvbiA9IDExLjA7XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn0oKTtcblxudmFyIElTX1NBRkFSSSA9IC9TYWZhcmkvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19DSFJPTUUgJiYgIUlTX0FORFJPSUQgJiYgIUlTX0VER0U7XG52YXIgSVNfQU5ZX1NBRkFSSSA9IElTX1NBRkFSSSB8fCBJU19JT1M7XG5cbnZhciBUT1VDSF9FTkFCTEVEID0gaXNSZWFsKCkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiB3aW5kb3cuZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG5cbnZhciBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEID0gaXNSZWFsKCkgJiYgJ2JhY2tncm91bmRTaXplJyBpbiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKS5zdHlsZTtcblxudmFyIGJyb3dzZXIgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0SVNfSVBBRDogSVNfSVBBRCxcblx0SVNfSVBIT05FOiBJU19JUEhPTkUsXG5cdElTX0lQT0Q6IElTX0lQT0QsXG5cdElTX0lPUzogSVNfSU9TLFxuXHRJT1NfVkVSU0lPTjogSU9TX1ZFUlNJT04sXG5cdElTX0FORFJPSUQ6IElTX0FORFJPSUQsXG5cdEFORFJPSURfVkVSU0lPTjogQU5EUk9JRF9WRVJTSU9OLFxuXHRJU19PTERfQU5EUk9JRDogSVNfT0xEX0FORFJPSUQsXG5cdElTX05BVElWRV9BTkRST0lEOiBJU19OQVRJVkVfQU5EUk9JRCxcblx0SVNfRklSRUZPWDogSVNfRklSRUZPWCxcblx0SVNfRURHRTogSVNfRURHRSxcblx0SVNfQ0hST01FOiBJU19DSFJPTUUsXG5cdENIUk9NRV9WRVJTSU9OOiBDSFJPTUVfVkVSU0lPTixcblx0SVNfSUU4OiBJU19JRTgsXG5cdElFX1ZFUlNJT046IElFX1ZFUlNJT04sXG5cdElTX1NBRkFSSTogSVNfU0FGQVJJLFxuXHRJU19BTllfU0FGQVJJOiBJU19BTllfU0FGQVJJLFxuXHRUT1VDSF9FTkFCTEVEOiBUT1VDSF9FTkFCTEVELFxuXHRCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEOiBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UgPSBmdW5jdGlvbiAoc3RyaW5ncywgcmF3KSB7XG4gIHN0cmluZ3MucmF3ID0gcmF3O1xuICByZXR1cm4gc3RyaW5ncztcbn07XG5cbi8qKlxuICogQGZpbGUgb2JqLmpzXG4gKiBAbW9kdWxlIG9ialxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpFYWNoQ2FsbGJhY2tcbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleSBmb3IgdGhlIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleS12YWx1ZSBmb3Igb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpSZWR1Y2VDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjY3VtXG4gKiAgICAgICAgVGhlIHZhbHVlIHRoYXQgaXMgYWNjdW11bGF0aW5nIG92ZXIgdGhlIHJlZHVjZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IHRoZSBrZXlzIG9mIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogICAgICAgIFRoZSBPYmplY3QgdG8gZ2V0IHRoZSBrZXlzIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2YgdGhlIGtleXMgZnJvbSB0aGUgb2JqZWN0LiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZVxuICogICAgICAgICBvYmplY3QgcGFzc2VkIGluIHdhcyBpbnZhbGlkIG9yIGhhZCBubyBrZXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBrZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3Qua2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIEFycmF5LWxpa2UgaXRlcmF0aW9uIGZvciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICpcbiAqIEBwYXJhbSB7b2JqOkVhY2hDYWxsYmFja30gZm5cbiAqICAgICAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGtleSBpbiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlYWNoKG9iamVjdCwgZm4pIHtcbiAga2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmbihvYmplY3Rba2V5XSwga2V5KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXJyYXktbGlrZSByZWR1Y2UgZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBPYmplY3QgdGhhdCB5b3Ugd2FudCB0byByZWR1Y2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICAgQSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuIEl0XG4gKiAgICAgICAgIHJlY2VpdmVzIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBhbmQgdGhlIHBlci1pdGVyYXRpb24gdmFsdWUgYW5kIGtleVxuICogICAgICAgICBhcyBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gW2luaXRpYWwgPSAwXVxuICogICAgICAgIFN0YXJ0aW5nIHZhbHVlXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBmaW5hbCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmVkdWNlKG9iamVjdCwgZm4pIHtcbiAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgcmV0dXJuIGtleXMob2JqZWN0KS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBrZXkpIHtcbiAgICByZXR1cm4gZm4oYWNjdW0sIG9iamVjdFtrZXldLCBrZXkpO1xuICB9LCBpbml0aWFsKTtcbn1cblxuLyoqXG4gKiBPYmplY3QuYXNzaWduLXN0eWxlIG9iamVjdCBzaGFsbG93IG1lcmdlL2V4dGVuZC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7T2JqZWN0fSAuLi5zb3VyY2VzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoT2JqZWN0LmFzc2lnbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3RhcmdldF0uY29uY2F0KHNvdXJjZXMpKTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIGFueSBraW5kIC0gaW5jbHVkaW5nIERPTSBub2RlcyxcbiAqIGFycmF5cywgcmVndWxhciBleHByZXNzaW9ucywgZXRjLiBOb3QgZnVuY3Rpb25zLCB0aG91Z2guXG4gKlxuICogVGhpcyBhdm9pZHMgdGhlIGdvdGNoYSB3aGVyZSB1c2luZyBgdHlwZW9mYCBvbiBhIGBudWxsYCB2YWx1ZVxuICogcmVzdWx0cyBpbiBgJ29iamVjdCdgLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgYXBwZWFycyB0byBiZSBhIFwicGxhaW5cIiBvYmplY3QgLSB0aGF0IGlzLCBhXG4gKiBkaXJlY3QgaW5zdGFuY2Ugb2YgYE9iamVjdGAuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vKipcbiAqIEBmaWxlIGxvZy5qc1xuICogQG1vZHVsZSBsb2dcbiAqL1xudmFyIGxvZyA9IHZvaWQgMDtcblxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgbG9nZ2luZyBsZXZlbC5cbnZhciBsZXZlbCA9ICdpbmZvJztcblxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgdGhlIGxvZ2dpbmcgaGlzdG9yeS5cbnZhciBoaXN0b3J5ID0gW107XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlIGFuZCBoaXN0b3J5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIG1lc3NhZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zb2xlIG1ldGhvZCB0byB1c2UuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyZ3NcbiAqICAgICAgICAgVGhlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIG1hdGNoaW5nIGNvbnNvbGUgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtzdHJpbmdpZnldXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIG9ubHkgb2xkIElFcyBzaG91bGQgZ2V0IGNvbnNvbGUgYXJndW1lbnQgc3RyaW5naWZpY2F0aW9uLFxuICogICAgICAgICBidXQgdGhpcyBpcyBleHBvc2VkIGFzIGEgcGFyYW1ldGVyIHRvIGZhY2lsaXRhdGUgdGVzdGluZy5cbiAqL1xudmFyIGxvZ0J5VHlwZSA9IGZ1bmN0aW9uIGxvZ0J5VHlwZSh0eXBlLCBhcmdzKSB7XG4gIHZhciBzdHJpbmdpZnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICEhSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTE7XG5cbiAgdmFyIGx2bCA9IGxvZy5sZXZlbHNbbGV2ZWxdO1xuICB2YXIgbHZsUmVnRXhwID0gbmV3IFJlZ0V4cCgnXignICsgbHZsICsgJykkJyk7XG5cbiAgaWYgKHR5cGUgIT09ICdsb2cnKSB7XG5cbiAgICAvLyBBZGQgdGhlIHR5cGUgdG8gdGhlIGZyb250IG9mIHRoZSBtZXNzYWdlIHdoZW4gaXQncyBub3QgXCJsb2dcIi5cbiAgICBhcmdzLnVuc2hpZnQodHlwZS50b1VwcGVyQ2FzZSgpICsgJzonKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGNsb25lIG9mIHRoZSBhcmdzIGF0IHRoaXMgcG9pbnQgdG8gaGlzdG9yeS5cbiAgaWYgKGhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnB1c2goW10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIC8vIEFkZCBjb25zb2xlIHByZWZpeCBhZnRlciBhZGRpbmcgdG8gaGlzdG9yeS5cbiAgYXJncy51bnNoaWZ0KCdWSURFT0pTOicpO1xuXG4gIC8vIElmIHRoZXJlJ3Mgbm8gY29uc29sZSB0aGVuIGRvbid0IHRyeSB0byBvdXRwdXQgbWVzc2FnZXMsIGJ1dCB0aGV5IHdpbGxcbiAgLy8gc3RpbGwgYmUgc3RvcmVkIGluIGhpc3RvcnkuXG4gIGlmICghd2luZG93LmNvbnNvbGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxuICAvLyBpbiB0aGUgZnVuY3Rpb24gbWFrZXMgaXQgZWFzaWVyIHRvIHRlc3QgY2FzZXMgd2hlcmUgY29uc29sZSBkb2Vzbid0IGV4aXN0XG4gIC8vIHdoZW4gdGhlIG1vZHVsZSBpcyBleGVjdXRlZC5cbiAgdmFyIGZuID0gd2luZG93LmNvbnNvbGVbdHlwZV07XG5cbiAgaWYgKCFmbiAmJiB0eXBlID09PSAnZGVidWcnKSB7XG4gICAgLy8gQ2VydGFpbiBicm93c2VycyBkb24ndCBoYXZlIHN1cHBvcnQgZm9yIGNvbnNvbGUuZGVidWcuIEZvciB0aG9zZSwgd2VcbiAgICAvLyBzaG91bGQgZGVmYXVsdCB0byB0aGUgY2xvc2VzdCBjb21wYXJhYmxlIGxvZy5cbiAgICBmbiA9IHdpbmRvdy5jb25zb2xlLmluZm8gfHwgd2luZG93LmNvbnNvbGUubG9nO1xuICB9XG5cbiAgLy8gQmFpbCBvdXQgaWYgdGhlcmUncyBubyBjb25zb2xlIG9yIGlmIHRoaXMgdHlwZSBpcyBub3QgYWxsb3dlZCBieSB0aGVcbiAgLy8gY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICBpZiAoIWZuIHx8ICFsdmwgfHwgIWx2bFJlZ0V4cC50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSUVzIHByZXZpb3VzIHRvIDExIGxvZyBvYmplY3RzIHVzZWxlc3NseSBhcyBcIltvYmplY3QgT2JqZWN0XVwiOyBzbywgSlNPTmlmeVxuICAvLyBvYmplY3RzIGFuZCBhcnJheXMgZm9yIHRob3NlIGxlc3MtY2FwYWJsZSBicm93c2Vycy5cbiAgaWYgKHN0cmluZ2lmeSkge1xuICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGEpIHx8IEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhc3QgdG8gc3RyaW5nIGJlZm9yZSBqb2luaW5nLCBzbyB3ZSBnZXQgbnVsbCBhbmQgdW5kZWZpbmVkIGV4cGxpY2l0bHlcbiAgICAgIC8vIGluY2x1ZGVkIGluIG91dHB1dCAoYXMgd2Ugd291bGQgaW4gYSBtb2Rlcm4gY29uc29sZSkuXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIC8vIE9sZCBJRSB2ZXJzaW9ucyBkbyBub3QgYWxsb3cgLmFwcGx5KCkgZm9yIGNvbnNvbGUgbWV0aG9kcyAodGhleSBhcmVcbiAgLy8gcmVwb3J0ZWQgYXMgb2JqZWN0cyByYXRoZXIgdGhhbiBmdW5jdGlvbnMpLlxuICBpZiAoIWZuLmFwcGx5KSB7XG4gICAgZm4oYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgZm5bQXJyYXkuaXNBcnJheShhcmdzKSA/ICdhcHBseScgOiAnY2FsbCddKHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIHBsYWluIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcbiAqICAgICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZC5cbiAqL1xubG9nID0gZnVuY3Rpb24gbG9nKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBsb2dCeVR5cGUoJ2xvZycsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcbiAqIGFuZCB0aGUgdmFsdWVzIGFyZSBgfGAtc2VwYXJhdGVkIHN0cmluZ3MgY29udGFpbmluZyBsb2dnaW5nIG1ldGhvZHMgYWxsb3dlZFxuICogaW4gdGhhdCBsb2dnaW5nIGxldmVsLiBUaGVzZSBzdHJpbmdzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxuICpcbiAqIExldmVscyBwcm92aWRlZCBieSB2aWRlby5qcyBhcmU6XG4gKlxuICogLSBgb2ZmYDogTWF0Y2hlcyBubyBjYWxscy4gQW55IHZhbHVlIHRoYXQgY2FuIGJlIGNhc3QgdG8gYGZhbHNlYCB3aWxsIGhhdmVcbiAqICAgdGhpcyBlZmZlY3QuIFRoZSBtb3N0IHJlc3RyaWN0aXZlLlxuICogLSBgYWxsYDogTWF0Y2hlcyBvbmx5IFZpZGVvLmpzLXByb3ZpZGVkIGZ1bmN0aW9ucyAoYGRlYnVnYCwgYGxvZ2AsXG4gKiAgIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCkuXG4gKiAtIGBkZWJ1Z2A6IE1hdGNoZXMgYGxvZy5kZWJ1Z2AsIGBsb2dgLCBgbG9nLndhcm5gLCBhbmQgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKiAtIGBpbmZvYCAoZGVmYXVsdCk6IE1hdGNoZXMgYGxvZ2AsIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCBjYWxscy5cbiAqIC0gYHdhcm5gOiBNYXRjaGVzIGBsb2cud2FybmAgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICogLSBgZXJyb3JgOiBNYXRjaGVzIG9ubHkgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xubG9nLmxldmVscyA9IHtcbiAgYWxsOiAnZGVidWd8bG9nfHdhcm58ZXJyb3InLFxuICBvZmY6ICcnLFxuICBkZWJ1ZzogJ2RlYnVnfGxvZ3x3YXJufGVycm9yJyxcbiAgaW5mbzogJ2xvZ3x3YXJufGVycm9yJyxcbiAgd2FybjogJ3dhcm58ZXJyb3InLFxuICBlcnJvcjogJ2Vycm9yJyxcbiAgREVGQVVMVDogbGV2ZWxcbn07XG5cbi8qKlxuICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLiBJZiBhIHN0cmluZyBtYXRjaGluZyBhIGtleSBmcm9tXG4gKiB7QGxpbmsgbG9nLmxldmVsc30gaXMgcHJvdmlkZWQsIGFjdHMgYXMgYSBzZXR0ZXIuIFJlZ2FyZGxlc3Mgb2YgYXJndW1lbnQsXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBbbHZsXVxuICogICAgICAgICBQYXNzIHRvIHNldCBhIG5ldyBsb2dnaW5nIGxldmVsLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAqL1xubG9nLmxldmVsID0gZnVuY3Rpb24gKGx2bCkge1xuICBpZiAodHlwZW9mIGx2bCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWxvZy5sZXZlbHMuaGFzT3duUHJvcGVydHkobHZsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBsdmwgKyAnXCIgaW4gbm90IGEgdmFsaWQgbG9nIGxldmVsJyk7XG4gICAgfVxuICAgIGxldmVsID0gbHZsO1xuICB9XG4gIHJldHVybiBsZXZlbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGV2ZXJ5dGhpbmcgdGhhdCBoYXMgYmVlbiBsb2dnZWQgdG8gdGhlIGhpc3RvcnkuXG4gKlxuICogVGhpcyBhcnJheSBpcyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGludGVybmFsIGhpc3RvcnkgcmVjb3JkLiBIb3dldmVyLCBpdHNcbiAqIGNvbnRlbnRzIGFyZSBfbm90XyBjbG9uZWQ7IHNvLCBtdXRhdGluZyBvYmplY3RzIGluc2lkZSB0aGlzIGFycmF5IHdpbGxcbiAqIG11dGF0ZSB0aGVtIGluIGhpc3RvcnkuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmxvZy5oaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGlzdG9yeSA/IFtdLmNvbmNhdChoaXN0b3J5KSA6IFtdO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGludGVybmFsIGhpc3RvcnkgdHJhY2tpbmcsIGJ1dCBkb2VzIG5vdCBwcmV2ZW50IGZ1cnRoZXIgaGlzdG9yeVxuICogdHJhY2tpbmcuXG4gKi9cbmxvZy5oaXN0b3J5LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSkge1xuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGhpc3RvcnkgdHJhY2tpbmcgaWYgaXQgaXMgY3VycmVudGx5IGVuYWJsZWQuXG4gKi9cbmxvZy5oaXN0b3J5LmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5ICE9PSBudWxsKSB7XG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIGhpc3RvcnkgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAqL1xubG9nLmhpc3RvcnkuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaGlzdG9yeSA9PT0gbnVsbCkge1xuICAgIGhpc3RvcnkgPSBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBMb2dzIGVycm9yIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmVycm9yYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkW119IGFyZ3NcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhbiBlcnJvclxuICovXG5sb2cuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZXJyb3InLCBhcmdzKTtcbn07XG5cbi8qKlxuICogTG9ncyB3YXJuaW5nIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLndhcm5gLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGEgd2FybmluZy5cbiAqL1xubG9nLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnd2FybicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmRlYnVnYCwgYnV0IG1heSBhbHNvIGFjdCBhcyBhIGNvbXBhcmFibGVcbiAqIGxvZyBpZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGRlYnVnLlxuICovXG5sb2cuZGVidWcgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIGxvZ0J5VHlwZSgnZGVidWcnLCBhcmdzKTtcbn07XG5cbnZhciBsb2ckMSA9IGxvZztcblxuLyoqXG4gKiBAZmlsZSBjb21wdXRlZC1zdHlsZS5qc1xuICogQG1vZHVsZSBjb21wdXRlZC1zdHlsZVxuICovXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgaW4gRmlyZWZveCwgaWYgdGhlIHBsYXllciBpcyBsb2FkZWQgaW4gYW4gaWZyYW1lIHdpdGhcbiAqIGBkaXNwbGF5Om5vbmVgLCB0aGVuIGBnZXRDb21wdXRlZFN0eWxlYCByZXR1cm5zIGBudWxsYCwgc28sIHdlIGRvIGEgbnVsbC1jaGVjayB0b1xuICogbWFrZSBzdXJlICB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBicmVhayBpbiB0aGVzZSBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB5b3Ugd2FudFxuICpcbiAqIEBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWwsIHByb3ApIHtcbiAgaWYgKCFlbCB8fCAhcHJvcCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICByZXR1cm4gY3MgPyBjc1twcm9wXSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIGVsLmN1cnJlbnRTdHlsZVtwcm9wXSB8fCAnJztcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10sIFsnU2V0dGluZyBhdHRyaWJ1dGVzIGluIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgY3JlYXRlRWwoKVxcbiAgICAgICAgICAgICAgICBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIHRoaXJkIGFyZ3VtZW50IGluc3RlYWQuXFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsKHR5cGUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpLiBBdHRlbXB0aW5nIHRvIHNldCAnLCAnIHRvICcsICcuJ10pO1xuXG4vKipcbiAqIEBmaWxlIGRvbS5qc1xuICogQG1vZHVsZSBkb21cbiAqL1xuLyoqXG4gKiBEZXRlY3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgbm9uLWJsYW5rXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICovXG5mdW5jdGlvbiBpc05vbkJsYW5rU3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdChzdHIpO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIHN0cmluZyBoYXMgd2hpdGVzcGFjZS4gVGhpcyBpcyB1c2VkIGJ5XG4gKiBjbGFzcyBtZXRob2RzIHRvIGJlIHJlbGF0aXZlbHkgY29uc2lzdGVudCB3aXRoIHRoZSBjbGFzc0xpc3QgQVBJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqICAgICAgICAgVGhlIHN0cmluZyB0byBjaGVjayBmb3Igd2hpdGVzcGFjZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIHdoaXRlc3BhY2UgaW4gdGhlIHN0cmluZy5cbiAqXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZXaGl0ZXNwYWNlKHN0cikge1xuICBpZiAoL1xccy8udGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBoYXMgaWxsZWdhbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb2R1Y2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIGEgY2xhc3NOYW1lIHdpdGhpbiBhbiBlbGVtZW50cyBjbGFzc05hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgICBUaGUgY2xhc3NOYW1lIHRvIGdlbmVyYXRlIHRoZSBSZWdFeHAgZm9yLlxuICpcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqICAgICAgICAgVGhlIFJlZ0V4cCB0aGF0IHdpbGwgY2hlY2sgZm9yIGEgc3BlY2lmaWMgYGNsYXNzTmFtZWAgaW4gYW4gZWxlbWVudHNcbiAqICAgICAgICAgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjbGFzc1JlZ0V4cChjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKCR8XFxcXHMpJyk7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgY3VycmVudCBET00gaW50ZXJmYWNlIGFwcGVhcnMgdG8gYmUgcmVhbC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1JlYWwoKSB7XG4gIHJldHVybiAoXG5cbiAgICAvLyBCb3RoIGRvY3VtZW50IGFuZCB3aW5kb3cgd2lsbCBuZXZlciBiZSB1bmRlZmluZWQgdGhhbmtzIHRvIGBnbG9iYWxgLlxuICAgIGRvY3VtZW50ID09PSB3aW5kb3cuZG9jdW1lbnQgJiZcblxuICAgIC8vIEluIElFIDwgOSwgRE9NIG1ldGhvZHMgcmV0dXJuIFwib2JqZWN0XCIgYXMgdGhlaXIgdHlwZSwgc28gYWxsIHdlIGNhblxuICAgIC8vIGNvbmZpZGVudGx5IGNoZWNrIGlzIHRoYXQgaXQgZXhpc3RzLlxuICAgIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIHRoaW5nIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNFbCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgRE9NIGlzIGVtYmVkZGVkIGluIGFuIGlmcmFtZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqL1xuZnVuY3Rpb24gaXNJbkZyYW1lKCkge1xuXG4gIC8vIFdlIG5lZWQgYSB0cnkvY2F0Y2ggaGVyZSBiZWNhdXNlIFNhZmFyaSB3aWxsIHRocm93IGVycm9ycyB3aGVuIGF0dGVtcHRpbmdcbiAgLy8gdG8gZ2V0IGVpdGhlciBgcGFyZW50YCBvciBgc2VsZmBcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LnBhcmVudCAhPT0gd2luZG93LnNlbGY7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgZnVuY3Rpb25zIHRvIHF1ZXJ5IHRoZSBET00gdXNpbmcgYSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogICAgICAgICBUaGUgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcXVlcnkgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqICAgICAgICAgVGhlIHF1ZXJ5IG1ldGhvZFxuICovXG5mdW5jdGlvbiBjcmVhdGVRdWVyaWVyKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc05vbkJsYW5rU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50W21ldGhvZF0obnVsbCk7XG4gICAgfVxuICAgIGlmIChpc05vbkJsYW5rU3RyaW5nKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgY3R4ID0gaXNFbChjb250ZXh0KSA/IGNvbnRleHQgOiBkb2N1bWVudDtcblxuICAgIHJldHVybiBjdHhbbWV0aG9kXSAmJiBjdHhbbWV0aG9kXShzZWxlY3Rvcik7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lPSdkaXYnXVxuICogICAgICAgICBOYW1lIG9mIHRhZyB0byBiZSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBwcm9wZXJ0aWVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICogICAgICAgICBFbGVtZW50IGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBbY29udGVudF1cbiAqICAgICAgICAgQ29udGVudHMgZm9yIHRoZSBlbGVtZW50IChzZWU6IHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH0pXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gIHZhciB0YWdOYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBjb250ZW50ID0gYXJndW1lbnRzWzNdO1xuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgdmFsID0gcHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAvLyBTZWUgIzIxNzZcbiAgICAvLyBXZSBvcmlnaW5hbGx5IHdlcmUgYWNjZXB0aW5nIGJvdGggcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcyBpbiB0aGVcbiAgICAvLyBzYW1lIG9iamVjdCwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHNvIHdlbGwuXG4gICAgaWYgKHByb3BOYW1lLmluZGV4T2YoJ2FyaWEtJykgIT09IC0xIHx8IHByb3BOYW1lID09PSAncm9sZScgfHwgcHJvcE5hbWUgPT09ICd0eXBlJykge1xuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCwgcHJvcE5hbWUsIHZhbCkpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xuXG4gICAgICAvLyBIYW5kbGUgdGV4dENvbnRlbnQgc2luY2UgaXQncyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmUgYW5kIHdlIGhhdmUgYVxuICAgICAgLy8gbWV0aG9kIGZvciBpdC5cbiAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICB0ZXh0Q29udGVudChlbCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxbcHJvcE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHRleHQgaW50byBhbiBlbGVtZW50LCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIGNvbnRlbnRzIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IGludG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogICAgICAgIFRoZSB0ZXh0IGNvbnRlbnQgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYWRkZWQgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiB0ZXh0Q29udGVudChlbCwgdGV4dCkge1xuICBpZiAodHlwZW9mIGVsLnRleHRDb250ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGVsLmlubmVyVGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBhcyB0aGUgZmlyc3QgY2hpbGQgbm9kZSBvZiBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZFxuICogICAgICAgIEVsZW1lbnQgdG8gaW5zZXJ0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBjaGlsZCBpbnRvXG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUbyhjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xuICogICAgICAgIENsYXNzIG5hbWUgdG8gY2hlY2sgZm9yXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBlbGVtZW50IGhhZCB0aGUgY2xhc3NcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiBgY2xhc3NUb0NoZWNrYCBoYXMgd2hpdGUgc3BhY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9DaGVjaykge1xuICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvQ2hlY2spO1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NUb0NoZWNrKTtcbiAgfVxuICByZXR1cm4gY2xhc3NSZWdFeHAoY2xhc3NUb0NoZWNrKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBhZGQgY2xhc3MgbmFtZSB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0FkZFxuICogICAgICAgIENsYXNzIG5hbWUgdG8gYWRkLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBkb20gZWxlbWVudCB3aXRoIHRoZSBhZGRlZCBjbGFzcyBuYW1lLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc1RvQWRkKTtcblxuICAgIC8vIERvbid0IG5lZWQgdG8gYHRocm93SWZXaGl0ZXNwYWNlYCBoZXJlIGJlY2F1c2UgYGhhc0VsQ2xhc3NgIHdpbGwgZG8gaXRcbiAgICAvLyBpbiB0aGUgY2FzZSBvZiBjbGFzc0xpc3Qgbm90IGJlaW5nIHN1cHBvcnRlZC5cbiAgfSBlbHNlIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IChlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzVG9BZGQpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gcmVtb3ZlIGEgY2xhc3MgbmFtZSBmcm9tLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9SZW1vdmUpIHtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93SWZXaGl0ZXNwYWNlKGNsYXNzVG9SZW1vdmUpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjICE9PSBjbGFzc1RvUmVtb3ZlO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFRoZSBjYWxsYmFjayBkZWZpbml0aW9uIGZvciB0b2dnbGVFbENsYXNzLlxuICpcbiAqIEBjYWxsYmFjayBEb21+UHJlZGljYXRlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCBvZiB0aGUgQ29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGBjbGFzc05hbWVgIHRoYXQgd2FudHMgdG8gYmUgdG9nZ2xlZFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICogICAgICAgICAtIElmIHRydWUgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCBhZGRlZCB0byBgZWxlbWVudGAuXG4gKiAgICAgICAgIC0gSWYgZmFsc2UgdGhlIGBjbGFzc1RvVG9nZ2xlYCB3aWxsIGdldCByZW1vdmVkIGZyb20gYGVsZW1lbnRgLlxuICogICAgICAgICAtIElmIHVuZGVmaW5lZCB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgaWdub3JlZFxuICovXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byB0b2dnbGUgYSBjbGFzcyBuYW1lIG9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXG4gKiAgICAgICAgVGhlIGNsYXNzIHRoYXQgc2hvdWxkIGJlIHRvZ2dsZWRcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW58UHJlZGljYXRlQ2FsbGJhY2t9IFtwcmVkaWNhdGVdXG4gKiAgICAgICAgU2VlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHtAbGluayBEb21+UHJlZGljYXRlQ2FsbGJhY2t9XG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhIGNsYXNzIHRoYXQgaGFzIGJlZW4gdG9nZ2xlZC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XG5cbiAgLy8gVGhpcyBDQU5OT1QgdXNlIGBjbGFzc0xpc3RgIGludGVybmFsbHkgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICAvLyBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoZSBgY2xhc3NMaXN0LnRvZ2dsZSgpYCBtZXRob2QhIFdoaWNoIGlzIGZpbmUgYmVjYXVzZVxuICAvLyBgY2xhc3NMaXN0YCB3aWxsIGJlIHVzZWQgYnkgdGhlIGFkZC9yZW1vdmUgZnVuY3Rpb25zLlxuICB2YXIgaGFzID0gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG5cbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcHJlZGljYXRlID0gIWhhcztcbiAgfVxuXG4gIC8vIElmIHRoZSBuZWNlc3NhcnkgY2xhc3Mgb3BlcmF0aW9uIG1hdGNoZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlXG4gIC8vIGVsZW1lbnQsIG5vIGFjdGlvbiBpcyByZXF1aXJlZC5cbiAgaWYgKHByZWRpY2F0ZSA9PT0gaGFzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZSkge1xuICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGF0dHJpYnV0ZXMgdG8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICogICAgICAgIEF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbCwgYXR0cmlidXRlcykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcblxuICAgIGlmIChhdHRyVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0clZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUgPT09IHRydWUgPyAnJyA6IGF0dHJWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhZ1xuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgdGFnIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBbGwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyh0YWcpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIC8vIGtub3duIGJvb2xlYW4gYXR0cmlidXRlc1xuICAvLyB3ZSBjYW4gY2hlY2sgZm9yIG1hdGNoaW5nIGJvb2xlYW4gcHJvcGVydGllcywgYnV0IG9sZGVyIGJyb3dzZXJzXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXG4gIHZhciBrbm93bkJvb2xlYW5zID0gJywnICsgJ2F1dG9wbGF5LGNvbnRyb2xzLHBsYXlzaW5saW5lLGxvb3AsbXV0ZWQsZGVmYXVsdCxkZWZhdWx0TXV0ZWQnICsgJywnO1xuXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBhdHRycyA9IHRhZy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgdmFyIGF0dHJWYWwgPSBhdHRyc1tpXS52YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGtub3duIGJvb2xlYW5zXG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgZWxlbWVudCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHZhbHVlIGZvciB0eXBlb2ZcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcgKyBhdHRyTmFtZSArICcsJykgIT09IC0xKSB7XG4gICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBhbiBpbmNsdWRlZCBib29sZWFuIGF0dHJpYnV0ZSBpcyB0eXBpY2FsbHkgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nICgnJykgd2hpY2ggd291bGQgZXF1YWwgZmFsc2UgaWYgd2UganVzdCBjaGVjayBmb3IgYSBmYWxzZSB2YWx1ZS5cbiAgICAgICAgLy8gd2UgYWxzbyBkb24ndCB3YW50IHN1cHBvcnQgYmFkIGNvZGUgbGlrZSBhdXRvcGxheT0nZmFsc2UnXG4gICAgICAgIGF0dHJWYWwgPSBhdHRyVmFsICE9PSBudWxsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYmpbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBnZXQgdGhlIHZhbHVlIG9mXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgYXR0cmlidXRlKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgQSBET00gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqICAgICAgICBBdHRyaWJ1dGUgdG8gc2V0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG9cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xuICovXG5mdW5jdGlvbiBibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcbiAqL1xuZnVuY3Rpb24gdW5ibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbi8qKlxuICogSWRlbnRpY2FsIHRvIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgZnVuY3Rpb24sIGJ1dCBlbnN1cmVzIHRoYXRcbiAqIHRoZSBtZXRob2QgaXMgc3VwcG9ydGVkIGF0IGFsbCAoaXQgaXMgaW4gYWxsIGJyb3dzZXJzIHdlIGNsYWltIHRvIHN1cHBvcnQpXG4gKiBhbmQgdGhhdCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGJlZm9yZSBjb250aW51aW5nLlxuICpcbiAqIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBhbHNvIHNoaW1zIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBwcm92aWRlZCBieSBzb21lXG4gKiBvbGRlciBicm93c2VycyAobmFtZWx5LCBJRTgpLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhZGRpbmcgcHJvcGVydGllcyB0byBhXG4gKiBgQ2xpZW50UmVjdGAvYERPTVJlY3RgIG9iamVjdDsgc28sIHdlIHNoYWxsb3ctY29weSBpdCB3aXRoIHRoZSBzdGFuZGFyZFxuICogcHJvcGVydGllcyAoZXhjZXB0IGB4YCBhbmQgYHlgIHdoaWNoIGFyZSBub3Qgd2lkZWx5IHN1cHBvcnRlZCkuIFRoaXMgaGVscHNcbiAqIGF2b2lkIGltcGxlbWVudGF0aW9ucyB3aGVyZSBrZXlzIGFyZSBub24tZW51bWVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICBFbGVtZW50IHdob3NlIGBDbGllbnRSZWN0YCB3ZSB3YW50IHRvIGNhbGN1bGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICogICAgICAgICBBbHdheXMgcmV0dXJucyBhIHBsYWluXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICBpZiAoZWwgJiYgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnYm90dG9tJywgJ2hlaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChyZWN0W2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVjdFtrXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0LmhlaWdodCkge1xuICAgICAgcmVzdWx0LmhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZShlbCwgJ2hlaWdodCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC53aWR0aCkge1xuICAgICAgcmVzdWx0LndpZHRoID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnd2lkdGgnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBwb3N0aW9uIG9mIGEgRE9NIGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRvbX5Qb3NpdGlvblxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4gKiAgICAgICAgICAgUGl4ZWxzIHRvIHRoZSBsZWZ0XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxuICogICAgICAgICAgIFBpeGVscyBvbiB0b3BcbiAqL1xuXG4vKipcbiAqIE9mZnNldCBMZWZ0LlxuICogZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRlY2huaXF1ZSBmcm9tXG4gKiBKb2huIFJlc2lnXG4gKlxuICogQHNlZSBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvZ2V0Ym91bmRpbmdjbGllbnRyZWN0LWlzLWF3ZXNvbWUvXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgb2Zmc2V0XG4gKlxuICogQHJldHVybiB7bW9kdWxlOmRvbX5Qb3NpdGlvbn1cbiAqICAgICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZmluZFBvc2l0aW9uKGVsKSB7XG4gIHZhciBib3ggPSB2b2lkIDA7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gIHZhciBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgdmFyIGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xuICB2YXIgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcblxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHRvcClcbiAgfTtcbn1cblxuLyoqXG4gKiB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBhIGRvbSBlbGVtZW50IG9yIG1vdXNlIHBvaW50ZXJcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb21+Q29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxuICogICAgICAgICAgIHggY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geVxuICogICAgICAgICAgIHkgY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEdldCBwb2ludGVyIHBvc2l0aW9uIGluIGVsZW1lbnRcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIFRoZSBiYXNlIG9uIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIGJvdHRvbSBsZWZ0IG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IG9uIHdoaWNoIHRvIGdldCB0aGUgcG9pbnRlciBwb3NpdGlvbiBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gKlxuICogQHJldHVybiB7RG9tfkNvb3JkaW5hdGVzfVxuICogICAgICAgICBBIENvb3JkaW5hdGVzIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihlbCwgZXZlbnQpIHtcbiAgdmFyIHBvc2l0aW9uID0ge307XG4gIHZhciBib3ggPSBmaW5kUG9zaXRpb24oZWwpO1xuICB2YXIgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICB2YXIgYm94SCA9IGVsLm9mZnNldEhlaWdodDtcblxuICB2YXIgYm94WSA9IGJveC50b3A7XG4gIHZhciBib3hYID0gYm94LmxlZnQ7XG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICB2YXIgcGFnZVggPSBldmVudC5wYWdlWDtcblxuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHBhZ2VZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gIH1cblxuICBwb3NpdGlvbi55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGJveFkgLSBwYWdlWSArIGJveEgpIC8gYm94SCkpO1xuICBwb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIENoZWNrIGlmIHRoaXMgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGV4dCBub2RlXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBlbXB0eSBjaGlsZHJlbiBmcm9tXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBubyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBlbXB0eUVsKGVsKSB7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgY29udGVudCBmb3IgZXZlbnR1YWwgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAqXG4gKiBUaGlzIGFsbG93cyBhIHdpZGUgcmFuZ2Ugb2YgY29udGVudCBkZWZpbml0aW9uIG1ldGhvZHMsIGJ1dCBwcm90ZWN0c1xuICogZnJvbSBmYWxsaW5nIGludG8gdGhlIHRyYXAgb2Ygc2ltcGx5IHdyaXRpbmcgdG8gYGlubmVySFRNTGAsIHdoaWNoIGlzXG4gKiBhbiBYU1MgY29uY2Vybi5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqICAgICAgICAtIFN0cmluZzogTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICogICAgICAgIC0gRWxlbWVudC9UZXh0Tm9kZTogUGFzc2VkIHRocm91Z2guXG4gKiAgICAgICAgLSBBcnJheTogQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnNcbiAqICAgICAgICAgICh3aGljaCByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKiAgICAgICAgLSBGdW5jdGlvbjogSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgICAgICAgICBub2RlLCBvciBhcnJheSBhcyBkZWZpbmVkIGFib3ZlLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcGFzc2VkIGluIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuXG4gIC8vIEZpcnN0LCBpbnZva2UgY29udGVudCBpZiBpdCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBwcm9kdWNlcyBhbiBhcnJheSxcbiAgLy8gdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KCk7XG4gIH1cblxuICAvLyBOZXh0IHVwLCBub3JtYWxpemUgdG8gYW4gYXJyYXksIHNvIG9uZSBvciBtYW55IGl0ZW1zIGNhbiBiZSBub3JtYWxpemVkLFxuICAvLyBmaWx0ZXJlZCwgYW5kIHJldHVybmVkLlxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAvLyBGaXJzdCwgaW52b2tlIHZhbHVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyB2YWx1ZSxcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0VsKHZhbHVlKSB8fCBpc1RleHROb2RlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH1cbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYXBwZW5kIG5vcm1hbGl6ZWQgY29udGVudCB0by5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFwcGVuZGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ29udGVudChlbCwgY29udGVudCkge1xuICBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgbm9ybWFsaXplZCBjb250ZW50IGludG8uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGluc2VydGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGluc2VydENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFwcGVuZENvbnRlbnQoZW1wdHlFbChlbCksIGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGV2ZW50IHdhcyBhIHNpbmdsZSBsZWZ0IGNsaWNrXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgYSBsZWZ0IGNsaWNrXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgbm90IGEgbGVmdCBjbGlja1xuICovXG5mdW5jdGlvbiBpc1NpbmdsZUxlZnRDbGljayhldmVudCkge1xuICAvLyBOb3RlOiBpZiB5b3UgY3JlYXRlIHNvbWV0aGluZyBkcmFnZ2FibGUsIGJlIHN1cmUgdG9cbiAgLy8gY2FsbCBpdCBvbiBib3RoIGBtb3VzZWRvd25gIGFuZCBgbW91c2Vtb3ZlYCBldmVudCxcbiAgLy8gb3RoZXJ3aXNlIGBtb3VzZWRvd25gIHNob3VsZCBiZSBlbm91Z2ggZm9yIGEgYnV0dG9uXG5cbiAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gdW5kZWZpbmVkICYmIGV2ZW50LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdoeSBkbyB3ZSBuZWVkIGBidXR0dG9uc2AgP1xuICAgIC8vIEJlY2F1c2UsIG1pZGRsZSBtb3VzZSBzb21ldGltZXMgaGF2ZSB0aGlzOlxuICAgIC8vIGUuYnV0dG9uID09PSAwIGFuZCBlLmJ1dHRvbnMgPT09IDRcbiAgICAvLyBGdXJ0aGVybW9yZSwgd2Ugd2FudCB0byBwcmV2ZW50IGNvbWJpbmF0aW9uIGNsaWNrLCBzb21ldGhpbmcgbGlrZVxuICAgIC8vIEhPTEQgbWlkZGxlbW91c2UgdGhlbiBsZWZ0IGNsaWNrLCB0aGF0IHdvdWxkIGJlXG4gICAgLy8gZS5idXR0b24gPT09IDAsIGUuYnV0dG9ucyA9PT0gNVxuICAgIC8vIGp1c3QgYGJ1dHRvbmAgaXMgbm90IGdvbm5hIHdvcmtcblxuICAgIC8vIEFscmlnaHQsIHRoZW4gd2hhdCB0aGlzIGJsb2NrIGRvZXMgP1xuICAgIC8vIHRoaXMgaXMgZm9yIGNocm9tZSBgc2ltdWxhdGUgbW9iaWxlIGRldmljZXNgXG4gICAgLy8gSSB3YW50IHRvIHN1cHBvcnQgdGhpcyBhcyB3ZWxsXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChldmVudC5idXR0b24gPT09IDAgJiYgZXZlbnQuYnV0dG9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVG91Y2ggc2NyZWVuLCBzb21ldGltZXMgb24gc29tZSBzcGVjaWZpYyBkZXZpY2UsIGBidXR0b25zYFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnl0aGluZyAoc2FmYXJpIG9uIGlvcywgYmxhY2tiZXJyeS4uLilcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKElFX1ZFUlNJT04gPT09IDkpIHtcbiAgICAvLyBJZ25vcmUgSUU5XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuYnV0dG9ucyAhPT0gMSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHJlYXNvbiB3ZSBoYXZlIHRob3NlIGlmIGVsc2UgYmxvY2sgYWJvdmVcbiAgICAvLyBpZiBhbnkgc3BlY2lhbCBjYXNlIHdlIGNhbiBjYXRjaCBhbmQgbGV0IGl0IHNsaWRlXG4gICAgLy8gd2UgZG8gaXQgYWJvdmUsIHdoZW4gZ2V0IHRvIGhlcmUsIHRoaXMgZGVmaW5pdGVseVxuICAgIC8vIGlzLW5vdC1sZWZ0LWNsaWNrXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBgc2VsZWN0b3JgIHdpdGhpbiB0aGUgb3B0aW9uYWxcbiAqIGBjb250ZXh0YCBvZiBhbm90aGVyIERPTSBlbGVtZW50IChkZWZhdWx0aW5nIHRvIGBkb2N1bWVudGApLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvcmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAqICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAqICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICogICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGZvdW5kIG9yIG51bGwuXG4gKi9cbnZhciAkID0gY3JlYXRlUXVlcmllcigncXVlcnlTZWxlY3RvcicpO1xuXG4vKipcbiAqIEZpbmRzIGEgYWxsIERPTSBlbGVtZW50cyBtYXRjaGluZyBgc2VsZWN0b3JgIHdpdGhpbiB0aGUgb3B0aW9uYWxcbiAqIGBjb250ZXh0YCBvZiBhbm90aGVyIERPTSBlbGVtZW50IChkZWZhdWx0aW5nIHRvIGBkb2N1bWVudGApLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogICAgICAgICAgIEEgdmFsaWQgQ1NTIHNlbGVjdG9yLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byBgcXVlcnlTZWxlY3RvckFsbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gW2NvbnRleHQ9ZG9jdW1lbnRdXG4gKiAgICAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3JcbiAqICAgICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcbiAqICAgICAgICAgICBhcyBjb250ZXh0LiBJZiBtaXNzaW5nIChvciBubyBlbGVtZW50IG1hdGNoZXMgc2VsZWN0b3IpLCBmYWxsc1xuICogICAgICAgICAgIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlTGlzdH1cbiAqICAgICAgICAgQSBlbGVtZW50IGxpc3Qgb2YgZWxlbWVudHMgdGhhdCB3ZXJlIGZvdW5kLiBXaWxsIGJlIGVtcHR5IGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAqXG4gKi9cbnZhciAkJCA9IGNyZWF0ZVF1ZXJpZXIoJ3F1ZXJ5U2VsZWN0b3JBbGwnKTtcblxuXG5cbnZhciBEb20gPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0aXNSZWFsOiBpc1JlYWwsXG5cdGlzRWw6IGlzRWwsXG5cdGlzSW5GcmFtZTogaXNJbkZyYW1lLFxuXHRjcmVhdGVFbDogY3JlYXRlRWwsXG5cdHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcblx0cHJlcGVuZFRvOiBwcmVwZW5kVG8sXG5cdGhhc0NsYXNzOiBoYXNDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdHRvZ2dsZUNsYXNzOiB0b2dnbGVDbGFzcyxcblx0c2V0QXR0cmlidXRlczogc2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlczogZ2V0QXR0cmlidXRlcyxcblx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlLFxuXHRyZW1vdmVBdHRyaWJ1dGU6IHJlbW92ZUF0dHJpYnV0ZSxcblx0YmxvY2tUZXh0U2VsZWN0aW9uOiBibG9ja1RleHRTZWxlY3Rpb24sXG5cdHVuYmxvY2tUZXh0U2VsZWN0aW9uOiB1bmJsb2NrVGV4dFNlbGVjdGlvbixcblx0Z2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG5cdGZpbmRQb3NpdGlvbjogZmluZFBvc2l0aW9uLFxuXHRnZXRQb2ludGVyUG9zaXRpb246IGdldFBvaW50ZXJQb3NpdGlvbixcblx0aXNUZXh0Tm9kZTogaXNUZXh0Tm9kZSxcblx0ZW1wdHlFbDogZW1wdHlFbCxcblx0bm9ybWFsaXplQ29udGVudDogbm9ybWFsaXplQ29udGVudCxcblx0YXBwZW5kQ29udGVudDogYXBwZW5kQ29udGVudCxcblx0aW5zZXJ0Q29udGVudDogaW5zZXJ0Q29udGVudCxcblx0aXNTaW5nbGVMZWZ0Q2xpY2s6IGlzU2luZ2xlTGVmdENsaWNrLFxuXHQkOiAkLFxuXHQkJDogJCRcbn0pO1xuXG4vKipcbiAqIEBmaWxlIGd1aWQuanNcbiAqIEBtb2R1bGUgZ3VpZFxuICovXG5cbi8qKlxuICogVW5pcXVlIElEIGZvciBhbiBlbGVtZW50IG9yIGZ1bmN0aW9uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG52YXIgX2d1aWQgPSAxO1xuXG4vKipcbiAqIEdldCBhIHVuaXF1ZSBhdXRvLWluY3JlbWVudGluZyBJRCBieSBudW1iZXIgdGhhdCBoYXMgbm90IGJlZW4gcmV0dXJuZWQgYmVmb3JlLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgQSBuZXcgdW5pcXVlIElELlxuICovXG5mdW5jdGlvbiBuZXdHVUlEKCkge1xuICByZXR1cm4gX2d1aWQrKztcbn1cblxuLyoqXG4gKiBAZmlsZSBkb20tZGF0YS5qc1xuICogQG1vZHVsZSBkb20tZGF0YVxuICovXG4vKipcbiAqIEVsZW1lbnQgRGF0YSBTdG9yZS5cbiAqXG4gKiBBbGxvd3MgZm9yIGJpbmRpbmcgZGF0YSB0byBhbiBlbGVtZW50IHdpdGhvdXQgcHV0dGluZyBpdCBkaXJlY3RseSBvbiB0aGVcbiAqIGVsZW1lbnQuIEV4LiBFdmVudCBsaXN0ZW5lcnMgYXJlIHN0b3JlZCBoZXJlLlxuICogKGFsc28gZnJvbSBqc25pbmphLmNvbSwgc2xpZ2h0bHkgbW9kaWZpZWQgYW5kIHVwZGF0ZWQgZm9yIGNsb3N1cmUgY29tcGlsZXIpXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbERhdGEgPSB7fTtcblxuLypcbiAqIFVuaXF1ZSBhdHRyaWJ1dGUgbmFtZSB0byBzdG9yZSBhbiBlbGVtZW50J3MgZ3VpZCBpblxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlbElkQXR0ciA9ICd2ZGF0YScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgd2hlcmUgZGF0YSBmb3IgYW4gZWxlbWVudCBpcyBzdG9yZWRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBzdG9yZSBkYXRhIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjYWNoZSBvYmplY3QgZm9yIHRoYXQgZWwgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5mdW5jdGlvbiBnZXREYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBlbFtlbElkQXR0cl0gPSBuZXdHVUlEKCk7XG4gIH1cblxuICBpZiAoIWVsRGF0YVtpZF0pIHtcbiAgICBlbERhdGFbaWRdID0ge307XG4gIH1cblxuICByZXR1cm4gZWxEYXRhW2lkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIENoZWNrIGlmIHRoaXMgZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZWxEYXRhW2lkXSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIERlbGV0ZSBkYXRhIGZvciB0aGUgZWxlbWVudCBmcm9tIHRoZSBjYWNoZSBhbmQgdGhlIGd1aWQgYXR0ciBmcm9tIGdldEVsZW1lbnRCeUlkXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFJlbW92ZSBjYWNoZWQgZGF0YSBmb3IgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiByZW1vdmVEYXRhKGVsKSB7XG4gIHZhciBpZCA9IGVsW2VsSWRBdHRyXTtcblxuICBpZiAoIWlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFsbCBzdG9yZWQgZGF0YVxuICBkZWxldGUgZWxEYXRhW2lkXTtcblxuICAvLyBSZW1vdmUgdGhlIGVsSWRBdHRyIHByb3BlcnR5IGZyb20gdGhlIERPTSBub2RlXG4gIHRyeSB7XG4gICAgZGVsZXRlIGVsW2VsSWRBdHRyXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShlbElkQXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFIGRvZXNuJ3QgYXBwZWFyIHRvIHN1cHBvcnQgcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICBlbFtlbElkQXR0cl0gPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIGV2ZW50cy5qcy4gQW4gRXZlbnQgU3lzdGVtIChKb2huIFJlc2lnIC0gU2VjcmV0cyBvZiBhIEpTIE5pbmphIGh0dHA6Ly9qc25pbmphLmNvbS8pXG4gKiAoT3JpZ2luYWwgYm9vayB2ZXJzaW9uIHdhc24ndCBjb21wbGV0ZWx5IHVzYWJsZSwgc28gZml4ZWQgc29tZSB0aGluZ3MgYW5kIG1hZGUgQ2xvc3VyZSBDb21waWxlciBjb21wYXRpYmxlKVxuICogVGhpcyBzaG91bGQgd29yayB2ZXJ5IHNpbWlsYXJseSB0byBqUXVlcnkncyBldmVudHMsIGhvd2V2ZXIgaXQncyBiYXNlZCBvZmYgdGhlIGJvb2sgdmVyc2lvbiB3aGljaCBpc24ndCBhc1xuICogcm9idXN0IGFzIGpxdWVyeSdzLCBzbyB0aGVyZSdzIHByb2JhYmx5IHNvbWUgZGlmZmVyZW5jZXMuXG4gKlxuICogQG1vZHVsZSBldmVudHNcbiAqL1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBsaXN0ZW5lciBjYWNoZSBhbmQgZGlzcGF0Y2hlcnNcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCB0byBjbGVhbiB1cFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBjbGVhbiB1cFxuICovXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcblxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvZiBhIHBhcnRpY3VsYXIgdHlwZSBpZiB0aGVyZSBhcmUgbm9uZSBsZWZ0XG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xuICAgIC8vIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBudWxsO1xuICAgIC8vIFNldHRpbmcgdG8gbnVsbCB3YXMgY2F1c2luZyBhbiBlcnJvciB3aXRoIGRhdGEuaGFuZGxlcnNcblxuICAgIC8vIFJlbW92ZSB0aGUgbWV0YS1oYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XG4gICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBkYXRhLmRpc3BhdGNoZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9iamVjdCBpZiB0aGVyZSBhcmUgbm8gdHlwZXMgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YS5oYW5kbGVycykubGVuZ3RoIDw9IDApIHtcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVycztcbiAgICBkZWxldGUgZGF0YS5kaXNwYXRjaGVyO1xuICAgIGRlbGV0ZSBkYXRhLmRpc2FibGVkO1xuICB9XG5cbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZGF0YSBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJlbW92ZURhdGEoZWxlbSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb29wcyB0aHJvdWdoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFuZCBjYWxscyB0aGUgcmVxdWVzdGVkIG1ldGhvZCBmb3IgZWFjaCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGV2ZW50IG1ldGhvZCB3ZSB3YW50IHRvIHVzZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXG4gKiAgICAgICAgRXZlbnQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBDYWxsIHRoZSBldmVudCBtZXRob2QgZm9yIGVhY2ggb25lIG9mIHRoZSB0eXBlc1xuICAgIGZuKGVsZW0sIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRml4IGEgbmF0aXZlIGV2ZW50IHRvIGhhdmUgc3RhbmRhcmQgcHJvcGVydHkgdmFsdWVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0IHRvIGZpeC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEZpeGVkIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBpZiBmaXhpbmcgdXAgaXMgbmVlZGVkXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXG4gIC8vIEJ1dCBuYXRpdmUgZXZlbnRzIHJldHVybiB0cnVlIGZvciBzdG9wUHJvcGFnYXRpb24sIGJ1dCBkb24ndCBoYXZlXG4gIC8vIG90aGVyIGV4cGVjdGVkIG1ldGhvZHMgbGlrZSBpc1Byb3BhZ2F0aW9uU3RvcHBlZC4gU2VlbXMgdG8gYmUgYSBwcm9ibGVtXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxuICBpZiAoIWV2ZW50IHx8ICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgIHZhciBvbGQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICBldmVudCA9IHt9O1xuICAgIC8vIENsb25lIHRoZSBvbGQgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGUgdmFsdWVzIGV2ZW50ID0ge307XG4gICAgLy8gSUU4IERvZXNuJ3QgbGlrZSB3aGVuIHlvdSBtZXNzIHdpdGggbmF0aXZlIGV2ZW50IHByb3BlcnRpZXNcbiAgICAvLyBGaXJlZm94IHJldHVybnMgZmFsc2UgZm9yIGV2ZW50Lmhhc093blByb3BlcnR5KCd0eXBlJykgYW5kIG90aGVyIHByb3BzXG4gICAgLy8gIHdoaWNoIG1ha2VzIGNvcHlpbmcgbW9yZSBkaWZmaWN1bHQuXG4gICAgLy8gVE9ETzogUHJvYmFibHkgYmVzdCB0byBjcmVhdGUgYSB3aGl0ZWxpc3Qgb2YgZXZlbnQgcHJvcHNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2xkKSB7XG4gICAgICAvLyBTYWZhcmkgNi4wLjMgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGxheWVyWC9ZXG4gICAgICAvLyBDaHJvbWUgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGtleWJvYXJkRXZlbnQua2V5TG9jYXRpb25cbiAgICAgIC8vIGFuZCB3ZWJraXRNb3ZlbWVudFgvWVxuICAgICAgaWYgKGtleSAhPT0gJ2xheWVyWCcgJiYga2V5ICE9PSAnbGF5ZXJZJyAmJiBrZXkgIT09ICdrZXlMb2NhdGlvbicgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRYJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFknKSB7XG4gICAgICAgIC8vIENocm9tZSAzMisgd2FybnMgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgcmV0dXJuVmFsdWUsIGJ1dFxuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGlmIHByZXZlbnREZWZhdWx0IGlzbid0IHN1cHBvcnRlZCAoSUU4KS5cbiAgICAgICAgaWYgKCEoa2V5ID09PSAncmV0dXJuVmFsdWUnICYmIG9sZC5wcmV2ZW50RGVmYXVsdCkpIHtcbiAgICAgICAgICBldmVudFtrZXldID0gb2xkW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZXZlbnQgb2NjdXJyZWQgb24gdGhpcyBlbGVtZW50XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdoaWNoIG90aGVyIGVsZW1lbnQgdGhlIGV2ZW50IGlzIHJlbGF0ZWQgdG9cbiAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU3RvcCB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBvbGQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBvbGQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIG9sZC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgIH07XG5cbiAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZyBhbmQgZXhlY3V0aW5nIG90aGVyIGhhbmRsZXJzXG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcbiAgICAgICAgb2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgcG9zaXRpb25cbiAgICBpZiAoZXZlbnQuY2xpZW50WCAhPT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIGV2ZW50LnBhZ2VYID0gZXZlbnQuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xuICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUga2V5IHByZXNzZXNcbiAgICBldmVudC53aGljaCA9IGV2ZW50LmNoYXJDb2RlIHx8IGV2ZW50LmtleUNvZGU7XG5cbiAgICAvLyBGaXggYnV0dG9uIGZvciBtb3VzZSBjbGlja3M6XG4gICAgLy8gMCA9PSBsZWZ0OyAxID09IG1pZGRsZTsgMiA9PSByaWdodFxuICAgIGlmIChldmVudC5idXR0b24gIT09IG51bGwgJiYgZXZlbnQuYnV0dG9uICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBkaXNhYmxlZCBiZWNhdXNlIGl0IGRvZXMgbm90IHBhc3MgdmlkZW9qcy1zdGFuZGFyZFxuICAgICAgLy8gYW5kLi4uIHlpa2VzLlxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGV2ZW50LmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiAmIDEgPyAwIDogZXZlbnQuYnV0dG9uICYgNCA/IDEgOiBldmVudC5idXR0b24gJiAyID8gMiA6IDA7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBmaXhlZC11cCBpbnN0YW5jZVxuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogV2hldGhlciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycyBhcmUgc3VwcG9ydGVkXG4gKi9cbnZhciBfc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIF9zdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZGlzcmVnYXJkXG4gIH1cbn0pKCk7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIENocm9tZSBleHBlY3RzIHRvIGJlIHBhc3NpdmVcbiAqL1xudmFyIHBhc3NpdmVFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gV2UgbmVlZCBhIHBsYWNlIHRvIHN0b3JlIGFsbCBvdXIgaGFuZGxlciBkYXRhXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIGRhdGEuaGFuZGxlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghZGF0YS5oYW5kbGVyc1t0eXBlXSkge1xuICAgIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50LCBoYXNoKSB7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbZXZlbnQudHlwZV07XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAvLyBDb3B5IGhhbmRsZXJzIHNvIGlmIGhhbmRsZXJzIGFyZSBhZGRlZC9yZW1vdmVkIGR1cmluZyB0aGUgcHJvY2VzcyBpdCBkb2Vzbid0IHRocm93IGV2ZXJ5dGhpbmcgb2ZmLlxuICAgICAgICB2YXIgaGFuZGxlcnNDb3B5ID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSBoYW5kbGVyc0NvcHkubGVuZ3RoOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGxvZyQxLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3N1cHBvcnRzUGFzc2l2ZSAmJiBwYXNzaXZlRXZlbnRzLmluZGV4T2YodHlwZSkgPiAtMSkge1xuICAgICAgICBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB9XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIE9iamVjdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt0eXBlXVxuICogICAgICAgIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IFtmbl1cbiAqICAgICAgICBTcGVjaWZpYyBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IgYW4gZXZlbnRcbiAqICAgICAgICB0eXBlLlxuICovXG5mdW5jdGlvbiBvZmYoZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXRFbERhdGEgaWYgbm90IG5lZWRlZFxuICBpZiAoIWhhc0RhdGEoZWxlbSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24gcmVtb3ZlVHlwZShlbCwgdCkge1xuICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcbiAgICBfY2xlYW5VcEV2ZW50cyhlbCwgdCk7XG4gIH07XG5cbiAgLy8gQXJlIHdlIHJlbW92aW5nIGFsbCBib3VuZCBldmVudHM/XG4gIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciB0IGluIGRhdGEuaGFuZGxlcnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5oYW5kbGVycyB8fCB7fSwgdCkpIHtcbiAgICAgICAgcmVtb3ZlVHlwZShlbGVtLCB0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1t0eXBlXTtcblxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcbiAgaWYgKCFoYW5kbGVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIG5vIGxpc3RlbmVyIHdhcyBwcm92aWRlZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHR5cGVcbiAgaWYgKCFmbikge1xuICAgIHJlbW92ZVR5cGUoZWxlbSwgdHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UncmUgb25seSByZW1vdmluZyBhIHNpbmdsZSBoYW5kbGVyXG4gIGlmIChmbi5ndWlkKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBoYW5kbGVycy5sZW5ndGg7IG4rKykge1xuICAgICAgaWYgKGhhbmRsZXJzW25dLmd1aWQgPT09IGZuLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsZWFuVXBFdmVudHMoZWxlbSwgdHlwZSk7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fHN0cmluZ30gZXZlbnRcbiAqICAgICAgICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBvZiBgZGVmYXVsdFByZXZlbnRlZGAgaWYgZGVmYXVsdCB3YXMgcHJldmVudGVkXG4gKiAgICAgICAgIC0gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQsIGhhc2gpIHtcbiAgLy8gRmV0Y2hlcyBlbGVtZW50IGRhdGEgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgKGZvciBidWJibGluZykuXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgZGF0YSBvYmplY3QgdG8gY2FjaGUgZm9yIGV2ZXJ5IHBhcmVudCxcbiAgLy8gc28gY2hlY2tpbmcgaGFzRWxEYXRhIGZpcnN0LlxuICB2YXIgZWxlbURhdGEgPSBoYXNEYXRhKGVsZW0pID8gZ2V0RGF0YShlbGVtKSA6IHt9O1xuICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIHx8IGVsZW0ub3duZXJEb2N1bWVudDtcbiAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXG4gIC8vIGhhbmRsZXI7XG5cbiAgLy8gSWYgYW4gZXZlbnQgbmFtZSB3YXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBjcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBpdFxuICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgIGV2ZW50ID0geyB0eXBlOiBldmVudCwgdGFyZ2V0OiBlbGVtIH07XG4gIH1cbiAgLy8gTm9ybWFsaXplcyB0aGUgZXZlbnQgcHJvcGVydGllcy5cbiAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgLy8gSWYgdGhlIHBhc3NlZCBlbGVtZW50IGhhcyBhIGRpc3BhdGNoZXIsIGV4ZWN1dGVzIHRoZSBlc3RhYmxpc2hlZCBoYW5kbGVycy5cbiAgaWYgKGVsZW1EYXRhLmRpc3BhdGNoZXIpIHtcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQsIGhhc2gpO1xuICB9XG5cbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcbiAgLy8gcmVjdXJzaXZlbHkgY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBidWJibGUgdGhlIGV2ZW50IHVwIHRoZSBET00uXG4gIGlmIChwYXJlbnQgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgJiYgZXZlbnQuYnViYmxlcyA9PT0gdHJ1ZSkge1xuICAgIHRyaWdnZXIuY2FsbChudWxsLCBwYXJlbnQsIGV2ZW50LCBoYXNoKTtcblxuICAgIC8vIElmIGF0IHRoZSB0b3Agb2YgdGhlIERPTSwgdHJpZ2dlcnMgdGhlIGRlZmF1bHQgYWN0aW9uIHVubGVzcyBkaXNhYmxlZC5cbiAgfSBlbHNlIGlmICghcGFyZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdmFyIHRhcmdldERhdGEgPSBnZXREYXRhKGV2ZW50LnRhcmdldCk7XG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHRhcmdldCBoYXMgYSBkZWZhdWx0IGFjdGlvbiBmb3IgdGhpcyBldmVudC5cbiAgICBpZiAoZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKSB7XG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlcyBldmVudCBkaXNwYXRjaGluZyBvbiB0aGUgdGFyZ2V0IGFzIHdlIGhhdmUgYWxyZWFkeSBleGVjdXRlZCB0aGUgaGFuZGxlci5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgLy8gRXhlY3V0ZXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgICAgaWYgKHR5cGVvZiBldmVudC50YXJnZXRbZXZlbnQudHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKCk7XG4gICAgICB9XG4gICAgICAvLyBSZS1lbmFibGVzIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluZm9ybSB0aGUgdHJpZ2dlcmVyIGlmIHRoZSBkZWZhdWx0IHdhcyBwcmV2ZW50ZWQgYnkgcmV0dXJuaW5nIGZhbHNlXG4gIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgTmFtZS90eXBlIG9mIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIEV2ZW50IExpc3RlbmVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG9uZShlbGVtLCB0eXBlLCBmbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob25lLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIG9mZihlbGVtLCB0eXBlLCBmdW5jKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIGNvcHkgdGhlIGd1aWQgdG8gdGhlIG5ldyBmdW5jdGlvbiBzbyBpdCBjYW4gcmVtb3ZlZCB1c2luZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24ncyBJRFxuICBmdW5jLmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBuZXdHVUlEKCk7XG4gIG9uKGVsZW0sIHR5cGUsIGZ1bmMpO1xufVxuXG52YXIgRXZlbnRzID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdGZpeEV2ZW50OiBmaXhFdmVudCxcblx0b246IG9uLFxuXHRvZmY6IG9mZixcblx0dHJpZ2dlcjogdHJpZ2dlcixcblx0b25lOiBvbmVcbn0pO1xuXG4vKipcbiAqIEBmaWxlIHNldHVwLmpzIC0gRnVuY3Rpb25zIGZvciBzZXR0aW5nIHVwIGEgcGxheWVyIHdpdGhvdXRcbiAqIHVzZXIgaW50ZXJhY3Rpb24gYmFzZWQgb24gdGhlIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgb2YgdGhlIHZpZGVvIHRhZy5cbiAqXG4gKiBAbW9kdWxlIHNldHVwXG4gKi9cbnZhciBfd2luZG93TG9hZGVkID0gZmFsc2U7XG52YXIgdmlkZW9qcyQyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB1cCBhbnkgdGFncyB0aGF0IGhhdmUgYSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIHdoZW4gdGhlIHBsYXllciBpcyBzdGFydGVkLlxuICovXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24gYXV0b1NldHVwKCkge1xuXG4gIC8vIFByb3RlY3QgYWdhaW5zdCBicmVha2FnZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIGlmICghaXNSZWFsKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPbmUgZGF5LCB3aGVuIHdlIHN0b3Agc3VwcG9ydGluZyBJRTgsIGdvIGJhY2sgdG8gdGhpcywgYnV0IGluIHRoZSBtZWFudGltZS4uLipoYWNrIGhhY2sgaGFjaypcbiAgLy8gdmFyIHZpZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKSk7XG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XG4gIC8vIHZhciBtZWRpYUVscyA9IHZpZHMuY29uY2F0KGF1ZGlvcyk7XG5cbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcFxuICAvLyB0aHJvdWdoIGVhY2ggbGlzdCBvZiBlbGVtZW50cyB0byBidWlsZCB1cCBhIG5ldywgY29tYmluZWQgbGlzdCBvZiBlbGVtZW50cy5cbiAgdmFyIHZpZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcbiAgdmFyIGF1ZGlvcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhdWRpbycpO1xuICB2YXIgZGl2cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd2aWRlby1qcycpO1xuICB2YXIgbWVkaWFFbHMgPSBbXTtcblxuICBpZiAodmlkcyAmJiB2aWRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IHZpZHMubGVuZ3RoOyBpIDwgZTsgaSsrKSB7XG4gICAgICBtZWRpYUVscy5wdXNoKHZpZHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdWRpb3MgJiYgYXVkaW9zLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9lID0gYXVkaW9zLmxlbmd0aDsgX2kgPCBfZTsgX2krKykge1xuICAgICAgbWVkaWFFbHMucHVzaChhdWRpb3NbX2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGl2cyAmJiBkaXZzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfZTIgPSBkaXZzLmxlbmd0aDsgX2kyIDwgX2UyOyBfaTIrKykge1xuICAgICAgbWVkaWFFbHMucHVzaChkaXZzW19pMl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGFueSBtZWRpYSBlbGVtZW50cyBleGlzdFxuICBpZiAobWVkaWFFbHMgJiYgbWVkaWFFbHMubGVuZ3RoID4gMCkge1xuXG4gICAgZm9yICh2YXIgX2kzID0gMCwgX2UzID0gbWVkaWFFbHMubGVuZ3RoOyBfaTMgPCBfZTM7IF9pMysrKSB7XG4gICAgICB2YXIgbWVkaWFFbCA9IG1lZGlhRWxzW19pM107XG5cbiAgICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgZXhpc3RzLCBoYXMgZ2V0QXR0cmlidXRlIGZ1bmMuXG4gICAgICAvLyBJRSBzZWVtcyB0byBjb25zaWRlciB0eXBlb2YgZWwuZ2V0QXR0cmlidXRlID09ICdvYmplY3QnIGluc3RlYWQgb2ZcbiAgICAgIC8vICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAobWVkaWFFbCAmJiBtZWRpYUVsLmdldEF0dHJpYnV0ZSkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cbiAgICAgICAgaWYgKG1lZGlhRWwucGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IG1lZGlhRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNldHVwJyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgYXV0by1zZXR1cCBpZiB0aGV5J3ZlIGFkZGVkIHRoZSBkYXRhLXNldHVwIGF0dHIuXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdmlkZW8uanMgaW5zdGFuY2UuXG4gICAgICAgICAgICB2aWRlb2pzJDIobWVkaWFFbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgZ2V0QXR0cmlidXRlIGlzbid0IGRlZmluZWQsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpZGVvcyB3ZXJlIGZvdW5kLCBzbyBrZWVwIGxvb3BpbmcgdW5sZXNzIHBhZ2UgaXMgZmluaXNoZWQgbG9hZGluZy5cbiAgfSBlbHNlIGlmICghX3dpbmRvd0xvYWRlZCkge1xuICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FpdCB1bnRpbCB0aGUgcGFnZSBpcyBsb2FkZWQgYmVmb3JlIHJ1bm5pbmcgYXV0b1NldHVwLiBUaGlzIHdpbGwgYmUgY2FsbGVkIGluXG4gKiBhdXRvU2V0dXAgaWYgYGhhc0xvYWRlZGAgcmV0dXJucyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdFxuICogICAgICAgIEhvdyBsb25nIHRvIHdhaXQgaW4gbXNcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTp2aWRlb2pzfSBbdmpzXVxuICogICAgICAgIFRoZSB2aWRlb2pzIGxpYnJhcnkgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gYXV0b1NldHVwVGltZW91dCh3YWl0LCB2anMpIHtcbiAgaWYgKHZqcykge1xuICAgIHZpZGVvanMkMiA9IHZqcztcbiAgfVxuXG4gIHdpbmRvdy5zZXRUaW1lb3V0KGF1dG9TZXR1cCwgd2FpdCk7XG59XG5cbmlmIChpc1JlYWwoKSAmJiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gIF93aW5kb3dMb2FkZWQgPSB0cnVlO1xufSBlbHNlIHtcbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgdGhlIGxvYWQgZXZlbnQgb24gd2luZG93LCBhbmQgc2V0IF93aW5kb3dMb2FkZWQgdG8gdHJ1ZS5cbiAgICpcbiAgICogQGxpc3RlbnMgbG9hZFxuICAgKi9cbiAgb25lKHdpbmRvdywgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmaWxlIHN0eWxlc2hlZXQuanNcbiAqIEBtb2R1bGUgc3R5bGVzaGVldFxuICovXG4vKipcbiAqIENyZWF0ZSBhIERPTSBzeWxlIGVsZW1lbnQgZ2l2ZW4gYSBjbGFzc05hbWUgZm9yIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqICAgICAgICBUaGUgY2xhc3NOYW1lIHRvIGFkZCB0byB0aGUgY3JlYXRlZCBzdHlsZSBlbGVtZW50LlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbnZhciBjcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoY2xhc3NOYW1lKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgc3R5bGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8qKlxuICogQWRkIHRleHQgdG8gYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIEVsZW1lbnQgdG8gYWRkIHRleHQgY29udGVudCB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogICAgICAgIFRoZSB0ZXh0IHRvIGFkZCB0byB0aGUgZWxlbWVudC5cbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgaWYgKGVsLnN0eWxlU2hlZXQpIHtcbiAgICBlbC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuICB9IGVsc2Uge1xuICAgIGVsLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgfVxufTtcblxuLyoqXG4gKiBAZmlsZSBmbi5qc1xuICogQG1vZHVsZSBmblxuICovXG4vKipcbiAqIEJpbmQgKGEuay5hIHByb3h5IG9yIENvbnRleHQpLiBBIHNpbXBsZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBjb250ZXh0IG9mIGEgZnVuY3Rpb25cbiAqIEl0IGFsc28gc3RvcmVzIGEgdW5pcXVlIGlkIG9uIHRoZSBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgZWFzaWx5IHJlbW92ZWQgZnJvbSBldmVudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gY29udGV4dFxuICogICAgICAgIFRoZSBvYmplY3QgdG8gYmluZCBhcyBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBib3VuZCB0byBhIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdWlkXVxuICogICAgICAgIEFuIG9wdGlvbmFsIHVuaXF1ZSBJRCBmb3IgdGhlIGZ1bmN0aW9uIHRvIGJlIHNldFxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBUaGUgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBib3VuZCBpbnRvIHRoZSBjb250ZXh0IGdpdmVuXG4gKi9cbnZhciBiaW5kID0gZnVuY3Rpb24gYmluZChjb250ZXh0LCBmbiwgdWlkKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZnVuY3Rpb24gaGFzIGEgdW5pcXVlIElEXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5ldyBmdW5jdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGNvbnRleHRcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQWxsb3cgZm9yIHRoZSBhYmlsaXR5IHRvIGluZGl2aWR1YWxpemUgdGhpcyBmdW5jdGlvblxuICAvLyBOZWVkZWQgaW4gdGhlIGNhc2Ugd2hlcmUgbXVsdGlwbGUgb2JqZWN0cyBtaWdodCBzaGFyZSB0aGUgc2FtZSBwcm90b3R5cGVcbiAgLy8gSUYgYm90aCBpdGVtcyBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbiwgdGhlbiB5b3UgdHJ5IHRvIHJlbW92ZSBqdXN0IG9uZVxuICAvLyBpdCB3aWxsIHJlbW92ZSBib3RoIGJlY2F1c2UgdGhleSBib3RoIGhhdmUgdGhlIHNhbWUgZ3VpZC5cbiAgLy8gd2hlbiB1c2luZyB0aGlzLCB5b3UgbmVlZCB0byB1c2UgdGhlIGJpbmQgbWV0aG9kIHdoZW4geW91IHJlbW92ZSB0aGUgbGlzdGVuZXIgYXMgd2VsbC5cbiAgLy8gY3VycmVudGx5IHVzZWQgaW4gdGV4dCB0cmFja3NcbiAgYm91bmQuZ3VpZCA9IHVpZCA/IHVpZCArICdfJyArIGZuLmd1aWQgOiBmbi5ndWlkO1xuXG4gIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogV3JhcHMgdGhlIGdpdmVuIGZ1bmN0aW9uLCBgZm5gLCB3aXRoIGEgbmV3IGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmbmBcbiAqIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIHRocm90dGxlZC5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgd2FpdFxuICogICAgICAgICBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBieSB3aGljaCB0byB0aHJvdHRsZS5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudmFyIHRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXQpIHtcbiAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xuXG4gIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAobm93IC0gbGFzdCA+PSB3YWl0KSB7XG4gICAgICBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICBsYXN0ID0gbm93O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufTtcblxuLyoqXG4gKiBAZmlsZSBzcmMvanMvZXZlbnQtdGFyZ2V0LmpzXG4gKi9cbi8qKlxuICogYEV2ZW50VGFyZ2V0YCBpcyBhIGNsYXNzIHRoYXQgY2FuIGhhdmUgdGhlIHNhbWUgQVBJIGFzIHRoZSBET00gYEV2ZW50VGFyZ2V0YC4gSXRcbiAqIGFkZHMgc2hvcnRoYW5kIGZ1bmN0aW9ucyB0aGF0IHdyYXAgYXJvdW5kIGxlbmd0aHkgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqIHRoZSBgb25gIGZ1bmN0aW9uIGlzIGEgd3JhcHBlciBhcm91bmQgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEBzZWUgW0V2ZW50VGFyZ2V0IFNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0fVxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKi9cbnZhciBFdmVudFRhcmdldCA9IGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge307XG5cbi8qKlxuICogQSBDdXN0b20gRE9NIGV2ZW50LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50VGFyZ2V0fkV2ZW50XG4gKiBAc2VlIFtQcm9wZXJ0aWVzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnR9XG4gKi9cblxuLyoqXG4gKiBBbGwgZXZlbnQgbGlzdGVuZXJzIHNob3VsZCBmb2xsb3cgdGhlIGZvbGxvd2luZyBmb3JtYXQuXG4gKlxuICogQGNhbGxiYWNrIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICogICAgICAgIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoXVxuICogICAgICAgIGhhc2ggb2YgZGF0YSBzZW50IGR1cmluZyB0aGUgZXZlbnRcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIGV2ZW50IG5hbWVzIGFzIGtleXMgYW5kIGJvb2xlYW5zIGFzIHZhbHVlcy5cbiAqXG4gKiA+IE5PVEU6IElmIGFuIGV2ZW50IG5hbWUgaXMgc2V0IHRvIGEgdHJ1ZSB2YWx1ZSBoZXJlIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfVxuICogICAgICAgICB3aWxsIGhhdmUgZXh0cmEgZnVuY3Rpb25hbGl0eS4gU2VlIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHByb3BlcnR5IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzX1xuICogQHByaXZhdGVcbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge307XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnQgbGlzdGVuZXJgIHRvIGFuIGluc3RhbmNlIG9mIGFuIGBFdmVudFRhcmdldGAuIEFuIGBldmVudCBsaXN0ZW5lcmAgaXMgYVxuICogZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbiBhbiBldmVudCB3aXRoIGEgY2VydGFpbiBuYW1lIGdldHMgdHJpZ2dlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBgRXZlbnRUYXJnZXRgc1xuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFzIGJlZm9yZSBjYWxsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgdmFyIGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgb24odGhpcywgdHlwZSwgZm4pO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCNvbn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I29ufVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbjtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGBldmVudCBsaXN0ZW5lcmAgZm9yIGEgc3BlY2lmaWMgZXZlbnQgZnJvbSBhbiBpbnN0YW5jZSBvZiBgRXZlbnRUYXJnZXRgLlxuICogVGhpcyBtYWtlcyBpdCBzbyB0aGF0IHRoZSBgZXZlbnQgbGlzdGVuZXJgIHdpbGwgbm8gbG9uZ2VyIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIG5hbWVkIGV2ZW50IGhhcHBlbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIG9mZih0aGlzLCB0eXBlLCBmbik7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCNvZmZ9LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCNvZmZ9XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZjtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGFuIGBldmVudCBsaXN0ZW5lcmAgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmx5IG9uY2UuIEFmdGVyIHRoZVxuICogZmlyc3QgdHJpZ2dlciBpdCB3aWxsIGdldCByZW1vdmVkLiBUaGlzIGlzIGxpa2UgYWRkaW5nIGFuIGBldmVudCBsaXN0ZW5lcmBcbiAqIHdpdGgge0BsaW5rIEV2ZW50VGFyZ2V0I29ufSB0aGF0IGNhbGxzIHtAbGluayBFdmVudFRhcmdldCNvZmZ9IG9uIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBldmVudCBuYW1lLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIC8vIFJlbW92ZSB0aGUgYWRkRXZlbnRMaXN0ZW5lciBhbGlhbGluZyBFdmVudHMub25cbiAgLy8gc28gd2UgZG9uJ3QgZ2V0IGludG8gYW4gaW5maW5pdGUgdHlwZSBsb29wXG4gIHZhciBhZWwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307XG4gIG9uZSh0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYXVzZXMgYW4gZXZlbnQgdG8gaGFwcGVuLiBUaGlzIHdpbGwgdGhlbiBjYXVzZSBhbnkgYGV2ZW50IGxpc3RlbmVyc2BcbiAqIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoYXQgZXZlbnQsIHRvIGdldCBjYWxsZWQuIElmIHRoZXJlIGFyZSBubyBgZXZlbnQgbGlzdGVuZXJzYFxuICogZm9yIGFuIGV2ZW50IHRoZW4gbm90aGluZyB3aWxsIGhhcHBlbi5cbiAqXG4gKiBJZiB0aGUgbmFtZSBvZiB0aGUgYEV2ZW50YCB0aGF0IGlzIGJlaW5nIHRyaWdnZXJlZCBpcyBpbiBgRXZlbnRUYXJnZXQuYWxsb3dlZEV2ZW50c19gLlxuICogVHJpZ2dlciB3aWxsIGFsc28gY2FsbCB0aGUgYG9uYCArIGB1cHBlcmNhc2VFdmVudE5hbWVgIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKiAnY2xpY2snIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AsIHNvLCB0cmlnZ2VyIHdpbGwgYXR0ZW1wdCB0byBjYWxsXG4gKiBgb25DbGlja2AgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEV2ZW50VGFyZ2V0fkV2ZW50fE9iamVjdH0gZXZlbnRcbiAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGFuIGBFdmVudGAsIG9yIGFuIG9iamVjdCB3aXRoIGEga2V5IG9mIHR5cGUgc2V0IHRvXG4gKiAgICAgICAgYW4gZXZlbnQgbmFtZS5cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50O1xuXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgZXZlbnQgPSB7IHR5cGU6IHR5cGUgfTtcbiAgfVxuICBldmVudCA9IGZpeEV2ZW50KGV2ZW50KTtcblxuICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzX1t0eXBlXSAmJiB0aGlzWydvbicgKyB0eXBlXSkge1xuICAgIHRoaXNbJ29uJyArIHR5cGVdKGV2ZW50KTtcbiAgfVxuXG4gIHRyaWdnZXIodGhpcywgZXZlbnQpO1xufTtcblxuLyoqXG4gKiBBbiBhbGlhcyBvZiB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnRyaWdnZXI7XG5cbi8qKlxuICogQGZpbGUgbWl4aW5zL2V2ZW50ZWQuanNcbiAqIEBtb2R1bGUgZXZlbnRlZFxuICovXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBoYWQgdGhlIGV2ZW50ZWQgbWl4aW4gYXBwbGllZC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgICBBbiBvYmplY3QgdG8gdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGFwcGVhcnMgdG8gYmUgZXZlbnRlZC5cbiAqL1xudmFyIGlzRXZlbnRlZCA9IGZ1bmN0aW9uIGlzRXZlbnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0IHx8ICEhb2JqZWN0LmV2ZW50QnVzRWxfICYmIFsnb24nLCAnb25lJywgJ29mZicsICd0cmlnZ2VyJ10uZXZlcnkoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtrXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgYSB2YWx1ZSBpcyBhIHZhbGlkIGV2ZW50IHR5cGUgLSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcbiAqICAgICAgICAgVGhlIHR5cGUgdmFsdWUgdG8gdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgdHlwZSBpcyBhIHZhbGlkIGV2ZW50IHR5cGUuXG4gKi9cbnZhciBpc1ZhbGlkRXZlbnRUeXBlID0gZnVuY3Rpb24gaXNWYWxpZEV2ZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gVGhlIHJlZ2V4IGhlcmUgdmVyaWZpZXMgdGhhdCB0aGUgYHR5cGVgIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBub24tXG4gICAgLy8gd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodHlwZSkgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSAmJiAhIXR5cGUubGVuZ3RoXG4gICk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSB0YXJnZXQgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlVGFyZ2V0ID0gZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICghdGFyZ2V0Lm5vZGVOYW1lICYmICFpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQ7IG11c3QgYmUgYSBET00gbm9kZSBvciBldmVudGVkIG9iamVjdC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBldmVudCB0YXJnZXQuIFRocm93cyBpZiBub3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBJZiB0aGUgdHlwZSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBldmVudCB0eXBlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBUaGUgdHlwZSB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKSB7XG4gIGlmICghaXNWYWxpZEV2ZW50VHlwZSh0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB2YWx1ZSB0byBkZXRlcm1pbmUgaWYgaXQgaXMgYSB2YWxpZCBsaXN0ZW5lci4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSBsaXN0ZW5lciBpcyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqICAgICAgICAgVGhlIGxpc3RlbmVyIHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3RlbmVyOyBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGBvbigpYCBvciBgb25lKClgLCB2YWxpZGF0ZXMgdGhlbSwgYW5kXG4gKiBub3JtYWxpemVzIHRoZW0gaW50byBhbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gc2VsZlxuICogICAgICAgICBUaGUgZXZlbnRlZCBvYmplY3Qgb24gd2hpY2ggYG9uKClgIG9yIGBvbmUoKWAgd2FzIGNhbGxlZC4gVGhpc1xuICogICAgICAgICBvYmplY3Qgd2lsbCBiZSBib3VuZCBhcyB0aGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFyZ3NcbiAqICAgICAgICAgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBgb24oKWAgb3IgYG9uZSgpYC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHVzZWZ1bCB2YWx1ZXMgZm9yIGBvbigpYCBvciBgb25lKClgIGNhbGxzLlxuICovXG52YXIgbm9ybWFsaXplTGlzdGVuQXJncyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpc3RlbkFyZ3Moc2VsZiwgYXJncykge1xuXG4gIC8vIElmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGxlc3MgdGhhbiAzLCB0aGUgdGFyZ2V0IGlzIGFsd2F5cyB0aGVcbiAgLy8gZXZlbnRlZCBvYmplY3QgaXRzZWxmLlxuICB2YXIgaXNUYXJnZXRpbmdTZWxmID0gYXJncy5sZW5ndGggPCAzIHx8IGFyZ3NbMF0gPT09IHNlbGYgfHwgYXJnc1swXSA9PT0gc2VsZi5ldmVudEJ1c0VsXztcbiAgdmFyIHRhcmdldCA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XG4gICAgdGFyZ2V0ID0gc2VsZi5ldmVudEJ1c0VsXztcblxuICAgIC8vIERlYWwgd2l0aCBjYXNlcyB3aGVyZSB3ZSBnb3QgMyBhcmd1bWVudHMsIGJ1dCB3ZSBhcmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gdGhlIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cbiAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgYXJncy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHR5cGUgPSBhcmdzWzBdO1xuICAgIGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSBhcmdzWzBdO1xuICAgIHR5cGUgPSBhcmdzWzFdO1xuICAgIGxpc3RlbmVyID0gYXJnc1syXTtcbiAgfVxuXG4gIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG4gIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpO1xuICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBsaXN0ZW5lciA9IGJpbmQoc2VsZiwgbGlzdGVuZXIpO1xuXG4gIHJldHVybiB7IGlzVGFyZ2V0aW5nU2VsZjogaXNUYXJnZXRpbmdTZWxmLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGxpc3RlbmVyIHRvIHRoZSBldmVudCB0eXBlKHMpIG9uIHRoZSB0YXJnZXQsIG5vcm1hbGl6aW5nIGZvclxuICogdGhlIHR5cGUgb2YgdGFyZ2V0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIEEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2RcbiAqICAgICAgICAgVGhlIGV2ZW50IGJpbmRpbmcgbWV0aG9kIHRvIHVzZSAoXCJvblwiIG9yIFwib25lXCIpLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBPbmUgb3IgbW9yZSBldmVudCB0eXBlKHMpLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICAgICAgICBBIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICovXG52YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgbWV0aG9kLCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcbiAgICBFdmVudHNbbWV0aG9kXSh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udGFpbnMgbWV0aG9kcyB0aGF0IHByb3ZpZGUgZXZlbnQgY2FwYWJpbGl0ZXMgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpldmVudGVkfGV2ZW50ZWR9LlxuICpcbiAqIEBtaXhpbiBFdmVudGVkTWl4aW5cbiAqL1xudmFyIEV2ZW50ZWRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgKG9yIGV2ZW50cykgb24gdGhpcyBvYmplY3Qgb3IgYW5vdGhlciBldmVudGVkXG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSB0YXJnZXRPclR5cGVcbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpXG4gICAqICAgICAgICAgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIHdoaWNoIHdpbGxcbiAgICogICAgICAgICBjYXVzZSB0aGUgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBldmVudHMgb24gX3RoYXRfIG9iamVjdC5cbiAgICpcbiAgICogICAgICAgICBJbiBlaXRoZXIgY2FzZSwgdGhlIGxpc3RlbmVyJ3MgYHRoaXNgIHZhbHVlIHdpbGwgYmUgYm91bmQgdG9cbiAgICogICAgICAgICB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSB0eXBlT3JMaXN0ZW5lclxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgc2hvdWxkIGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uJCQxKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBub3JtYWxpemVMaXN0ZW5BcmdzKHRoaXMsIGFyZ3MpLFxuICAgICAgICBpc1RhcmdldGluZ1NlbGYgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5pc1RhcmdldGluZ1NlbGYsXG4gICAgICAgIHRhcmdldCA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLnR5cGUsXG4gICAgICAgIGxpc3RlbmVyID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MubGlzdGVuZXI7XG5cbiAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAvLyBJZiB0aGlzIG9iamVjdCBpcyBsaXN0ZW5pbmcgdG8gYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoIWlzVGFyZ2V0aW5nU2VsZikge1xuXG4gICAgICAvLyBJZiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMub2ZmKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyIGl0XG4gICAgICAvLyB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XG5cbiAgICAgIC8vIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSB0YXJnZXQncyBkaXNwb3NlIGV2ZW50IGFzIHdlbGwuIFRoaXMgZW5zdXJlc1xuICAgICAgLy8gdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGRpc3Bvc2VkIEJFRk9SRSB0aGlzIG9iamVjdCwgd2UgcmVtb3ZlIHRoZVxuICAgICAgLy8gcmVtb3ZhbCBsaXN0ZW5lciB0aGF0IHdhcyBqdXN0IGFkZGVkLiBPdGhlcndpc2UsIHdlIGNyZWF0ZSBhIG1lbW9yeSBsZWFrLlxuICAgICAgdmFyIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UgPSBmdW5jdGlvbiByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMub2ZmKCdkaXNwb3NlJywgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAvLyBpdCB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZS5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcblxuICAgICAgbGlzdGVuKHRoaXMsICdvbicsICdkaXNwb3NlJywgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UpO1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogQWRkIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgKG9yIGV2ZW50cykgb24gdGhpcyBvYmplY3Qgb3IgYW5vdGhlciBldmVudGVkXG4gICAqIG9iamVjdC4gVGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcbiAgICogICAgICAgICB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgIGNhdXNlIHRoZSBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGV2ZW50cyBvbiBfdGhhdF8gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xuICAgKiAgICAgICAgIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbmU6IGZ1bmN0aW9uIG9uZSQkMSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIF9ub3JtYWxpemVMaXN0ZW5BcmdzMiA9IG5vcm1hbGl6ZUxpc3RlbkFyZ3ModGhpcywgYXJncyksXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi5pc1RhcmdldGluZ1NlbGYsXG4gICAgICAgIHRhcmdldCA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50YXJnZXQsXG4gICAgICAgIHR5cGUgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIudHlwZSxcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIubGlzdGVuZXI7XG5cbiAgICAvLyBUYXJnZXRpbmcgdGhpcyBldmVudGVkIG9iamVjdC5cblxuXG4gICAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uZScsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBsYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgbGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5vZmYodGFyZ2V0LCB0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgbGFyZ3MpO1xuICAgICAgfTtcblxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXG4gICAgICAvLyBpdCB1c2luZyB0aGUgSUQgb2YgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLlxuICAgICAgd3JhcHBlci5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogUmVtb3ZlcyBsaXN0ZW5lcihzKSBmcm9tIGV2ZW50KHMpIG9uIGFuIGV2ZW50ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IFt0YXJnZXRPclR5cGVdXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKS5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCBpbiB3aGljaCBjYXNlXG4gICAqICAgICAgICAgQUxMIDMgYXJndW1lbnRzIGFyZSBfcmVxdWlyZWRfLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IFt0eXBlT3JMaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIG1heSBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbjsgb3RoZXJ3aXNlLCBfYWxsXyBsaXN0ZW5lcnMgYm91bmQgdG8gdGhlXG4gICAqICAgICAgICAgZXZlbnQgdHlwZShzKSB3aWxsIGJlIHJlbW92ZWQuXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZiQkMSh0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyLCBsaXN0ZW5lcikge1xuXG4gICAgLy8gVGFyZ2V0aW5nIHRoaXMgZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKCF0YXJnZXRPclR5cGUgfHwgaXNWYWxpZEV2ZW50VHlwZSh0YXJnZXRPclR5cGUpKSB7XG4gICAgICBvZmYodGhpcy5ldmVudEJ1c0VsXywgdGFyZ2V0T3JUeXBlLCB0eXBlT3JMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFRhcmdldGluZyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0T3JUeXBlO1xuICAgICAgdmFyIHR5cGUgPSB0eXBlT3JMaXN0ZW5lcjtcblxuICAgICAgLy8gRmFpbCBmYXN0IGFuZCBpbiBhIG1lYW5pbmdmdWwgd2F5IVxuICAgICAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcbiAgICAgIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpO1xuICAgICAgdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGF0IGxlYXN0IGEgZ3VpZCwgZXZlbiBpZiB0aGUgZnVuY3Rpb24gaGFzbid0IGJlZW4gdXNlZFxuICAgICAgbGlzdGVuZXIgPSBiaW5kKHRoaXMsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBkaXNwb3NlIGxpc3RlbmVyIG9uIHRoaXMgZXZlbnRlZCBvYmplY3QsIHdoaWNoIHdhcyBnaXZlblxuICAgICAgLy8gdGhlIHNhbWUgZ3VpZCBhcyB0aGUgZXZlbnQgbGlzdGVuZXIgaW4gb24oKS5cbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgbGlzdGVuZXIpO1xuXG4gICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSB7XG4gICAgICAgIG9mZih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgb2ZmKHRhcmdldCwgJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2UgaWYgKGlzRXZlbnRlZCh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldC5vZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB0YXJnZXQub2ZmKCdkaXNwb3NlJywgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGaXJlIGFuIGV2ZW50IG9uIHRoaXMgZXZlbnRlZCBvYmplY3QsIGNhdXNpbmcgaXRzIGxpc3RlbmVycyB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgICBBbiBldmVudCB0eXBlIG9yIGFuIG9iamVjdCB3aXRoIGEgdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2hdXG4gICAqICAgICAgICAgIEFuIGFkZGl0aW9uYWwgb2JqZWN0IHRvIHBhc3MgYWxvbmcgdG8gbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2FzIHByZXZlbnRlZC5cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIkJDEoZXZlbnQsIGhhc2gpIHtcbiAgICByZXR1cm4gdHJpZ2dlcih0aGlzLmV2ZW50QnVzRWxfLCBldmVudCwgaGFzaCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGlufEV2ZW50ZWRNaXhpbn0gdG8gYSB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gKiAgICAgICAgIFRoZSBvYmplY3QgdG8gd2hpY2ggdG8gYWRkIGV2ZW50IG1ldGhvZHMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAqICAgICAgICAgT3B0aW9ucyBmb3IgY3VzdG9taXppbmcgdGhlIG1peGluIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuZXZlbnRCdXNLZXldXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIGFkZHMgYSBgZXZlbnRCdXNFbF9gIERPTSBlbGVtZW50IHRvIHRoZSB0YXJnZXQgb2JqZWN0LFxuICogICAgICAgICB3aGljaCBpcyB1c2VkIGFzIGFuIGV2ZW50IGJ1cy4gSWYgdGhlIHRhcmdldCBvYmplY3QgYWxyZWFkeSBoYXMgYVxuICogICAgICAgICBET00gZWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkLCBwYXNzIGl0cyBrZXkgaGVyZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBldmVudGVkKHRhcmdldCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBldmVudEJ1c0tleSA9IG9wdGlvbnMuZXZlbnRCdXNLZXk7XG5cbiAgLy8gU2V0IG9yIGNyZWF0ZSB0aGUgZXZlbnRCdXNFbF8uXG5cbiAgaWYgKGV2ZW50QnVzS2V5KSB7XG4gICAgaWYgKCF0YXJnZXRbZXZlbnRCdXNLZXldLm5vZGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBldmVudEJ1c0tleSBcIicgKyBldmVudEJ1c0tleSArICdcIiBkb2VzIG5vdCByZWZlciB0byBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSB0YXJnZXRbZXZlbnRCdXNLZXldO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IGNyZWF0ZUVsKCdzcGFuJywgeyBjbGFzc05hbWU6ICd2anMtZXZlbnQtYnVzJyB9KTtcbiAgfVxuXG4gIGFzc2lnbih0YXJnZXQsIEV2ZW50ZWRNaXhpbik7XG5cbiAgLy8gV2hlbiBhbnkgZXZlbnRlZCBvYmplY3QgaXMgZGlzcG9zZWQsIGl0IHJlbW92ZXMgYWxsIGl0cyBsaXN0ZW5lcnMuXG4gIHRhcmdldC5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQub2ZmKCk7XG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gbnVsbDtcbiAgICB9LCAwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvc3RhdGVmdWwuanNcbiAqIEBtb2R1bGUgc3RhdGVmdWxcbiAqL1xuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBzdGF0ZWZ1bG5lc3MgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxuICogdG8ge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH0uXG4gKlxuICogQG1peGluIFN0YXRlZnVsTWl4aW5cbiAqL1xudmFyIFN0YXRlZnVsTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEEgaGFzaCBjb250YWluaW5nIGFyYml0cmFyeSBrZXlzIGFuZCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZlxuICAgKiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGU6IHt9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXRlIG9mIGFuIG9iamVjdCBieSBtdXRhdGluZyBpdHNcbiAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluLnN0YXRlfHN0YXRlfSBvYmplY3QgaW4gcGxhY2UuXG4gICAqXG4gICAqIEBmaXJlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fEZ1bmN0aW9ufSBzdGF0ZVVwZGF0ZXNcbiAgICogICAgICAgICAgQSBuZXcgc2V0IG9mIHByb3BlcnRpZXMgdG8gc2hhbGxvdy1tZXJnZSBpbnRvIHRoZSBwbHVnaW4gc3RhdGUuXG4gICAqICAgICAgICAgIENhbiBiZSBhIHBsYWluIG9iamVjdCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZC4gSWYgbm8gY2hhbmdlc1xuICAgKiAgICAgICAgICBvY2N1cnJlZCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZVVwZGF0ZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgdGhlIGBzdGF0ZVVwZGF0ZXNgIHN0YXRlIGFzIGEgZnVuY3Rpb24uXG4gICAgaWYgKHR5cGVvZiBzdGF0ZVVwZGF0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlVXBkYXRlcyA9IHN0YXRlVXBkYXRlcygpO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xuXG4gICAgZWFjaChzdGF0ZVVwZGF0ZXMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG5cbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhbmdlIGlmIHRoZSB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB3aGF0J3MgaW4gdGhlXG4gICAgICAvLyBjdXJyZW50IHN0YXRlLlxuICAgICAgaWYgKF90aGlzLnN0YXRlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgIGNoYW5nZXMgPSBjaGFuZ2VzIHx8IHt9O1xuICAgICAgICBjaGFuZ2VzW2tleV0gPSB7XG4gICAgICAgICAgZnJvbTogX3RoaXMuc3RhdGVba2V5XSxcbiAgICAgICAgICB0bzogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gT25seSB0cmlnZ2VyIFwic3RhdGVjaGFuZ2VcIiBpZiB0aGVyZSB3ZXJlIGNoYW5nZXMgQU5EIHdlIGhhdmUgYSB0cmlnZ2VyXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgYmUgYW5cbiAgICAvLyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoY2hhbmdlcyAmJiBpc0V2ZW50ZWQodGhpcykpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBldmVudCB0cmlnZ2VyZWQgb24gYW4gb2JqZWN0IHRoYXQgaXMgYm90aFxuICAgICAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bHxzdGF0ZWZ1bH0gYW5kIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfVxuICAgICAgICogaW5kaWNhdGluZyB0aGF0IGl0cyBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXG4gICAgICAgKiBAdHlwZSAgICAge09iamVjdH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjaGFuZ2VzXG4gICAgICAgKiAgICAgICAgICAgQSBoYXNoIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNoYW5nZWQgYW5kXG4gICAgICAgKiAgICAgICAgICAgdGhlIHZhbHVlcyB0aGV5IHdlcmUgY2hhbmdlZCBgZnJvbWAgYW5kIGB0b2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIGNoYW5nZXM6IGNoYW5nZXMsXG4gICAgICAgIHR5cGU6ICdzdGF0ZWNoYW5nZWQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbnxTdGF0ZWZ1bE1peGlufSB0byBhIHRhcmdldFxuICogb2JqZWN0LlxuICpcbiAqIElmIHRoZSB0YXJnZXQgb2JqZWN0IGlzIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfSBhbmQgaGFzIGFcbiAqIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCwgdGhhdCBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZVxuICogYHN0YXRlY2hhbmdlZGAgZXZlbnQgb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHRhcmdldFxuICogICAgICAgICAgVGhlIG9iamVjdCB0byBiZSBtYWRlIHN0YXRlZnVsLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3R9IFtkZWZhdWx0U3RhdGVdXG4gKiAgICAgICAgICBBIGRlZmF1bHQgc2V0IG9mIHByb3BlcnRpZXMgdG8gcG9wdWxhdGUgdGhlIG5ld2x5LXN0YXRlZnVsIG9iamVjdCdzXG4gKiAgICAgICAgICBgc3RhdGVgIHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBSZXR1cm5zIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZnVuY3Rpb24gc3RhdGVmdWwodGFyZ2V0LCBkZWZhdWx0U3RhdGUpIHtcbiAgYXNzaWduKHRhcmdldCwgU3RhdGVmdWxNaXhpbik7XG5cbiAgLy8gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBtaXhpbmctaW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIGBzdGF0ZWBcbiAgLy8gYWRkZWQgaW4gdGhhdCBzdGVwLlxuICB0YXJnZXQuc3RhdGUgPSBhc3NpZ24oe30sIHRhcmdldC5zdGF0ZSwgZGVmYXVsdFN0YXRlKTtcblxuICAvLyBBdXRvLWJpbmQgdGhlIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCBpZiBpdCBleGlzdHMuXG4gIGlmICh0eXBlb2YgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0V2ZW50ZWQodGFyZ2V0KSkge1xuICAgIHRhcmdldC5vbignc3RhdGVjaGFuZ2VkJywgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBmaWxlIHRvLXRpdGxlLWNhc2UuanNcbiAqIEBtb2R1bGUgdG8tdGl0bGUtY2FzZVxuICovXG5cbi8qKlxuICogVXBwZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogICAgICAgIFN0cmluZyB0byBiZSB1cHBlcmNhc2VkXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgc3RyaW5nIHdpdGggYW4gdXBwZXJjYXNlZCBmaXJzdCBsZXR0ZXJcbiAqL1xuZnVuY3Rpb24gdG9UaXRsZUNhc2Uoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHR3byBzdHJpbmdzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMVxuICogICAgICAgIFRoZSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIyXG4gKiAgICAgICAgVGhlIHNlY29uZCBzdHJpbmcgdG8gY29tcGFyZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5ncyBhcmUgZXF1YWxcbiAqL1xuZnVuY3Rpb24gdGl0bGVDYXNlRXF1YWxzKHN0cjEsIHN0cjIpIHtcbiAgcmV0dXJuIHRvVGl0bGVDYXNlKHN0cjEpID09PSB0b1RpdGxlQ2FzZShzdHIyKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBtZXJnZS1vcHRpb25zLmpzXG4gKiBAbW9kdWxlIG1lcmdlLW9wdGlvbnNcbiAqL1xuLyoqXG4gKiBEZWVwLW1lcmdlIG9uZSBvciBtb3JlIG9wdGlvbnMgb2JqZWN0cywgcmVjdXJzaXZlbHkgbWVyZ2luZyAqKm9ubHkqKiBwbGFpblxuICogb2JqZWN0IHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtICAge09iamVjdFtdfSBzb3VyY2VzXG4gKiAgICAgICAgICBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlIGludG8gYSBuZXcgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiAgICAgICAgICBBIG5ldyBvYmplY3QgdGhhdCBpcyB0aGUgbWVyZ2VkIHJlc3VsdCBvZiBhbGwgc291cmNlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc291cmNlLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKCFpc1BsYWluKHZhbHVlKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQbGFpbihyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9wdGlvbnMocmVzdWx0W2tleV0sIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQbGF5ZXIgQ29tcG9uZW50IC0gQmFzZSBjbGFzcyBmb3IgYWxsIFVJIG9iamVjdHNcbiAqXG4gKiBAZmlsZSBjb21wb25lbnQuanNcbiAqL1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgVUkgQ29tcG9uZW50cy5cbiAqIENvbXBvbmVudHMgYXJlIFVJIG9iamVjdHMgd2hpY2ggcmVwcmVzZW50IGJvdGggYSBqYXZhc2NyaXB0IG9iamVjdCBhbmQgYW4gZWxlbWVudFxuICogaW4gdGhlIERPTS4gVGhleSBjYW4gYmUgY2hpbGRyZW4gb2Ygb3RoZXIgY29tcG9uZW50cywgYW5kIGNhbiBoYXZlXG4gKiBjaGlsZHJlbiB0aGVtc2VsdmVzLlxuICpcbiAqIENvbXBvbmVudHMgY2FuIGFsc28gdXNlIG1ldGhvZHMgZnJvbSB7QGxpbmsgRXZlbnRUYXJnZXR9XG4gKi9cblxudmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlYWR5LiBEb2VzIG5vdCBoYXZlIGFueVxuICAgKiBwYXJhbXRlcnMgYW5kIGFueSBjYWxsYmFjayB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+UmVhZHlDYWxsYmFja1xuICAgKiBAdGhpcyBDb21wb25lbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmNoaWxkcmVuXVxuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4gb2JqZWN0cyB0byBpbnRpYWxpemUgdGhpcyBjb21wb25lbnQgd2l0aC4gQ2hpbGRyZW4gb2JqZWN0cyBoYXZlXG4gICAqICAgICAgICBhIG5hbWUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbW9yZSB0aGFuIG9uZSBjb21wb25lbnQgb2YgdGhlIHNhbWUgdHlwZSBuZWVkcyB0byBiZVxuICAgKiAgICAgICAgYWRkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIEZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYENvbXBvbmVudGAgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudCk7XG5cblxuICAgIC8vIFRoZSBjb21wb25lbnQgbWlnaHQgYmUgdGhlIHBsYXllciBpdHNlbGYgYW5kIHdlIGNhbid0IHBhc3MgYHRoaXNgIHRvIHN1cGVyXG4gICAgaWYgKCFwbGF5ZXIgJiYgdGhpcy5wbGF5KSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXyA9IHBsYXllcjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgY29weSBvZiBwcm90b3R5cGUub3B0aW9uc18gdG8gcHJvdGVjdCBhZ2FpbnN0IG92ZXJyaWRpbmcgZGVmYXVsdHNcbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIFVwZGF0ZWQgb3B0aW9ucyB3aXRoIHN1cHBsaWVkIG9wdGlvbnNcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvcHRpb25zKTtcblxuICAgIC8vIEdldCBJRCBmcm9tIG9wdGlvbnMgb3Igb3B0aW9ucyBlbGVtZW50IGlmIG9uZSBpcyBzdXBwbGllZFxuICAgIHRoaXMuaWRfID0gb3B0aW9ucy5pZCB8fCBvcHRpb25zLmVsICYmIG9wdGlvbnMuZWwuaWQ7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgbm8gSUQgZnJvbSB0aGUgb3B0aW9ucywgZ2VuZXJhdGUgb25lXG4gICAgaWYgKCF0aGlzLmlkXykge1xuICAgICAgLy8gRG9uJ3QgcmVxdWlyZSB0aGUgcGxheWVyIElEIGZ1bmN0aW9uIGluIHRoZSBjYXNlIG9mIG1vY2sgcGxheWVyc1xuICAgICAgdmFyIGlkID0gcGxheWVyICYmIHBsYXllci5pZCAmJiBwbGF5ZXIuaWQoKSB8fCAnbm9fcGxheWVyJztcblxuICAgICAgdGhpcy5pZF8gPSBpZCArICdfY29tcG9uZW50XycgKyBuZXdHVUlEKCk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaWYgb25lIHdhc24ndCBwcm92aWRlZCBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgIHRoaXMuZWxfID0gb3B0aW9ucy5lbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlRWwgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVsXyA9IHRoaXMuY3JlYXRlRWwoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBldmVudGVkIGlzIGFueXRoaW5nIGV4Y2VwdCBmYWxzZSwgd2Ugd2FudCB0byBtaXhpbiBpbiBldmVudGVkXG4gICAgaWYgKG9wdGlvbnMuZXZlbnRlZCAhPT0gZmFsc2UpIHtcbiAgICAgIC8vIE1ha2UgdGhpcyBhbiBldmVudGVkIG9iamVjdCBhbmQgdXNlIGBlbF9gLCBpZiBhdmFpbGFibGUsIGFzIGl0cyBldmVudCBidXNcbiAgICAgIGV2ZW50ZWQodGhpcywgeyBldmVudEJ1c0tleTogdGhpcy5lbF8gPyAnZWxfJyA6IG51bGwgfSk7XG4gICAgfVxuICAgIHN0YXRlZnVsKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFN0YXRlKTtcblxuICAgIHRoaXMuY2hpbGRyZW5fID0gW107XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IHt9O1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0ge307XG5cbiAgICAvLyBBZGQgYW55IGNoaWxkIGNvbXBvbmVudHMgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmluaXRDaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuaW5pdENoaWxkcmVuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWFkeShyZWFkeSk7XG4gICAgLy8gRG9uJ3Qgd2FudCB0byB0cmlnZ2VyIHJlYWR5IGhlcmUgb3IgaXQgd2lsbCBiZWZvcmUgaW5pdCBpcyBhY3R1YWxseVxuICAgIC8vIGZpbmlzaGVkIGZvciBhbGwgY2hpbGRyZW4gdGhhdCBydW4gdGhpcyBjb25zdHJ1Y3RvclxuXG4gICAgaWYgKG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZW5hYmxlVG91Y2hBY3Rpdml0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBgQ29tcG9uZW50YCBhbmQgYWxsIGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjZGlzcG9zZVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGBDb21wb25lbnRgIGlzIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IENvbXBvbmVudCNkaXNwb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnViYmxlcz1mYWxzZV1cbiAgICAgKiAgICAgICAgICAgc2V0IHRvIGZhbHNlIHNvIHRoYXQgdGhlIGNsb3NlIGV2ZW50IGRvZXMgbm90XG4gICAgICogICAgICAgICAgIGJ1YmJsZSB1cFxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdkaXNwb3NlJywgYnViYmxlczogZmFsc2UgfSk7XG5cbiAgICAvLyBEaXNwb3NlIGFsbCBjaGlsZHJlbi5cbiAgICBpZiAodGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNoaWxkcmVuXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5fW2ldLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBjaGlsZCByZWZlcmVuY2VzXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGRJbmRleF8gPSBudWxsO1xuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmVsXykge1xuICAgICAgLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbiAgICAgIGlmICh0aGlzLmVsXy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVEYXRhKHRoaXMuZWxfKTtcbiAgICAgIHRoaXMuZWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgYWZ0ZXIgZGlzcG9zaW5nIG9mIHRoZSBlbGVtZW50XG4gICAgdGhpcy5wbGF5ZXJfID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoZSBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICogICAgICAgICBUaGUgcGxheWVyIHRoYXQgdGhpcyBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5wbGF5ZXIgPSBmdW5jdGlvbiBwbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXztcbiAgfTtcblxuICAvKipcbiAgICogRGVlcCBtZXJnZSBvZiBvcHRpb25zIG9iamVjdHMgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICogPiBOb3RlOiBXaGVuIGJvdGggYG9iamAgYW5kIGBvcHRpb25zYCBjb250YWluIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBvYmplY3RzLlxuICAgKiAgICAgICAgIFRoZSB0d28gcHJvcGVydGllcyBnZXQgbWVyZ2VkIHVzaW5nIHtAbGluayBtb2R1bGU6bWVyZ2VPcHRpb25zfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgbmV3IG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBIG5ldyBvYmplY3Qgb2YgYHRoaXMub3B0aW9uc19gIGFuZCBgb2JqYCBtZXJnZWQgdG9nZXRoZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uIG9wdGlvbnMob2JqKSB7XG4gICAgbG9nJDEud2FybigndGhpcy5vcHRpb25zKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSBtb3ZlZCB0byB0aGUgY29uc3RydWN0b3IgaW4gNi4wJyk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvYmopO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBgQ29tcG9uZW50YC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lXVxuICAgKiAgICAgICAgRWxlbWVudCdzIERPTSBub2RlIHR5cGUuIGUuZy4gJ2RpdidcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2FsaXplIGEgc3RyaW5nIGdpdmVuIHRoZSBzdHJpbmcgaW4gZW5nbGlzaC5cbiAgICpcbiAgICogSWYgdG9rZW5zIGFyZSBwcm92aWRlZCwgaXQnbGwgdHJ5IGFuZCBydW4gYSBzaW1wbGUgdG9rZW4gcmVwbGFjZW1lbnQgb24gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICogVGhlIHRva2VucyBpdCBsb29va3MgZm9yIGxvb2sgbGlrZSBgezF9YCB3aXRoIHRoZSBpbmRleCBiZWluZyAxLWluZGV4ZWQgaW50byB0aGUgdG9rZW5zIGFycmF5LlxuICAgKlxuICAgKiBJZiBhIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCdsbCB1c2UgdGhhdCBvdmVyIGBzdHJpbmdgLFxuICAgKiBpZiBhIHZhbHVlIGlzbid0IGZvdW5kIGluIHByb3ZpZGVkIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBoYXZlIGEgZGVzY3JpcHRpdmUga2V5IGZvciB0b2tlbiByZXBsYWNlbWVudFxuICAgKiBidXQgaGF2ZSBhIHN1Y2NpbmN0IGxvY2FsaXplZCBzdHJpbmcgYW5kIG5vdCByZXF1aXJlIGBlbi5qc29uYCB0byBiZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQ3VycmVudGx5LCBpdCBpcyB1c2VkIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHRpbWluZy5cbiAgICogYGBganNcbiAgICoge1xuICAgKiAgIFwicHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfVwiOiBcInsxfSBvZiB7Mn1cIlxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBJdCBpcyB0aGVuIHVzZWQgbGlrZSBzbzpcbiAgICogYGBganNcbiAgICogdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uezJ9JyxcbiAgICogICAgICAgICAgICAgICBbdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCksIHRoaXMucGxheWVyXy5kdXJhdGlvbigpXSxcbiAgICogICAgICAgICAgICAgICAnezF9IG9mIHsyfScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hpY2ggb3V0cHV0cyBzb21ldGhpbmcgbGlrZTogYDAxOjIzIG9mIDI0OjU2YC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiAgICAgICAgVGhlIHN0cmluZyB0byBsb2NhbGl6ZSBhbmQgdGhlIGtleSB0byBsb29rdXAgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdG9rZW5zXVxuICAgKiAgICAgICAgSWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgdG9rZW4gcmVwbGFjZW1lbnRzLCBwcm92aWRlIHRoZSB0b2tlbnMgaGVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqICAgICAgICBEZWZhdWx0cyB0byBgc3RyaW5nYC4gQ2FuIGJlIGEgZGVmYXVsdCB2YWx1ZSB0byB1c2UgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqICAgICAgICBpZiB0aGUgbG9va3VwIGtleSBpcyBuZWVkZWQgdG8gYmUgc2VwYXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIHN0cmluZyBvciBpZiBubyBsb2NhbGl6YXRpb24gZXhpc3RzIHRoZSBlbmdsaXNoIHN0cmluZy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUoc3RyaW5nLCB0b2tlbnMpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmc7XG5cbiAgICB2YXIgY29kZSA9IHRoaXMucGxheWVyXy5sYW5ndWFnZSAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UoKTtcbiAgICB2YXIgbGFuZ3VhZ2VzID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcyAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzKCk7XG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tjb2RlXTtcbiAgICB2YXIgcHJpbWFyeUNvZGUgPSBjb2RlICYmIGNvZGUuc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgcHJpbWFyeUxhbmcgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW3ByaW1hcnlDb2RlXTtcblxuICAgIHZhciBsb2NhbGl6ZWRTdHJpbmcgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Vbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbGFuZ3VhZ2Vbc3RyaW5nXTtcbiAgICB9IGVsc2UgaWYgKHByaW1hcnlMYW5nICYmIHByaW1hcnlMYW5nW3N0cmluZ10pIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IHByaW1hcnlMYW5nW3N0cmluZ107XG4gICAgfVxuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbG9jYWxpemVkU3RyaW5nLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgcmV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXQgPSBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxpemVkU3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC4gVGhpcyBpcyB3aGVyZSBjaGlsZHJlbiBnZXQgaW5zZXJ0ZWQuXG4gICAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCByZXR1cm5lZCBpbiB7QGxpbmsgQ29tcG9uZW50I2VsfS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udGVudCBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY29udGVudEVsID0gZnVuY3Rpb24gY29udGVudEVsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbF8gfHwgdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIGBDb21wb25lbnRgcyBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgYENvbXBvbmVudGBcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBuYW1lLiBUaGUgbmFtZSBnZXRzIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBgQ29tcG9uZW50YFxuICAgKiBhbmQgaXMgc2V0IGR1cmluZyByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbmFtZSBvZiB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBUaGUgY2hpbGRyZW5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIHRoZSBjdXJyZW50IGBDb21wb25lbnRgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9dGhpcy5jaGlsZHJlbl8ubGVuZ3RoXVxuICAgKiAgICAgICAgVGhlIGluZGV4IHRvIGF0dGVtcHQgdG8gYWRkIGEgY2hpbGQgaW50by5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmNoaWxkcmVuXy5sZW5ndGg7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdm9pZCAwO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBjb21wb25lbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0b1RpdGxlQ2FzZShjaGlsZCk7XG5cbiAgICAgIHZhciBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIFNldCBuYW1lIHRocm91Z2ggb3B0aW9uc1xuICAgICAgb3B0aW9ucy5uYW1lID0gY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCAmIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbHMgc2V0XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIC5wbGF5ZXJfLCB0aGlzIGlzIGEgcGxheWVyXG4gICAgICB2YXIgQ29tcG9uZW50Q2xhc3MgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNvbXBvbmVudENsYXNzTmFtZSk7XG5cbiAgICAgIGlmICghQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudENsYXNzTmFtZSArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0YSBzdG9yZWQgZGlyZWN0bHkgb24gdGhlIHZpZGVvanMgb2JqZWN0IG1heSBiZVxuICAgICAgLy8gbWlzaWRlbnRpZmllZCBhcyBhIGNvbXBvbmVudCB0byByZXRhaW5cbiAgICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggNC54LiBjaGVjayB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRDbGFzcyh0aGlzLnBsYXllcl8gfHwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IGNoaWxkO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgY29tcG9uZW50Lm5hbWUgJiYgdG9UaXRsZUNhc2UoY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jb250ZW50RWwoKS5jaGlsZHJlbjtcbiAgICAgIHZhciByZWZOb2RlID0gY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbDtcblxuICAgICAgdGhpcy5jb250ZW50RWwoKS5pbnNlcnRCZWZvcmUoY29tcG9uZW50LmVsKCksIHJlZk5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBgQ29tcG9uZW50YCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGxpc3Qgb2YgY2hpbGRyZW4uIEFsc28gcmVtb3Zlc1xuICAgKiB0aGUgY2hpbGQgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgdG8gcmVtb3ZlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjb21wb25lbnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0Q2hpbGQoY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhdGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0gPT09IGNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkRm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50Lm5hbWUoKV0gPSBudWxsO1xuXG4gICAgdmFyIGNvbXBFbCA9IGNvbXBvbmVudC5lbCgpO1xuXG4gICAgaWYgKGNvbXBFbCAmJiBjb21wRWwucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50RWwoKSkge1xuICAgICAgdGhpcy5jb250ZW50RWwoKS5yZW1vdmVDaGlsZChjb21wb25lbnQuZWwoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBgQ29tcG9uZW50YHMgYmFzZWQgdXBvbiBvcHRpb25zLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaW5pdENoaWxkcmVuID0gZnVuY3Rpb24gaW5pdENoaWxkcmVuKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm9wdGlvbnNfLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAvLyBgdGhpc2AgaXMgYHBhcmVudGBcbiAgICAgIHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zXztcblxuICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChjaGlsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgIHZhciBvcHRzID0gY2hpbGQub3B0cztcblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGZvciBjaGlsZHJlbiB0byBiZSBzZXQgYXQgdGhlIHBhcmVudCBvcHRpb25zXG4gICAgICAgIC8vIGUuZy4gdmlkZW9qcyhpZCwgeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB2aWRlb2pzKGlkLCB7IGNoaWxkcmVuOiB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICBpZiAocGFyZW50T3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0cyA9IHBhcmVudE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xuICAgICAgICAvLyBlLmcuIG9wdGlvbnNbJ2NoaWxkcmVuJ11bJ3Bvc3RlckltYWdlJ10gPSBmYWxzZVxuICAgICAgICBpZiAob3B0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIHRvIGJlIHBhc3NlZCBhcyBhIHNpbXBsZSBib29sZWFuIGlmIG5vIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gaXMgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAob3B0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9uc1xuICAgICAgICAvLyB0byBlYWNoIGNvbXBvbmVudCBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgICAvLyBBZGQgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBieSBuYW1lIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2UuXG4gICAgICAgIC8vIElmIHR3byBvZiB0aGUgc2FtZSBjb21wb25lbnQgYXJlIHVzZWQsIGRpZmZlcmVudCBuYW1lcyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgLy8gZm9yIGVhY2hcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYWRkQ2hpbGQobmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gQWxsb3cgZm9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIGRldGFpbHMgdG8gcGFzc2VkIGluIHRoZSBvcHRpb25zXG4gICAgICB2YXIgd29ya2luZ0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgd29ya2luZ0NoaWxkcmVuXG4gICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcbiAgICAgIC8vIGdpdmUgdXMgZXh0cmEgY2hpbGRyZW4gd2UgZG8gbm90IHdhbnQuIFNvLCB3ZSB3YW50IHRvIGZpbHRlciB0aGVtIG91dC5cbiAgICAgIC5jb25jYXQoT2JqZWN0LmtleXModGhpcy5vcHRpb25zXykuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gIXdvcmtpbmdDaGlsZHJlbi5zb21lKGZ1bmN0aW9uICh3Y2hpbGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3B0cyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICBvcHRzID0gY2hpbGRyZW5bbmFtZV0gfHwgX3RoaXMub3B0aW9uc19bbmFtZV0gfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgb3B0cyA9IGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGNoaWxkLm5hbWUgaXNuJ3QgaW4gdGhlIHRlY2hPcmRlciBzaW5jZVxuICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjc3MlxuICAgICAgICB2YXIgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY2hpbGQub3B0cy5jb21wb25lbnRDbGFzcyB8fCB0b1RpdGxlQ2FzZShjaGlsZC5uYW1lKSk7XG5cbiAgICAgICAgcmV0dXJuIGMgJiYgIVRlY2guaXNUZWNoKGMpO1xuICAgICAgfSkuZm9yRWFjaChoYW5kbGVBZGQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBjbGFzcyBuYW1lLiBTaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHN1Yi1jb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBjbGFzcyBuYW1lIGZvciB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQmluZCBhIGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByZWFkeSBzdGF0ZS5cbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG4gICAqIGl0IHdpbGwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBSZXR1cm5zIGl0c2VsZjsgbWV0aG9kIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmICghZm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSB0aGlzLnJlYWR5UXVldWVfIHx8IFtdO1xuICAgICAgdGhpcy5yZWFkeVF1ZXVlXy5wdXNoKGZuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgZm4uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdCBmb3IgY29uc2lzdGVuY3lcbiAgICAgIHRoaXMuc2V0VGltZW91dChmbiwgMSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCB0aGUgcmVhZHkgbGlzdGVuZXJzIGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I3JlYWR5XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlYWR5UXVldWUgPSB0aGlzLnJlYWR5UXVldWVfO1xuXG4gICAgICAvLyBSZXNldCBSZWFkeSBRdWV1ZVxuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IFtdO1xuXG4gICAgICBpZiAocmVhZHlRdWV1ZSAmJiByZWFkeVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVhZHlRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBmb3IgdXNpbmcgZXZlbnQgbGlzdGVuZXJzIGFsc29cbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyByZWFkeS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3JlYWR5XG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknKTtcbiAgICB9LCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICAgKiAgICAgICAgIHRoZSBkb20gZWxlbWVudCB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQgPSBmdW5jdGlvbiAkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqICAgICAgICAgYSBsaXN0IG9mIGRvbSBlbGVtZW50cyB0aGF0IHdlcmUgZm91bmRcbiAgICpcbiAgICogQHNlZSBbSW5mb3JtYXRpb24gb24gQ1NTIFNlbGVjdG9yc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfU3RhcnRlZC9TZWxlY3RvcnMpXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kJCA9IGZ1bmN0aW9uICQkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQkKHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGVudEVsKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCdzIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgYENvbXBvbmVudGAgaGFzIHRoZSBjbGFzcy5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIHRoZSBgQ29tcG9uZW50YCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzc2BcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MkJDEoY2xhc3NUb0NoZWNrKSB7XG4gICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQ2hlY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQWRkXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byBhZGRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MkJDEoY2xhc3NUb0FkZCkge1xuICAgIGFkZENsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQWRkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byByZW1vdmVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MkJDEoY2xhc3NUb1JlbW92ZSkge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvUmVtb3ZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIG9yIHJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgYWRkZWQgd2hlbiB7QGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfSB3b3VsZCByZXR1cm4gZmFsc2UuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgcmVtb3ZlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiB0cnVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAgICogICAgICAgICBUaGUgY2xhc3MgdG8gYWRkIG9yIHJlbW92ZSBiYXNlZCBvbiAoQGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfVxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufERvbX5wcmVkaWNhdGV9IFtwcmVkaWNhdGVdXG4gICAqICAgICAgICAgQW4ge0BsaW5rIERvbX5wcmVkaWNhdGV9IGZ1bmN0aW9uIG9yIGEgYm9vbGVhblxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyQkMShjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgaWYgaXQgaXMgaGlkZGVuIGJ5IHJlbW92aW5nIHRoZVxuICAgKiAndmpzLWhpZGRlbicgY2xhc3MgbmFtZSBmcm9tIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBjdXJyZW50bHkgc2hvd2luZyBieSBhZGRpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuYCBjbGFzcyBuYW1lIHRvIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgaW4gaXRzIHZpc2libGUgc3RhdGUgYnkgYWRkaW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSB0byBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NrU2hvd2luZyA9IGZ1bmN0aW9uIGxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5sb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSBpdHMgdmlzaWJsZSBzdGF0ZSBieSByZW1vdmluZyB0aGUgJ3Zqcy1sb2NrLXNob3dpbmcnXG4gICAqIGNsYXNzIG5hbWUgZnJvbSBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS51bmxvY2tTaG93aW5nID0gZnVuY3Rpb24gdW5sb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdhcyBhc2tlZCBmb3IuXG4gICAqICAgICAgICAgLSBDYW4gYmUgYW4gZW1wdHkgc3RyaW5nIG9uIHNvbWUgYnJvd3NlcnMgaWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdFxuICAgKiAgICAgICAgICAgb3IgaGFzIG5vIHZhbHVlXG4gICAqICAgICAgICAgLSBNb3N0IGJyb3dzZXJzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGF0dGlidXRlIGRvZXMgbm90IGV4aXN0IG9yIGhhc1xuICAgKiAgICAgICAgICAgbm8gdmFsdWUuXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgYENvbXBvbmVudGAncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3NldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVtb3ZlQXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgd2lkdGggdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgaGVpZ2h0IHRoYXQgeW91IHdhbnQgdG8gc2V0IHBvc3RmaXhlZCB3aXRoICclJywgJ3B4JyBvciBub3RoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICogICAgICAgICBUaGUgd2lkdGggd2hlbiBnZXR0aW5nLCB6ZXJvIGlmIHRoZXJlIGlzIG5vIHdpZHRoLiBDYW4gYmUgYSBzdHJpbmdcbiAgICogICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IHdpZHRoXG4gICAqICAgICAgICAgV2lkdGggdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gaGVpZ2h0XG4gICAqICAgICAgICAgSGVpZ2h0IHRvIHNldCB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb25zID0gZnVuY3Rpb24gZGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gU2tpcCBjb21wb25lbnRyZXNpemUgbGlzdGVuZXJzIG9uIHdpZHRoIGZvciBvcHRpbWl6YXRpb25cbiAgICB0aGlzLndpZHRoKHdpZHRoLCB0cnVlKTtcbiAgICB0aGlzLmhlaWdodChoZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudC4gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGVcbiAgICogZm9yIHRoZSB7QGxpbmsgQ29tcG9uZW50I3dpZHRofSBhbmQge0BsaW5rIENvbXBvbmVudCNoZWlnaHR9LlxuICAgKlxuICAgKiBUaGluZ3MgdG8ga25vdzpcbiAgICogLSBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGluIGFuIG51bWJlciB0aGlzIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgcG9zdGZpeGVkIHdpdGggJ3B4Jy5cbiAgICogLSBJZiB0aGUgd2lkdGgvaGVpZ2h0IGlzIGEgcGVyY2VudCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBwZXJjZW50IHBvc3RmaXhlZCB3aXRoICclJ1xuICAgKiAtIEhpZGRlbiBlbGVtZW50cyBoYXZlIGEgd2lkdGggb2YgMCB3aXRoIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuIFRoaXMgZnVuY3Rpb25cbiAgICogICBkZWZhdWx0cyB0byB0aGUgYENvbXBvbmVudGBzIGBzdHlsZS53aWR0aGAgYW5kIGZhbGxzIGJhY2sgdG8gYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICogICBTZWUgW3RoaXNde0BsaW5rIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC99XG4gICAqICAgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogLSBJZiB5b3Ugd2FudCB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgdGhlIGNvbXBvbmVudCwgdXNlIHtAbGluayBDb21wb25lbnQjY3VycmVudFdpZHRofVxuICAgKiAgIGFuZCB7QGxpbmsge0NvbXBvbmVudCNjdXJyZW50SGVpZ2h0fVxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhPckhlaWdodFxuICAgOCAgICAgICAgJ3dpZHRoJyBvciAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBbbnVtXVxuICAgOCAgICAgICAgIE5ldyBkaW1lbnNpb25cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICAgU2tpcCBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB3aGVuIGdldHRpbmcgb3IgMCBpZiB1bnNldFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2V0IHRvIHplcm8gaWYgbnVsbCBvciBsaXRlcmFsbHkgTmFOIChOYU4gIT09IE5hTilcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcbiAgICAgICAgbnVtID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgY3NzIHdpZHRoL2hlaWdodCAoJSBvciBweCkgYW5kIGFkanVzdFxuICAgICAgaWYgKCgnJyArIG51bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycgKyBudW0pLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW0gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW0gKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZXNpemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBvbmVudHJlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm90IHNldHRpbmcgYSB2YWx1ZSwgc28gZ2V0dGluZyBpdFxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50IGV4aXN0c1xuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEdldCBkaW1lbnNpb24gdmFsdWUgZnJvbSBzdHlsZVxuICAgIHZhciB2YWwgPSB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XTtcbiAgICB2YXIgcHhJbmRleCA9IHZhbC5pbmRleE9mKCdweCcpO1xuXG4gICAgaWYgKHB4SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHBpeGVsIHZhbHVlIHdpdGggbm8gJ3B4J1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbC5zbGljZSgwLCBweEluZGV4KSwgMTApO1xuICAgIH1cblxuICAgIC8vIE5vIHB4IHNvIHVzaW5nICUgb3Igbm8gc3R5bGUgd2FzIHNldCwgc28gZmFsbGluZyBiYWNrIHRvIG9mZnNldFdpZHRoL2hlaWdodFxuICAgIC8vIElmIGNvbXBvbmVudCBoYXMgZGlzcGxheTpub25lLCBvZmZzZXQgd2lsbCByZXR1cm4gMFxuICAgIC8vIFRPRE86IGhhbmRsZSBkaXNwbGF5Om5vbmUgYW5kIG5vIGRpbWVuc2lvbiBzdHlsZSB1c2luZyBweFxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmVsX1snb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpXSwgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9yIHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnRzIGNvbXB1dGVkIHN0eWxlLiBVc2VzXG4gICAqIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICAqICAgICAgICBBIHN0cmluZyBjb250YWluaW5nICd3aWR0aCcgb3IgJ2hlaWdodCcuIFdoaWNoZXZlciBvbmUgeW91IHdhbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB0aGF0IGdldHMgYXNrZWQgZm9yIG9yIDAgaWYgbm90aGluZyB3YXMgc2V0XG4gICAqICAgICAgICAgZm9yIHRoYXQgZGltZW5zaW9uLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbiA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb24od2lkdGhPckhlaWdodCkge1xuICAgIHZhciBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSAwO1xuXG4gICAgaWYgKHdpZHRoT3JIZWlnaHQgIT09ICd3aWR0aCcgJiYgd2lkdGhPckhlaWdodCAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudERpbWVuc2lvbiBvbmx5IGFjY2VwdHMgd2lkdGggb3IgaGVpZ2h0IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsXyk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh3aWR0aE9ySGVpZ2h0KSB8fCBjb21wdXRlZFN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSAncHgnIGZyb20gdmFyaWFibGUgYW5kIHBhcnNlIGFzIGludGVnZXJcbiAgICBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbXB1dGVkV2lkdGhPckhlaWdodCk7XG5cbiAgICAvLyBpZiB0aGUgY29tcHV0ZWQgdmFsdWUgaXMgc3RpbGwgMCwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGlzIGx5aW5nXG4gICAgLy8gYW5kIHdlIHdhbnQgdG8gY2hlY2sgdGhlIG9mZnNldCB2YWx1ZXMuXG4gICAgLy8gVGhpcyBjb2RlIGFsc28gcnVucyBvbiBJRTggYW5kIHdoZXJldmVyIGdldENvbXB1dGVkU3R5bGUgZG9lc24ndCBleGlzdC5cbiAgICBpZiAoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID09PSAwKSB7XG4gICAgICB2YXIgcnVsZSA9ICdvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHRoaXMuZWxfW3J1bGVdO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlZFdpZHRoT3JIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIHRoZSBgQ29tcG9uZW50YHNcbiAgICogY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tcG9uZW50fkRpbWVuc2lvbk9iamVjdFxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAqICAgICAgICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fkRpbWVuc2lvbk9iamVjdH1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9ucyBvZiB0aGUgY29tcG9uZW50cyBlbGVtZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFdpZHRoID0gZnVuY3Rpb24gY3VycmVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRIZWlnaHQgPSBmdW5jdGlvbiBjdXJyZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvY3VzIHRvIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMuZWxfLmZvY3VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGlzIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5lbF8uYmx1cigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0IGEgJ3RhcCcgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnQgc3VwcG9ydCBnZXRzIGRldGVjdGVkLiBUaGlzIGdldHMgdXNlZCB0b1xuICAgKiBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby4gVGhleSBnZXQgZW5hYmxlZFxuICAgKiBiZWNhdXNlIGV2ZXJ5IHN1Yi1jb21wb25lbnQgd291bGQgaGF2ZSBleHRyYSBvdmVyaGVhZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBDb21wb25lbnQjdGFwXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaHN0YXJ0XG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaG1vdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobGVhdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVtaXRUYXBFdmVudHMgPSBmdW5jdGlvbiBlbWl0VGFwRXZlbnRzKCkge1xuICAgIC8vIFRyYWNrIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlcm1pbmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgIHZhciB0b3VjaFN0YXJ0ID0gMDtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IG51bGw7XG5cbiAgICAvLyBNYXhpbXVtIG1vdmVtZW50IGFsbG93ZWQgZHVyaW5nIGEgdG91Y2ggZXZlbnQgdG8gc3RpbGwgYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgIC8vIE90aGVyIHBvcHVsYXIgbGlicyB1c2UgYW55d2hlcmUgZnJvbSAyIChoYW1tZXIuanMpIHRvIDE1LFxuICAgIC8vIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgdmFyIHRhcE1vdmVtZW50VGhyZXNob2xkID0gMTA7XG5cbiAgICAvLyBUaGUgbWF4aW11bSBsZW5ndGggYSB0b3VjaCBjYW4gYmUgd2hpbGUgc3RpbGwgYmVpbmcgY29uc2lkZXJlZCBhIHRhcFxuICAgIHZhciB0b3VjaFRpbWVUaHJlc2hvbGQgPSAyMDA7XG5cbiAgICB2YXIgY291bGRCZVRhcCA9IHZvaWQgMDtcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb3B5IHBhZ2VYL3BhZ2VZIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBmaXJzdFRvdWNoID0ge1xuICAgICAgICAgIHBhZ2VYOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRvdWNoKSB7XG4gICAgICAgIC8vIFNvbWUgZGV2aWNlcyB3aWxsIHRocm93IHRvdWNobW92ZXMgZm9yIGFsbCBidXQgdGhlIHNsaWdodGVzdCBvZiB0YXBzLlxuICAgICAgICAvLyBTbywgaWYgd2UgbW92ZWQgb25seSBhIHNtYWxsIGRpc3RhbmNlLCB0aGlzIGNvdWxkIHN0aWxsIGJlIGEgdGFwXG4gICAgICAgIHZhciB4ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBmaXJzdFRvdWNoLnBhZ2VYO1xuICAgICAgICB2YXIgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgdmFyIHRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuXG4gICAgICAgIGlmICh0b3VjaERpc3RhbmNlID4gdGFwTW92ZW1lbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBub1RhcCA9IGZ1bmN0aW9uIG5vVGFwKCkge1xuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBMaXN0ZW4gdG8gdGhlIG9yaWdpbmFsIHRhcmdldC4gaHR0cDovL3lvdXR1LmJlL0R1amZwWE9LVXA4P3Q9MTNtOHNcbiAgICB0aGlzLm9uKCd0b3VjaGxlYXZlJywgbm9UYXApO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgbm9UYXApO1xuXG4gICAgLy8gV2hlbiB0aGUgdG91Y2ggZW5kcywgbWVhc3VyZSBob3cgbG9uZyBpdCB0b29rIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICB2YXIgdG91Y2hUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0b3VjaFN0YXJ0O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG91Y2ggd2FzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAgICAgaWYgKHRvdWNoVGltZSA8IHRvdWNoVGltZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgdGFwcGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IENvbXBvbmVudCN0YXBcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwb3J0cyB1c2VyIGFjdGl2aXR5IHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4uIFRoaXMgY2FuIGdldFxuICAgKiB0dXJuZWQgb2ZmIGJ5IGFueSBzdWItY29tcG9uZW50cyB0aGF0IHdhbnRzIHRvdWNoIGV2ZW50cyB0byBhY3QgYW5vdGhlciB3YXkuXG4gICAqXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyLiBVc2VyIGFjdGl2aXR5IGdldHMgdXNlZCB0b1xuICAgKiBkZXRlcm1pbmUgd2hlbiBjb250cm9scyBzaG91bGQgc2hvdy9oaWRlLiBJdCBpcyBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZVxuICAgKiBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50IHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZVxuICAgKiBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5IGFzIGB0b3VjaHN0YXJ0YCBhbmQgYHRvdWNoZW5kYCB0b2dnbGUgcGxheWVyXG4gICAqIGNvbnRyb2xzLiBTbyB0b3VjaCBldmVudHMgY2FuJ3QgaGVscCB1cyBhdCB0aGUgcGxheWVyIGxldmVsIGVpdGhlci5cbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBnZXRzIGNoZWNrZWQgYXN5bmNocm9ub3VzbHkuIFNvIHdoYXQgY291bGQgaGFwcGVuIGlzIGEgdGFwIGV2ZW50XG4gICAqIG9uIHRoZSB2aWRlbyB0dXJucyB0aGUgY29udHJvbHMgb2ZmLiBUaGVuIHRoZSBgdG91Y2hlbmRgIGV2ZW50IGJ1YmJsZXMgdXAgdG9cbiAgICogdGhlIHBsYXllci4gV2hpY2gsIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0XG4gICAqIGJhY2sgb24uIFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwLlxuICAgKiBGdXJ0aGVybW9yZSBhIGB0b3VjaG1vdmVgIGV2ZW50IGFuZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgdGFwLCBzaG91bGQgbm90IHR1cm5cbiAgICogY29udHJvbHMgYmFjayBvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVUb3VjaEFjdGl2aXR5ID0gZnVuY3Rpb24gZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcbiAgICAvLyBEb24ndCBjb250aW51ZSBpZiB0aGUgcm9vdCBwbGF5ZXIgZG9lc24ndCBzdXBwb3J0IHJlcG9ydGluZyB1c2VyIGFjdGl2aXR5XG4gICAgaWYgKCF0aGlzLnBsYXllcigpIHx8ICF0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICB2YXIgcmVwb3J0ID0gYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgdG91Y2hIb2xkaW5nID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gdG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gc3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIHRvdWNoIGlzIGhvbGRpbmdcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCByZXBvcnQpO1xuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgdG91Y2hFbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIGlzIGJvdW5kIGludG8gYENvbXBvbmVudGBzIGNvbnRleHQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrXG4gICAqIEB0aGlzIENvbXBvbmVudFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBhZnRlciBhbiBgeGAgbWlsbGlzZWNvbmQgdGltZW91dC4gVGhpcyBmdW5jdGlvbiBpcyBhXG4gICAqIHdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0VGltZW91dGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZVxuICAgKiBpbnN0ZWFkIHRob3VnaDpcbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgZ2V0cyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiA+IE5vdGU6IFlvdSBjYW4gdXNlIGB3aW5kb3cuY2xlYXJUaW1lb3V0YCBvbiB0aGUgaWQgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi4gVGhpc1xuICAgKiAgICAgICAgIHdpbGwgY2F1c2UgaXRzIGRpc3Bvc2UgbGlzdGVuZXIgbm90IHRvIGdldCBjbGVhbmVkIHVwISBQbGVhc2UgdXNlXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IG9yIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIGFmdGVyIGB0aW1lb3V0YC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICogICAgICAgIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYSB0aW1lb3V0IElEIHRoYXQgZ2V0cyB1c2VkIHRvIGlkZW50aWZ5IHRoZSB0aW1lb3V0LiBJdCBjYW4gYWxzb1xuICAgKiAgICAgICAgIGdldCB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2xlYXJUaW1lb3V0fSB0byBjbGVhciB0aGUgdGltZW91dCB0aGF0XG4gICAqICAgICAgICAgd2FzIHNldC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICB2YXIgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVvdXQpO1xuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYSB0aW1lb3V0IHRoYXQgZ2V0cyBjcmVhdGVkIHZpYSBgd2luZG93LnNldFRpbWVvdXRgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uIElmIHlvdSBzZXQgYSB0aW1lb3V0IHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhclRpbW91dGAuIElmIHlvdSBkb24ndCB5b3VyIGRpc3Bvc2VcbiAgICogbGlzdGVuZXIgd2lsbCBub3QgZ2V0IGNsZWFuZWQgdXAgdW50aWwge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSFcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSB0aW1lb3V0IHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9IG9yIGB3aW5kb3cuc2V0VGltZW91dGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSB0aW1lb3V0IGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkge1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gdGltZW91dElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHJ1biBldmVyeSBgeGAgbWlsbGlzZWNvbmRzLiBUaGlzIGZ1bmN0aW9uIGlzIGEgd3JhcHBlclxuICAgKiBhcm91bmQgYHdpbmRvdy5zZXRJbnRlcnZhbGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZSBpbnN0ZWFkIHRob3VnaC5cbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB3aGVuXG4gICAqICAgIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0gZ2V0cyBjYWxsZWQuXG4gICAqIDIuIFRoZSBmdW5jdGlvbiBjYWxsYmFjayB3aWxsIGJlIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBydW4gZXZlcnkgYHhgIHNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFxuICAgKiAgICAgICAgRXhlY3V0ZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGludGVydmFsLiBJdCBjYW4gYWxzbyBiZSBiZSB1c2VkIGluXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhckludGVydmFsfSB0byBjbGVhciB0aGUgaW50ZXJ2YWwuXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvc2V0SW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcblxuICAgIHZhciBpbnRlcnZhbElkID0gd2luZG93LnNldEludGVydmFsKGZuLCBpbnRlcnZhbCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5jbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH07XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYW4gaW50ZXJ2YWwgdGhhdCBnZXRzIGNyZWF0ZWQgdmlhIGB3aW5kb3cuc2V0SW50ZXJ2YWxgIG9yXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9LiBJZiB5b3Ugc2V0IGFuIGludGV2YWwgdmlhIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9XG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhckludGVydmFsYC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxuICAgKiBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJZFxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnRlcnZhbCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZlxuICAgKiAgICAgICAge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0gb3IgYHdpbmRvdy5zZXRJbnRlcnZhbGAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBpbnRlcnZhbCBpZCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL2NsZWFySW50ZXJ2YWx9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtaW50ZXJ2YWwtJyArIGludGVydmFsSWQ7XG5cbiAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcbiAgfTtcblxuICAvKipcbiAgICogUXVldWVzIHVwIGEgY2FsbGJhY2sgdG8gYmUgcGFzc2VkIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSwgYnV0XG4gICAqIHdpdGggYSBmZXcgZXh0cmEgYm9udXNlczpcbiAgICpcbiAgICogLSBTdXBwb3J0cyBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHJBRiBieSBmYWxsaW5nIGJhY2sgdG9cbiAgICogICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9LlxuICAgKlxuICAgKiAtIFRoZSBjYWxsYmFjayBpcyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSAoaS5lLlxuICAgKiAgIGJvdW5kIHRvIHRoZSBjb21wb25lbnQpLlxuICAgKlxuICAgKiAtIEF1dG9tYXRpYyBjYW5jZWxsYXRpb24gb2YgdGhlIHJBRiBjYWxsYmFjayBpcyBoYW5kbGVkIGlmIHRoZSBjb21wb25lbnRcbiAgICogICBpcyBkaXNwb3NlZCBiZWZvcmUgaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfSBmblxuICAgKiAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoaXMgY29tcG9uZW50IGFuZCBleGVjdXRlZCBqdXN0XG4gICAqICAgICAgICAgYmVmb3JlIHRoZSBicm93c2VyJ3MgbmV4dCByZXBhaW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhbiByQUYgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhblxuICAgKiAgICAgICAgIGFsc28gYmUgdXNlZCBpbiB7QGxpbmsgQ29tcG9uZW50I2NhbmNlbEFuaW1hdGlvbkZyYW1lfSB0byBjYW5jZWxcbiAgICogICAgICAgICB0aGUgYW5pbWF0aW9uIGZyYW1lIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3VwcG9ydHNSYWZfKSB7XG4gICAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgICB2YXIgaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgfTtcblxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxuICAgIHJldHVybiB0aGlzLnNldFRpbWVvdXQoZm4sIDEwMDAgLyA2MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBxdWV1ZWQgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKiAockFGKS5cbiAgICpcbiAgICogSWYgeW91IHF1ZXVlIGFuIHJBRiBjYWxsYmFjayB2aWEge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9LFxuICAgKiB1c2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVgLiBJZiB5b3UgZG9uJ3QsXG4gICAqIHlvdXIgZGlzcG9zZSBsaXN0ZW5lciB3aWxsIG5vdCBnZXQgY2xlYW5lZCB1cCB1bnRpbCB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRcbiAgICogICAgICAgIFRoZSByQUYgSUQgdG8gY2xlYXIuIFRoZSByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgckFGIElEIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWV9XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNSYWZfKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuXG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1yYWYtJyArIGlkO1xuXG4gICAgICB0aGlzLm9mZignZGlzcG9zZScsIGRpc3Bvc2VGbik7XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cbiAgICByZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoaWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGBDb21wb25lbnRgIHdpdGggYHZpZGVvanNgIGdpdmVuIHRoZSBuYW1lIGFuZCB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiA+IE5PVEU6IHtAbGluayBUZWNofXMgc2hvdWxkIG5vdCBiZSByZWdpc3RlcmVkIGFzIGEgYENvbXBvbmVudGAuIHtAbGluayBUZWNofXNcbiAgICogICAgICAgICBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgVGVjaC5yZWdpc3RlclRlY2h9IG9yXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlclRlY2h9LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gYmUgc2VlbiBvbiB2aWRlb2pzIGFzXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudH0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYENvbXBvbmVudGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBDb21wb25lbnRUb1JlZ2lzdGVyXG4gICAqICAgICAgICBUaGUgYENvbXBvbmVudGAgY2xhc3MgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCB3YXMgcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudChuYW1lLCBDb21wb25lbnRUb1JlZ2lzdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCBuYW1lLCBcIicgKyBuYW1lICsgJ1wiOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgY2hlY2sgaXMgb25seSBkb25lIGlmIFRlY2ggaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICB2YXIgaXNUZWNoID0gVGVjaCAmJiBUZWNoLmlzVGVjaChDb21wb25lbnRUb1JlZ2lzdGVyKTtcbiAgICB2YXIgaXNDb21wID0gQ29tcG9uZW50ID09PSBDb21wb25lbnRUb1JlZ2lzdGVyIHx8IENvbXBvbmVudC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihDb21wb25lbnRUb1JlZ2lzdGVyLnByb3RvdHlwZSk7XG5cbiAgICBpZiAoaXNUZWNoIHx8ICFpc0NvbXApIHtcbiAgICAgIHZhciByZWFzb24gPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpc1RlY2gpIHtcbiAgICAgICAgcmVhc29uID0gJ3RlY2hzIG11c3QgYmUgcmVnaXN0ZXJlZCB1c2luZyBUZWNoLnJlZ2lzdGVyVGVjaCgpJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdtdXN0IGJlIGEgQ29tcG9uZW50IHN1YmNsYXNzJztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCwgXCInICsgbmFtZSArICdcIjsgJyArIHJlYXNvbiArICcuJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKCFDb21wb25lbnQuY29tcG9uZW50c18pIHtcbiAgICAgIENvbXBvbmVudC5jb21wb25lbnRzXyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBQbGF5ZXIgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcblxuICAgIGlmIChuYW1lID09PSAnUGxheWVyJyAmJiBQbGF5ZXIgJiYgUGxheWVyLnBsYXllcnMpIHtcbiAgICAgIHZhciBwbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG4gICAgICB2YXIgcGxheWVyTmFtZXMgPSBPYmplY3Qua2V5cyhwbGF5ZXJzKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBwbGF5ZXJzIHRoYXQgd2VyZSBkaXNwb3NlZCwgdGhlbiB0aGVpciBuYW1lIHdpbGwgc3RpbGwgYmVcbiAgICAgIC8vIGluIFBsYXllcnMucGxheWVycy4gU28sIHdlIG11c3QgbG9vcCB0aHJvdWdoIGFuZCB2ZXJpZnkgdGhhdCB0aGUgdmFsdWVcbiAgICAgIC8vIGZvciBlYWNoIGl0ZW0gaXMgbm90IG51bGwuIFRoaXMgYWxsb3dzIHJlZ2lzdHJhdGlvbiBvZiB0aGUgUGxheWVyIGNvbXBvbmVudFxuICAgICAgLy8gYWZ0ZXIgYWxsIHBsYXllcnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIG9yIGJlZm9yZSBhbnkgd2VyZSBjcmVhdGVkLlxuICAgICAgaWYgKHBsYXllcnMgJiYgcGxheWVyTmFtZXMubGVuZ3RoID4gMCAmJiBwbGF5ZXJOYW1lcy5tYXAoZnVuY3Rpb24gKHBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwbGF5ZXJzW3BuYW1lXTtcbiAgICAgIH0pLmV2ZXJ5KEJvb2xlYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCByZWdpc3RlciBQbGF5ZXIgY29tcG9uZW50IGFmdGVyIHBsYXllciBoYXMgYmVlbiBjcmVhdGVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIENvbXBvbmVudC5jb21wb25lbnRzX1tuYW1lXSA9IENvbXBvbmVudFRvUmVnaXN0ZXI7XG5cbiAgICByZXR1cm4gQ29tcG9uZW50VG9SZWdpc3RlcjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYENvbXBvbmVudGAgYmFzZWQgb24gdGhlIG5hbWUgaXQgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ290IHJlZ2lzdGVyZWQgdW5kZXIgdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluIGB2aWRlb2pzYCA2IHRoaXMgd2lsbCBub3QgcmV0dXJuIGBDb21wb25lbnRgcyB0aGF0IHdlcmUgbm90XG4gICAqICAgICAgICAgICAgIHJlZ2lzdGVyZWQgdXNpbmcge0BsaW5rIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudH0uIEN1cnJlbnRseSB3ZVxuICAgKiAgICAgICAgICAgICBjaGVjayB0aGUgZ2xvYmFsIGB2aWRlb2pzYCBvYmplY3QgZm9yIGEgYENvbXBvbmVudGAgbmFtZSBhbmRcbiAgICogICAgICAgICAgICAgcmV0dXJuIHRoYXQgaWYgaXQgZXhpc3RzLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRDb21wb25lbnQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50c18gJiYgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IHN1cHBvcnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICpcbiAqIFRoaXMgaXMgZXhwb3NlZCBwcmltYXJpbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zdXBwb3J0c1JhZl8gPSB0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NvbXBvbmVudCcsIENvbXBvbmVudCk7XG5cbi8qKlxuICogQGZpbGUgdGltZS1yYW5nZXMuanNcbiAqIEBtb2R1bGUgdGltZS1yYW5nZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRpbWUgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggYXQgdGhlIHN0YXJ0IG9yIGVuZFxuICogb2YgYSBUaW1lUmFuZ2Ugb2JqZWN0LlxuICpcbiAqIEBmdW5jdGlvbiB0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXVxuICogICAgICAgIFRoZSByYW5nZSBudW1iZXIgdG8gcmV0dXJuIHRoZSB0aW1lIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB0aW1lIHRoYXQgb2Zmc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gKlxuICogQGRlcHJpY2F0ZWQgaW5kZXggbXVzdCBiZSBzZXQgdG8gYSB2YWx1ZSwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyByYW5nZXMgb2YgdGltZSBmb3IgdmFyaW91cyByZWFzb25zLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVSYW5nZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAqICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHRpbWUgcmFuZ2VzIHJlcHJlc2VudGVkIGJ5IHRoaXMgT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBzdGFydFxuICogICAgICAgICAgIFJldHVybnMgdGhlIHRpbWUgb2Zmc2V0IGF0IHdoaWNoIGEgc3BlY2lmaWVkIHRpbWUgcmFuZ2UgYmVnaW5zLlxuICpcbiAqIEBwcm9wZXJ0eSB7dGltZS1yYW5nZXM6aW5kZXhGdW5jdGlvbn0gZW5kXG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGltZVJhbmdlc1xuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgICAgICAgVGhlIGluZGV4IHRvIGNoZWNrXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEluZGV4XG4gKiAgICAgICAgVGhlIG1heGltdW0gcG9zc2libGUgaW5kZXhcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIHRpbWVSYW5nZXMgcHJvdmlkZWQgYXJlIG92ZXIgdGhlIG1heEluZGV4XG4gKi9cbmZ1bmN0aW9uIHJhbmdlQ2hlY2soZm5OYW1lLCBpbmRleCwgbWF4SW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJycgKyBmbk5hbWUgKyAnXFwnIG9uIFxcJ1RpbWVSYW5nZXNcXCc6IFRoZSBpbmRleCBwcm92aWRlZCAoJyArIGluZGV4ICsgJykgaXMgbm9uLW51bWVyaWMgb3Igb3V0IG9mIGJvdW5kcyAoMC0nICsgbWF4SW5kZXggKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFueSBvZiB0aGUgdGltZSByYW5nZXMgYXJlIG92ZXIgdGhlIG1heGltdW0gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUluZGV4XG4gKiAgICAgICAgVGhlIHByb3ByZXR5IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IHRoZSB0aW1lLiBzaG91bGQgYmUgJ3N0YXJ0JyBvciAnZW5kJ1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlc1xuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3JhbmdlSW5kZXg9MF1cbiAqICAgICAgICBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdFxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKlxuICogQGRlcHJpY2F0ZWQgcmFuZ2VJbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiByYW5nZUluZGV4IGlzIG1vcmUgdGhhbiB0aGUgbGVuZ3RoIG9mIHJhbmdlc1xuICovXG5mdW5jdGlvbiBnZXRSYW5nZShmbk5hbWUsIHZhbHVlSW5kZXgsIHJhbmdlcywgcmFuZ2VJbmRleCkge1xuICByYW5nZUNoZWNrKGZuTmFtZSwgcmFuZ2VJbmRleCwgcmFuZ2VzLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHRpbWUgcmFuZ2Ugb2JqZWN0IGdpdmVudCByYW5nZXMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbcmFuZ2VzXVxuICogICAgICAgIEFuIGFycmF5IG9mIHRpbWUgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHJhbmdlcykge1xuICBpZiAocmFuZ2VzID09PSB1bmRlZmluZWQgfHwgcmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZW5ndGg6IDAsXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfSxcbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVGltZVJhbmdlcyBvYmplY3QgaXMgZW1wdHknKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVuZ3RoOiByYW5nZXMubGVuZ3RoLFxuICAgIHN0YXJ0OiBnZXRSYW5nZS5iaW5kKG51bGwsICdzdGFydCcsIDAsIHJhbmdlcyksXG4gICAgZW5kOiBnZXRSYW5nZS5iaW5kKG51bGwsICdlbmQnLCAxLCByYW5nZXMpXG4gIH07XG59XG5cbi8qKlxuICogU2hvdWxkIGNyZWF0ZSBhIGZha2UgYFRpbWVSYW5nZWAgb2JqZWN0IHdoaWNoIG1pbWljcyBhbiBIVE1MNSB0aW1lIHJhbmdlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5fSBzdGFydFxuICogICAgICAgIFRoZSBzdGFydCBvZiBhIHNpbmdsZSByYW5nZSBvciBhbiBhcnJheSBvZiByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiAgICAgICAgVGhlIGVuZCBvZiBhIHNpbmdsZSByYW5nZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhcnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooc3RhcnQpO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaigpO1xuICB9XG4gIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKFtbc3RhcnQsIGVuZF1dKTtcbn1cblxuLyoqXG4gKiBAZmlsZSBidWZmZXIuanNcbiAqIEBtb2R1bGUgYnVmZmVyXG4gKi9cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGVyY2VudGFnZSBvZiB0aGUgbWVkaWEgdGhhdCBoYXMgYmVlbiBidWZmZXJlZC5cbiAqXG4gKiBAcGFyYW0ge1RpbWVSYW5nZX0gYnVmZmVyZWRcbiAqICAgICAgICBUaGUgY3VycmVudCBgVGltZVJhbmdlYCBvYmplY3QgcmVwcmVzZW50aW5nIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXG4gKiAgICAgICAgVG90YWwgZHVyYXRpb24gb2YgdGhlIG1lZGlhXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBQZXJjZW50IGJ1ZmZlcmVkIG9mIHRoZSB0b3RhbCBkdXJhdGlvbiBpbiBkZWNpbWFsIGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcmVkUGVyY2VudChidWZmZXJlZCwgZHVyYXRpb24pIHtcbiAgdmFyIGJ1ZmZlcmVkRHVyYXRpb24gPSAwO1xuICB2YXIgc3RhcnQgPSB2b2lkIDA7XG4gIHZhciBlbmQgPSB2b2lkIDA7XG5cbiAgaWYgKCFkdXJhdGlvbikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgYnVmZmVyZWQgPSBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XG4gICAgZW5kID0gYnVmZmVyZWQuZW5kKGkpO1xuXG4gICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cbiAgICBpZiAoZW5kID4gZHVyYXRpb24pIHtcbiAgICAgIGVuZCA9IGR1cmF0aW9uO1xuICAgIH1cblxuICAgIGJ1ZmZlcmVkRHVyYXRpb24gKz0gZW5kIC0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyZWREdXJhdGlvbiAvIGR1cmF0aW9uO1xufVxuXG4vKipcbiAqIEBmaWxlIGZ1bGxzY3JlZW4tYXBpLmpzXG4gKiBAbW9kdWxlIGZ1bGxzY3JlZW4tYXBpXG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIFN0b3JlIHRoZSBicm93c2VyLXNwZWNpZmljIG1ldGhvZHMgZm9yIHRoZSBmdWxsc2NyZWVuIEFQSS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHNlZSBbU3BlY2lmaWNhdGlvbl17QGxpbmsgaHR0cHM6Ly9mdWxsc2NyZWVuLnNwZWMud2hhdHdnLm9yZ31cbiAqIEBzZWUgW01hcCBBcHByb2FjaCBGcm9tIFNjcmVlbmZ1bGwuanNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2NyZWVuZnVsbC5qc31cbiAqL1xudmFyIEZ1bGxzY3JlZW5BcGkgPSB7fTtcblxuLy8gYnJvd3NlciBBUEkgbWV0aG9kc1xudmFyIGFwaU1hcCA9IFtbJ3JlcXVlc3RGdWxsc2NyZWVuJywgJ2V4aXRGdWxsc2NyZWVuJywgJ2Z1bGxzY3JlZW5FbGVtZW50JywgJ2Z1bGxzY3JlZW5FbmFibGVkJywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCAnZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBXZWJLaXRcblsnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLCAnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLCAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLCAnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE9sZCBXZWJLaXQgKFNhZmFyaSA1LjEpXG5bJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50JywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcbi8vIE1vemlsbGFcblsnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLCAnbW96Q2FuY2VsRnVsbFNjcmVlbicsICdtb3pGdWxsU2NyZWVuRWxlbWVudCcsICdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsICdtb3pmdWxsc2NyZWVuY2hhbmdlJywgJ21vemZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTWljcm9zb2Z0XG5bJ21zUmVxdWVzdEZ1bGxzY3JlZW4nLCAnbXNFeGl0RnVsbHNjcmVlbicsICdtc0Z1bGxzY3JlZW5FbGVtZW50JywgJ21zRnVsbHNjcmVlbkVuYWJsZWQnLCAnTVNGdWxsc2NyZWVuQ2hhbmdlJywgJ01TRnVsbHNjcmVlbkVycm9yJ11dO1xuXG52YXIgc3BlY0FwaSA9IGFwaU1hcFswXTtcbnZhciBicm93c2VyQXBpID0gdm9pZCAwO1xuXG4vLyBkZXRlcm1pbmUgdGhlIHN1cHBvcnRlZCBzZXQgb2YgZnVuY3Rpb25zXG5mb3IgKHZhciBpID0gMDsgaSA8IGFwaU1hcC5sZW5ndGg7IGkrKykge1xuICAvLyBjaGVjayBmb3IgZXhpdEZ1bGxzY3JlZW4gZnVuY3Rpb25cbiAgaWYgKGFwaU1hcFtpXVsxXSBpbiBkb2N1bWVudCkge1xuICAgIGJyb3dzZXJBcGkgPSBhcGlNYXBbaV07XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gbWFwIHRoZSBicm93c2VyIEFQSSBuYW1lcyB0byB0aGUgc3BlYyBBUEkgbmFtZXNcbmlmIChicm93c2VyQXBpKSB7XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBicm93c2VyQXBpLmxlbmd0aDsgX2krKykge1xuICAgIEZ1bGxzY3JlZW5BcGlbc3BlY0FwaVtfaV1dID0gYnJvd3NlckFwaVtfaV07XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZSBtZWRpYS1lcnJvci5qc1xuICovXG4vKipcbiAqIEEgQ3VzdG9tIGBNZWRpYUVycm9yYCBjbGFzcyB3aGljaCBtaW1pY3MgdGhlIHN0YW5kYXJkIEhUTUw1IGBNZWRpYUVycm9yYCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8T2JqZWN0fE1lZGlhRXJyb3J9IHZhbHVlXG4gKiAgICAgICAgVGhpcyBjYW4gYmUgb2YgbXVsdGlwbGUgdHlwZXM6XG4gKiAgICAgICAgLSBudW1iZXI6IHNob3VsZCBiZSBhIHN0YW5kYXJkIGVycm9yIGNvZGVcbiAqICAgICAgICAtIHN0cmluZzogYW4gZXJyb3IgbWVzc2FnZSAodGhlIGNvZGUgd2lsbCBiZSAwKVxuICogICAgICAgIC0gT2JqZWN0OiBhcmJpdHJhcnkgcHJvcGVydGllc1xuICogICAgICAgIC0gYE1lZGlhRXJyb3JgIChuYXRpdmUpOiB1c2VkIHRvIHBvcHVsYXRlIGEgdmlkZW8uanMgYE1lZGlhRXJyb3JgIG9iamVjdFxuICogICAgICAgIC0gYE1lZGlhRXJyb3JgICh2aWRlby5qcyk6IHdpbGwgcmV0dXJuIGl0c2VsZiBpZiBpdCdzIGFscmVhZHkgYVxuICogICAgICAgICAgdmlkZW8uanMgYE1lZGlhRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc2VlIFtNZWRpYUVycm9yIFNwZWNde0BsaW5rIGh0dHBzOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjLWF1dGhvci12aWV3L3ZpZGVvLmh0bWwjbWVkaWFlcnJvcn1cbiAqIEBzZWUgW0VuY3J5cHRlZCBNZWRpYUVycm9yIFNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELWVuY3J5cHRlZC1tZWRpYS0yMDEzMDUxMC8jZXJyb3ItY29kZXN9XG4gKlxuICogQGNsYXNzIE1lZGlhRXJyb3JcbiAqL1xuZnVuY3Rpb24gTWVkaWFFcnJvcih2YWx1ZSkge1xuXG4gIC8vIEFsbG93IHJlZHVuZGFudCBjYWxscyB0byB0aGlzIGNvbnN0cnVjdG9yIHRvIGF2b2lkIGhhdmluZyBgaW5zdGFuY2VvZmBcbiAgLy8gY2hlY2tzIHBlcHBlcmVkIGFyb3VuZCB0aGUgY29kZS5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWVkaWFFcnJvcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5jb2RlID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIGRlZmF1bHQgY29kZSBpcyB6ZXJvLCBzbyB0aGlzIGlzIGEgY3VzdG9tIGVycm9yXG4gICAgdGhpcy5tZXNzYWdlID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cbiAgICAvLyBXZSBhc3NpZ24gdGhlIGBjb2RlYCBwcm9wZXJ0eSBtYW51YWxseSBiZWNhdXNlIG5hdGl2ZSBgTWVkaWFFcnJvcmAgb2JqZWN0c1xuICAgIC8vIGRvIG5vdCBleHBvc2UgaXQgYXMgYW4gb3duL2VudW1lcmFibGUgcHJvcGVydHkgb2YgdGhlIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlLmNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNvZGUgPSB2YWx1ZS5jb2RlO1xuICAgIH1cblxuICAgIGFzc2lnbih0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAoIXRoaXMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IE1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzW3RoaXMuY29kZV0gfHwgJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZXJyb3IgY29kZSB0aGF0IHJlZmVycyB0d28gb25lIG9mIHRoZSBkZWZpbmVkIGBNZWRpYUVycm9yYCB0eXBlc1xuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLmNvZGUgPSAwO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdGhhdCB0byBzaG93IHdpdGggdGhlIGVycm9yLiBNZXNzYWdlIGlzIG5vdCBwYXJ0IG9mIHRoZSBIVE1MNVxuICogdmlkZW8gc3BlYyBidXQgYWxsb3dzIGZvciBtb3JlIGluZm9ybWF0aXZlIGN1c3RvbSBlcnJvcnMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUubWVzc2FnZSA9ICcnO1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIHN0YXR1cyBjb2RlIHRoYXQgY2FuIGJlIHNldCBieSBwbHVnaW5zIHRvIGFsbG93IGV2ZW4gbW9yZSBkZXRhaWwgYWJvdXRcbiAqIHRoZSBlcnJvci4gRm9yIGV4YW1wbGUgYSBwbHVnaW4gbWlnaHQgcHJvdmlkZSBhIHNwZWNpZmljIEhUVFAgc3RhdHVzIGNvZGUgYW5kIGFuXG4gKiBlcnJvciBtZXNzYWdlIGZvciB0aGF0IGNvZGUuIFRoZW4gd2hlbiB0aGUgcGx1Z2luIGdldHMgdGhhdCBlcnJvciB0aGlzIGNsYXNzIHdpbGxcbiAqIGtub3cgaG93IHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBmb3IgaXQuIFRoaXMgYWxsb3dzIGEgY3VzdG9tIG1lc3NhZ2UgdG8gc2hvd1xuICogdXAgb24gdGhlIGBQbGF5ZXJgIGVycm9yIG92ZXJsYXkuXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5zdGF0dXMgPSBudWxsO1xuXG4vKipcbiAqIEVycm9ycyBpbmRleGVkIGJ5IHRoZSBXM0Mgc3RhbmRhcmQuIFRoZSBvcmRlciAqKkNBTk5PVCBDSEFOR0UqKiEgU2VlIHRoZVxuICogc3BlY2lmaWNhdGlvbiBsaXN0ZWQgdW5kZXIge0BsaW5rIE1lZGlhRXJyb3J9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBlbnVtIHthcnJheX1cbiAqIEByZWFkb25seVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDAgLSBNRURJQV9FUlJfQ1VTVE9NXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMSAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAyIC0gTUVESUFfRVJSX0FCT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAzIC0gTUVESUFfRVJSX05FVFdPUktcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA0IC0gTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEXG4gKiBAcHJvcGVydHkge3N0cmluZ30gNSAtIE1FRElBX0VSUl9FTkNSWVBURURcbiAqL1xuTWVkaWFFcnJvci5lcnJvclR5cGVzID0gWydNRURJQV9FUlJfQ1VTVE9NJywgJ01FRElBX0VSUl9BQk9SVEVEJywgJ01FRElBX0VSUl9ORVRXT1JLJywgJ01FRElBX0VSUl9ERUNPREUnLCAnTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEJywgJ01FRElBX0VSUl9FTkNSWVBURUQnXTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBgTWVkaWFFcnJvcmAgbWVzc2FnZXMgYmFzZWQgb24gdGhlIHtAbGluayBNZWRpYUVycm9yLmVycm9yVHlwZXN9LlxuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBjb25zdGFudFxuICovXG5NZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlcyA9IHtcbiAgMTogJ1lvdSBhYm9ydGVkIHRoZSBtZWRpYSBwbGF5YmFjaycsXG4gIDI6ICdBIG5ldHdvcmsgZXJyb3IgY2F1c2VkIHRoZSBtZWRpYSBkb3dubG9hZCB0byBmYWlsIHBhcnQtd2F5LicsXG4gIDM6ICdUaGUgbWVkaWEgcGxheWJhY2sgd2FzIGFib3J0ZWQgZHVlIHRvIGEgY29ycnVwdGlvbiBwcm9ibGVtIG9yIGJlY2F1c2UgdGhlIG1lZGlhIHVzZWQgZmVhdHVyZXMgeW91ciBicm93c2VyIGRpZCBub3Qgc3VwcG9ydC4nLFxuICA0OiAnVGhlIG1lZGlhIGNvdWxkIG5vdCBiZSBsb2FkZWQsIGVpdGhlciBiZWNhdXNlIHRoZSBzZXJ2ZXIgb3IgbmV0d29yayBmYWlsZWQgb3IgYmVjYXVzZSB0aGUgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgNTogJ1RoZSBtZWRpYSBpcyBlbmNyeXB0ZWQgYW5kIHdlIGRvIG5vdCBoYXZlIHRoZSBrZXlzIHRvIGRlY3J5cHQgaXQuJ1xufTtcblxuLy8gQWRkIHR5cGVzIGFzIHByb3BlcnRpZXMgb24gTWVkaWFFcnJvclxuLy8gZS5nLiBNZWRpYUVycm9yLk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRCA9IDQ7XG5mb3IgKHZhciBlcnJOdW0gPSAwOyBlcnJOdW0gPCBNZWRpYUVycm9yLmVycm9yVHlwZXMubGVuZ3RoOyBlcnJOdW0rKykge1xuICBNZWRpYUVycm9yW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbiAgLy8gdmFsdWVzIHNob3VsZCBiZSBhY2Nlc3NpYmxlIG9uIGJvdGggdGhlIGNsYXNzIGFuZCBpbnN0YW5jZVxuICBNZWRpYUVycm9yLnByb3RvdHlwZVtNZWRpYUVycm9yLmVycm9yVHlwZXNbZXJyTnVtXV0gPSBlcnJOdW07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBpcyBgUHJvbWlzZWAtbGlrZSAoaS5lLiBoYXMgYSBgdGhlbmAgbWV0aG9kKS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICB2YWx1ZVxuICogICAgICAgICBBbiBvYmplY3QgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBgUHJvbWlzZWAtbGlrZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGBQcm9taXNlYC1saWtlLlxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogU2lsZW5jZSBhIFByb21pc2UtbGlrZSBvYmplY3QuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nIG5vbi1oYXJtZnVsLCBidXQgcG90ZW50aWFsbHkgY29uZnVzaW5nIFwidW5jYXVnaHRcbiAqIHBsYXkgcHJvbWlzZVwiIHJlamVjdGlvbiBlcnJvciBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHZhbHVlXG4gKiAgICAgICAgIEFuIG9iamVjdCB0aGF0IG1heSBvciBtYXkgbm90IGJlIGBQcm9taXNlYC1saWtlLlxuICovXG5mdW5jdGlvbiBzaWxlbmNlUHJvbWlzZSh2YWx1ZSkge1xuICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHZhbHVlLnRoZW4obnVsbCwgZnVuY3Rpb24gKGUpIHt9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXIuanMgVXRpbGl0aWVzIGZvciBjYXB0dXJpbmcgdGV4dCB0cmFjayBzdGF0ZSBhbmRcbiAqIHJlLWNyZWF0aW5nIHRyYWNrcyBiYXNlZCBvbiBhIGNhcHR1cmUuXG4gKlxuICogQG1vZHVsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyXG4gKi9cblxuLyoqXG4gKiBFeGFtaW5lIGEgc2luZ2xlIHtAbGluayBUZXh0VHJhY2t9IGFuZCByZXR1cm4gYSBKU09OLWNvbXBhdGlibGUgamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICogcmVwcmVzZW50cyB0aGUge0BsaW5rIFRleHRUcmFja30ncyBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBxdWVyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIEEgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRleHRUcmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB0cmFja1RvSnNvbl8gPSBmdW5jdGlvbiB0cmFja1RvSnNvbl8odHJhY2spIHtcbiAgdmFyIHJldCA9IFsna2luZCcsICdsYWJlbCcsICdsYW5ndWFnZScsICdpZCcsICdpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlJywgJ21vZGUnLCAnc3JjJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3AsIGkpIHtcblxuICAgIGlmICh0cmFja1twcm9wXSkge1xuICAgICAgYWNjW3Byb3BdID0gdHJhY2tbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge1xuICAgIGN1ZXM6IHRyYWNrLmN1ZXMgJiYgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrLmN1ZXMsIGZ1bmN0aW9uIChjdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogY3VlLnN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogY3VlLmVuZFRpbWUsXG4gICAgICAgIHRleHQ6IGN1ZS50ZXh0LFxuICAgICAgICBpZDogY3VlLmlkXG4gICAgICB9O1xuICAgIH0pXG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEV4YW1pbmUgYSB7QGxpbmsgVGVjaH0gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGVcbiAqIHN0YXRlIG9mIGFsbCB7QGxpbmsgVGV4dFRyYWNrfXMgY3VycmVudGx5IGNvbmZpZ3VyZWQuIFRoZSByZXR1cm4gYXJyYXkgaXMgY29tcGF0aWJsZSB3aXRoXG4gKiB7QGxpbmsgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlcjpqc29uVG9UZXh0VHJhY2tzfS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHRlY2hcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdG8gcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRlY2h9c1xuICogICAgICAgICB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gKi9cbnZhciB0ZXh0VHJhY2tzVG9Kc29uID0gZnVuY3Rpb24gdGV4dFRyYWNrc1RvSnNvbih0ZWNoKSB7XG5cbiAgdmFyIHRyYWNrRWxzID0gdGVjaC4kJCgndHJhY2snKTtcblxuICB2YXIgdHJhY2tPYmpzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRyYWNrO1xuICB9KTtcbiAgdmFyIHRyYWNrcyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFja0VscywgZnVuY3Rpb24gKHRyYWNrRWwpIHtcbiAgICB2YXIganNvbiA9IHRyYWNrVG9Kc29uXyh0cmFja0VsLnRyYWNrKTtcblxuICAgIGlmICh0cmFja0VsLnNyYykge1xuICAgICAganNvbi5zcmMgPSB0cmFja0VsLnNyYztcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH0pO1xuXG4gIHJldHVybiB0cmFja3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0ZWNoLnRleHRUcmFja3MoKSwgZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgcmV0dXJuIHRyYWNrT2Jqcy5pbmRleE9mKHRyYWNrKSA9PT0gLTE7XG4gIH0pLm1hcCh0cmFja1RvSnNvbl8pKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfXMgb24gYSB7QGxpbmsgVGVjaH0gYmFzZWQgb24gYW4gYXJyYXkgb2YgamF2YXNjcmlwdFxuICogb2JqZWN0IHtAbGluayBUZXh0VHJhY2t9IHJlcHJlc2VudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBqc29uXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgYFRleHRUcmFja2AgcmVwcmVzZW50YXRpb24gb2JqZWN0cywgbGlrZSB0aG9zZSB0aGF0IHdvdWxkIGJlXG4gKiAgICAgICAgcHJvZHVjZWQgYnkgYHRleHRUcmFja3NUb0pzb25gLlxuICpcbiAqIEBwYXJhbSB7VGVjaH0gdGVjaFxuICogICAgICAgIFRoZSBgVGVjaGAgdG8gY3JlYXRlIHRoZSBgVGV4dFRyYWNrYHMgb24uXG4gKi9cbnZhciBqc29uVG9UZXh0VHJhY2tzID0gZnVuY3Rpb24ganNvblRvVGV4dFRyYWNrcyhqc29uLCB0ZWNoKSB7XG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICB2YXIgYWRkZWRUcmFjayA9IHRlY2guYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrKS50cmFjaztcblxuICAgIGlmICghdHJhY2suc3JjICYmIHRyYWNrLmN1ZXMpIHtcbiAgICAgIHRyYWNrLmN1ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VlKSB7XG4gICAgICAgIHJldHVybiBhZGRlZFRyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGVjaC50ZXh0VHJhY2tzKCk7XG59O1xuXG52YXIgdGV4dFRyYWNrQ29udmVydGVyID0geyB0ZXh0VHJhY2tzVG9Kc29uOiB0ZXh0VHJhY2tzVG9Kc29uLCBqc29uVG9UZXh0VHJhY2tzOiBqc29uVG9UZXh0VHJhY2tzLCB0cmFja1RvSnNvbl86IHRyYWNrVG9Kc29uXyB9O1xuXG4vKipcbiAqIEBmaWxlIG1vZGFsLWRpYWxvZy5qc1xuICovXG52YXIgTU9EQUxfQ0xBU1NfTkFNRSA9ICd2anMtbW9kYWwtZGlhbG9nJztcbnZhciBFU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgYE1vZGFsRGlhbG9nYCBkaXNwbGF5cyBvdmVyIHRoZSB2aWRlbyBhbmQgaXRzIGNvbnRyb2xzLCB3aGljaCBibG9ja3NcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHBsYXllciB1bnRpbCBpdCBpcyBjbG9zZWQuXG4gKlxuICogTW9kYWwgZGlhbG9ncyBpbmNsdWRlIGEgXCJDbG9zZVwiIGJ1dHRvbiBhbmQgd2lsbCBjbG9zZSB3aGVuIHRoYXQgYnV0dG9uXG4gKiBpcyBhY3RpdmF0ZWQgLSBvciB3aGVuIEVTQyBpcyBwcmVzc2VkIGFueXdoZXJlLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNb2RhbERpYWxvZyA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vZGFsRGlhbG9nLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBbb3B0aW9ucy5jb250ZW50PXVuZGVmaW5lZF1cbiAgICogICAgICAgIFByb3ZpZGUgY3VzdG9taXplZCBjb250ZW50IGZvciB0aGlzIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGVzY3JpcHRpb25dXG4gICAqICAgICAgICBBIHRleHQgZGVzY3JpcHRpb24gZm9yIHRoZSBtb2RhbCwgcHJpbWFyaWx5IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbGxBbHdheXM9ZmFsc2VdXG4gICAqICAgICAgICBOb3JtYWxseSwgbW9kYWxzIGFyZSBhdXRvbWF0aWNhbGx5IGZpbGxlZCBvbmx5IHRoZSBmaXJzdCB0aW1lXG4gICAqICAgICAgICB0aGV5IG9wZW4uIFRoaXMgdGVsbHMgdGhlIG1vZGFsIHRvIHJlZnJlc2ggaXRzIGNvbnRlbnRcbiAgICogICAgICAgIGV2ZXJ5IHRpbWUgaXQgb3BlbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF1cbiAgICogICAgICAgIEEgdGV4dCBsYWJlbCBmb3IgdGhlIG1vZGFsLCBwcmltYXJpbHkgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGVtcG9yYXJ5PXRydWVdXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSBtb2RhbCBjYW4gb25seSBiZSBvcGVuZWQgb25jZTsgaXQgd2lsbCBiZVxuICAgKiAgICAgICAgZGlzcG9zZWQgYXMgc29vbiBhcyBpdCdzIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmNsb3NlYWJsZT1mYWxzZV1cbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBjbG9zZSB0aGUgbW9kYWxcbiAgICogICAgICAgIHRocm91Z2ggdGhlIFVJIGluIHRoZSBub3JtYWwgd2F5cy4gUHJvZ3JhbW1hdGljIGNsb3NpbmcgaXNcbiAgICogICAgICAgIHN0aWxsIHBvc3NpYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gTW9kYWxEaWFsb2cocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxEaWFsb2cpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vcGVuZWRfID0gX3RoaXMuaGFzQmVlbk9wZW5lZF8gPSBfdGhpcy5oYXNCZWVuRmlsbGVkXyA9IGZhbHNlO1xuXG4gICAgX3RoaXMuY2xvc2VhYmxlKCFfdGhpcy5vcHRpb25zXy51bmNsb3NlYWJsZSk7XG4gICAgX3RoaXMuY29udGVudChfdGhpcy5vcHRpb25zXy5jb250ZW50KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGVudEVsIGlzIGRlZmluZWQgQUZURVIgYW55IGNoaWxkcmVuIGFyZSBpbml0aWFsaXplZFxuICAgIC8vIGJlY2F1c2Ugd2Ugb25seSB3YW50IHRoZSBjb250ZW50cyBvZiB0aGUgbW9kYWwgaW4gdGhlIGNvbnRlbnRFbFxuICAgIC8vIChub3QgdGhlIFVJIGVsZW1lbnRzIGxpa2UgdGhlIGNsb3NlIGJ1dHRvbikuXG4gICAgX3RoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IE1PREFMX0NMQVNTX05BTUUgKyAnLWNvbnRlbnQnXG4gICAgfSwge1xuICAgICAgcm9sZTogJ2RvY3VtZW50J1xuICAgIH0pO1xuXG4gICAgX3RoaXMuZGVzY0VsXyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1kZXNjcmlwdGlvbiB2anMtY29udHJvbC10ZXh0JyxcbiAgICAgIGlkOiBfdGhpcy5lbCgpLmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXG4gICAgfSk7XG5cbiAgICB0ZXh0Q29udGVudChfdGhpcy5kZXNjRWxfLCBfdGhpcy5kZXNjcmlwdGlvbigpKTtcbiAgICBfdGhpcy5lbF8uYXBwZW5kQ2hpbGQoX3RoaXMuZGVzY0VsXyk7XG4gICAgX3RoaXMuZWxfLmFwcGVuZENoaWxkKF90aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNb2RhbERpYWxvZ2AncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5pZCgpICsgJ19kZXNjcmlwdGlvbicsXG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWwoKSxcbiAgICAgICdyb2xlJzogJ2RpYWxvZydcbiAgICB9KTtcbiAgfTtcblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcbiAgICB0aGlzLmRlc2NFbF8gPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIE1PREFMX0NMQVNTX05BTUUgKyAnIHZqcy1oaWRkZW4gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBga2V5ZG93bmAgZXZlbnRzIG9uIHRoZSBkb2N1bWVudCwgbG9va2luZyBmb3IgRVNDLCB3aGljaCBjbG9zZXNcbiAgICogdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBlXG4gICAqICAgICAgICBUaGUga2V5cHJlc3MgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGUpIHtcbiAgICBpZiAoZS53aGljaCA9PT0gRVNDICYmIHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhYmVsIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICB0aGUgbG9jYWxpemVkIG9yIHJhdyBsYWJlbCBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwgfHwgJ01vZGFsIFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvclxuICAgKiBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGxvY2FsaXplZCBvciByYXcgZGVzY3JpcHRpb24gb2YgdGhpcyBtb2RhbC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgZGVzYyA9IHRoaXMub3B0aW9uc18uZGVzY3JpcHRpb24gfHwgdGhpcy5sb2NhbGl6ZSgnVGhpcyBpcyBhIG1vZGFsIHdpbmRvdy4nKTtcblxuICAgIC8vIEFwcGVuZCBhIHVuaXZlcnNhbCBjbG9zZWFiaWxpdHkgbWVzc2FnZSBpZiB0aGUgbW9kYWwgaXMgY2xvc2VhYmxlLlxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICBkZXNjICs9ICcgJyArIHRoaXMubG9jYWxpemUoJ1RoaXMgbW9kYWwgY2FuIGJlIGNsb3NlZCBieSBwcmVzc2luZyB0aGUgRXNjYXBlIGtleSBvciBhY3RpdmF0aW5nIHRoZSBjbG9zZSBidXR0b24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxvcGVuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgICAgLyoqXG4gICAgICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsb3BlbicpO1xuICAgICAgdGhpcy5vcGVuZWRfID0gdHJ1ZTtcblxuICAgICAgLy8gRmlsbCBjb250ZW50IGlmIHRoZSBtb2RhbCBoYXMgbmV2ZXIgb3BlbmVkIGJlZm9yZSBhbmRcbiAgICAgIC8vIG5ldmVyIGJlZW4gZmlsbGVkLlxuICAgICAgaWYgKHRoaXMub3B0aW9uc18uZmlsbEFsd2F5cyB8fCAhdGhpcy5oYXNCZWVuT3BlbmVkXyAmJiAhdGhpcy5oYXNCZWVuRmlsbGVkXykge1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBsYXllciB3YXMgcGxheWluZywgcGF1c2UgaXQgYW5kIHRha2Ugbm90ZSBvZiBpdHMgcHJldmlvdXNseVxuICAgICAgLy8gcGxheWluZyBzdGF0ZS5cbiAgICAgIHRoaXMud2FzUGxheWluZ18gPSAhcGxheWVyLnBhdXNlZCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5wYXVzZU9uT3BlbiAmJiB0aGlzLndhc1BsYXlpbmdfKSB7XG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgICB0aGlzLm9uKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhpZGUgY29udHJvbHMgYW5kIG5vdGUgaWYgdGhleSB3ZXJlIGVuYWJsZWQuXG4gICAgICB0aGlzLmhhZENvbnRyb2xzXyA9IHBsYXllci5jb250cm9scygpO1xuICAgICAgcGxheWVyLmNvbnRyb2xzKGZhbHNlKTtcblxuICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB0aGlzLmNvbmRpdGlvbmFsRm9jdXNfKCk7XG4gICAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAvKipcbiAgICAgICAgKiBGaXJlZCBqdXN0IGFmdGVyIGEgYE1vZGFsRGlhbG9nYCBpcyBvcGVuZWQuXG4gICAgICAgICpcbiAgICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxvcGVuXG4gICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RhbG9wZW4nKTtcbiAgICAgIHRoaXMuaGFzQmVlbk9wZW5lZF8gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSWYgdGhlIGBNb2RhbERpYWxvZ2AgaXMgY3VycmVudGx5IG9wZW4gb3IgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZ2l2ZW4sIGl0IHdpbGwgb3BlbiAoYHRydWVgKSBvciBjbG9zZSAoYGZhbHNlYCkgdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgdGhlIG1vZGFsZGlhbG9nXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW5lZCA9IGZ1bmN0aW9uIG9wZW5lZCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpc1t2YWx1ZSA/ICdvcGVuJyA6ICdjbG9zZSddKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wZW5lZF87XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwsIGRvZXMgbm90aGluZyBpZiB0aGUgYE1vZGFsRGlhbG9nYCBpc1xuICAgKiBub3Qgb3Blbi5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsY2xvc2VcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsY2xvc2VcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgIC8qKlxuICAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxuICAgICAgKlxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxjbG9zZScpO1xuICAgIHRoaXMub3BlbmVkXyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMud2FzUGxheWluZ18gJiYgdGhpcy5vcHRpb25zXy5wYXVzZU9uT3Blbikge1xuICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgdGhpcy5vZmYodGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYWRDb250cm9sc18pIHtcbiAgICAgIHBsYXllci5jb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvKipcbiAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxuICAgICAgKlxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxjbG9zZScpO1xuICAgIHRoaXMuY29uZGl0aW9uYWxCbHVyXygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udGVtcG9yYXJ5KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWFibGUgdmlhIHRoZSBVSS5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuIGFzIGEgYm9vbGVhbiwgaXQgd2lsbCBzZXQgdGhlIGBjbG9zZWFibGVgIG9wdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgY2xvc2FibGUgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZWFibGUgPSBmdW5jdGlvbiBjbG9zZWFibGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHZhciBjbG9zZWFibGUgPSB0aGlzLmNsb3NlYWJsZV8gPSAhIXZhbHVlO1xuICAgICAgdmFyIGNsb3NlID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBiZWluZyBtYWRlIGNsb3NlYWJsZSBhbmQgaGFzIG5vIGNsb3NlIGJ1dHRvbiwgYWRkIG9uZS5cbiAgICAgIGlmIChjbG9zZWFibGUgJiYgIWNsb3NlKSB7XG5cbiAgICAgICAgLy8gVGhlIGNsb3NlIGJ1dHRvbiBzaG91bGQgYmUgYSBjaGlsZCBvZiB0aGUgbW9kYWwgLSBub3QgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgZWxlbWVudCwgc28gdGVtcG9yYXJpbHkgY2hhbmdlIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5jb250ZW50RWxfO1xuXG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRoaXMuZWxfO1xuICAgICAgICBjbG9zZSA9IHRoaXMuYWRkQ2hpbGQoJ2Nsb3NlQnV0dG9uJywgeyBjb250cm9sVGV4dDogJ0Nsb3NlIE1vZGFsIERpYWxvZycgfSk7XG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRlbXA7XG4gICAgICAgIHRoaXMub24oY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgdW5jbG9zZWFibGUgYW5kIGhhcyBhIGNsb3NlIGJ1dHRvbiwgcmVtb3ZlIGl0LlxuICAgICAgaWYgKCFjbG9zZWFibGUgJiYgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vZmYoY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNsb3NlKTtcbiAgICAgICAgY2xvc2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZWFibGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIHRoZSBtb2RhbCdzIFwiY29udGVudFwiIG9wdGlvbi5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCgpIHtcbiAgICB0aGlzLmZpbGxXaXRoKHRoaXMuY29udGVudCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCBhcmJpdHJhcnkgY29udGVudC5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRlbnRdXG4gICAqICAgICAgICBUaGUgc2FtZSBydWxlcyBhcHBseSB0byB0aGlzIGFzIGFwcGx5IHRvIHRoZSBgY29udGVudGAgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsV2l0aCA9IGZ1bmN0aW9uIGZpbGxXaXRoKGNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwoKTtcbiAgICB2YXIgcGFyZW50RWwgPSBjb250ZW50RWwucGFyZW50Tm9kZTtcbiAgICB2YXIgbmV4dFNpYmxpbmdFbCA9IGNvbnRlbnRFbC5uZXh0U2libGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBmaWxsZWQgd2l0aCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZmlsbFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZmlsbCcpO1xuICAgIHRoaXMuaGFzQmVlbkZpbGxlZF8gPSB0cnVlO1xuXG4gICAgLy8gRGV0YWNoIHRoZSBjb250ZW50IGVsZW1lbnQgZnJvbSB0aGUgRE9NIGJlZm9yZSBwZXJmb3JtaW5nXG4gICAgLy8gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyB0aGUgbGl2ZSBET00gbXVsdGlwbGUgdGltZXMuXG4gICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQoY29udGVudEVsKTtcbiAgICB0aGlzLmVtcHR5KCk7XG4gICAgaW5zZXJ0Q29udGVudChjb250ZW50RWwsIGNvbnRlbnQpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxmaWxsJyk7XG5cbiAgICAvLyBSZS1pbmplY3QgdGhlIHJlLWZpbGxlZCBjb250ZW50IGVsZW1lbnQuXG4gICAgaWYgKG5leHRTaWJsaW5nRWwpIHtcbiAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShjb250ZW50RWwsIG5leHRTaWJsaW5nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zZSBidXR0b24gaXMgbGFzdCBpbiB0aGUgZGlhbG9nIERPTVxuICAgIHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuZ2V0Q2hpbGQoJ2Nsb3NlQnV0dG9uJyk7XG5cbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBjb250ZW50IGVsZW1lbnQuIFRoaXMgaGFwcGVucyBhbnl0aW1lIHRoZSBtb2RhbCBpcyBmaWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGVtcHRpZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxlbXB0eVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZW1wdHknKTtcbiAgICBlbXB0eUVsKHRoaXMuY29udGVudEVsKCkpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxlbXB0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG1vZGFsIGNvbnRlbnQsIHdoaWNoIGdldHMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogcmVuZGVyZWQgaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBUaGlzIGRvZXMgbm90IHVwZGF0ZSB0aGUgRE9NIG9yIGZpbGwgdGhlIG1vZGFsLCBidXQgaXQgaXMgY2FsbGVkIGR1cmluZ1xuICAgKiB0aGF0IHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge01peGVkfSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZGVmaW5lZCwgc2V0cyB0aGUgaW50ZXJuYWwgY29udGVudCB2YWx1ZSB0byBiZSB1c2VkIG9uIHRoZVxuICAgKiAgICAgICAgIG5leHQgY2FsbChzKSB0byBgZmlsbGAuIFRoaXMgdmFsdWUgaXMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogICAgICAgICBpbnNlcnRlZC4gVG8gXCJjbGVhclwiIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlLCBwYXNzIGBudWxsYC5cbiAgICpcbiAgICogQHJldHVybiB7TWl4ZWR9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgbW9kYWwgZGlhbG9nXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuY29udGVudF8gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbmRpdGlvbmFsbHkgZm9jdXMgdGhlIG1vZGFsIGRpYWxvZyBpZiBmb2N1cyB3YXMgcHJldmlvdXNseSBvbiB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEZvY3VzXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsRm9jdXNfKCkge1xuICAgIHZhciBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdmFyIHBsYXllckVsID0gdGhpcy5wbGF5ZXJfLmVsXztcblxuICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG5cbiAgICBpZiAocGxheWVyRWwuY29udGFpbnMoYWN0aXZlRWwpIHx8IHBsYXllckVsID09PSBhY3RpdmVFbCkge1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gYWN0aXZlRWw7XG5cbiAgICAgIHRoaXMuZm9jdXMoKTtcblxuICAgICAgdGhpcy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8uZm9jdXMoKTtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgfTtcblxuICAvKipcbiAgICogS2V5ZG93biBoYW5kbGVyLiBBdHRhY2hlZCB3aGVuIG1vZGFsIGlzIGZvY3VzZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAvLyBleGl0IGVhcmx5IGlmIGl0IGlzbid0IGEgdGFiIGtleVxuICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmb2N1c2FibGVFbHMgPSB0aGlzLmZvY3VzYWJsZUVsc18oKTtcbiAgICB2YXIgYWN0aXZlRWwgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yKCc6Zm9jdXMnKTtcbiAgICB2YXIgZm9jdXNJbmRleCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0aXZlRWwgPT09IGZvY3VzYWJsZUVsc1tpXSkge1xuICAgICAgICBmb2N1c0luZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZWxfKSB7XG4gICAgICBmb2N1c0luZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNJbmRleCA9PT0gMCkge1xuICAgICAgZm9jdXNhYmxlRWxzW2ZvY3VzYWJsZUVscy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSBmb2N1c2FibGVFbHMubGVuZ3RoIC0gMSkge1xuICAgICAgZm9jdXNhYmxlRWxzWzBdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZm9jdXNhYmxlRWxzXyA9IGZ1bmN0aW9uIGZvY3VzYWJsZUVsc18oKSB7XG4gICAgdmFyIGFsbENoaWxkcmVuID0gdGhpcy5lbF8ucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhbGxDaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBbmNob3JFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBcmVhRWxlbWVudCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdocmVmJykgfHwgKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJbnB1dEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQnV0dG9uRWxlbWVudCkgJiYgIWNoaWxkLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MT2JqZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRW1iZWRFbGVtZW50IHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgIT09IC0xIHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vZGFsRGlhbG9nO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYE1vZGFsRGlhbG9nYCBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Nb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIHBhdXNlT25PcGVuOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IHRydWVcbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW9kYWxEaWFsb2cnLCBNb2RhbERpYWxvZyk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbmFsaXkgYmV0d2VlbiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0sIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIGFuZFxuICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICpcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2tMaXN0LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrW119IHRyYWNrc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIHRyYWNrcyB0byBpbml0aWFsaXplIHRoZSBsaXN0IHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdF1cbiAgICogICAgICAgIFRoZSBjaGlsZCBvYmplY3Qgd2l0aCBpbmhlcml0YW5jZSBkb25lIG1hbnVhbGx5IGZvciBpZTguXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0xpc3QpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKElTX0lFOCkge1xuICAgICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja0xpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QuYWRkVHJhY2sodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBtdXN0IHJldHVybiB0aGUgb2JqZWN0LCBhcyBmb3IgaWU4IGl0IHdpbGwgbm90IGJlIHRoaXNcbiAgICAvLyBidXQgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCBvYmplY3RcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUcmFja30gdG8gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzX1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhZGQgZHVwbGljYXRlIHRyYWNrc1xuICAgIGlmICh0aGlzLnRyYWNrc18uaW5kZXhPZih0cmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYSB0cmFjayBsaXN0LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2t9IHRyYWNrXG4gICAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgdHlwZTogJ2FkZHRyYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgVHJhY2t9IGZyb20gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHJ0cmFja1xuICAgKiAgICAgICAgVGhlIGF1ZGlvLCB2aWRlbywgb3IgdGV4dCB0cmFjayB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhydHJhY2spIHtcbiAgICB2YXIgdHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gcnRyYWNrKSB7XG4gICAgICAgIHRyYWNrID0gdGhpc1tpXTtcbiAgICAgICAgaWYgKHRyYWNrLm9mZikge1xuICAgICAgICAgIHRyYWNrLm9mZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFja3NfLnNwbGljZShpLCAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyByZW1vdmVkIGZyb20gdHJhY2sgbGlzdC5cbiAgICAgKlxuICAgICAqIEBldmVudCBUcmFja0xpc3QjcmVtb3ZldHJhY2tcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgdHlwZTogJ3JlbW92ZXRyYWNrJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBUcmFjayBmcm9tIHRoZSBUcmFja0xpc3QgYnkgYSB0cmFja3MgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSB0cmFjayB0byBnZXRcbiAgICogQG1ldGhvZCBnZXRUcmFja0J5SWRcbiAgICogQHJldHVybiB7VHJhY2t9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbiBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0cmFjay5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRyYWNrTGlzdDtcbn0oRXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIFRyaWdnZXJlZCB3aGVuIGEgZGlmZmVyZW50IHRyYWNrIGlzIHNlbGVjdGVkL2VuYWJsZWQuXG4gKlxuICogQGV2ZW50IFRyYWNrTGlzdCNjaGFuZ2VcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEV2ZW50cyB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCBvbiArIGV2ZW50TmFtZS4gU2VlIHtAbGluayBFdmVudEhhbmRsZXJ9LlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBUcmFja0xpc3QjYWxsb3dlZEV2ZW50c19cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICBhZGR0cmFjazogJ2FkZHRyYWNrJyxcbiAgcmVtb3ZldHJhY2s6ICdyZW1vdmV0cmFjaydcbn07XG5cbi8vIGVtdWxhdGUgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBzdXBwb3J0IHRvIGFsbG93IGZvciBmZWF0dXJlIGRldGVjdGlvblxuZm9yICh2YXIgZXZlbnQgaW4gVHJhY2tMaXN0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXykge1xuICBUcmFja0xpc3QucHJvdG90eXBlWydvbicgKyBldmVudF0gPSBudWxsO1xufVxuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBBbnl3aGVyZSB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gd2UgZGl2ZXJnZSBmcm9tIHRoZSBzcGVjXG4gKiBhcyB3ZSBvbmx5IHN1cHBvcnQgb25lIGVuYWJsZWQgYXVkaW90cmFjayBhdCBhIHRpbWVcbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2tMaXN0fSBsaXN0XG4gKiAgICAgICAgbGlzdCB0byB3b3JrIG9uXG4gKlxuICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0cmFjayB0byBza2lwXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGRpc2FibGVPdGhlcnMgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciBhdWRpbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQXVkaW9UcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgQXVkaW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgQXVkaW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uZW5hYmxlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgQXVkaW9UcmFja30gdG8gdGhlIGBBdWRpb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBBdWRpb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5lbmFibGVkKSB7XG4gICAgICBkaXNhYmxlT3RoZXJzKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHdoZW4gd2UgYXJlIGRpc2FibGluZyBvdGhlciB0cmFja3MgKHNpbmNlIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1vcmUgdGhhbiBvbmUgdHJhY2sgYXQgYSB0aW1lKSB3ZSB3aWxsIHNldCBjaGFuZ2luZ19cbiAgICAgIC8vIHRvIHRydWUgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIGFkZGl0aW9uYWwgY2hhbmdlIGV2ZW50c1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby10cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogVW4tc2VsZWN0IGFsbCBvdGhlciB7QGxpbmsgVmlkZW9UcmFja31zIHRoYXQgYXJlIHNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyQxID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGFub3RoZXIgdmlkZW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxuICAgIGxpc3RbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBWaWRlb1RyYWNrfSBmb3IgYSB2aWRlby5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVmlkZW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVmlkZW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgZGlzYWJsZU90aGVycyQxKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFZpZGVvVHJhY2tMaXN0I3NlbGVjdGVkSW5kZXhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBzZWxlY3RlZCB7QGxpbmsgVmlkZW9UcmFja2B9LlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnc2VsZWN0ZWRJbmRleCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAodGhpc1tfaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFZpZGVvVHJhY2t9IHRvIHRoZSBgVmlkZW9UcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgVmlkZW9UcmFjayB0byBhZGQgdG8gdGhlIGxpc3RcbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHJhY2suc2VsZWN0ZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnMkMSh0aGlzLCB0cmFjayk7XG4gICAgfVxuXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG4gICAgLy8gbmF0aXZlIHRyYWNrcyBkb24ndCBoYXZlIHRoaXNcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIuY2hhbmdpbmdfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSB0cnVlO1xuICAgICAgZGlzYWJsZU90aGVycyQxKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWaWRlb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBUZXh0VHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVGV4dFRyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrTGlzdCgpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZVtfcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0ID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KSksIF90aGlzKTtcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUZXh0VHJhY2t9IHRvIHRoZSBgVGV4dFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KSk7XG5cbiAgICB2YXIgbm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kID0gWydtZXRhZGF0YScsICdjaGFwdGVycyddO1xuXG4gICAgaWYgKG5vbkxhbmd1YWdlVGV4dFRyYWNrS2luZC5pbmRleE9mKHRyYWNrLmtpbmQpID09PSAtMSkge1xuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LWxpc3QuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9cy5cbiAqL1xuXG52YXIgSHRtbFRyYWNrRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnRbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgSHRtbFRyYWNrRWxlbWVudGAgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEh0bWxUcmFja0VsZW1lbnRMaXN0KCkge1xuICAgIHZhciB0cmFja0VsZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVHJhY2tFbGVtZW50TGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdC50cmFja0VsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEh0bWxUcmFja0VsZW1lbnRMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVHJhY2tgcyBpbiB0aGUgdGhpcyBUcmFja2lzdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9IHRvIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmFkZFRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiBhZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoO1xuXG4gICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHNcbiAgICBpZiAodGhpcy50cmFja0VsZW1lbnRzXy5pbmRleE9mKHRyYWNrRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnB1c2godHJhY2tFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YCBnaXZlbiBhblxuICAgKiB7QGxpbmsgVGV4dFRyYWNrfS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIGEgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyA9IGZ1bmN0aW9uIGdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudF8gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldLnRyYWNrKSB7XG4gICAgICAgIHRyYWNrRWxlbWVudF8gPSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFja0VsZW1lbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnR9IHRyYWNrRWxlbWVudFxuICAgKiAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiByZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tFbGVtZW50ID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldKSB7XG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50c18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSHRtbFRyYWNrRWxlbWVudExpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1jdWUtbGlzdC5qc1xuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXG4gKiAgICAgICAgICAgVGhlIHVuaXF1ZSBpZCBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFRpbWVcbiAqICAgICAgICAgICBUaGUgc3RhcnQgdGltZSBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRUaW1lXG4gKiAgICAgICAgICAgVGhlIGVuZCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZU9uRXhpdFxuICogICAgICAgICAgIFBhdXNlIHdoZW4gdGhlIGVuZCB0aW1lIGlzIHJlYWNoZWQgaWYgdHJ1ZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlfVxuICovXG5cbi8qKlxuICogQSBMaXN0IG9mIFRleHRUcmFja0N1ZXMuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2N1ZWxpc3R9XG4gKi9cblxudmFyIFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIGN1ZXMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aFxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQ3VlTGlzdChjdWVzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfLmNhbGwobGlzdCwgY3Vlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrQ3VlTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRleHRUcmFja0N1ZWBzIGluIHRoZSBUZXh0VHJhY2tDdWVMaXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aF87XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIGN1ZXMgaW4gdGhpcyBsaXN0LiBDcmVhdGVzIGdldHRlcnNcbiAgICogYW4gYW4gaW5kZXggZm9yIHRoZSBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBjdWVzIHRvIHNldFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfID0gZnVuY3Rpb24gc2V0Q3Vlc18oY3Vlcykge1xuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbCA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jdWVzXyA9IGN1ZXM7XG4gICAgdGhpcy5sZW5ndGhfID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVmaW5lUHJvcCA9IGZ1bmN0aW9uIGRlZmluZVByb3AoaW5kZXgpIHtcbiAgICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICcnICsgaW5kZXgsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1ZXNfW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob2xkTGVuZ3RoIDwgbCkge1xuICAgICAgaSA9IG9sZExlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZGVmaW5lUHJvcC5jYWxsKHRoaXMsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYFRleHRUcmFja0N1ZWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGBUZXh0VHJhY2tDdWVMaXN0YCBieSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGN1ZSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlfG51bGx9XG4gICAqICAgICAgICAgQSBzaW5nbGUgY3VlIG9yIG51bGwgaWYgbm9uZSB3YXMgZm91bmQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuZ2V0Q3VlQnlJZCA9IGZ1bmN0aW9uIGdldEN1ZUJ5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzW2ldO1xuXG4gICAgICBpZiAoY3VlLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSBjdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0N1ZUxpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2sta2luZHMuanNcbiAqL1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVmlkZW9UcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS12aWRlb3RyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFZpZGVvVHJhY2t+S2luZFxuICogQGVudW1cbiAqL1xudmFyIFZpZGVvVHJhY2tLaW5kID0ge1xuICBhbHRlcm5hdGl2ZTogJ2FsdGVybmF0aXZlJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIG1haW46ICdtYWluJyxcbiAgc2lnbjogJ3NpZ24nLFxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjb21tZW50YXJ5OiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBBdWRpb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLWF1ZGlvdHJhY2sta2luZFxuICogQHR5cGVkZWYgQXVkaW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgQXVkaW9UcmFja0tpbmQgPSB7XG4gICdhbHRlcm5hdGl2ZSc6ICdhbHRlcm5hdGl2ZScsXG4gICdkZXNjcmlwdGlvbnMnOiAnZGVzY3JpcHRpb25zJyxcbiAgJ21haW4nOiAnbWFpbicsXG4gICdtYWluLWRlc2MnOiAnbWFpbi1kZXNjJyxcbiAgJ3RyYW5zbGF0aW9uJzogJ3RyYW5zbGF0aW9uJyxcbiAgJ2NvbW1lbnRhcnknOiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBUZXh0VHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tdGV4dHRyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFRleHRUcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrS2luZCA9IHtcbiAgc3VidGl0bGVzOiAnc3VidGl0bGVzJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIGRlc2NyaXB0aW9uczogJ2Rlc2NyaXB0aW9ucycsXG4gIGNoYXB0ZXJzOiAnY2hhcHRlcnMnLFxuICBtZXRhZGF0YTogJ21ldGFkYXRhJ1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja01vZGVgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja21vZGVcbiAqIEB0eXBlZGVmIFRleHRUcmFja35Nb2RlXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrTW9kZSA9IHtcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIHNob3dpbmc6ICdzaG93aW5nJ1xufTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay5qc1xuICovXG4vKipcbiAqIEEgVHJhY2sgY2xhc3MgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciB7QGxpbmsgQXVkaW9UcmFja30sXG4gKiB7QGxpbmsgVmlkZW9UcmFja30sIGFuZCB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiA+IE5vdGU6IFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sfVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBhYnN0cmFjdFxuICovXG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGtpbmQgZm9yIHRoZSB0cmFjayB0eXBlIHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFjayk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciB0cmFjayA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFRyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFja1Byb3BzID0ge1xuICAgICAgaWQ6IG9wdGlvbnMuaWQgfHwgJ3Zqc190cmFja18nICsgbmV3R1VJRCgpLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kIHx8ICcnLFxuICAgICAgbGFiZWw6IG9wdGlvbnMubGFiZWwgfHwgJycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCAnJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGlkXG4gICAgICogICAgICAgICBUaGUgaWQgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2luZFxuICAgICAqICAgICAgICAgVGhlIGtpbmQgb2YgdHJhY2sgdGhhdCB0aGlzIGlzLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxuICAgICAqICAgICAgICAgVGhlIGxhYmVsIG9mIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICogICAgICAgICBUaGUgdHdvIGxldHRlciBsYW5ndWFnZSBjb2RlIGZvciB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrUHJvcHNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja1Byb3BzKSB7XG4gICAgICBfbG9vcChrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogQGZpbGUgdXJsLmpzXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHVybDpVUkxPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvdG9jb2xcbiAqICAgICAgICAgICBUaGUgcHJvdG9jb2wgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RuYW1lXG4gKiAgICAgICAgICAgVGhlIGhvc3RuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwb3J0XG4gKiAgICAgICAgICAgVGhlIHBvcnQgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhuYW1lXG4gKiAgICAgICAgICAgVGhlIHBhdGhuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWFyY2hcbiAqICAgICAgICAgICBUaGUgc2VhcmNoIHF1ZXJ5IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoXG4gKiAgICAgICAgICAgVGhlIGhhc2ggb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RcbiAqICAgICAgICAgICBUaGUgaG9zdCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqL1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxuICogICAgICAgICBUaGUgdXJsIHRvIHBhcnNlXG4gKlxuICogQHJldHVybiB7dXJsOlVSTE9iamVjdH1cbiAqICAgICAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXG4gKi9cbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xuXG4gIC8vIGFkZCB0aGUgdXJsIHRvIGFuIGFuY2hvciBhbmQgbGV0IHRoZSBicm93c2VyIHBhcnNlIHRoZSBVUkxcbiAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgYS5ocmVmID0gdXJsO1xuXG4gIC8vIElFOCAoYW5kIDk/KSBGaXhcbiAgLy8gaWU4IGRvZXNuJ3QgcGFyc2UgdGhlIFVSTCBjb3JyZWN0bHkgdW50aWwgdGhlIGFuY2hvciBpcyBhY3R1YWxseVxuICAvLyBhZGRlZCB0byB0aGUgYm9keSwgYW5kIGFuIGlubmVySFRNTCBpcyBuZWVkZWQgdG8gdHJpZ2dlciB0aGUgcGFyc2luZ1xuICB2YXIgYWRkVG9Cb2R5ID0gYS5ob3N0ID09PSAnJyAmJiBhLnByb3RvY29sICE9PSAnZmlsZTonO1xuICB2YXIgZGl2ID0gdm9pZCAwO1xuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPjwvYT4nO1xuICAgIGEgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAvLyBwcmV2ZW50IHRoZSBkaXYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOyBwb3NpdGlvbjphYnNvbHV0ZTsnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIH1cblxuICAvLyBDb3B5IHRoZSBzcGVjaWZpYyBVUkwgcHJvcGVydGllcyB0byBhIG5ldyBvYmplY3RcbiAgLy8gVGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgSUU4IGJlY2F1c2UgdGhlIGFuY2hvciBsb3NlcyBpdHNcbiAgLy8gcHJvcGVydGllcyB3aGVuIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgdmFyIGRldGFpbHMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGV0YWlsc1twcm9wc1tpXV0gPSBhW3Byb3BzW2ldXTtcbiAgfVxuXG4gIC8vIElFOSBhZGRzIHRoZSBwb3J0IHRvIHRoZSBob3N0IHByb3BlcnR5IHVubGlrZSBldmVyeW9uZSBlbHNlLiBJZlxuICAvLyBhIHBvcnQgaWRlbnRpZmllciBpcyBhZGRlZCBmb3Igc3RhbmRhcmQgcG9ydHMsIHN0cmlwIGl0LlxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86ODAkLywgJycpO1xuICB9XG5cbiAgaWYgKGRldGFpbHMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo0NDMkLywgJycpO1xuICB9XG5cbiAgaWYgKCFkZXRhaWxzLnByb3RvY29sKSB7XG4gICAgZGV0YWlscy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgfVxuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cblxuICByZXR1cm4gZGV0YWlscztcbn07XG5cbi8qKlxuICogR2V0IGFic29sdXRlIHZlcnNpb24gb2YgcmVsYXRpdmUgVVJMLiBVc2VkIHRvIHRlbGwgZmxhc2ggY29ycmVjdCBVUkwuXG4gKlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gKiAgICAgICAgIFVSTCB0byBtYWtlIGFic29sdXRlXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBBYnNvbHV0ZSBVUkxcbiAqXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDcwODMyL2dldHRpbmctYW4tYWJzb2x1dGUtdXJsLWZyb20tYS1yZWxhdGl2ZS1vbmUtaWU2LWlzc3VlXG4gKi9cbnZhciBnZXRBYnNvbHV0ZVVSTCA9IGZ1bmN0aW9uIGdldEFic29sdXRlVVJMKHVybCkge1xuICAvLyBDaGVjayBpZiBhYnNvbHV0ZSBVUkxcbiAgaWYgKCF1cmwubWF0Y2goL15odHRwcz86XFwvXFwvLykpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGFic29sdXRlIFVSTC4gRmxhc2ggaG9zdGVkIG9mZi1zaXRlIG5lZWRzIGFuIGFic29sdXRlIFVSTC5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPng8L2E+JztcbiAgICB1cmwgPSBkaXYuZmlyc3RDaGlsZC5ocmVmO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW5zaW9uIG9mIHRoZSBwYXNzZWQgZmlsZSBuYW1lLiBJdCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmdcbiAqIGlmIHBhc3NlZCBhbiBpbnZhbGlkIHBhdGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqICAgICAgICBUaGUgZmlsZU5hbWUgcGF0aCBsaWtlICcvcGF0aC90by9maWxlLm1wNCdcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICAgICAgICAgVGhlIGV4dGVuc2lvbiBpbiBsb3dlciBjYXNlIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub1xuICogICAgICAgICAgZXh0ZW5zaW9uIGNvdWxkIGJlIGZvdW5kLlxuICovXG52YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvPykoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz8pKFxcLihbXlxcLlxcL1xcP10rKSkpKD86W1xcL10qfFtcXD9dLiopJC9pO1xuICAgIHZhciBwYXRoUGFydHMgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpO1xuXG4gICAgaWYgKHBhdGhQYXJ0cykge1xuICAgICAgcmV0dXJuIHBhdGhQYXJ0cy5wb3AoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB1cmwgcGFzc2VkIGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqICAgICAgICBUaGUgdXJsIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgaXQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKi9cbnZhciBpc0Nyb3NzT3JpZ2luID0gZnVuY3Rpb24gaXNDcm9zc09yaWdpbih1cmwpIHtcbiAgdmFyIHdpbkxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgdmFyIHVybEluZm8gPSBwYXJzZVVybCh1cmwpO1xuXG4gIC8vIElFOCBwcm90b2NvbCByZWxhdGl2ZSB1cmxzIHdpbGwgcmV0dXJuICc6JyBmb3IgcHJvdG9jb2xcbiAgdmFyIHNyY1Byb3RvY29sID0gdXJsSW5mby5wcm90b2NvbCA9PT0gJzonID8gd2luTG9jLnByb3RvY29sIDogdXJsSW5mby5wcm90b2NvbDtcblxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxuICAvLyBJRTggZG9lc24ndCBrbm93IGxvY2F0aW9uLm9yaWdpbiwgc28gd2Ugd29uJ3QgcmVseSBvbiBpdCBoZXJlXG4gIHZhciBjcm9zc09yaWdpbiA9IHNyY1Byb3RvY29sICsgdXJsSW5mby5ob3N0ICE9PSB3aW5Mb2MucHJvdG9jb2wgKyB3aW5Mb2MuaG9zdDtcblxuICByZXR1cm4gY3Jvc3NPcmlnaW47XG59O1xuXG52YXIgVXJsID0gKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh7XG5cdHBhcnNlVXJsOiBwYXJzZVVybCxcblx0Z2V0QWJzb2x1dGVVUkw6IGdldEFic29sdXRlVVJMLFxuXHRnZXRGaWxlRXh0ZW5zaW9uOiBnZXRGaWxlRXh0ZW5zaW9uLFxuXHRpc0Nyb3NzT3JpZ2luOiBpc0Nyb3NzT3JpZ2luXG59KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLmpzXG4gKi9cbi8qKlxuICogVGFrZXMgYSB3ZWJ2dHQgZmlsZSBjb250ZW50cyBhbmQgcGFyc2VzIGl0IGludG8gY3Vlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNDb250ZW50XG4gKiAgICAgICAgd2ViVlRUIGZpbGUgY29udGVudHNcbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUZXh0VHJhY2sgdG8gYWRkIGN1ZXMgdG8uIEN1ZXMgY29tZSBmcm9tIHRoZSBzcmNDb250ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbiBwYXJzZUN1ZXMoc3JjQ29udGVudCwgdHJhY2spIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB3aW5kb3cuV2ViVlRULlBhcnNlcih3aW5kb3csIHdpbmRvdy52dHRqcywgd2luZG93LldlYlZUVC5TdHJpbmdEZWNvZGVyKCkpO1xuICB2YXIgZXJyb3JzID0gW107XG5cbiAgcGFyc2VyLm9uY3VlID0gZnVuY3Rpb24gKGN1ZSkge1xuICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xuICB9O1xuXG4gIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgfTtcblxuICBwYXJzZXIub25mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cmFjay50cmlnZ2VyKHtcbiAgICAgIHR5cGU6ICdsb2FkZWRkYXRhJyxcbiAgICAgIHRhcmdldDogdHJhY2tcbiAgICB9KTtcbiAgfTtcblxuICBwYXJzZXIucGFyc2Uoc3JjQ29udGVudCk7XG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xuICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoJ1RleHQgVHJhY2sgcGFyc2luZyBlcnJvcnMgZm9yICcgKyB0cmFjay5zcmMpO1xuICAgIH1cbiAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBsb2ckMS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlci5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBMb2FkIGEgYFRleHRUcmFja2AgZnJvbSBhIHNwZWNpZmVkIHVybC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXG4gKiAgICAgICAgVXJsIHRvIGxvYWQgdHJhY2sgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAqICAgICAgICBUcmFjayB0byBhZGQgY3VlcyB0by4gQ29tZXMgZnJvbSB0aGUgY29udGVudCBhdCB0aGUgZW5kIG9mIGB1cmxgLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBsb2FkVHJhY2sgPSBmdW5jdGlvbiBsb2FkVHJhY2soc3JjLCB0cmFjaykge1xuICB2YXIgb3B0cyA9IHtcbiAgICB1cmk6IHNyY1xuICB9O1xuICB2YXIgY3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luKHNyYyk7XG5cbiAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XG4gIH1cblxuICB4aHIob3B0cywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVyciwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdnR0anMgaGFzIGxvYWRlZCwgb3RoZXJ3aXNlLCB3YWl0IHRpbGwgaXQgZmluaXNoZWQgbG9hZGluZ1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgb25seSB1c2VkIGZvciB0aGUgYWx0L3ZpZGVvLm5vdnR0LmpzIGJ1aWxkXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHJhY2sudGVjaF8pIHtcbiAgICAgICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gbG9hZEhhbmRsZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNsb2FkZWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvZyQxLmVycm9yKCd2dHRqcyBmYWlsZWQgdG8gbG9hZCwgc3RvcHBpbmcgdHJ5aW5nIHRvIHByb2Nlc3MgJyArIHRyYWNrLnNyYyk7XG4gICAgICAgICAgdHJhY2sudGVjaF8ub2ZmKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlQ3VlcyhyZXNwb25zZUJvZHksIHRyYWNrKTtcbiAgICB9XG4gIH0pKTtcbn07XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgVGV4dFRyYWNrYC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgVGV4dFRyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhUZXh0VHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH0gb3B0aW9ucy50ZWNoXG4gICAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdGVjaCB0aGF0IG93bnMgdGhpcyBUZXh0VHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9J3N1YnRpdGxlcyddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+TW9kZX0gW29wdGlvbnMubW9kZT0nZGlzYWJsZWQnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjbGFuZz0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcbiAgICogICAgICAgIHZlc2lvbiBvZiBgb3B0aW9ucy5sYW5ndWFnZWBcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgdXJsIHRvIFRleHRUcmFjayBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIHNob3VsZCBkZWZhdWx0IHRvIG9uIG9yIG9mZi5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrKTtcblxuICAgIGlmICghb3B0aW9ucy50ZWNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGVjaCB3YXMgbm90IHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBUZXh0VHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJ3N1YnRpdGxlcycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcgfHwgJydcbiAgICB9KTtcbiAgICB2YXIgbW9kZSA9IFRleHRUcmFja01vZGVbc2V0dGluZ3MubW9kZV0gfHwgJ2Rpc2FibGVkJztcbiAgICB2YXIgZGVmYXVsdF8gPSBzZXR0aW5nc1snZGVmYXVsdCddO1xuXG4gICAgaWYgKHNldHRpbmdzLmtpbmQgPT09ICdtZXRhZGF0YScgfHwgc2V0dGluZ3Mua2luZCA9PT0gJ2NoYXB0ZXJzJykge1xuICAgICAgbW9kZSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHQgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcblxuICAgIHR0LnRlY2hfID0gc2V0dGluZ3MudGVjaDtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVGV4dFRyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHR0W3Byb3BdID0gVGV4dFRyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR0LmN1ZXNfID0gW107XG4gICAgdHQuYWN0aXZlQ3Vlc18gPSBbXTtcblxuICAgIHZhciBjdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QodHQuY3Vlc18pO1xuICAgIHZhciBhY3RpdmVDdWVzID0gbmV3IFRleHRUcmFja0N1ZUxpc3QodHQuYWN0aXZlQ3Vlc18pO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIHRpbWV1cGRhdGVIYW5kbGVyID0gYmluZCh0dCwgZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBBY2Nlc3NpbmcgdGhpcy5hY3RpdmVDdWVzIGZvciB0aGUgc2lkZS1lZmZlY3RzIG9mIHVwZGF0aW5nIGl0c2VsZlxuICAgICAgLy8gZHVlIHRvIGl0J3MgbmF0dXJlIGFzIGEgZ2V0dGVyIGZ1bmN0aW9uLiBEbyBub3QgcmVtb3ZlIG9yIGN1ZXMgd2lsbFxuICAgICAgLy8gc3RvcCB1cGRhdGluZyFcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgdGhpcy5hY3RpdmVDdWVzO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY3VlY2hhbmdlJyk7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChtb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICB0dC50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHR0LnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGRlZmF1bHRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgdHJhY2sgd2FzIHNldCB0byBiZSBvbiBvciBvZmYgYnkgZGVmYXVsdC4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXJcbiAgICAgKiAgICAgICAgIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnZGVmYXVsdCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdF87XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbW9kZVxuICAgICAqICAgICAgICAgU2V0IHRoZSBtb2RlIG9mIHRoaXMgVGV4dFRyYWNrIHRvIGEgdmFsaWQge0BsaW5rIFRleHRUcmFja35Nb2RlfS4gV2lsbFxuICAgICAqICAgICAgICAgbm90IGJlIHNldCBpZiBzZXR0aW5nIHRvIGFuIGludmFsaWQgbW9kZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ21vZGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3TW9kZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoIVRleHRUcmFja01vZGVbbmV3TW9kZV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IG5ld01vZGU7XG4gICAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcblxuICAgICAgICAgIHRoaXMudGVjaF8ucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gbW9kZSBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBUZXh0VHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyFcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW9kZWNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRleHRUcmFja1xuICAgICAqIEBtZW1iZXIge1RleHRUcmFja0N1ZUxpc3R9IGN1ZXNcbiAgICAgKiAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIGN1ZSBsaXN0IGZvciB0aGlzIFRleHRUcmFjay5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdjdWVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VlcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrQ3VlTGlzdH0gYWN0aXZlQ3Vlc1xuICAgICAqICAgICAgICAgVGhlIGxpc3QgdGV4dCB0cmFjayBjdWVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2FjdGl2ZUN1ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgaWYgKHRoaXMuY3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdCA9IHRoaXMudGVjaF8uY3VycmVudFRpbWUoKTtcbiAgICAgICAgdmFyIGFjdGl2ZSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNbaV07XG5cbiAgICAgICAgICBpZiAoY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuZW5kVGltZSA+PSBjdCkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPT09IGN1ZS5lbmRUaW1lICYmIGN1ZS5zdGFydFRpbWUgPD0gY3QgJiYgY3VlLnN0YXJ0VGltZSArIDAuNSA+PSBjdCkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggIT09IHRoaXMuYWN0aXZlQ3Vlc18ubGVuZ3RoKSB7XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFjdGl2ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUN1ZXNfLmluZGV4T2YoYWN0aXZlW19pXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWN0aXZlQ3Vlc18gPSBhY3RpdmU7XG4gICAgICAgIGFjdGl2ZUN1ZXMuc2V0Q3Vlc18odGhpcy5hY3RpdmVDdWVzXyk7XG5cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgIH0pO1xuXG4gICAgaWYgKHNldHRpbmdzLnNyYykge1xuICAgICAgdHQuc3JjID0gc2V0dGluZ3Muc3JjO1xuICAgICAgbG9hZFRyYWNrKHNldHRpbmdzLnNyYywgdHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0dC5sb2FkZWRfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IHR0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdWUgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+Q3VlfSBjdWVcbiAgICogICAgICAgIFRoZSBjdWUgdG8gYWRkIHRvIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5hZGRDdWUgPSBmdW5jdGlvbiBhZGRDdWUob3JpZ2luYWxDdWUpIHtcbiAgICB2YXIgY3VlID0gb3JpZ2luYWxDdWU7XG5cbiAgICBpZiAod2luZG93LnZ0dGpzICYmICEob3JpZ2luYWxDdWUgaW5zdGFuY2VvZiB3aW5kb3cudnR0anMuVlRUQ3VlKSkge1xuICAgICAgY3VlID0gbmV3IHdpbmRvdy52dHRqcy5WVFRDdWUob3JpZ2luYWxDdWUuc3RhcnRUaW1lLCBvcmlnaW5hbEN1ZS5lbmRUaW1lLCBvcmlnaW5hbEN1ZS50ZXh0KTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcmlnaW5hbEN1ZSkge1xuICAgICAgICBpZiAoIShwcm9wIGluIGN1ZSkpIHtcbiAgICAgICAgICBjdWVbcHJvcF0gPSBvcmlnaW5hbEN1ZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBgaWRgIGlzIGNvcGllZCBvdmVyXG4gICAgICBjdWUuaWQgPSBvcmlnaW5hbEN1ZS5pZDtcbiAgICAgIGN1ZS5vcmlnaW5hbEN1ZV8gPSBvcmlnaW5hbEN1ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZWNoXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrc1tpXSAhPT0gdGhpcykge1xuICAgICAgICB0cmFja3NbaV0ucmVtb3ZlQ3VlKGN1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jdWVzXy5wdXNoKGN1ZSk7XG4gICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjdWUgZnJvbSBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35DdWV9IHJlbW92ZUN1ZVxuICAgKiAgICAgICAgVGhlIGN1ZSB0byByZW1vdmUgZnJvbSBvdXIgaW50ZXJuYWwgbGlzdFxuICAgKi9cblxuXG4gIFRleHRUcmFjay5wcm90b3R5cGUucmVtb3ZlQ3VlID0gZnVuY3Rpb24gcmVtb3ZlQ3VlKF9yZW1vdmVDdWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuY3Vlc18ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc19baV07XG5cbiAgICAgIGlmIChjdWUgPT09IF9yZW1vdmVDdWUgfHwgY3VlLm9yaWdpbmFsQ3VlXyAmJiBjdWUub3JpZ2luYWxDdWVfID09PSBfcmVtb3ZlQ3VlKSB7XG4gICAgICAgIHRoaXMuY3Vlc18uc3BsaWNlKGksIDEpO1xuICAgICAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogY3VlY2hhbmdlIC0gT25lIG9yIG1vcmUgY3VlcyBpbiB0aGUgdHJhY2sgaGF2ZSBiZWNvbWUgYWN0aXZlIG9yIHN0b3BwZWQgYmVpbmcgYWN0aXZlLlxuICovXG5cblxuVGV4dFRyYWNrLnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgY3VlY2hhbmdlOiAnY3VlY2hhbmdlJ1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBBdWRpb1RyYWNrYC4gSWYgaXQgaXMgcGFydCBvZiBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gKiBvbmx5IG9uZSBgQXVkaW9UcmFja2AgaW4gdGhlIGxpc3Qgd2lsbCBiZSBlbmFibGVkIGF0IGEgdGltZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja31cbiAqIEBleHRlbmRzIFRyYWNrXG4gKi9cblxudmFyIEF1ZGlvVHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2ssIF9UcmFjayk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrfktpbmR9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGF1ZGlvIHRyYWNrIGtpbmRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZWRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIGlzIHRoZSBvbmUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZy4gSWYgdGhpcyB0cmFjayBpcyBwYXJ0IG9mXG4gICAqICAgICAgICBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LCBvbmx5IG9uZSB7QGxpbmsgQXVkaW9UcmFja30gd2lsbCBiZSBlbmFibGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFjaygpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFjayk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAga2luZDogQXVkaW9UcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnJ1xuICAgIH0pO1xuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0cmFjayA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuICAgIHZhciBlbmFibGVkID0gZmFsc2U7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIEF1ZGlvVHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHJhY2tbcHJvcF0gPSBBdWRpb1RyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYEF1ZGlvVHJhY2tgIGlzIGVuYWJsZWQgb3Igbm90LiBXaGVuIHNldHRpbmcgdGhpcyB3aWxsXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2V9IGlmIHRoZSBzdGF0ZSBvZiBlbmFibGVkIGlzIGNoYW5nZWQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ2VuYWJsZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3RW5hYmxlZCkge1xuICAgICAgICAvLyBhbiBpbnZhbGlkIG9yIHVuY2hhbmdlZCB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIG5ld0VuYWJsZWQgIT09ICdib29sZWFuJyB8fCBuZXdFbmFibGVkID09PSBlbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVuYWJsZWQgPSBuZXdFbmFibGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gZW5hYmxlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXG4gICAgICAgICAqIHRoZSBBdWRpb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgQXVkaW9UcmFjayNlbmFibGVkY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignZW5hYmxlZGNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgdGhlIHVzZXIgc2V0cyB0aGlzIHRyYWNrIHRvIHNlbGVjdGVkIHRoZW5cbiAgICAvLyBzZXQgc2VsZWN0ZWQgdG8gdGhhdCB0cnVlIHZhbHVlIG90aGVyd2lzZVxuICAgIC8vIHdlIGtlZXAgaXQgZmFsc2VcbiAgICBpZiAoc2V0dGluZ3MuZW5hYmxlZCkge1xuICAgICAgdHJhY2suZW5hYmxlZCA9IHNldHRpbmdzLmVuYWJsZWQ7XG4gICAgfVxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gQXVkaW9UcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFZpZGVvVHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgVmlkZW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoVmlkZW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQge0BsaW5rIFZpZGVvVHJhY2t+S2luZH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgQXVkaW9UcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbGVjdGVkXVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBWaWRlb1RyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWaWRlb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBWaWRlb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG5cbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcbiAgICB2YXIgdHJhY2sgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVmlkZW9UcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFZpZGVvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFZpZGVvVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqICAgICAgICAgSWYgdGhpcyBgVmlkZW9UcmFja2AgaXMgc2VsZWN0ZWQgb3Igbm90LiBXaGVuIHNldHRpbmcgdGhpcyB3aWxsXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2Ygc2VsZWN0ZWQgY2hhbmdlZC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCAnc2VsZWN0ZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld1NlbGVjdGVkKSB7XG4gICAgICAgIC8vIGFuIGludmFsaWQgb3IgdW5jaGFuZ2VkIHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgbmV3U2VsZWN0ZWQgIT09ICdib29sZWFuJyB8fCBuZXdTZWxlY3RlZCA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWQgPSBuZXdTZWxlY3RlZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIHNlbGVjdGVkIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIFZpZGVvVHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyEgTmF0aXZlIHRyYWNrcyB3aWxsIGRvXG4gICAgICAgICAqICAgICAgICAgdGhpcyBpbnRlcm5hbGx5IHdpdGhvdXQgYW4gZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0ZWRjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXG4gICAgLy8gc2V0IHNlbGVjdGVkIHRvIHRoYXQgdHJ1ZSB2YWx1ZSBvdGhlcndpc2VcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXG4gICAgaWYgKHNldHRpbmdzLnNlbGVjdGVkKSB7XG4gICAgICB0cmFjay5zZWxlY3RlZCA9IHNldHRpbmdzLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIFZpZGVvVHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sLXRyYWNrLWVsZW1lbnQuanNcbiAqL1xuXG4vKipcbiAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gKiBAdHlwZWRlZiB7SFRNTFRyYWNrRWxlbWVudH5SZWFkeVN0YXRlfVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIE5PTkUgPSAwO1xudmFyIExPQURJTkcgPSAxO1xudmFyIExPQURFRCA9IDI7XG52YXIgRVJST1IgPSAzO1xuXG4vKipcbiAqIEEgc2luZ2xlIHRyYWNrIHJlcHJlc2VudGVkIGluIHRoZSBET00uXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2h0bWx0cmFja2VsZW1lbnR9XG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5cbnZhciBIVE1MVHJhY2tFbGVtZW50ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xuICBpbmhlcml0cyhIVE1MVHJhY2tFbGVtZW50LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e31cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h9IG9wdGlvbnMudGVjaFxuICAgKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHRlY2ggdGhhdCBvd25zIHRoaXMgSFRNTFRyYWNrRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gSFRNTFRyYWNrRWxlbWVudCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTFRyYWNrRWxlbWVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciByZWFkeVN0YXRlID0gdm9pZCAwO1xuICAgIHZhciB0cmFja0VsZW1lbnQgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgdHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja0VsZW1lbnRbcHJvcF0gPSBIVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFjayA9IG5ldyBUZXh0VHJhY2sob3B0aW9ucyk7XG5cbiAgICB0cmFja0VsZW1lbnQua2luZCA9IHRyYWNrLmtpbmQ7XG4gICAgdHJhY2tFbGVtZW50LnNyYyA9IHRyYWNrLnNyYztcbiAgICB0cmFja0VsZW1lbnQuc3JjbGFuZyA9IHRyYWNrLmxhbmd1YWdlO1xuICAgIHRyYWNrRWxlbWVudC5sYWJlbCA9IHRyYWNrLmxhYmVsO1xuICAgIHRyYWNrRWxlbWVudFsnZGVmYXVsdCddID0gdHJhY2tbJ2RlZmF1bHQnXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gICAgICogQG1lbWJlciB7SFRNTFRyYWNrRWxlbWVudH5SZWFkeVN0YXRlfSByZWFkeVN0YXRlXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCByZWFkeSBzdGF0ZSBvZiB0aGUgdHJhY2sgZWxlbWVudC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tFbGVtZW50LCAncmVhZHlTdGF0ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcmVhZHlTdGF0ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrfSB0cmFja1xuICAgICAqICAgICAgICAgVGhlIHVuZGVybHlpbmcgVGV4dFRyYWNrIG9iamVjdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja0VsZW1lbnQsICd0cmFjaycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFkeVN0YXRlID0gTk9ORTtcblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIFRleHRUcmFjayNsb2FkZWRkYXRhXG4gICAgICogQGZpcmVzIEhUTUxUcmFja0VsZW1lbnQjbG9hZFxuICAgICAqL1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZWFkeVN0YXRlID0gTE9BREVEO1xuXG4gICAgICB0cmFja0VsZW1lbnQudHJpZ2dlcih7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgdGFyZ2V0OiB0cmFja0VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgIHJldHVybiBfcmV0ID0gdHJhY2tFbGVtZW50LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEhUTUxUcmFja0VsZW1lbnQ7XG59KEV2ZW50VGFyZ2V0KTtcblxuSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XG4gIGxvYWQ6ICdsb2FkJ1xufTtcblxuSFRNTFRyYWNrRWxlbWVudC5OT05FID0gTk9ORTtcbkhUTUxUcmFja0VsZW1lbnQuTE9BRElORyA9IExPQURJTkc7XG5IVE1MVHJhY2tFbGVtZW50LkxPQURFRCA9IExPQURFRDtcbkhUTUxUcmFja0VsZW1lbnQuRVJST1IgPSBFUlJPUjtcblxuLypcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbGwgdHJhY2sgcHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGluXG4gKiBwbGF5ZXIuanMsIHRlY2guanMsIGh0bWw1LmpzIGFuZCBwb3NzaWJseSBvdGhlciB0ZWNocyBpbiB0aGUgZnV0dXJlLlxuICovXG5cbnZhciBOT1JNQUwgPSB7XG4gIGF1ZGlvOiB7XG4gICAgTGlzdENsYXNzOiBBdWRpb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBBdWRpb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnQXVkaW8nXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgTGlzdENsYXNzOiBWaWRlb1RyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBWaWRlb1RyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVmlkZW8nXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnVGV4dCdcbiAgfVxufTtcblxuT2JqZWN0LmtleXMoTk9STUFMKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIE5PUk1BTFt0eXBlXS5nZXR0ZXJOYW1lID0gdHlwZSArICdUcmFja3MnO1xuICBOT1JNQUxbdHlwZV0ucHJpdmF0ZU5hbWUgPSB0eXBlICsgJ1RyYWNrc18nO1xufSk7XG5cbnZhciBSRU1PVEUgPSB7XG4gIHJlbW90ZVRleHQ6IHtcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxuICAgIGNhcGl0YWxOYW1lOiAnUmVtb3RlVGV4dCcsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja3MnLFxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrc18nXG4gIH0sXG4gIHJlbW90ZVRleHRFbDoge1xuICAgIExpc3RDbGFzczogSHRtbFRyYWNrRWxlbWVudExpc3QsXG4gICAgVHJhY2tDbGFzczogSFRNTFRyYWNrRWxlbWVudCxcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHRUcmFja0VscycsXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja0VscycsXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tFbHNfJ1xuICB9XG59O1xuXG52YXIgQUxMID0gbWVyZ2VPcHRpb25zKE5PUk1BTCwgUkVNT1RFKTtcblxuUkVNT1RFLm5hbWVzID0gT2JqZWN0LmtleXMoUkVNT1RFKTtcbk5PUk1BTC5uYW1lcyA9IE9iamVjdC5rZXlzKE5PUk1BTCk7XG5BTEwubmFtZXMgPSBbXS5jb25jYXQoUkVNT1RFLm5hbWVzKS5jb25jYXQoTk9STUFMLm5hbWVzKTtcblxuLyoqXG4gKiBAZmlsZSB0ZWNoLmpzXG4gKi9cblxuLyoqXG4gKiBBbiBPYmplY3QgY29udGFpbmluZyBhIHN0cnVjdHVyZSBsaWtlOiBge3NyYzogJ3VybCcsIHR5cGU6ICdtaW1ldHlwZSd9YCBvciBzdHJpbmdcbiAqIHRoYXQganVzdCBjb250YWlucyB0aGUgc3JjIHVybCBhbG9uZS5cbiAqICogYHZhciBTb3VyY2VPYmplY3QgPSB7c3JjOiAnaHR0cDovL2V4LmNvbS92aWRlby5tcDQnLCB0eXBlOiAndmlkZW8vbXA0J307YFxuICAgKiBgdmFyIFNvdXJjZVN0cmluZyA9ICdodHRwOi8vZXhhbXBsZS5jb20vc29tZS12aWRlby5tcDQnO2BcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fHN0cmluZ30gVGVjaH5Tb3VyY2VPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3JjXG4gKiAgICAgICAgICAgVGhlIHVybCB0byB0aGUgc291cmNlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICBUaGUgbWltZSB0eXBlIG9mIHRoZSBzb3VyY2VcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdXNlZCBieSB7QGxpbmsgVGVjaH0gdG8gY3JlYXRlIGEgbmV3IHtAbGluayBUZXh0VHJhY2t9LlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtUZWNofSBzZWxmXG4gKiAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIFRlY2ggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIHRleHQgdHJhY2sgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja31cbiAqICAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrSGVscGVyKHNlbGYsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgdmFyIHRyYWNrcyA9IHNlbGYudGV4dFRyYWNrcygpO1xuXG4gIG9wdGlvbnMua2luZCA9IGtpbmQ7XG5cbiAgaWYgKGxhYmVsKSB7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICB9XG4gIGlmIChsYW5ndWFnZSkge1xuICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgfVxuICBvcHRpb25zLnRlY2ggPSBzZWxmO1xuXG4gIHZhciB0cmFjayA9IG5ldyBBTEwudGV4dC5UcmFja0NsYXNzKG9wdGlvbnMpO1xuXG4gIHRyYWNrcy5hZGRUcmFjayh0cmFjayk7XG5cbiAgcmV0dXJuIHRyYWNrO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIG1lZGlhIHBsYXliYWNrIHRlY2hub2xvZ3kgY29udHJvbGxlcnMsIHN1Y2ggYXNcbiAqIHtAbGluayBGbGFzaH0gYW5kIHtAbGluayBIVE1MNX1cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGVjaCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRlY2gsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSByZWFkeVxuICAgKiAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBgSFRNTDVgIFRlY2ggaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBUZWNoKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgcmVhZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRlY2gpO1xuXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdGVjaCB0byByZXBvcnQgdXNlciBhY3Rpdml0eSBhdXRvbWF0aWNhbGx5LlxuICAgIC8vIFRoaXMgaXMgZG9uZSBtYW51YWxseSBpbiBhZGRDb250cm9sc0xpc3RlbmVyc1xuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBjdXJyZW50IHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCB0b1xuICAgIC8vIGltcGxlbWVudCBhIHZlcnkgbGltaXRlZCBwbGF5ZWQoKVxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBfdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIF90aGlzLm9uKCdwbGF5aW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IHRydWU7XG4gICAgfSk7XG4gICAgX3RoaXMub24oJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0pIHtcbiAgICAgICAgX3RoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFByb2dyZXNzT24oKTtcbiAgICB9XG5cbiAgICAvLyBNYW51YWxseSB0cmFjayB0aW1ldXBkYXRlcyBpbiBjYXNlcyB3aGVyZSB0aGUgYnJvd3Nlci9mbGFzaCBwbGF5ZXIgZG9lc24ndCByZXBvcnQgaXQuXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMpIHtcbiAgICAgIF90aGlzLm1hbnVhbFRpbWVVcGRhdGVzT24oKTtcbiAgICB9XG5cbiAgICBbJ1RleHQnLCAnQXVkaW8nLCAnVmlkZW8nXS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgaWYgKG9wdGlvbnNbJ25hdGl2ZScgKyB0cmFjayArICdUcmFja3MnXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgX3RoaXNbJ2ZlYXR1cmVzTmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVDYXB0aW9ucyA9PT0gZmFsc2UgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSBmYWxzZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSB0cnVlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gdHJ1ZSkge1xuICAgICAgX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgX3RoaXMuZW11bGF0ZVRleHRUcmFja3MoKTtcbiAgICB9XG5cbiAgICBfdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18gPSBuZXcgQUxMLnRleHQuTGlzdENsYXNzKCk7XG5cbiAgICBfdGhpcy5pbml0VHJhY2tMaXN0ZW5lcnMoKTtcblxuICAgIC8vIFR1cm4gb24gY29tcG9uZW50IHRhcCBldmVudHMgb25seSBpZiBub3QgdXNpbmcgbmF0aXZlIGNvbnRyb2xzXG4gICAgaWYgKCFvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gpIHtcbiAgICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIF90aGlzLm5hbWVfID0gX3RoaXMuY29uc3RydWN0b3IubmFtZSB8fCAnVW5rbm93biBUZWNoJztcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyogRmFsbGJhY2tzIGZvciB1bnN1cHBvcnRlZCBldmVudCB0eXBlc1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCB0aGUgYHByb2dyZXNzYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPbiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT24oKSB7XG4gICAgdGhpcy5vbignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XG5cbiAgICAvLyBUcmlnZ2VyIHByb2dyZXNzIHdhdGNoaW5nIHdoZW4gYSBzb3VyY2UgYmVnaW5zIGxvYWRpbmdcbiAgICB0aGlzLm9uZSgncmVhZHknLCB0aGlzLnRyYWNrUHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGBwcm9ncmVzc2AgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG5cbiAgICB0aGlzLm9mZignZHVyYXRpb25jaGFuZ2UnLCB0aGlzLm9uRHVyYXRpb25DaGFuZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gdHJpZ2dlciBhIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiB0aGUgYnVmZmVyZWQgcGVyY2VudCBjaGFuZ2VzLiBJdFxuICAgKiBzZXRzIGFuIGludGVydmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgNTAwIG1pbGxpc2Vjb25kcyB0byBjaGVjayBpZiB0aGVcbiAgICogYnVmZmVyIGVuZCBwZXJjZW50IGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiA+IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYHJlYWR5YCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNyZWFkeVxuICAgKiBAZmlyZXMgVGVjaCNwcm9ncmVzc1xuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiB0cmFja1Byb2dyZXNzKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgIHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIHVubGVzcyBidWZmZXJlZCBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIGxhc3QgdGltZVxuXG4gICAgICB2YXIgbnVtQnVmZmVyZWRQZXJjZW50ID0gdGhpcy5idWZmZXJlZFBlcmNlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuYnVmZmVyZWRQZXJjZW50XyAhPT0gbnVtQnVmZmVyZWRQZXJjZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFBsYXllciNwcm9ncmVzc31cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjcHJvZ3Jlc3NcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gPSBudW1CdWZmZXJlZFBlcmNlbnQ7XG5cbiAgICAgIGlmIChudW1CdWZmZXJlZFBlcmNlbnQgPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH0pLCA1MDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgb3VyIGludGVybmFsIGR1cmF0aW9uIG9uIGEgYGR1cmF0aW9uY2hhbmdlYCBldmVudCBieSBjYWxsaW5nXG4gICAqIHtAbGluayBUZWNoI2R1cmF0aW9ufS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUub25EdXJhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIG9uRHVyYXRpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLmR1cmF0aW9uXyA9IHRoaXMuZHVyYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuZCBjcmVhdGUgYSBgVGltZVJhbmdlYCBvYmplY3QgZm9yIGJ1ZmZlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmJ1ZmZlcmVkID0gZnVuY3Rpb24gYnVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgY3VycmVudCB2aWRlbyB0aGF0IGlzIGN1cnJlbnRseSBidWZmZXJlZC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxIHRoYXQgcmVwcmVzZW50cyB0aGUgZGVjaW1hbCBwZXJjZW50YWdlIG9mIHRoZVxuICAgKiAgICAgICAgIHZpZGVvIHRoYXQgaXMgYnVmZmVyZWQuXG4gICAqXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWRQZXJjZW50ID0gZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50JCQxKCkge1xuICAgIHJldHVybiBidWZmZXJlZFBlcmNlbnQodGhpcy5idWZmZXJlZCgpLCB0aGlzLmR1cmF0aW9uXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKiBTdG9wIG1hbnVhbGx5IHRyYWNraW5nIHByb2dyZXNzIGV2ZW50cyBieSBjbGVhcmluZyB0aGUgaW50ZXJ2YWwgdGhhdCB3YXMgc2V0IGluXG4gICAqIHtAbGluayBUZWNoI3RyYWNrUHJvZ3Jlc3N9LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ1Byb2dyZXNzID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT24gPSBmdW5jdGlvbiBtYW51YWxUaW1lVXBkYXRlc09uKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgdGhpcy5vbigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgdGltZXVwZGF0ZWAgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cbiAgICoge0BsaW5rIFRlY2gjbWFudWFsVGltZVVwZGF0ZXNPbn1cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT2ZmKCkge1xuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgdGhpcy5vZmYoJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xuICAgIHRoaXMub2ZmKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGFuIGludGVydmFsIGZ1bmN0aW9uIHRvIHRyYWNrIGN1cnJlbnQgdGltZSBhbmQgdHJpZ2dlciBgdGltZXVwZGF0ZWAgZXZlcnlcbiAgICogMjUwIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEB0cmlnZ2VycyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS50cmFja0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gdHJhY2tDdXJyZW50VGltZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50VGltZUludGVydmFsKSB7XG4gICAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyZWQgYXQgYW4gaW50ZXJ2YWwgb2YgMjUwbXMgdG8gaW5kaWNhdGVkIHRoYXQgdGltZSBpcyBwYXNzaW5nIGluIHRoZSB2aWRlby5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcblxuICAgICAgLy8gNDIgPSAyNCBmcHMgLy8gMjUwIGlzIHdoYXQgV2Via2l0IHVzZXMgLy8gRkYgdXNlcyAxNVxuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGludGVydmFsIGZ1bmN0aW9uIGNyZWF0ZWQgaW4ge0BsaW5rIFRlY2gjdHJhY2tDdXJyZW50VGltZX0gc28gdGhhdCB0aGVcbiAgICogYHRpbWV1cGRhdGVgIGV2ZW50IGlzIG5vIGxvbmdlciB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHtUZWNoI3BhdXNlfVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCk7XG5cbiAgICAvLyAjMTAwMiAtIGlmIHRoZSB2aWRlbyBlbmRzIHJpZ2h0IGJlZm9yZSB0aGUgbmV4dCB0aW1ldXBkYXRlIHdvdWxkIGhhcHBlbixcbiAgICAvLyB0aGUgcHJvZ3Jlc3MgYmFyIHdvbid0IG1ha2UgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZFxuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgYWxsIGV2ZW50IHBvbHlmaWxscywgY2xlYXIgdGhlIGBUZWNoYHMge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSxcbiAgICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fSwgYW5kIHtAbGluayBUZXh0VHJhY2tMaXN0fSwgYW5kIGRpc3Bvc2Ugb2YgdGhpcyBUZWNoLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdGhpcy5jbGVhclRyYWNrcyhOT1JNQUwubmFtZXMpO1xuXG4gICAgLy8gVHVybiBvZmYgYW55IG1hbnVhbCBwcm9ncmVzcyBvciB0aW1ldXBkYXRlIHRyYWNraW5nXG4gICAgaWYgKHRoaXMubWFudWFsUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMubWFudWFsUHJvZ3Jlc3NPZmYoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYW51YWxUaW1lVXBkYXRlcykge1xuICAgICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlc09mZigpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgb3V0IGEgc2luZ2xlIGBUcmFja0xpc3RgIG9yIGFuIGFycmF5IG9mIGBUcmFja0xpc3RzYCBnaXZlbiB0aGVpciBuYW1lcy5cbiAgICpcbiAgICogPiBOb3RlOiBUZWNocyB3aXRob3V0IHNvdXJjZSBoYW5kbGVycyBzaG91bGQgY2FsbCB0aGlzIGJldHdlZW4gc291cmNlcyBmb3IgYHZpZGVvYFxuICAgKiAgICAgICAgICYgYGF1ZGlvYCB0cmFja3MuIFlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGVtIGJldHdlZW4gdHJhY2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfHN0cmluZ30gdHlwZXNcbiAgICogICAgICAgIFRyYWNrTGlzdCBuYW1lcyB0byBjbGVhciwgdmFsaWQgbmFtZXMgYXJlIGB2aWRlb2AsIGBhdWRpb2AsIGFuZFxuICAgKiAgICAgICAgYHRleHRgLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFyVHJhY2tzID0gZnVuY3Rpb24gY2xlYXJUcmFja3ModHlwZXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHR5cGVzID0gW10uY29uY2F0KHR5cGVzKTtcbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ID0gX3RoaXMyW3R5cGUgKyAnVHJhY2tzJ10oKSB8fCBbXTtcbiAgICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgX3RoaXMyLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgVGV4dFRyYWNrcyBhZGRlZCB2aWEgYWRkUmVtb3RlVGV4dFRyYWNrIHRoYXQgYXJlXG4gICAqIGZsYWdnZWQgZm9yIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jbGVhbnVwQXV0b1RleHRUcmFja3MgPSBmdW5jdGlvbiBjbGVhbnVwQXV0b1RleHRUcmFja3MoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXyB8fCBbXTtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHRlY2gsIHdoaWNoIHdpbGwgcmVtb3ZlcyBhbGwgc291cmNlcyBhbmQgcmVzZXQgdGhlIGludGVybmFsIHJlYWR5U3RhdGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7fTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCBhbiBlcnJvciBvbiB0aGUgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYUVycm9yfSBbZXJyXVxuICAgKiAgICAgICAgRXJyb3IgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBlcnJvciBvYmplY3Qgb24gdGhlIHRlY2gsIG9yIG51bGwgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYFRpbWVSYW5nZWBzIHRoYXQgaGF2ZSBiZWVuIHBsYXllZCB0aHJvdWdoIGZvciB0aGUgY3VycmVudCBzb3VyY2UuXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBpbmNvbXBsZXRlLiBJdCBkb2VzIG5vdCB0cmFjayB0aGUgcGxheWVkIGBUaW1lUmFuZ2VgLlxuICAgKiAgICAgICAgIEl0IG9ubHkgY2hlY2tzIHdldGhlciB0aGUgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIC0gQSBzaW5nbGUgdGltZSByYW5nZSBpZiB0aGlzIHZpZGVvIGhhcyBwbGF5ZWRcbiAgICogICAgICAgICAtIEFuIGVtcHR5IHNldCBvZiByYW5nZXMgaWYgbm90LlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXllZCA9IGZ1bmN0aW9uIHBsYXllZCgpIHtcbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhdXNlcyBhIG1hbnVhbCB0aW1lIHVwZGF0ZSB0byBvY2N1ciBpZiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufSB3YXNcbiAgICogcHJldmlvdXNseSBjYWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKCkge1xuICAgIC8vIGltcHJvdmUgdGhlIGFjY3VyYWN5IG9mIG1hbnVhbCB0aW1ldXBkYXRlc1xuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbWFudWFsIGB0aW1ldXBkYXRlYCBldmVudC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb24gbGlzdGVuZXJzIGZvciB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCB7QGxpbmsge0F1ZGlvVHJhY2tMaXN0fSwgYW5kXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBldmVudHMuXG4gICAqXG4gICAqIFRoaXMgYWRkcyB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcnN9IGZvciBgYWRkdHJhY2tgLCBhbmQgIGByZW1vdmV0cmFja2AuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcbiAgICogQGZpcmVzIFRlY2gjdmlkZW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5pbml0VHJhY2tMaXN0ZW5lcnMgPSBmdW5jdGlvbiBpbml0VHJhY2tMaXN0ZW5lcnMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdGV4dHRyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIE5PUk1BTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcHJvcHMgPSBOT1JNQUxbbmFtZV07XG4gICAgICB2YXIgdHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIHRyYWNrTGlzdENoYW5nZXMoKSB7XG4gICAgICAgIF90aGlzMy50cmlnZ2VyKG5hbWUgKyAndHJhY2tjaGFuZ2UnKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFja3MgPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcblxuICAgICAgX3RoaXMzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSBUZXh0VHJhY2tzIHVzaW5nIHZ0dC5qcyBpZiBuZWNlc3NhcnlcbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdnR0anNsb2FkZWRcbiAgICogQGZpcmVzIFRlY2gjdnR0anNlcnJvclxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFdlYlZ0dFNjcmlwdF8gPSBmdW5jdGlvbiBhZGRXZWJWdHRTY3JpcHRfKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHdpbmRvdy5XZWJWVFQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsbHksIFRlY2guZWxfIGlzIGEgY2hpbGQgb2YgYSBkdW1teS1kaXYgd2FpdCB1bnRpbCB0aGUgQ29tcG9uZW50IHN5c3RlbVxuICAgIC8vIHNpZ25hbHMgdGhhdCB0aGUgVGVjaCBpcyByZWFkeSBhdCB3aGljaCBwb2ludCBUZWNoLmVsXyBpcyBwYXJ0IG9mIHRoZSBET01cbiAgICAvLyBiZWZvcmUgaW5zZXJ0aW5nIHRoZSBXZWJWVFQgc2NyaXB0XG4gICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5lbCgpKSkge1xuXG4gICAgICAvLyBsb2FkIHZpYSByZXF1aXJlIGlmIGF2YWlsYWJsZSBhbmQgdnR0LmpzIHNjcmlwdCBsb2NhdGlvbiB3YXMgbm90IHBhc3NlZCBpblxuICAgICAgLy8gYXMgYW4gb3B0aW9uLiBub3Z0dCBidWlsZHMgd2lsbCB0dXJuIHRoZSBhYm92ZSByZXF1aXJlIGNhbGwgaW50byBhbiBlbXB0eSBvYmplY3RcbiAgICAgIC8vIHdoaWNoIHdpbGwgY2F1c2UgdGhpcyBpZiBjaGVjayB0byBhbHdheXMgZmFpbC5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gJiYgaXNQbGFpbih2dHQpICYmIE9iamVjdC5rZXlzKHZ0dCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9hZCB2dHQuanMgdmlhIHRoZSBzY3JpcHQgbG9jYXRpb24gb3B0aW9uIG9yIHRoZSBjZG4gb2Ygbm8gbG9jYXRpb24gd2FzXG4gICAgICAvLyBwYXNzZWQgaW5cbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICdodHRwczovL3Zqcy56ZW5jZG4ubmV0L3Z0dGpzLzAuMTIuNC92dHQubWluLmpzJztcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyBpcyBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNC50cmlnZ2VyKCd2dHRqc2xvYWRlZCcpO1xuICAgICAgfTtcbiAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB2dHQuanMgd2FzIG5vdCBsb2FkZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBUZWNoI3Z0dGpzbG9hZGVkXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzNC50cmlnZ2VyKCd2dHRqc2Vycm9yJyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgLy8gYnV0IGhhdmUgbm90IGxvYWRlZCB5ZXQgYW5kIHdlIHNldCBpdCB0byB0cnVlIGJlZm9yZSB0aGUgaW5qZWN0IHNvIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5qZWN0ZWQgd2luZG93LldlYlZUVCBpZiBpdCBsb2FkcyByaWdodCBhd2F5XG4gICAgICB3aW5kb3cuV2ViVlRUID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWwoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHkodGhpcy5hZGRXZWJWdHRTY3JpcHRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVtdWxhdGUgdGV4dHRyYWNrc1xuICAgKlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmVtdWxhdGVUZXh0VHJhY2tzID0gZnVuY3Rpb24gZW11bGF0ZVRleHRUcmFja3MoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHJlbW90ZVRyYWNrcyA9IHRoaXMucmVtb3RlVGV4dFRyYWNrcygpO1xuICAgIHZhciBoYW5kbGVBZGRUcmFjayA9IGZ1bmN0aW9uIGhhbmRsZUFkZFRyYWNrKGUpIHtcbiAgICAgIHJldHVybiB0cmFja3MuYWRkVHJhY2soZS50cmFjayk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlUmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVSZW1vdmVUcmFjayhlKSB7XG4gICAgICByZXR1cm4gdHJhY2tzLnJlbW92ZVRyYWNrKGUudHJhY2spO1xuICAgIH07XG5cbiAgICByZW1vdGVUcmFja3Mub24oJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xuICAgIHJlbW90ZVRyYWNrcy5vbigncmVtb3ZldHJhY2snLCBoYW5kbGVSZW1vdmVUcmFjayk7XG5cbiAgICB0aGlzLmFkZFdlYlZ0dFNjcmlwdF8oKTtcblxuICAgIHZhciB1cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHJldHVybiBfdGhpczUudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XG4gICAgfTtcblxuICAgIHZhciB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uIHRleHRUcmFja3NDaGFuZ2VzKCkge1xuICAgICAgdXBkYXRlRGlzcGxheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0ZXh0VHJhY2tzQ2hhbmdlcygpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdhZGR0cmFjaycsIGhhbmRsZUFkZFRyYWNrKTtcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ3JlbW92ZXRyYWNrJywgaGFuZGxlUmVtb3ZlVHJhY2spO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRleHRUcmFja3NDaGFuZ2VzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICgha2luZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0VHJhY2sga2luZCBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVUcmFja0hlbHBlcih0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW11bGF0ZWQgVGV4dFRyYWNrIGZvciB1c2UgYnkgYWRkUmVtb3RlVGV4dFRyYWNrXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tXG4gICAqIFRlY2ggaW4gb3JkZXIgdG8gY3JlYXRlIG5hdGl2ZSBvciBjdXN0b20gVGV4dFRyYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhY2sgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgdGVjaDogdGhpc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSRU1PVEUucmVtb3RlVGV4dEVsLlRyYWNrQ2xhc3ModHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogPiBOb3RlOiBUaGlzIGNhbiBiZSBhbiBlbXVsYXRlZCB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gb3IgYSBuYXRpdmUgb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgU2VlIHtAbGluayBUZWNoI2NyZWF0ZVJlbW90ZVRleHRUcmFja30gZm9yIG1vcmUgZGV0YWlsZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbWFudWFsQ2xlYW51cD10cnVlXVxuICAgKiAgICAgICAgLSBXaGVuIGZhbHNlOiB0aGUgVGV4dFRyYWNrIHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvXG4gICAqICAgICAgICAgIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqICAgICAgICAtIFdoZW4gVHJ1ZTogVGhlIFRleHRUcmFjayB3aWxsIGhhdmUgdG8gYmUgY2xlYW5lZCB1cCBtYW51YWxseVxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBmb3IgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGVxdWl2YWxlbnRcbiAgICogICAgICAgICAgICAgdG8gXCJtYW51YWxDbGVhbnVwPWZhbHNlXCIgaW4gdGhlIGZ1dHVyZS4gVGhlIG1hbnVhbENsZWFudXAgcGFyYW1ldGVyIHdpbGxcbiAgICogICAgICAgICAgICAgYWxzbyBiZSByZW1vdmVkLlxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgbWFudWFsQ2xlYW51cCA9IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gdGhpcy5jcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucyk7XG5cbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSAmJiBtYW51YWxDbGVhbnVwICE9PSBmYWxzZSkge1xuICAgICAgLy8gZGVwcmVjYXRpb24gd2FybmluZ1xuICAgICAgbG9nJDEud2FybignQ2FsbGluZyBhZGRSZW1vdGVUZXh0VHJhY2sgd2l0aG91dCBleHBsaWNpdGx5IHNldHRpbmcgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB0byBgdHJ1ZWAgaXMgZGVwcmVjYXRlZCBhbmQgZGVmYXVsdCB0byBgZmFsc2VgIGluIGZ1dHVyZSB2ZXJzaW9uIG9mIHZpZGVvLmpzJyk7XG4gICAgICBtYW51YWxDbGVhbnVwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8oaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2soaHRtbFRyYWNrRWxlbWVudC50cmFjayk7XG5cbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSkge1xuICAgICAgLy8gY3JlYXRlIHRoZSBUZXh0VHJhY2tMaXN0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM2LmF1dG9SZW1vdGVUZXh0VHJhY2tzXy5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSByZW1vdGUgdGV4dCB0cmFjayBmcm9tIHRoZSByZW1vdGUgYFRleHRUcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIHRvIHJlbW92ZSBmcm9tIHRoZSBgVGV4dFRyYWNrTGlzdGBcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICB2YXIgdHJhY2tFbGVtZW50ID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjayk7XG5cbiAgICAvLyByZW1vdmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIGZyb20gcmVtb3RlIGxpc3RcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLnJlbW92ZVRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18ucmVtb3ZlVHJhY2sodHJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljc1xuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gc2V0IGEgcG9zdGVyIGZyb20gYSBgVGVjaGAuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldFBvc3RlciA9IGZ1bmN0aW9uIHNldFBvc3RlcigpIHt9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBjaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUoKSB7fTtcblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gc2V0IG9yIHVuc2V0IHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldFBsYXlzaW5saW5lID0gZnVuY3Rpb24gc2V0UGxheXNpbmxpbmUoKSB7fTtcblxuICAvKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gbWltZS10eXBlLlxuICAgKlxuICAgKiBUaGUgYmFzZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgYW55IHR5cGUsIGJ1dCBzb3VyY2UgaGFuZGxlcnMgbWlnaHRcbiAgICogb3ZlcndyaXRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjayBmb3Igc3VwcG9ydFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgZW1wdHkgc3RyaW5nXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L2NhblBsYXlUeXBlfVxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKCkge1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgdGVjaC5cbiAgICpcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XG4gICAqIG92ZXJ3cml0ZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1lZGlhIHR5cGUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuYXRpdmUgdmlkZW8gZWxlbWVudCdzIHJlc3BvbnNlXG4gICAqL1xuXG5cbiAgVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKCkge1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqIEByZXR1cm4ge3N0cmluZ30gJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG5cblxuICBUZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiBjYW5QbGF5U291cmNlKHNyY09iaiwgb3B0aW9ucykge1xuICAgIHJldHVybiBUZWNoLmNhblBsYXlUeXBlKHNyY09iai50eXBlKTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgYXJndW1lbnQgaXMgYSBUZWNoIG9yIG5vdC5cbiAgICogQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYSBDbGFzcyBsaWtlIGBIdG1sNWAgb3IgYSBpbnN0YW5jZSBsaWtlIGBwbGF5ZXIudGVjaF9gXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBpdGVtIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgV2hldGhlciBpdCBpcyBhIHRlY2ggb3Igbm90XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGVjaFxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgaXQgaXMgbm90XG4gICAqL1xuXG5cbiAgVGVjaC5pc1RlY2ggPSBmdW5jdGlvbiBpc1RlY2goY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50ID09PSBUZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBgVGVjaGAgaW50byBhIHNoYXJlZCBsaXN0IGZvciB2aWRlb2pzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYFRlY2hgIHRvIHJlZ2lzdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGVjaFxuICAgKiAgICAgICAgVGhlIGBUZWNoYCBjbGFzcyB0byByZWdpc3Rlci5cbiAgICovXG5cblxuICBUZWNoLnJlZ2lzdGVyVGVjaCA9IGZ1bmN0aW9uIHJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKSB7XG4gICAgaWYgKCFUZWNoLnRlY2hzXykge1xuICAgICAgVGVjaC50ZWNoc18gPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIVRlY2guaXNUZWNoKHRlY2gpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2ggJyArIG5hbWUgKyAnIG11c3QgYmUgYSBUZWNoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFUZWNoLmNhblBsYXlUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5VHlwZSBtZXRob2Qgb24gdGhlbScpO1xuICAgIH1cbiAgICBpZiAoIVRlY2guY2FuUGxheVNvdXJjZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNocyBtdXN0IGhhdmUgYSBzdGF0aWMgY2FuUGxheVNvdXJjZSBtZXRob2Qgb24gdGhlbScpO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIFRlY2gudGVjaHNfW25hbWVdID0gdGVjaDtcbiAgICBpZiAobmFtZSAhPT0gJ1RlY2gnKSB7XG4gICAgICAvLyBjYW1lbCBjYXNlIHRoZSB0ZWNoTmFtZSBmb3IgdXNlIGluIHRlY2hPcmRlclxuICAgICAgVGVjaC5kZWZhdWx0VGVjaE9yZGVyXy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGVjaDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYFRlY2hgIGZyb20gdGhlIHNoYXJlZCBsaXN0IGJ5IG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBgY2FtZWxDYXNlYCBvciBgVGl0bGVDYXNlYCBuYW1lIG9mIHRoZSBUZWNoIHRvIGdldFxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNofHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgYFRlY2hgIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSB3YXMgbm8gdGVjaCB3aXRoIHRoZSBuYW1lIHJlcXVzdGVkLlxuICAgKi9cblxuXG4gIFRlY2guZ2V0VGVjaCA9IGZ1bmN0aW9uIGdldFRlY2gobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIGlmIChUZWNoLnRlY2hzXyAmJiBUZWNoLnRlY2hzX1tuYW1lXSkge1xuICAgICAgcmV0dXJuIFRlY2gudGVjaHNfW25hbWVdO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LnZpZGVvanMgJiYgd2luZG93LnZpZGVvanNbbmFtZV0pIHtcbiAgICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSArICcgdGVjaCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2gobmFtZSwgdGVjaCknKTtcbiAgICAgIHJldHVybiB3aW5kb3cudmlkZW9qc1tuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRlY2g7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVmlkZW9UcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge1ZpZGVvVHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS52aWRlb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gKlxuICogQHJldHVybnMge0F1ZGlvVHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5hdWRpb1RyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUgZWxlbWVudCB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUgZWxlbWVudCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKlxuICogQHJldHVybnMge0h0bWxUcmFja0VsZW1lbnRMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tFbHNcbiAqL1xuXG5BTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XG5cbiAgVGVjaC5wcm90b3R5cGVbcHJvcHMuZ2V0dGVyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICB9O1xufSk7XG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzXG4gKlxuICogQHR5cGUge1RleHRUcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjdGV4dFRyYWNrc19cbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgYXNzb2NpYXRlZCBhdWRpbyB0cmFja3MuXG4gKlxuICogQHR5cGUge0F1ZGlvVHJhY2tMaXN0fVxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBUZWNoI2F1ZGlvVHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHZpZGVvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7VmlkZW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjdmlkZW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdm9sdW1lIGNvbnRyb2wuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0IGZ1bGxzY3JlZW4gcmVzaXplIGNvbnRyb2wuXG4gKiBSZXNpemluZyBwbHVnaW5zIHVzaW5nIHJlcXVlc3QgZnVsbHNjcmVlbiByZWxvYWRzIHRoZSBwbHVnaW5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIHZpZGVvXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHByb2dyZXNzYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259IHNob3VsZCBiZSBjYWxsZWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgdGltZXVwZGF0ZWAgZXZlbnQuIFRoaXMgaXMgY3VycmVudGx5XG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXG4gKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc30gc2hvdWxkIGJlIGNhbGxlZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IGZhbHNlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqIFRoaXMgd2lsbCBoZWxwIHVzIGludGVncmF0ZSB3aXRoIG5hdGl2ZSBgVGV4dFRyYWNrYHMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlbS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xuXG4vKipcbiAqIEEgZnVuY3Rpb25hbCBtaXhpbiBmb3IgdGVjaHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgU291cmNlIEhhbmRsZXIgcGF0dGVybi5cbiAqIFNvdXJjZSBoYW5kbGVycyBhcmUgc2NyaXB0cyBmb3IgaGFuZGxpbmcgc3BlY2lmaWMgZm9ybWF0cy5cbiAqIFRoZSBzb3VyY2UgaGFuZGxlciBwYXR0ZXJuIGlzIHVzZWQgZm9yIGFkYXB0aXZlIGZvcm1hdHMgKEhMUywgREFTSCkgdGhhdFxuICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcbiAqIEV4YW1wbGU6IGBUZWNoLndpdGhTb3VyY2VIYW5kbGVycy5jYWxsKE15VGVjaCk7YFxuICpcbiAqIEBwYXJhbSB7VGVjaH0gX1RlY2hcbiAqICAgICAgICBUaGUgdGVjaCB0byBhZGQgc291cmNlIGhhbmRsZXIgZnVuY3Rpb25zIHRvLlxuICpcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcbiAqL1xuVGVjaC53aXRoU291cmNlSGFuZGxlcnMgPSBmdW5jdGlvbiAoX1RlY2gpIHtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBzb3VyY2UgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgICAgICBUaGUgc291cmNlIGhhbmRsZXIgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICogICAgICAgIFJlZ2lzdGVyIGl0IGF0IHRoZSBmb2xsb3dpbmcgaW5kZXhcbiAgICovXG4gIF9UZWNoLnJlZ2lzdGVyU291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmRleCkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzO1xuXG4gICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgaW5kZXggPSBoYW5kbGVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAwLCBoYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGUuIEFsc28gY2hlY2tzIHRoZVxuICAgKiBUZWNocyBzb3VyY2VIYW5kbGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5QbGF5VHlwZSh0eXBlKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gY2FuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUT0RPOiBBbnN3ZXIgcXVlc3Rpb246IHNob3VsZCAncHJvYmFibHknIGJlIHByaW9yaXRpemVkIG92ZXIgJ21heWJlJ1xuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICpcbiAgICogQHJldHVybiB7U291cmNlSGFuZGxlcnxudWxsfVxuICAgKiAgICAgICAgICBUaGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlIG9yIG51bGwgaWZcbiAgICogICAgICAgICAgbm8gU291cmNlSGFuZGxlciBzdXBwb3J0cyB0aGUgc291cmNlXG4gICAqL1xuICBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xuICAgIHZhciBjYW4gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYW4gPSBoYW5kbGVyc1tpXS5jYW5IYW5kbGVTb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGNhbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY09ialxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIF9UZWNoLmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzcmNPYmosIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoKSB7XG4gICAgICByZXR1cm4gc2guY2FuSGFuZGxlU291cmNlKHNyY09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzaW5nIGEgc291cmNlIGhhbmRsZXIsIHByZWZlciBpdHMgaW1wbGVtZW50YXRpb24gb2ZcbiAgICogYW55IGZ1bmN0aW9uIG5vcm1hbGx5IHByb3ZpZGVkIGJ5IHRoZSB0ZWNoLlxuICAgKi9cbiAgdmFyIGRlZmVycmFibGUgPSBbJ3NlZWthYmxlJywgJ2R1cmF0aW9uJ107XG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciBhcm91bmQge0BsaW5rIFRlY2gjc2Vla2FibGV9IHRoYXQgd2lsbCBjYWxsIGEgYFNvdXJjZUhhbmRsZXJgcyBzZWVrYWJsZVxuICAgKiBmdW5jdGlvbiBpZiBpdCBleGlzdHMsIHdpdGggYSBmYWxsYmFjayB0byB0aGUgVGVjaHMgc2Vla2FibGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBtZXRob2QgX1RlY2guc2Vla2FibGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgd3JhcHBlciBhcm91bmQge0BsaW5rIFRlY2gjZHVyYXRpb259IHRoYXQgd2lsbCBjYWxsIGEgYFNvdXJjZUhhbmRsZXJgcyBkdXJhdGlvblxuICAgKiBmdW5jdGlvbiBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBpdCB3aWxsIGZhbGxiYWNrIHRvIHRoZSB0ZWNocyBkdXJhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5kdXJhdGlvblxuICAgKi9cblxuICBkZWZlcnJhYmxlLmZvckVhY2goZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgIHZhciBvcmlnaW5hbEZuID0gdGhpc1tmbk5hbWVdO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbEZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1tmbk5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuc291cmNlSGFuZGxlcl8gJiYgdGhpcy5zb3VyY2VIYW5kbGVyX1tmbk5hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0uYXBwbHkodGhpcy5zb3VyY2VIYW5kbGVyXywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgX1RlY2gucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIHNvdXJjZSB1c2luZyBhIHNvdXJjZSBvYmplY3RcbiAgICogYW5kIHNvdXJjZSBoYW5kbGVycy5cbiAgICogU2hvdWxkIG5ldmVyIGJlIGNhbGxlZCB1bmxlc3MgYSBzb3VyY2UgaGFuZGxlciB3YXMgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgQSBzb3VyY2Ugb2JqZWN0IHdpdGggc3JjIGFuZCB0eXBlIGtleXNcbiAgICovXG4gIF9UZWNoLnByb3RvdHlwZS5zZXRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzb3VyY2UsIHRoaXMub3B0aW9uc18pO1xuXG4gICAgaWYgKCFzaCkge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGEgbmF0aXZlIHNvdXJjZSBoYW5kZXIgd2hlbiB1bnN1cHBvcnRlZCBzb3VyY2VzIGFyZVxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxuICAgICAgaWYgKF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgc2ggPSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nJDEuZXJyb3IoJ05vIHNvdXJjZSBoYW5kZXIgZm91bmQgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIGFueSBleGlzdGluZyBzb3VyY2UgaGFuZGxlclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcbiAgICB0aGlzLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xuXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gc291cmNlO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBzaC5oYW5kbGVTb3VyY2Uoc291cmNlLCB0aGlzLCB0aGlzLm9wdGlvbnNfKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBTb3VyY2VIYW5kbGVycyBhbmQgbGlzdGVuZXJzIHdoZW4gdGhlIFRlY2ggaXMgZGlzcG9zZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZGlzcG9zZVxuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLmRpc3Bvc2VTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBzb3VyY2UgYW5kIGdldCBhbm90aGVyIG9uZVxuICAgIC8vIHRoZW4gd2UgYXJlIGxvYWRpbmcgc29tZXRoaW5nIG5ld1xuICAgIC8vIHRoYW4gY2xlYXIgYWxsIG9mIG91ciBjdXJyZW50IHRyYWNrc1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tzKFsnYXVkaW8nLCAndmlkZW8nXSk7XG4gICAgICB0aGlzLmN1cnJlbnRTb3VyY2VfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgY2xlYW4gdXAgYXV0by10ZXh0IHRyYWNrc1xuICAgIHRoaXMuY2xlYW51cEF1dG9UZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXykge1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNvdXJjZUhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBUaGUgYmFzZSBUZWNoIGNsYXNzIG5lZWRzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuIEl0IGlzIHRoZSBvbmx5XG4vLyBUZWNoIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RlY2gnLCBUZWNoKTtcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XG5cbi8qKlxuICogQSBsaXN0IG9mIHRlY2hzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRlY2hPcmRlciBvbiBQbGF5ZXJzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyA9IFtdO1xuXG52YXIgbWlkZGxld2FyZXMgPSB7fTtcblxuZnVuY3Rpb24gdXNlKHR5cGUsIG1pZGRsZXdhcmUpIHtcbiAgbWlkZGxld2FyZXNbdHlwZV0gPSBtaWRkbGV3YXJlc1t0eXBlXSB8fCBbXTtcbiAgbWlkZGxld2FyZXNbdHlwZV0ucHVzaChtaWRkbGV3YXJlKTtcbn1cblxuXG5cbmZ1bmN0aW9uIHNldFNvdXJjZShwbGF5ZXIsIHNyYywgbmV4dCkge1xuICBwbGF5ZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzW3NyYy50eXBlXSwgbmV4dCwgcGxheWVyKTtcbiAgfSwgMSk7XG59XG5cbmZ1bmN0aW9uIHNldFRlY2gobWlkZGxld2FyZSwgdGVjaCkge1xuICBtaWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKG13KSB7XG4gICAgcmV0dXJuIG13LnNldFRlY2ggJiYgbXcuc2V0VGVjaCh0ZWNoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xuICByZXR1cm4gbWlkZGxld2FyZS5yZWR1Y2VSaWdodChtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSwgdGVjaFttZXRob2RdKCkpO1xufVxuXG5mdW5jdGlvbiBzZXQkMShtaWRkbGV3YXJlLCB0ZWNoLCBtZXRob2QsIGFyZykge1xuICByZXR1cm4gdGVjaFttZXRob2RdKG1pZGRsZXdhcmUucmVkdWNlKG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCBhcmcpKTtcbn1cblxudmFyIGFsbG93ZWRHZXR0ZXJzID0ge1xuICBidWZmZXJlZDogMSxcbiAgY3VycmVudFRpbWU6IDEsXG4gIGR1cmF0aW9uOiAxLFxuICBzZWVrYWJsZTogMSxcbiAgcGxheWVkOiAxXG59O1xuXG52YXIgYWxsb3dlZFNldHRlcnMgPSB7XG4gIHNldEN1cnJlbnRUaW1lOiAxXG59O1xuXG5mdW5jdGlvbiBtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG13KSB7XG4gICAgaWYgKG13W21ldGhvZF0pIHtcbiAgICAgIHJldHVybiBtd1ttZXRob2RdKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldFNvdXJjZUhlbHBlcigpIHtcbiAgdmFyIHNyYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBtaWRkbGV3YXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIG5leHQgPSBhcmd1bWVudHNbMl07XG4gIHZhciBwbGF5ZXIgPSBhcmd1bWVudHNbM107XG4gIHZhciBhY2MgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuICB2YXIgbGFzdFJ1biA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XG4gIHZhciBtd0ZhY3RvcnkgPSBtaWRkbGV3YXJlWzBdLFxuICAgICAgbXdyZXN0ID0gbWlkZGxld2FyZS5zbGljZSgxKTtcblxuICAvLyBpZiBtd0ZhY3RvcnkgaXMgYSBzdHJpbmcsIHRoZW4gd2UncmUgYXQgYSBmb3JrIGluIHRoZSByb2FkXG5cbiAgaWYgKHR5cGVvZiBtd0ZhY3RvcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbbXdGYWN0b3J5XSwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBtd0ZhY3RvcnksIGNhbGwgaXQgd2l0aCB0aGUgcGxheWVyIHRvIGdldCB0aGUgbXcsXG4gICAgLy8gdGhlbiBjYWxsIHRoZSBtdydzIHNldFNvdXJjZSBtZXRob2RcbiAgfSBlbHNlIGlmIChtd0ZhY3RvcnkpIHtcbiAgICB2YXIgbXcgPSBtd0ZhY3RvcnkocGxheWVyKTtcblxuICAgIG13LnNldFNvdXJjZShhc3NpZ24oe30sIHNyYyksIGZ1bmN0aW9uIChlcnIsIF9zcmMpIHtcblxuICAgICAgLy8gc29tZXRoaW5nIGhhcHBlbmVkLCB0cnkgdGhlIG5leHQgbWlkZGxld2FyZSBvbiB0aGUgY3VycmVudCBsZXZlbFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIHVzZSB0aGUgb2xkIHNyY1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc2V0U291cmNlSGVscGVyKHNyYywgbXdyZXN0LCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3ZlIHN1Y2NlZWRlZCwgbm93IHdlIG5lZWQgdG8gZ28gZGVlcGVyXG4gICAgICBhY2MucHVzaChtdyk7XG5cbiAgICAgIC8vIGlmIGl0J3MgdGhlIHNhbWUgdGltZSwgY29udGludWUgZG9lcyB0aGUgY3VycmVudCBjaGFpblxuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIGdvIGRvd24gdGhlIG5ldyBjaGFpblxuICAgICAgc2V0U291cmNlSGVscGVyKF9zcmMsIHNyYy50eXBlID09PSBfc3JjLnR5cGUgPyBtd3Jlc3QgOiBtaWRkbGV3YXJlc1tfc3JjLnR5cGVdLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobXdyZXN0Lmxlbmd0aCkge1xuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xuICB9IGVsc2UgaWYgKGxhc3RSdW4pIHtcbiAgICBuZXh0KHNyYywgYWNjKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1snKiddLCBuZXh0LCBwbGF5ZXIsIGFjYywgdHJ1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbW9kdWxlIGZpbHRlci1zb3VyY2VcbiAqL1xuLyoqXG4gKiBGaWx0ZXIgb3V0IHNpbmdsZSBiYWQgc291cmNlIG9iamVjdHMgb3IgbXVsdGlwbGUgc291cmNlIG9iamVjdHMgaW4gYW5cbiAqIGFycmF5LiBBbHNvIGZsYXR0ZW5zIG5lc3RlZCBzb3VyY2Ugb2JqZWN0IGFycmF5cyBpbnRvIGEgMSBkaW1lbnNpb25hbFxuICogYXJyYXkgb2Ygc291cmNlIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdHxUZWNoflNvdXJjZU9iamVjdFtdfSBzcmNcbiAqICAgICAgICBUaGUgc3JjIG9iamVjdCB0byBmaWx0ZXJcbiAqXG4gKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdFtdfVxuICogICAgICAgICBBbiBhcnJheSBvZiBzb3VyY2VvYmplY3RzIGNvbnRhaW5pbmcgb25seSB2YWxpZCBzb3VyY2VzXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGZpbHRlclNvdXJjZSA9IGZ1bmN0aW9uIGZpbHRlclNvdXJjZShzcmMpIHtcbiAgLy8gdHJhdmVyc2UgYXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIHZhciBuZXdzcmMgPSBbXTtcblxuICAgIHNyYy5mb3JFYWNoKGZ1bmN0aW9uIChzcmNvYmopIHtcbiAgICAgIHNyY29iaiA9IGZpbHRlclNvdXJjZShzcmNvYmopO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmNvYmopKSB7XG4gICAgICAgIG5ld3NyYyA9IG5ld3NyYy5jb25jYXQoc3Jjb2JqKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3Jjb2JqKSkge1xuICAgICAgICBuZXdzcmMucHVzaChzcmNvYmopO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3JjID0gbmV3c3JjO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy50cmltKCkpIHtcbiAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIG9iamVjdFxuICAgIHNyYyA9IFt7IHNyYzogc3JjIH1dO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNyYykgJiYgdHlwZW9mIHNyYy5zcmMgPT09ICdzdHJpbmcnICYmIHNyYy5zcmMgJiYgc3JjLnNyYy50cmltKCkpIHtcbiAgICAvLyBzcmMgaXMgYWxyZWFkeSB2YWxpZFxuICAgIHNyYyA9IFtzcmNdO1xuICB9IGVsc2Uge1xuICAgIC8vIGludmFsaWQgc291cmNlLCB0dXJuIGl0IGludG8gYW4gZW1wdHkgYXJyYXlcbiAgICBzcmMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59O1xuXG4vKipcbiAqIEBmaWxlIGxvYWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBgTWVkaWFMb2FkZXJgIGlzIHRoZSBgQ29tcG9uZW50YCB0aGF0IGRlY2lkZXMgd2hpY2ggcGxheWJhY2sgdGVjaG5vbG9neSB0byBsb2FkXG4gKiB3aGVuIGEgcGxheWVyIGlzIGluaXRpYWxpemVkLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZWRpYUxvYWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lZGlhTG9hZGVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdHJvZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgcnVuIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBNZWRpYUxvYWRlcihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVkaWFMb2FkZXIpO1xuXG4gICAgLy8gTWVkaWFMb2FkZXIgaGFzIG5vIGVsZW1lbnRcbiAgICB2YXIgb3B0aW9uc18gPSBtZXJnZU9wdGlvbnMoeyBjcmVhdGVFbDogZmFsc2UgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc291cmNlcyB3aGVuIHRoZSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQsXG4gICAgLy8gbG9hZCB0aGUgZmlyc3Qgc3VwcG9ydGVkIHBsYXliYWNrIHRlY2hub2xvZ3kuXG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnNfLCByZWFkeSkpO1xuXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyB8fCBvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gb3B0aW9ucy5wbGF5ZXJPcHRpb25zLnRlY2hPcmRlcjsgaSA8IGoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRlY2hOYW1lID0gdG9UaXRsZUNhc2UoaltpXSk7XG4gICAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXG4gICAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxuICAgICAgICBpZiAoIXRlY2hOYW1lKSB7XG4gICAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0ZWNoICYmIHRlY2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgIHBsYXllci5sb2FkVGVjaF8odGVjaE5hbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgKEhUTUw1LCBGbGFzaCkgYW5kIGNoZWNrIGZvciBzdXBwb3J0LlxuICAgICAgLy8gVGhlbiBsb2FkIHRoZSBiZXN0IHNvdXJjZS5cbiAgICAgIC8vIEEgZmV3IGFzc3VtcHRpb25zIGhlcmU6XG4gICAgICAvLyAgIEFsbCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgcmVzcGVjdCBwcmVsb2FkIGZhbHNlLlxuICAgICAgcGxheWVyLnNyYyhvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBNZWRpYUxvYWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYUxvYWRlcicsIE1lZGlhTG9hZGVyKTtcblxuLyoqXG4gKiBAZmlsZSBidXR0b24uanNcbiAqL1xuLyoqXG4gKiBDbGlja2FibGUgQ29tcG9uZW50IHdoaWNoIGlzIGNsaWNrYWJsZSBvciBrZXlib2FyZCBhY3Rpb25hYmxlLFxuICogYnV0IGlzIG5vdCBhIG5hdGl2ZSBIVE1MIGJ1dHRvbi5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ2xpY2thYmxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ2xpY2thYmxlQ29tcG9uZW50LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDbGlja2FibGVDb21wb25lbnQocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuZW1pdFRhcEV2ZW50cygpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZz1kaXZdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGl2JztcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBsb2ckMS5lcnJvcignQ3JlYXRpbmcgYSBDbGlja2FibGVDb21wb25lbnQgd2l0aCBhbiBIVE1MIGVsZW1lbnQgb2YgJyArIHRhZyArICcgaXMgbm90IHN1cHBvcnRlZDsgdXNlIGEgQnV0dG9uIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIEFSSUEgYXR0cmlidXRlcyBmb3IgY2xpY2thYmxlIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uXG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7XG4gICAgICAncm9sZSc6ICdidXR0b24nLFxuXG4gICAgICAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGVsZW1lbnQgbWF5IGNoYW5nZVxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSwgYXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLnRhYkluZGV4XyA9IHByb3BzLnRhYkluZGV4O1xuXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvLyByZW1vdmUgY29udHJvbFRleHRFbF8gb24gZGlwb3NlXG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnRyb2wgdGV4dCBlbGVtZW50IG9uIHRoaXMgYENvbXBvbmVudGBcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWxdXG4gICAqICAgICAgICBQYXJlbnQgZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgdGV4dC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udHJvbCB0ZXh0IGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVDb250cm9sVGV4dEVsID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFRleHRFbChlbCkge1xuICAgIHRoaXMuY29udHJvbFRleHRFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnXG4gICAgfSk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udHJvbFRleHRFbF8pO1xuICAgIH1cblxuICAgIHRoaXMuY29udHJvbFRleHQodGhpcy5jb250cm9sVGV4dF8sIGVsKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0RWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZSB0ZXh0IHRvIHVzZSBmb3IgdGhlIGNvbnRyb2xzIG9uIHRoZSBgQ29tcG9uZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuZWwoKTtcblxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xUZXh0XyB8fCAnTmVlZCBUZXh0JztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxpemVkVGV4dCA9IHRoaXMubG9jYWxpemUodGV4dCk7XG5cbiAgICB0aGlzLmNvbnRyb2xUZXh0XyA9IHRleHQ7XG4gICAgdGV4dENvbnRlbnQodGhpcy5jb250cm9sVGV4dEVsXywgbG9jYWxpemVkVGV4dCk7XG4gICAgaWYgKCF0aGlzLm5vbkljb25Db250cm9sKSB7XG4gICAgICAvLyBTZXQgdGl0bGUgYXR0cmlidXRlIGlmIG9ubHkgYW4gaWNvbiBpcyBzaG93blxuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxvY2FsaXplZFRleHQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY29udHJvbCB2anMtYnV0dG9uICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsIHRoaXMudGFiSW5kZXhfKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMpO1xuICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIH1cbiAgICB0aGlzLm9mZihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICB0aGlzLm9mZignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGdldHM6XG4gICAqIC0gQ2xpY2tlZCAodmlhIHRoZSBgY2xpY2tgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUYXBwZWQgKHZpYSB0aGUgYHRhcGAgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxuICAgKiAtIFRoZSBmb2xsb3dpbmcgdGhpbmdzIGhhcHBlbiBpbiBvcmRlcjpcbiAgICogICAxLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBpcyBjYWxsZWQgdmlhIGEgYGZvY3VzYCBldmVudCBvbiB0aGVcbiAgICogICAgICBgQ2xpY2thYmxlQ29tcG9uZW50YC5cbiAgICogICAyLiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUZvY3VzfSBhZGRzIGEgbGlzdGVuZXIgZm9yIGBrZXlkb3duYCBvbiB1c2luZ1xuICAgKiAgICAgIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9LlxuICAgKiAgIDMuIGBDbGlja2FibGVDb21wb25lbnRgIGhhcyBub3QgaGFkIGEgYGJsdXJgIGV2ZW50IChgYmx1cmAgbWVhbnMgdGhhdCBmb2N1cyB3YXMgbG9zdCkuIFRoZSB1c2VyIHByZXNzZXNcbiAgICogICAgICB0aGUgc3BhY2Ugb3IgZW50ZXIga2V5LlxuICAgKiAgIDQuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgYGtleWRvd25gXG4gICAqICAgICAgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKGV2ZW50KSB7XG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgQ2xpY2thYmxlQ29tcG9uZW50IGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUNsaWNrYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBTdXBwb3J0IFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uIHRvIGZpcmUgYSBjbGljayBldmVudFxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcblxuICAgICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGBDbGlja2FibGVDb21wb25lbnRgIGxvc2VzIGZvY3VzLiBUdXJucyBvZmYgdGhlIGxpc3RlbmVyIGZvclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGJsdXJcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIHJldHVybiBDbGlja2FibGVDb21wb25lbnQ7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2xpY2thYmxlQ29tcG9uZW50JywgQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSBwb3N0ZXItaW1hZ2UuanNcbiAqL1xuLyoqXG4gKiBBIGBDbGlja2FibGVDb21wb25lbnRgIHRoYXQgaGFuZGxlcyBzaG93aW5nIHRoZSBwb3N0ZXIgaW1hZ2UgZm9yIHRoZSBwbGF5ZXIuXG4gKlxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XG4gKi9cblxudmFyIFBvc3RlckltYWdlID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUG9zdGVySW1hZ2UsIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9zdGVySW1hZ2UocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zdGVySW1hZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcbiAgICBwbGF5ZXIub24oJ3Bvc3RlcmNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5vZmYoJ3Bvc3RlcmNoYW5nZScsIHRoaXMudXBkYXRlKTtcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBvc3RlckltYWdlYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wb3N0ZXInLFxuXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cbiAgICAgIHRhYkluZGV4OiAtMVxuICAgIH0pO1xuXG4gICAgLy8gVG8gZW5zdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgcmVzaXplcyB3aGlsZSBtYWludGFpbmluZyBpdHMgb3JpZ2luYWwgYXNwZWN0XG4gICAgLy8gcmF0aW8sIHVzZSBhIGRpdiB3aXRoIGBiYWNrZ3JvdW5kLXNpemVgIHdoZW4gYXZhaWxhYmxlLiBGb3IgYnJvd3NlcnMgdGhhdFxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcbiAgICAvLyBpbWcgZWxlbWVudC5cbiAgICBpZiAoIUJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQpIHtcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfID0gY3JlYXRlRWwoJ2ltZycpO1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5mYWxsYmFja0ltZ18pO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciB7QGxpbmsgUGxheWVyI3Bvc3RlcmNoYW5nZX0gZXZlbnRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgUGxheWVyI3Bvc3RlcmNoYW5nZWAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XG5cbiAgICB0aGlzLnNldFNyYyh1cmwpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBwb3N0ZXIgc291cmNlIHdlIHNob3VsZCBkaXNwbGF5Om5vbmUgb24gdGhpcyBjb21wb25lbnRcbiAgICAvLyBzbyBpdCdzIG5vdCBzdGlsbCBjbGlja2FibGUgb3IgcmlnaHQtY2xpY2thYmxlXG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGBQb3N0ZXJJbWFnZWAgZGVwZW5kaW5nIG9uIHRoZSBkaXNwbGF5IG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiAgICAgICAgVGhlIFVSTCB0byB0aGUgc291cmNlIGZvciB0aGUgYFBvc3RlckltYWdlYC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHVybCkge1xuICAgIGlmICh0aGlzLmZhbGxiYWNrSW1nXykge1xuICAgICAgdGhpcy5mYWxsYmFja0ltZ18uc3JjID0gdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gJyc7XG5cbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXG4gICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXh0cmEgZXJyb3JcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQW4ge0BsaW5rIEV2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZvciBjbGlja3Mgb24gdGhlIGBQb3N0ZXJJbWFnZWAuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICArICAgICAgICBUaGUgYGNsaWNrYCwgYHRhcGAgb3IgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBhIGNsaWNrIHRvIHRyaWdnZXIgcGxheWJhY2sgd2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWRcbiAgICBpZiAoIXRoaXMucGxheWVyXy5jb250cm9scygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQb3N0ZXJJbWFnZTtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWRpc3BsYXkuanNcbiAqL1xudmFyIGRhcmtHcmF5ID0gJyMyMjInO1xudmFyIGxpZ2h0R3JheSA9ICcjY2NjJztcbnZhciBmb250TWFwID0ge1xuICBtb25vc3BhY2U6ICdtb25vc3BhY2UnLFxuICBzYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcbiAgc2VyaWY6ICdzZXJpZicsXG4gIG1vbm9zcGFjZVNhbnNTZXJpZjogJ1wiQW5kYWxlIE1vbm9cIiwgXCJMdWNpZGEgQ29uc29sZVwiLCBtb25vc3BhY2UnLFxuICBtb25vc3BhY2VTZXJpZjogJ1wiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlJyxcbiAgcHJvcG9ydGlvbmFsU2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHByb3BvcnRpb25hbFNlcmlmOiAnc2VyaWYnLFxuICBjYXN1YWw6ICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcbiAgc2NyaXB0OiAnXCJNb25vdHlwZSBDb3JzaXZhXCIsIGN1cnNpdmUnLFxuICBzbWFsbGNhcHM6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlLCBzYW5zLXNlcmlmJ1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gcmdiYSBjb2xvciBmcm9tIGEgZ2l2ZW4gaGV4IGNvbG9yIGNvZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yXG4gKiAgICAgICAgSGV4IG51bWJlciBmb3IgY29sb3IsIGxpa2UgI2YwZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgcmV0dXJuICdyZ2JhKCcgK1xuICAvLyBjb2xvciBsb29rcyBsaWtlIFwiI2YwZVwiXG4gIHBhcnNlSW50KGNvbG9yWzFdICsgY29sb3JbMV0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzJdICsgY29sb3JbMl0sIDE2KSArICcsJyArIHBhcnNlSW50KGNvbG9yWzNdICsgY29sb3JbM10sIDE2KSArICcsJyArIG9wYWNpdHkgKyAnKSc7XG59XG5cbi8qKlxuICogVHJ5IHRvIHVwZGF0ZSB0aGUgc3R5bGUgb2YgYSBET00gZWxlbWVudC4gU29tZSBzdHlsZSBjaGFuZ2VzIHdpbGwgdGhyb3cgYW4gZXJyb3IsXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlVcGRhdGVTdHlsZShlbCwgc3R5bGUsIHJ1bGUpIHtcbiAgdHJ5IHtcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xuICB9IGNhdGNoIChlKSB7XG5cbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxuICAgIHJldHVybjtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZXh0VHJhY2tEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnRvZ2dsZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ3RleHR0cmFja2NoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZURpc3BsYXkpKTtcbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnByZXNlbGVjdFRyYWNrKSk7XG5cbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgY2FsbGVkIGR1cmluZyBwbGF5ZXIgaW5pdCwgYnV0IHdhcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cbiAgICAvLyBTaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgdG8gYW4gZXh0ZXJuYWwgdHJhY2sgbG9hZGVyIHdoZW4gd2Ugc3VwcG9ydFxuICAgIC8vIHRyYWNrcyB0aGF0IGRvbid0IG5lZWQgYSBkaXNwbGF5LlxuICAgIHBsYXllci5yZWFkeShiaW5kKF90aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGxheWVyLnRlY2hfICYmIHBsYXllci50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcblxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucy50cmFja3MgfHwgW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGxheWVyXy5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2tzW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmVzZWxlY3RUcmFjaygpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgKiBQcmVzZWxlY3QgYSB0cmFjayBmb2xsb3dpbmcgdGhpcyBwcmVjZWRlbmNlOlxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIGFuZCBraW5kXG4gICogLSBtYXRjaGVzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIHtAbGluayBUZXh0VHJhY2t9J3MgbGFuZ3VhZ2Ugb25seVxuICAqIC0gaXMgdGhlIGZpcnN0IGRlZmF1bHQgY2FwdGlvbnMgdHJhY2tcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFja1xuICAqXG4gICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUucHJlc2VsZWN0VHJhY2sgPSBmdW5jdGlvbiBwcmVzZWxlY3RUcmFjaygpIHtcbiAgICB2YXIgbW9kZXMgPSB7IGNhcHRpb25zOiAxLCBzdWJ0aXRsZXM6IDEgfTtcbiAgICB2YXIgdHJhY2tMaXN0ID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcbiAgICB2YXIgdXNlclByZWYgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XG4gICAgdmFyIGZpcnN0RGVzYyA9IHZvaWQgMDtcbiAgICB2YXIgZmlyc3RDYXB0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgcHJlZmVycmVkVHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tMaXN0W2ldO1xuXG4gICAgICBpZiAodXNlclByZWYgJiYgdXNlclByZWYuZW5hYmxlZCAmJiB1c2VyUHJlZi5sYW5ndWFnZSA9PT0gdHJhY2subGFuZ3VhZ2UpIHtcbiAgICAgICAgLy8gQWx3YXlzIGNob29zZSB0aGUgdHJhY2sgdGhhdCBtYXRjaGVzIGJvdGggbGFuZ3VhZ2UgYW5kIGtpbmRcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHVzZXJQcmVmLmtpbmQpIHtcbiAgICAgICAgICBwcmVmZXJyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICAgIC8vIG9yIGNob29zZSB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIGxhbmd1YWdlXG4gICAgICAgIH0gZWxzZSBpZiAoIXByZWZlcnJlZFRyYWNrKSB7XG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGV2ZXJ5dGhpbmcgaWYgb2ZmVGV4dFRyYWNrTWVudUl0ZW0gd2FzIGNsaWNrZWRcbiAgICAgIH0gZWxzZSBpZiAodXNlclByZWYgJiYgIXVzZXJQcmVmLmVuYWJsZWQpIHtcbiAgICAgICAgcHJlZmVycmVkVHJhY2sgPSBudWxsO1xuICAgICAgICBmaXJzdERlc2MgPSBudWxsO1xuICAgICAgICBmaXJzdENhcHRpb25zID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tbJ2RlZmF1bHQnXSkge1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2Rlc2NyaXB0aW9ucycgJiYgIWZpcnN0RGVzYykge1xuICAgICAgICAgIGZpcnN0RGVzYyA9IHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgaW4gbW9kZXMgJiYgIWZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgICAgICBmaXJzdENhcHRpb25zID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlZmVycmVkVHJhY2sgbWF0Y2hlcyB0aGUgdXNlciBwcmVmZXJlbmNlIGFuZCB0YWtlc1xuICAgIC8vIHByZWNlbmRlbmNlIG92ZXIgYWxsIHRoZSBvdGhlciB0cmFja3MuXG4gICAgLy8gU28sIGRpc3BsYXkgdGhlIHByZWZlcnJlZFRyYWNrIGJlZm9yZSB0aGUgZmlyc3QgZGVmYXVsdCB0cmFja1xuICAgIC8vIGFuZCB0aGUgc3VidGl0bGVzL2NhcHRpb25zIHRyYWNrIGJlZm9yZSB0aGUgZGVzY3JpcHRpb25zIHRyYWNrXG4gICAgaWYgKHByZWZlcnJlZFRyYWNrKSB7XG4gICAgICBwcmVmZXJyZWRUcmFjay5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3RDYXB0aW9ucykge1xuICAgICAgZmlyc3RDYXB0aW9ucy5tb2RlID0gJ3Nob3dpbmcnO1xuICAgIH0gZWxzZSBpZiAoZmlyc3REZXNjKSB7XG4gICAgICBmaXJzdERlc2MubW9kZSA9ICdzaG93aW5nJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gZGlzcGxheSBvZiB7QGxpbmsgVGV4dFRyYWNrfSdzIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgaW50byB0aGUgb3RoZXIgc3RhdGUuXG4gICAqIFRoZXJlIGFyZSBvbmx5IHR3byBzdGF0ZXM6XG4gICAqIC0gJ3Nob3duJ1xuICAgKiAtICdoaWRkZW4nXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS50b2dnbGVEaXNwbGF5ID0gZnVuY3Rpb24gdG9nZ2xlRGlzcGxheSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnRlY2hfICYmIHRoaXMucGxheWVyXy50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUge0BsaW5rIENvbXBvbmVudH0ncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnLFxuICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBkaXNwbGF5ZWQge0BsaW5rIFRleHRUcmFja31zLlxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNsZWFyRGlzcGxheSA9IGZ1bmN0aW9uIGNsZWFyRGlzcGxheSgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBbXSwgdGhpcy5lbF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkaXNwbGF5ZWQgVGV4dFRyYWNrIHdoZW4gYSBlaXRoZXIgYSB7QGxpbmsgUGxheWVyI3RleHR0cmFja2NoYW5nZX0gb3JcbiAgICogYSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGlzIGZpcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICB0aGlzLmNsZWFyRGlzcGxheSgpO1xuXG4gICAgLy8gVHJhY2sgZGlzcGxheSBwcmlvcml0aXphdGlvbiBtb2RlbDogaWYgbXVsdGlwbGUgdHJhY2tzIGFyZSAnc2hvd2luZycsXG4gICAgLy8gIGRpc3BsYXkgdGhlIGZpcnN0ICdzdWJ0aXRsZXMnIG9yICdjYXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnLFxuICAgIC8vICBvdGhlcndpc2UgZGlzcGxheSB0aGUgZmlyc3QgJ2Rlc2NyaXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnXG5cbiAgICB2YXIgZGVzY3JpcHRpb25zVHJhY2sgPSBudWxsO1xuICAgIHZhciBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gbnVsbDtcbiAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zVHJhY2sgPSB0cmFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0aW9uc1N1YnRpdGxlc1RyYWNrID0gdHJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FwdGlvbnNTdWJ0aXRsZXNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ29mZicpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayk7XG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbnNUcmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnKSAhPT0gJ2Fzc2VydGl2ZScpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9yVHJhY2soZGVzY3JpcHRpb25zVHJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIHtAbGluayBUZXh0dHJhY2t9IHRvIHRvIHRoZSB7QGxpbmsgVGVjaH1zIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUZXh0IHRyYWNrIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVGb3JUcmFjayA9IGZ1bmN0aW9uIHVwZGF0ZUZvclRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUICE9PSAnZnVuY3Rpb24nIHx8ICF0cmFjay5hY3RpdmVDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG92ZXJyaWRlcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tTZXR0aW5ncy5nZXRWYWx1ZXMoKTtcbiAgICB2YXIgY3VlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRyYWNrLmFjdGl2ZUN1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBjdWVzLnB1c2godHJhY2suYWN0aXZlQ3Vlc1tfaV0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93LCBjdWVzLCB0aGlzLmVsXyk7XG5cbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIGlmICghY3VlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcblxuICAgICAgaWYgKG92ZXJyaWRlcy5jb2xvcikge1xuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMudGV4dE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZE9wYWNpdHkpIHtcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd0NvbG9yKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xuICAgICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdiwgJ2JhY2tncm91bmRDb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy53aW5kb3dDb2xvciwgb3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2Ryb3BzaGFkb3cnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcycHggMnB4IDNweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDRweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4IDVweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCAnICsgZGFya0dyYXkgKyAnLCAzcHggM3B4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZGVwcmVzc2VkJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICd1bmlmb3JtJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuZm9udFBlcmNlbnQgJiYgb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICE9PSAxKSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvdy5wYXJzZUZsb2F0KGN1ZURpdi5zdHlsZS5mb250U2l6ZSk7XG5cbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQgKyAncHgnO1xuICAgICAgICBjdWVEaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgJiYgb3ZlcnJpZGVzLmZvbnRGYW1pbHkgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRWYXJpYW50ID0gJ3NtYWxsLWNhcHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXG4gKi9cbi8qKlxuICogQSBsb2FkaW5nIHNwaW5uZXIgZm9yIHVzZSBkdXJpbmcgd2FpdGluZy9sb2FkaW5nIGV2ZW50cy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTG9hZGluZ1NwaW5uZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkaW5nU3Bpbm5lciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9hZGluZ1NwaW5uZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1NwaW5uZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTG9hZGluZ1NwaW5uZXJgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBMb2FkaW5nU3Bpbm5lci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWRpbmctc3Bpbm5lcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRpbmdTcGlubmVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRpbmdTcGlubmVyJywgTG9hZGluZ1NwaW5uZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidXR0b25zLlxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBpbmhlcml0cyhCdXR0b24sIF9DbGlja2FibGVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJ1dHRvbigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPVwiYnV0dG9uXCJdXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS4gVGhpcyBhcmd1bWVudCBpcyBJR05PUkVEOiBubyBtYXR0ZXIgd2hhdFxuICAgKiAgICAgICAgaXMgcGFzc2VkLCBpdCB3aWxsIGFsd2F5cyBjcmVhdGUgYSBgYnV0dG9uYCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuICBCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodGFnKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB0YWcgPSAnYnV0dG9uJztcblxuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+JyxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcbiAgICB9LCBwcm9wcyk7XG5cbiAgICAvLyBBZGQgYXR0cmlidXRlcyBmb3IgYnV0dG9uIGVsZW1lbnRcbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcblxuICAgICAgLy8gTmVjZXNzYXJ5IHNpbmNlIHRoZSBkZWZhdWx0IGJ1dHRvbiB0eXBlIGlzIFwic3VibWl0XCJcbiAgICAgICd0eXBlJzogJ2J1dHRvbicsXG5cbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgYnV0dG9uIG1heSBjaGFuZ2VcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgdmFyIGVsID0gQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIG9mIHRoaXMgYEJ1dHRvbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcbiAgICogICAgICAgIHRoZSBjaGlsZC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1XG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGxvZyQxLndhcm4oJ0FkZGluZyBhbiBhY3Rpb25hYmxlICh1c2VyIGNvbnRyb2xsYWJsZSkgY2hpbGQgdG8gYSBCdXR0b24gKCcgKyBjbGFzc05hbWUgKyAnKSBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBDbGlja2FibGVDb21wb25lbnQgaW5zdGVhZC4nKTtcblxuICAgIC8vIEF2b2lkIHRoZSBlcnJvciBtZXNzYWdlIGdlbmVyYXRlZCBieSBDbGlja2FibGVDb21wb25lbnQncyBhZGRDaGlsZCBtZXRob2RcbiAgICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgQnV0dG9uYCBlbGVtZW50IHNvIHRoYXQgaXQgY2FuIGJlIGFjdGl2YXRlZCBvciBjbGlja2VkLiBVc2UgdGhpcyB3aXRoXG4gICAqIHtAbGluayBCdXR0b24jZGlzYWJsZX0uXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGBCdXR0b25gIGVsZW1lbnQgc28gdGhhdCBpdCBjYW5ub3QgYmUgYWN0aXZhdGVkIG9yIGNsaWNrZWQuIFVzZSB0aGlzIHdpdGhcbiAgICoge0BsaW5rIEJ1dHRvbiNlbmFibGV9LlxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJ1dHRvbmAgaGFzIGZvY3VzIGFuZCBga2V5ZG93bmAgaXMgdHJpZ2dlcmVkIHZpYSBhIGtleVxuICAgKiBwcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGdldCBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIElnbm9yZSBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBmb3IgYSBidXR0b24uXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGJpZy1wbGF5LWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBpbml0aWFsIHBsYXkgYnV0dG9uIHRoYXQgc2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxuICogYEJpZ1BsYXlCdXR0b25gIGdldCBkb25lIHZpYSBDU1MgYW5kIGBQbGF5ZXJgIHN0YXRlcy5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgQmlnUGxheUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKEJpZ1BsYXlCdXR0b24sIF9CdXR0b24pO1xuXG4gIGZ1bmN0aW9uIEJpZ1BsYXlCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlnUGxheUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuIEFsd2F5cyByZXR1cm5zICd2anMtYmlnLXBsYXktYnV0dG9uJy5cbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1iaWctcGxheS1idXR0b24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQmlnUGxheUJ1dHRvbmAgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxuICAgKiBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHBsYXlQcm9taXNlID0gdGhpcy5wbGF5ZXJfLnBsYXkoKTtcblxuICAgIC8vIGV4aXQgZWFybHkgaWYgY2xpY2tlZCB2aWEgdGhlIG1vdXNlXG4gICAgaWYgKHRoaXMubW91c2V1c2VkXyAmJiBldmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uZ2V0Q2hpbGQoJ2NvbnRyb2xCYXInKTtcbiAgICB2YXIgcGxheVRvZ2dsZSA9IGNiICYmIGNiLmdldENoaWxkKCdwbGF5VG9nZ2xlJyk7XG5cbiAgICBpZiAoIXBsYXlUb2dnbGUpIHtcbiAgICAgIHRoaXMucGxheWVyXy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwbGF5Rm9jdXMgPSBmdW5jdGlvbiBwbGF5Rm9jdXMoKSB7XG4gICAgICByZXR1cm4gcGxheVRvZ2dsZS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBpZiAoaXNQcm9taXNlKHBsYXlQcm9taXNlKSkge1xuICAgICAgcGxheVByb21pc2UudGhlbihwbGF5Rm9jdXMsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KHBsYXlGb2N1cywgMSk7XG4gICAgfVxuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcblxuICAgIF9CdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHRoaXMubW91c2V1c2VkXyA9IHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIEJpZ1BsYXlCdXR0b247XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQmlnUGxheUJ1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXkgVmlkZW8nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0JpZ1BsYXlCdXR0b24nLCBCaWdQbGF5QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjbG9zZS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYENsb3NlQnV0dG9uYCBpcyBhIGB7QGxpbmsgQnV0dG9ufWAgdGhhdCBmaXJlcyBhIGBjbG9zZWAgZXZlbnQgd2hlblxuICogaXQgZ2V0cyBjbGlja2VkLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvc2VCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNsb3NlLWJ1dHRvbiAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xvc2VCdXR0b25gIGdldHMgY2xpY2tlZC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXG4gICAqIHRyaWdnZXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBhIGBDbG9zZUJ1dHRvbmAgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXAgdG8gcGFyZW50cyBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lclxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdjbG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJldHVybiBDbG9zZUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbG9zZUJ1dHRvbicsIENsb3NlQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZS5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgUGxheVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKFBsYXlUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5VG9nZ2xlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAncGxheScsIF90aGlzLmhhbmRsZVBsYXkpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3BhdXNlJywgX3RoaXMuaGFuZGxlUGF1c2UpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgb25jZSBhZnRlciB0aGUgdmlkZW8gaGFzIGVuZGVkIGFuZCB0aGUgdXNlciBzZWVrcyBzbyB0aGF0XG4gICAqIHdlIGNhbiBjaGFuZ2UgdGhlIHJlcGxheSBidXR0b24gYmFjayB0byBhIHBsYXkgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNzZWVrZWRcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVTZWVrZWQgPSBmdW5jdGlvbiBoYW5kbGVTZWVrZWQoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcblxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlUGF1c2UoZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZVBsYXkoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtcGxheWluZyBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3BsYXlcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVQbGF5ID0gZnVuY3Rpb24gaGFuZGxlUGxheShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGxheWluZycpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQYXVzZVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtcGF1c2VkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcGF1c2VcbiAgICovXG5cblxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVQYXVzZSA9IGZ1bmN0aW9uIGhhbmRsZVBhdXNlKGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlBsYXlcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSB2anMtZW5kZWQgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlJlcGxheVwiXG4gICAgdGhpcy5jb250cm9sVGV4dCgnUmVwbGF5Jyk7XG5cbiAgICAvLyBvbiB0aGUgbmV4dCBzZWVrIHJlbW92ZSB0aGUgcmVwbGF5IGJ1dHRvblxuICAgIHRoaXMub25lKHRoaXMucGxheWVyXywgJ3NlZWtlZCcsIHRoaXMuaGFuZGxlU2Vla2VkKTtcbiAgfTtcblxuICByZXR1cm4gUGxheVRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBQbGF5VG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5VG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVRvZ2dsZScsIFBsYXlUb2dnbGUpO1xuXG4vKipcbiAqIEBmaWxlIGZvcm1hdC10aW1lLmpzXG4gKiBAbW9kdWxlIEZvcm1hdC10aW1lXG4gKi9cblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1MuIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKVxuICogd2lsbCBmb3JjZSBhIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzXG4gKiAgICAgICAgTnVtYmVyIG9mIHNlY29uZHMgdG8gYmUgdHVybmVkIGludG8gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZ3VpZGVcbiAqICAgICAgICBOdW1iZXIgKGluIHNlY29uZHMpIHRvIG1vZGVsIHRoZSBzdHJpbmcgYWZ0ZXJcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRpbWUgZm9ybWF0dGVkIGFzIEg6TU06U1Mgb3IgTTpTU1xuICovXG5mdW5jdGlvbiBmb3JtYXRUaW1lKHNlY29uZHMpIHtcbiAgdmFyIGd1aWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzZWNvbmRzO1xuXG4gIHNlY29uZHMgPSBzZWNvbmRzIDwgMCA/IDAgOiBzZWNvbmRzO1xuICB2YXIgcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAlIDYwKTtcbiAgdmFyIG0gPSBNYXRoLmZsb29yKHNlY29uZHMgLyA2MCAlIDYwKTtcbiAgdmFyIGggPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcbiAgdmFyIGdtID0gTWF0aC5mbG9vcihndWlkZSAvIDYwICUgNjApO1xuICB2YXIgZ2ggPSBNYXRoLmZsb29yKGd1aWRlIC8gMzYwMCk7XG5cbiAgLy8gaGFuZGxlIGludmFsaWQgdGltZXNcbiAgaWYgKGlzTmFOKHNlY29uZHMpIHx8IHNlY29uZHMgPT09IEluZmluaXR5KSB7XG4gICAgLy8gJy0nIGlzIGZhbHNlIGZvciBhbGwgcmVsYXRpb25hbCBvcGVyYXRvcnMgKGUuZy4gPCwgPj0pIHNvIHRoaXMgc2V0dGluZ1xuICAgIC8vIHdpbGwgYWRkIHRoZSBtaW5pbXVtIG51bWJlciBvZiBmaWVsZHMgc3BlY2lmaWVkIGJ5IHRoZSBndWlkZVxuICAgIGggPSBtID0gcyA9ICctJztcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyBob3Vyc1xuICBoID0gaCA+IDAgfHwgZ2ggPiAwID8gaCArICc6JyA6ICcnO1xuXG4gIC8vIElmIGhvdXJzIGFyZSBzaG93aW5nLCB3ZSBtYXkgbmVlZCB0byBhZGQgYSBsZWFkaW5nIHplcm8uXG4gIC8vIEFsd2F5cyBzaG93IGF0IGxlYXN0IG9uZSBkaWdpdCBvZiBtaW51dGVzLlxuICBtID0gKChoIHx8IGdtID49IDEwKSAmJiBtIDwgMTAgPyAnMCcgKyBtIDogbSkgKyAnOic7XG5cbiAgLy8gQ2hlY2sgaWYgbGVhZGluZyB6ZXJvIGlzIG5lZWQgZm9yIHNlY29uZHNcbiAgcyA9IHMgPCAxMCA/ICcwJyArIHMgOiBzO1xuXG4gIHJldHVybiBoICsgbSArIHM7XG59XG5cbi8qKlxuICogQGZpbGUgdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIHRpbWUgbGVmdCBpbiB0aGUgdmlkZW9cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3RpbWV1cGRhdGUnLCBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMShwbGFpbk5hbWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5idWlsZENTU0NsYXNzKCk7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAnIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAnLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSh0aGlzLmNvbnRyb2xUZXh0XylcbiAgICB9KSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHROb2RlXygpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIFRpbWVEaXNwbGF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBudWxsO1xuICAgIHRoaXMudGV4dE5vZGVfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgXCJyZW1haW5pbmcgdGltZVwiIHRleHQgbm9kZSB3aXRoIG5ldyBjb250ZW50IHVzaW5nIHRoZVxuICAgKiBjb250ZW50cyBvZiB0aGUgYGZvcm1hdHRlZFRpbWVfYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlVGV4dE5vZGVfID0gZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGVfKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50RWxfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuY29udGVudEVsXy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy5jb250ZW50RWxfLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMudGV4dE5vZGVfID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5mb3JtYXR0ZWRUaW1lXyB8fCAnMDowMCcpO1xuICAgIHRoaXMuY29udGVudEVsXy5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGZvcm1hdHRlZCB0aW1lIGZvciB0aGlzIGNvbXBvbmVudCB0byB1c2UgaW4gZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lXG4gICAqICAgICAgICAgQSBudW1lcmljIHRpbWUsIGluIHNlY29uZHMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBIGZvcm1hdHRlZCB0aW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGltZURpc3BsYXkucHJvdG90eXBlLmZvcm1hdFRpbWVfID0gZnVuY3Rpb24gZm9ybWF0VGltZV8odGltZSkge1xuICAgIHJldHVybiBmb3JtYXRUaW1lKHRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0aW1lIGRpc3BsYXkgdGV4dCBub2RlIGlmIGl0IGhhcyB3aGF0IHdhcyBwYXNzZWQgaW4gY2hhbmdlZFxuICAgKiB0aGUgZm9ybWF0dGVkIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG4gICAqICAgICAgICBUaGUgdGltZSB0byB1cGRhdGUgdG9cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRm9ybWF0dGVkVGltZV8gPSBmdW5jdGlvbiB1cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aW1lKSB7XG4gICAgdmFyIGZvcm1hdHRlZFRpbWUgPSB0aGlzLmZvcm1hdFRpbWVfKHRpbWUpO1xuXG4gICAgaWYgKGZvcm1hdHRlZFRpbWUgPT09IHRoaXMuZm9ybWF0dGVkVGltZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdHRlZFRpbWVfID0gZm9ybWF0dGVkVGltZTtcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZVRleHROb2RlXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvIGJlIGZpbGxlZCBvdXQgaW4gdGhlIGNoaWxkIGNsYXNzLCBzaG91bGQgdXBkYXRlIHRoZSBkaXNwbGF5ZWQgdGltZVxuICAgKiBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIGZhY3QgdGhhdCB0aGUgY3VycmVudCB0aW1lIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgICBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICovXG5cblxuICBUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHt9O1xuXG4gIHJldHVybiBUaW1lRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVGltZURpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGlzcGxheScsIFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ3VycmVudFRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9UaW1lRGlzcGxheSkge1xuICBpbmhlcml0cyhDdXJyZW50VGltZURpc3BsYXksIF9UaW1lRGlzcGxheSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDdXJyZW50VGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VycmVudFRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbWVEaXNwbGF5LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIF90aGlzLmhhbmRsZUVuZGVkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY3VycmVudC10aW1lJztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgZmlyZXMgZW5kZWQgdGhlcmUgc2hvdWxkIGJlIG5vIHRpbWUgbGVmdC4gU2FkbHlcbiAgICogdGhpcyBpcyBub3QgYWx3YXlzIHRoZSBjYXNlLCBsZXRzIG1ha2UgaXQgc2VlbSBsaWtlIHRoYXQgaXMgdGhlIGNhc2VcbiAgICogZm9yIHVzZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2VuZGVkXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcbiAgfTtcblxuICByZXR1cm4gQ3VycmVudFRpbWVEaXNwbGF5O1xufShUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ3VycmVudFRpbWVEaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDdXJyZW50IFRpbWUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0N1cnJlbnRUaW1lRGlzcGxheScsIEN1cnJlbnRUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgZHVyYXRpb24tZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSBkdXJhdGlvblxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBEdXJhdGlvbkRpc3BsYXkgPSBmdW5jdGlvbiAoX1RpbWVEaXNwbGF5KSB7XG4gIGluaGVyaXRzKER1cmF0aW9uRGlzcGxheSwgX1RpbWVEaXNwbGF5KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4gICAgLy8gd2UgZG8gbm90IHdhbnQgdG8vbmVlZCB0byB0aHJvdHRsZSBkdXJhdGlvbiBjaGFuZ2VzLFxuICAgIC8vIGFzIHRoZXkgc2hvdWxkIGFsd2F5cyBkaXNwbGF5IHRoZSBjaGFuZ2VkIGR1cmF0aW9uIGFzXG4gICAgLy8gaXQgaGFzIGNoYW5nZWRcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW1lRGlzcGxheS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZHVyYXRpb25jaGFuZ2UnLCBfdGhpcy51cGRhdGVDb250ZW50KTtcblxuICAgIC8vIEFsc28gbGlzdGVuIGZvciB0aW1ldXBkYXRlIChpbiB0aGUgcGFyZW50KSBhbmQgbG9hZGVkbWV0YWRhdGEgYmVjYXVzZSByZW1vdmluZyB0aG9zZVxuICAgIC8vIGxpc3RlbmVycyBjb3VsZCBoYXZlIGJyb2tlbiBkZXBlbmRlbnQgYXBwbGljYXRpb25zL2xpYnJhcmllcy4gVGhlc2VcbiAgICAvLyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQgZm9yIDcuMC5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdsb2FkZWRtZXRhZGF0YScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kdXJhdGlvbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkdXJhdGlvbiB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgLCBgdGltZXVwZGF0ZWAsIG9yIGBsb2FkZWRtZXRhZGF0YWAgZXZlbnQgdGhhdCBjYXVzZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgaWYgKGR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb25fICE9PSBkdXJhdGlvbikge1xuICAgICAgdGhpcy5kdXJhdGlvbl8gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMudXBkYXRlRm9ybWF0dGVkVGltZV8oZHVyYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHVyYXRpb25EaXNwbGF5O1xufShUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRHVyYXRpb25EaXNwbGF5YHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5EdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdEdXJhdGlvbiBUaW1lJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEdXJhdGlvbkRpc3BsYXknLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHRpbWUtZGl2aWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aGUgY3VycmVudCB0aW1lIGFuZCBkdXJhdGlvbi5cbiAqIENhbiBiZSBoaWRkZW4gaWYgaXQncyBub3QgbmVlZGVkIGluIHRoZSBkZXNpZ24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVEaXZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZURpdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVEaXZpZGVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXZpZGVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVGltZURpdmlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2PjxzcGFuPi88L3NwYW4+PC9kaXY+J1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUaW1lRGl2aWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGl2aWRlcicsIFRpbWVEaXZpZGVyKTtcblxuLyoqXG4gKiBAZmlsZSByZW1haW5pbmctdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIHRpbWUgbGVmdCBpbiB0aGUgdmlkZW9cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX1RpbWVEaXNwbGF5KSB7XG4gIGluaGVyaXRzKFJlbWFpbmluZ1RpbWVEaXNwbGF5LCBfVGltZURpc3BsYXkpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVtYWluaW5nVGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGltZURpc3BsYXkuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2R1cmF0aW9uY2hhbmdlJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcmVtYWluaW5nLXRpbWUnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmVtYWluaW5nIHRpbWUgZGlzcGxheSBwcmVmaXhlcyBudW1iZXJzIHdpdGggYSBcIm1pbnVzXCIgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWVcbiAgICogICAgICAgICBBIG51bWVyaWMgdGltZSwgaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEEgZm9ybWF0dGVkIHRpbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8gPSBmdW5jdGlvbiBmb3JtYXRUaW1lXyh0aW1lKSB7XG4gICAgcmV0dXJuICctJyArIF9UaW1lRGlzcGxheS5wcm90b3R5cGUuZm9ybWF0VGltZV8uY2FsbCh0aGlzLCB0aW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHJlbWFpbmluZyB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGR1cmF0aW9uY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXG4gICAqL1xuXG5cbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBsYXllcl8uZHVyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEBkZXByZWNhdGVkIFdlIHNob3VsZCBvbmx5IHVzZSByZW1haW5pbmdUaW1lRGlzcGxheVxuICAgIC8vIGFzIG9mIHZpZGVvLmpzIDdcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnJlbWFpbmluZ1RpbWVEaXNwbGF5KSB7XG4gICAgICB0aGlzLnVwZGF0ZUZvcm1hdHRlZFRpbWVfKHRoaXMucGxheWVyXy5yZW1haW5pbmdUaW1lRGlzcGxheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXyh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBmaXJlcyBlbmRlZCB0aGVyZSBzaG91bGQgYmUgbm8gdGltZSBsZWZ0LiBTYWRseVxuICAgKiB0aGlzIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UsIGxldHMgbWFrZSBpdCBzZWVtIGxpa2UgdGhhdCBpcyB0aGUgY2FzZVxuICAgKiBmb3IgdXNlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGb3JtYXR0ZWRUaW1lXygwKTtcbiAgfTtcblxuICByZXR1cm4gUmVtYWluaW5nVGltZURpc3BsYXk7XG59KFRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBSZW1haW5pbmdUaW1lRGlzcGxheWBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdSZW1haW5pbmcgVGltZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUmVtYWluaW5nVGltZURpc3BsYXknLCBSZW1haW5pbmdUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgbGl2ZS1kaXNwbGF5LmpzXG4gKi9cbi8vIFRPRE8gLSBGdXR1cmUgbWFrZSBpdCBjbGljayB0byBzbmFwIHRvIGxpdmVcblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUgbGl2ZSBpbmRpY2F0b3Igd2hlbiBkdXJhdGlvbiBpcyBJbmZpbml0eS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTGl2ZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMaXZlRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBMaXZlRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBMaXZlRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVNob3dpbmcoKTtcbiAgICBfdGhpcy5vbihfdGhpcy5wbGF5ZXIoKSwgJ2R1cmF0aW9uY2hhbmdlJywgX3RoaXMudXBkYXRlU2hvd2luZyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1kaXNwbGF5JyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKCdTdHJlYW0gVHlwZScpICsgJzwvc3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnTElWRScpXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jb250ZW50RWxfID0gbnVsbDtcblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGR1cmF0aW9uIHRvIHNlZSBpZiB0aGUgTGl2ZURpc3BsYXkgc2hvdWxkIGJlIHNob3dpbmcgb3Igbm90LiBUaGVuIHNob3cvaGlkZVxuICAgKiBpdCBhY2NvcmRpbmdseVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNkdXJhdGlvbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVTaG93aW5nID0gZnVuY3Rpb24gdXBkYXRlU2hvd2luZyhldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcigpLmR1cmF0aW9uKCkgPT09IEluZmluaXR5KSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMaXZlRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMaXZlRGlzcGxheScsIExpdmVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzbGlkZXIuanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBmdW5jdGlvbmFsaXR5IGZvciBhIHNsaWRlci4gQ2FuIGJlIHZlcnRpY2FsIG9yIGhvcml6b250YWwuXG4gKiBGb3IgaW5zdGFuY2UgdGhlIHZvbHVtZSBiYXIgb3IgdGhlIHNlZWsgYmFyIG9uIGEgdmlkZW8gaXMgYSBzbGlkZXIuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFNsaWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFNsaWRlciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2xpZGVyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XG5cbiAgICAvLyBTZXQgcHJvcGVydHkgbmFtZXMgdG8gYmFyIHRvIG1hdGNoIHdpdGggdGhlIGNoaWxkIFNsaWRlciBjbGFzcyBpcyBsb29raW5nIGZvclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYmFyID0gX3RoaXMuZ2V0Q2hpbGQoX3RoaXMub3B0aW9uc18uYmFyTmFtZSk7XG5cbiAgICAvLyBTZXQgYSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNsYXNzIG9uIHRoZSBzbGlkZXIgZGVwZW5kaW5nIG9uIHRoZSBzbGlkZXIgdHlwZVxuICAgIF90aGlzLnZlcnRpY2FsKCEhX3RoaXMub3B0aW9uc18udmVydGljYWwpO1xuXG4gICAgX3RoaXMuZW5hYmxlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFyZSBjb250cm9scyBhcmUgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgc2xpZGVyIG9yIG5vdC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0cnVlIGlmIGNvbnRyb2xzIGFyZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgY29udHJvbHMgZm9yIHRoaXMgc2xpZGVyIGlmIHRoZXkgYXJlIGRpc2FibGVkXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyKTtcbiAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2spO1xuXG4gICAgdGhpcy5vbih0aGlzLnBsYXllcl8sICdjb250cm9sc3Zpc2libGUnLCB0aGlzLnVwZGF0ZSk7XG5cbiAgICBpZiAodGhpcy5wbGF5ZXJFdmVudCkge1xuICAgICAgdGhpcy5vbih0aGlzLnBsYXllcl8sIHRoaXMucGxheWVyRXZlbnQsIHRoaXMudXBkYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgY29udHJvbHMgZm9yIHRoaXMgc2xpZGVyIGlmIHRoZXkgYXJlIGVuYWJsZWRcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9mZigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9mZignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgdGhpcy5vZmYoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vZmYodGhpcy5wbGF5ZXJfLCAnY29udHJvbHN2aXNpYmxlJywgdGhpcy51cGRhdGUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuXG4gICAgdGhpcy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblxuICAgIGlmICh0aGlzLnBsYXllckV2ZW50KSB7XG4gICAgICB0aGlzLm9mZih0aGlzLnBsYXllcl8sIHRoaXMucGxheWVyRXZlbnQsIHRoaXMudXBkYXRlKTtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBCdXR0b25gcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogICAgICAgIFR5cGUgb2YgZWxlbWVudCB0byBjcmVhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBMaXN0IG9mIHByb3BlcnRpZXMgaW4gT2JqZWN0IGZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAgICogICAgICAgIGxpc3Qgb2YgYXR0cmlidXRlcyBpbiBPYmplY3QgZm9ybS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEodHlwZSkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUgKyAnIHZqcy1zbGlkZXInO1xuICAgIHByb3BzID0gYXNzaWduKHtcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7XG4gICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICAgJ2FyaWEtdmFsdWVtYXgnOiAxMDAsXG4gICAgICAndGFiSW5kZXgnOiAwXG4gICAgfSwgYXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBwcm9wcywgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqIEBmaXJlcyBTbGlkZXIjc2xpZGVyYWN0aXZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGJsb2NrVGV4dFNlbGVjdGlvbigpO1xuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgc2xpZGVyIGlzIGluIGFuIGFjdGl2ZSBzdGF0ZVxuICAgICAqXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJhY3RpdmVcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzbGlkZXJhY3RpdmUnKTtcblxuICAgIHRoaXMub24oZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG5cbiAgICB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0aGUgYG1vdXNlbW92ZWAsIGB0b3VjaG1vdmVgLCBhbmQgYG1vdXNlZG93bmAgZXZlbnRzIG9uIHRoaXMgYFNsaWRlcmAuXG4gICAqIFRoZSBgbW91c2Vtb3ZlYCBhbmQgYHRvdWNobW92ZWAgZXZlbnRzIHdpbGwgb25seSBvbmx5IHRyaWdnZXIgdGhpcyBmdW5jdGlvbiBkdXJpbmdcbiAgICogYG1vdXNlZG93bmAgYW5kIGB0b3VjaHN0YXJ0YC4gVGhpcyBpcyBkdWUgdG8ge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZURvd259IGFuZFxuICAgKiB7QGxpbmsgU2xpZGVyI2hhbmRsZU1vdXNlVXB9LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAsIGBtb3VzZW1vdmVgLCBgdG91Y2hzdGFydGAsIG9yIGB0b3VjaG1vdmVgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVucyB0b3VjaG1vdmVcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge307XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudHMgb24gdGhlIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKiBAZmlyZXMgU2xpZGVyI3NsaWRlcmluYWN0aXZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcCgpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB1bmJsb2NrVGV4dFNlbGVjdGlvbigpO1xuXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgc2xpZGVyIGlzIG5vIGxvbmdlciBpbiBhbiBhY3RpdmUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgU2xpZGVyI3NsaWRlcmluYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcblxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwcm9ncmVzcyBiYXIgb2YgdGhlIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKiAgICAgICAgICBUaGUgcGVyY2VudGFnZSBvZiBwcm9ncmVzcyB0aGUgcHJvZ3Jlc3MgYmFyIHJlcHJlc2VudHMgYXMgYVxuICAgKiAgICAgICAgICBudW1iZXIgZnJvbSAwIHRvIDEuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICAvLyBJbiBWb2x1bWVCYXIgaW5pdCB3ZSBoYXZlIGEgc2V0VGltZW91dCBmb3IgdXBkYXRlIHRoYXQgcG9wcyBhbmQgdXBkYXRlXG4gICAgLy8gdG8gdGhlIGVuZCBvZiB0aGUgZXhlY3V0aW9uIHN0YWNrLiBUaGUgcGxheWVyIGlzIGRlc3Ryb3llZCBiZWZvcmUgdGhlblxuICAgIC8vIHVwZGF0ZSB3aWxsIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKCF0aGlzLmVsXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHNjcnViYmluZywgd2UgY291bGQgdXNlIGEgY2FjaGVkIHZhbHVlIHRvIG1ha2UgdGhlIGhhbmRsZSBrZWVwIHVwXG4gICAgLy8gd2l0aCB0aGUgdXNlcidzIG1vdXNlLiBPbiBIVE1MNSBicm93c2VycyBzY3J1YmJpbmcgaXMgcmVhbGx5IHNtb290aCwgYnV0XG4gICAgLy8gc29tZSBmbGFzaCBwbGF5ZXJzIGFyZSBzbG93LCBzbyB3ZSBtaWdodCB3YW50IHRvIHV0aWxpemUgdGhpcyBsYXRlci5cbiAgICAvLyB2YXIgcHJvZ3Jlc3MgPSAgKHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSkgPyB0aGlzLnBsYXllcl8uZ2V0Q2FjaGUoKS5jdXJyZW50VGltZSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLmdldFBlcmNlbnQoKTtcbiAgICB2YXIgYmFyID0gdGhpcy5iYXI7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGJhci4uLlxuICAgIGlmICghYmFyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vIGR1cmF0aW9uIGFuZCBvdGhlciBkaXZpc2lvbiBpc3N1ZXNcbiAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAnbnVtYmVyJyB8fCBwcm9ncmVzcyAhPT0gcHJvZ3Jlc3MgfHwgcHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID09PSBJbmZpbml0eSkge1xuICAgICAgcHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgdG8gYSBwZXJjZW50YWdlIGZvciBzZXR0aW5nXG4gICAgdmFyIHBlcmNlbnRhZ2UgPSAocHJvZ3Jlc3MgKiAxMDApLnRvRml4ZWQoMikgKyAnJSc7XG4gICAgdmFyIHN0eWxlID0gYmFyLmVsKCkuc3R5bGU7XG5cbiAgICAvLyBTZXQgdGhlIG5ldyBiYXIgd2lkdGggb3IgaGVpZ2h0XG4gICAgaWYgKHRoaXMudmVydGljYWwoKSkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gcGVyY2VudGFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBwZXJjZW50YWdlO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmVzcztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGRpc3RhbmNlIGZvciBzbGlkZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBTbGlkZXIuXG4gICAqICAgICAgICAgLSBwb3N0aXRpb24ueCBmb3IgdmVydGljYWwgYFNsaWRlcmBzXG4gICAqICAgICAgICAgLSBwb3N0aXRpb24ueSBmb3IgaG9yaXpvbnRhbCBgU2xpZGVyYHNcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmNhbGN1bGF0ZURpc3RhbmNlID0gZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb2ludGVyUG9zaXRpb24odGhpcy5lbF8sIGV2ZW50KTtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbi55O1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb24ueDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGZvY3VzYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMub24odGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiB0aGUgYFNsaWRlcmAuIFdhdGNoZXMgZm9yIGxlZnQsIHJpZ3RoLCB1cCwgYW5kIGRvd25cbiAgICogYXJyb3cga2V5cy4gVGhpcyBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIHNsaWRlciBoYXMgZm9jdXMuIFNlZVxuICAgKiB7QGxpbmsgU2xpZGVyI2hhbmRsZUZvY3VzfSBhbmQge0BsaW5rIFNsaWRlciNoYW5kbGVCbHVyfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwQmFjaygpO1xuXG4gICAgICAvLyBVcCBhbmQgUmlnaHQgQXJyb3dzXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDM5KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwRm9yd2FyZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGJsdXJgIGV2ZW50IG9uIHRoaXMgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBibHVyXG4gICAqL1xuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5vZmYodGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbmVyIGZvciBjbGljayBldmVudHMgb24gc2xpZGVyLCB1c2VkIHRvIHByZXZlbnQgY2xpY2tzXG4gICAqICAgZnJvbSBidWJibGluZyB1cCB0byBwYXJlbnQgZWxlbWVudHMgbGlrZSBidXR0b24gbWVudXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBvYmplY3QgdG8gcnVuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCBpZiBzbGlkZXIgaXMgaG9yaXpvbnRhbCBmb3IgdmVydGljYWxcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSBpZiBzbGlkZXIgaXMgdmVydGljYWwsXG4gICAqICAgICAgICAtIGZhbHNlIGlzIGhvcml6b250YWxcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLCBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgdGhlIHNsaWRlciBpcyBob3Jpem9udGFsLCBhbmQgZ2V0dGluZ1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudmVydGljYWwgPSBmdW5jdGlvbiB2ZXJ0aWNhbChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxfIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudmVydGljYWxfID0gISFib29sO1xuXG4gICAgaWYgKHRoaXMudmVydGljYWxfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLXZlcnRpY2FsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItaG9yaXpvbnRhbCcpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2xpZGVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlcicsIFNsaWRlcik7XG5cbi8qKlxuICogQGZpbGUgbG9hZC1wcm9ncmVzcy1iYXIuanNcbiAqL1xuLyoqXG4gKiBTaG93cyBsb2FkaW5nIHByb2dyZXNzXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExvYWRQcm9ncmVzc0JhciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKExvYWRQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBMb2FkUHJvZ3Jlc3NCYXIocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZFByb2dyZXNzQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMucGFydEVsc18gPSBbXTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdwcm9ncmVzcycsIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbG9hZC1wcm9ncmVzcycsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnTG9hZGVkJykgKyAnPC9zcGFuPjogMCU8L3NwYW4+J1xuICAgIH0pO1xuICB9O1xuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5wYXJ0RWxzXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm9ncmVzcyBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwcm9ncmVzc1xuICAgKi9cblxuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5wbGF5ZXJfLmJ1ZmZlcmVkKCk7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIGJ1ZmZlcmVkRW5kID0gdGhpcy5wbGF5ZXJfLmJ1ZmZlcmVkRW5kKCk7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wYXJ0RWxzXztcblxuICAgIC8vIGdldCB0aGUgcGVyY2VudCB3aWR0aCBvZiBhIHRpbWUgY29tcGFyZWQgdG8gdGhlIHRvdGFsIGVuZFxuICAgIHZhciBwZXJjZW50aWZ5ID0gZnVuY3Rpb24gcGVyY2VudGlmeSh0aW1lLCBlbmQpIHtcbiAgICAgIC8vIG5vIE5hTlxuICAgICAgdmFyIHBlcmNlbnQgPSB0aW1lIC8gZW5kIHx8IDA7XG5cbiAgICAgIHJldHVybiAocGVyY2VudCA+PSAxID8gMSA6IHBlcmNlbnQpICogMTAwICsgJyUnO1xuICAgIH07XG5cbiAgICAvLyB1cGRhdGUgdGhlIHdpZHRoIG9mIHRoZSBwcm9ncmVzcyBiYXJcbiAgICB0aGlzLmVsXy5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoYnVmZmVyZWRFbmQsIGR1cmF0aW9uKTtcblxuICAgIC8vIGFkZCBjaGlsZCBlbGVtZW50cyB0byByZXByZXNlbnQgdGhlIGluZGl2aWR1YWwgYnVmZmVyZWQgdGltZSByYW5nZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICAgIHZhciBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XG4gICAgICB2YXIgcGFydCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgcGFydCA9IHRoaXMuZWxfLmFwcGVuZENoaWxkKGNyZWF0ZUVsKCkpO1xuICAgICAgICBjaGlsZHJlbltpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgcGVyY2VudCBiYXNlZCBvbiB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhciAoYnVmZmVyZWRFbmQpXG4gICAgICBwYXJ0LnN0eWxlLmxlZnQgPSBwZXJjZW50aWZ5KHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgICBwYXJ0LnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShlbmQgLSBzdGFydCwgYnVmZmVyZWRFbmQpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB1bnVzZWQgYnVmZmVyZWQgcmFuZ2UgZWxlbWVudHNcbiAgICBmb3IgKHZhciBfaSA9IGNoaWxkcmVuLmxlbmd0aDsgX2kgPiBidWZmZXJlZC5sZW5ndGg7IF9pLS0pIHtcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUNoaWxkKGNoaWxkcmVuW19pIC0gMV0pO1xuICAgIH1cbiAgICBjaGlsZHJlbi5sZW5ndGggPSBidWZmZXJlZC5sZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRQcm9ncmVzc0Jhcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkUHJvZ3Jlc3NCYXInLCBMb2FkUHJvZ3Jlc3NCYXIpO1xuXG4vKipcbiAqIEBmaWxlIHRpbWUtdG9vbHRpcC5qc1xuICovXG4vKipcbiAqIFRpbWUgdG9vbHRpcHMgZGlzcGxheSBhIHRpbWUgYWJvdmUgdGhlIHByb2dyZXNzIGJhci5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGltZVRvb2x0aXAgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaW1lVG9vbHRpcCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGltZVRvb2x0aXAoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZVRvb2x0aXApO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB0aW1lIHRvb2x0aXAgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVGltZVRvb2x0aXAucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLXRvb2x0aXAnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aW1lIHRvb2x0aXAgcmVsYXRpdmUgdG8gdGhlIGBTZWVrQmFyYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlZWtCYXJSZWN0XG4gICAqICAgICAgICBUaGUgYENsaWVudFJlY3RgIGZvciB0aGUge0BsaW5rIFNlZWtCYXJ9IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVrQmFyUG9pbnRcbiAgICogICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHJlZmVyZW5jZSBwb2ludFxuICAgKiAgICAgICAgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB7QGxpbmsgU2Vla0Jhcn1cbiAgICovXG5cblxuICBUaW1lVG9vbHRpcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQsIGNvbnRlbnQpIHtcbiAgICB2YXIgdG9vbHRpcFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5lbF8pO1xuICAgIHZhciBwbGF5ZXJSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMucGxheWVyXy5lbCgpKTtcbiAgICB2YXIgc2Vla0JhclBvaW50UHggPSBzZWVrQmFyUmVjdC53aWR0aCAqIHNlZWtCYXJQb2ludDtcblxuICAgIC8vIGRvIG5vdGhpbmcgaWYgZWl0aGVyIHJlY3QgaXNuJ3QgYXZhaWxhYmxlXG4gICAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBwbGF5ZXIgaXNuJ3QgaW4gdGhlIERPTSBmb3IgdGVzdGluZ1xuICAgIGlmICghcGxheWVyUmVjdCB8fCAhdG9vbHRpcFJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBzcGFjZSBsZWZ0IG9mIHRoZSBgc2Vla0JhclBvaW50YCBhdmFpbGFibGUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAvLyBvZiB0aGUgcGxheWVyLiBXZSBjYWxjdWxhdGUgYW55IGdhcCBiZXR3ZWVuIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHBsYXllclxuICAgIC8vIGFuZCB0aGUgbGVmdCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIGFkZCB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGVcbiAgICAvLyBgU2Vla0JhcmAgYmVmb3JlIGhpdHRpbmcgdGhlIGBzZWVrQmFyUG9pbnRgXG4gICAgdmFyIHNwYWNlTGVmdE9mUG9pbnQgPSBzZWVrQmFyUmVjdC5sZWZ0IC0gcGxheWVyUmVjdC5sZWZ0ICsgc2Vla0JhclBvaW50UHg7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBzcGFjZSByaWdodCBvZiB0aGUgYHNlZWtCYXJQb2ludGAgYXZhaWxhYmxlIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgLy8gb2YgdGhlIHBsYXllci4gV2UgY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGZyb20gdGhlIGBzZWVrQmFyUG9pbnRgXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgYWRkIHRvIHRoYXQgYW55IGdhcCBiZXR3ZWVuIHRoZVxuICAgIC8vIHJpZ2h0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgdGhlIHBsYXllci5cbiAgICB2YXIgc3BhY2VSaWdodE9mUG9pbnQgPSBzZWVrQmFyUmVjdC53aWR0aCAtIHNlZWtCYXJQb2ludFB4ICsgKHBsYXllclJlY3QucmlnaHQgLSBzZWVrQmFyUmVjdC5yaWdodCk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGJ5IHdoaWNoIHRoZSB0b29sdGlwIHdpbGwgbmVlZCB0byBiZSBwdWxsZWRcbiAgICAvLyBmdXJ0aGVyIHRvIHRoZSByaWdodCB0byBjZW50ZXIgaXQgb3ZlciB0aGUgYHNlZWtCYXJQb2ludGAuXG4gICAgdmFyIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aCAvIDI7XG5cbiAgICAvLyBBZGp1c3QgdGhlIGBwdWxsVG9vbHRpcEJ5YCBkaXN0YW5jZSB0byB0aGUgbGVmdCBvciByaWdodCBkZXBlbmRpbmcgb25cbiAgICAvLyB0aGUgcmVzdWx0cyBvZiB0aGUgc3BhY2UgY2FsY3VsYXRpb25zIGFib3ZlLlxuICAgIGlmIChzcGFjZUxlZnRPZlBvaW50IDwgcHVsbFRvb2x0aXBCeSkge1xuICAgICAgcHVsbFRvb2x0aXBCeSArPSBwdWxsVG9vbHRpcEJ5IC0gc3BhY2VMZWZ0T2ZQb2ludDtcbiAgICB9IGVsc2UgaWYgKHNwYWNlUmlnaHRPZlBvaW50IDwgcHVsbFRvb2x0aXBCeSkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IHNwYWNlUmlnaHRPZlBvaW50O1xuICAgIH1cblxuICAgIC8vIER1ZSB0byB0aGUgaW1wcmVjaXNpb24gb2YgZGVjaW1hbC9yYXRpbyBiYXNlZCBjYWxjdWxhdGlvbnMgYW5kIHZhcnlpbmdcbiAgICAvLyByb3VuZGluZyBiZWhhdmlvcnMsIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgc3BhY2luZyBhZGp1c3RtZW50IGlzIG9mZlxuICAgIC8vIGJ5IGEgcGl4ZWwgb3IgdHdvLiBUaGlzIGFkZHMgaW5zdXJhbmNlIHRvIHRoZXNlIGNhbGN1bGF0aW9ucy5cbiAgICBpZiAocHVsbFRvb2x0aXBCeSA8IDApIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSAwO1xuICAgIH0gZWxzZSBpZiAocHVsbFRvb2x0aXBCeSA+IHRvb2x0aXBSZWN0LndpZHRoKSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gdG9vbHRpcFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgdGhpcy5lbF8uc3R5bGUucmlnaHQgPSAnLScgKyBwdWxsVG9vbHRpcEJ5ICsgJ3B4JztcbiAgICB0ZXh0Q29udGVudCh0aGlzLmVsXywgY29udGVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVUb29sdGlwO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RpbWVUb29sdGlwJywgVGltZVRvb2x0aXApO1xuXG4vKipcbiAqIEBmaWxlIHBsYXktcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbi8qKlxuICogVXNlZCBieSB7QGxpbmsgU2Vla0Jhcn0gdG8gZGlzcGxheSBtZWRpYSBwbGF5YmFjayBwcm9ncmVzcyBhcyBwYXJ0IG9mIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFBsYXlQcm9ncmVzc0JhciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFBsYXlQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUGxheVByb2dyZXNzQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlQcm9ncmVzc0Jhcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheS1wcm9ncmVzcyB2anMtc2xpZGVyLWJhcicsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48c3Bhbj4nICsgdGhpcy5sb2NhbGl6ZSgnUHJvZ3Jlc3MnKSArICc8L3NwYW4+OiAwJTwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHJBRiBJRCwgY2FuY2VsIGl0IHNvIHdlIGRvbid0IG92ZXItcXVldWUuXG4gICAgaWYgKHRoaXMucmFmSWRfKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhZklkXyA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aW1lID0gX3RoaXMyLnBsYXllcl8uc2NydWJiaW5nKCkgPyBfdGhpczIucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogX3RoaXMyLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHRpbWUsIF90aGlzMi5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xuICAgICAgdmFyIHRpbWVUb29sdGlwID0gX3RoaXMyLmdldENoaWxkKCd0aW1lVG9vbHRpcCcpO1xuXG4gICAgICBpZiAodGltZVRvb2x0aXApIHtcbiAgICAgICAgdGltZVRvb2x0aXAudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQbGF5UHJvZ3Jlc3NCYXI7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB7QGxpbmsgUGxheVByb2dyZXNzQmFyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbXVxufTtcblxuLy8gVGltZSB0b29sdGlwcyBzaG91bGQgbm90IGJlIGFkZGVkIHRvIGEgcGxheWVyIG9uIG1vYmlsZSBkZXZpY2VzIG9yIElFOFxuaWYgKCghSUVfVkVSU0lPTiB8fCBJRV9WRVJTSU9OID4gOCkgJiYgIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnB1c2goJ3RpbWVUb29sdGlwJyk7XG59XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheVByb2dyZXNzQmFyJywgUGxheVByb2dyZXNzQmFyKTtcblxuLyoqXG4gKiBAZmlsZSBtb3VzZS10aW1lLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBUaGUge0BsaW5rIE1vdXNlVGltZURpc3BsYXl9IGNvbXBvbmVudCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGVcbiAqIHtAbGluayBQcm9ncmVzc0NvbnRyb2x9LiBJdCBkaXNwbGF5cyBhbiBpbmRpY2F0b3IgYW5kIGEge0BsaW5rIFRpbWVUb29sdGlwfVxuICogaW5kaWNhdGluZyB0aGUgdGltZSB3aGljaCBpcyByZXByZXNlbnRlZCBieSBhIGdpdmVuIHBvaW50IGluIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1vdXNlVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb3VzZVRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllcn0gdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE1vdXNlVGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSksIDI1KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tb3VzZS1kaXNwbGF5J1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyB1cGRhdGVzIHRvIGl0cyBvd24gRE9NIGFzIHdlbGwgYXMgdGhlIERPTSBvZiBpdHNcbiAgICoge0BsaW5rIFRpbWVUb29sdGlwfSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlZWtCYXJSZWN0XG4gICAqICAgICAgICBUaGUgYENsaWVudFJlY3RgIGZvciB0aGUge0BsaW5rIFNlZWtCYXJ9IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVrQmFyUG9pbnRcbiAgICogICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHJlZmVyZW5jZSBwb2ludFxuICAgKiAgICAgICAgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB7QGxpbmsgU2Vla0Jhcn1cbiAgICovXG5cblxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgckFGIElELCBjYW5jZWwgaXQgc28gd2UgZG9uJ3Qgb3Zlci1xdWV1ZS5cbiAgICBpZiAodGhpcy5yYWZJZF8pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZF8pO1xuICAgIH1cblxuICAgIHRoaXMucmFmSWRfID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gX3RoaXMyLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICAgIHZhciBjb250ZW50ID0gZm9ybWF0VGltZShzZWVrQmFyUG9pbnQgKiBkdXJhdGlvbiwgZHVyYXRpb24pO1xuXG4gICAgICBfdGhpczIuZWxfLnN0eWxlLmxlZnQgPSBzZWVrQmFyUmVjdC53aWR0aCAqIHNlZWtCYXJQb2ludCArICdweCc7XG4gICAgICBfdGhpczIuZ2V0Q2hpbGQoJ3RpbWVUb29sdGlwJykudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQsIGNvbnRlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBNb3VzZVRpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYE1vdXNlVGltZURpc3BsYXlgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Nb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndGltZVRvb2x0aXAnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNb3VzZVRpbWVEaXNwbGF5JywgTW91c2VUaW1lRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgc2Vlay1iYXIuanNcbiAqL1xuLy8gVGhlIG51bWJlciBvZiBzZWNvbmRzIHRoZSBgc3RlcCpgIGZ1bmN0aW9ucyBtb3ZlIHRoZSB0aW1lbGluZS5cbnZhciBTVEVQX1NFQ09ORFMgPSA1O1xuXG4vLyBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdGhlIGJhciBzaG91bGQgdXBkYXRlIGFzIGl0IHByb2dyZXNzZXMuXG52YXIgVVBEQVRFX1JFRlJFU0hfSU5URVJWQUwgPSAzMDtcblxuLyoqXG4gKiBTZWVrIGJhciBhbmQgY29udGFpbmVyIGZvciB0aGUgcHJvZ3Jlc3MgYmFycy4gVXNlcyB7QGxpbmsgUGxheVByb2dyZXNzQmFyfVxuICogYXMgaXRzIGBiYXJgLlxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBTZWVrQmFyID0gZnVuY3Rpb24gKF9TbGlkZXIpIHtcbiAgaW5oZXJpdHMoU2Vla0JhciwgX1NsaWRlcik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBTZWVrQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNlZWtCYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpLCBVUERBVEVfUkVGUkVTSF9JTlRFUlZBTCk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgX3RoaXMudXBkYXRlKTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlbmRlZCcsIF90aGlzLmhhbmRsZUVuZGVkKTtcblxuICAgIC8vIHdoZW4gcGxheWluZywgbGV0J3MgZW5zdXJlIHdlIHNtb290aGx5IHVwZGF0ZSB0aGUgcGxheSBwcm9ncmVzcyBiYXJcbiAgICAvLyB2aWEgYW4gaW50ZXJ2YWxcbiAgICBfdGhpcy51cGRhdGVJbnRlcnZhbCA9IG51bGw7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsncGxheWluZyddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jbGVhckludGVydmFsKF90aGlzLnVwZGF0ZUludGVydmFsKTtcblxuICAgICAgX3RoaXMudXBkYXRlSW50ZXJ2YWwgPSBfdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMudXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgVVBEQVRFX1JFRlJFU0hfSU5URVJWQUwpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ2VuZGVkJywgJ3BhdXNlJywgJ3dhaXRpbmcnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xlYXJJbnRlcnZhbChfdGhpcy51cGRhdGVJbnRlcnZhbCk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsndGltZXVwZGF0ZScsICdlbmRlZCddLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wcm9ncmVzcy1ob2xkZXInXG4gICAgfSwge1xuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcyBCYXInKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIHBsYXkgcHJvZ3Jlc3MgYmFyIGFuZCBhY2Nlc3NpYmxpdHlcbiAgICogYXR0cmlidXRlcyB0byB3aGF0ZXZlciBpcyBwYXNzZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZVxuICAgKiAgICAgICAgVGhlIGN1cnJlbnRUaW1lIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2libGl0eVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudFxuICAgKiAgICAgICAgVGhlIHBlcmNlbnRhZ2UgYXMgYSBkZWNpbWFsIHRoYXQgdGhlIGJhciBzaG91bGQgYmUgZmlsbGVkIGZyb20gMC0xLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnVwZGF0ZV8gPSBmdW5jdGlvbiB1cGRhdGVfKGN1cnJlbnRUaW1lLCBwZXJjZW50KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCAocGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cbiAgICAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHRoaXMubG9jYWxpemUoJ3Byb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn0nLCBbZm9ybWF0VGltZShjdXJyZW50VGltZSwgZHVyYXRpb24pLCBmb3JtYXRUaW1lKGR1cmF0aW9uLCBkdXJhdGlvbildLCAnezF9IG9mIHsyfScpKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYFBsYXlQcm9ncmVzc0JhcmAuXG4gICAgdGhpcy5iYXIudXBkYXRlKGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsXyksIHBlcmNlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHNlZWsgYmFyJ3MgVUkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgb3IgYGVuZGVkYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIGN1cnJlbnQgcGVyY2VudCBhdCBhIG51bWJlciBmcm9tIDAtMVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBwZXJjZW50ID0gX1NsaWRlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnVwZGF0ZV8odGhpcy5nZXRDdXJyZW50VGltZV8oKSwgcGVyY2VudCk7XG4gICAgcmV0dXJuIHBlcmNlbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgY3VycmVudCB0aW1lIGJ1dCBhbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsXG4gICAqIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB0aW1lIHZhbHVlIHRvIGRpc3BsYXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5nZXRDdXJyZW50VGltZV8gPSBmdW5jdGlvbiBnZXRDdXJyZW50VGltZV8oKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdlIHdhbnQgdGhlIHNlZWsgYmFyIHRvIGJlIGZ1bGwgb24gZW5kZWRcbiAgICogbm8gbWF0dGVyIHdoYXQgdGhlIGFjdHVhbCBpbnRlcm5hbCB2YWx1ZXMgYXJlLiBzbyB3ZSBmb3JjZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVFbmRlZCA9IGZ1bmN0aW9uIGhhbmRsZUVuZGVkKGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVfKHRoaXMucGxheWVyXy5kdXJhdGlvbigpLCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGVyY2VudGFnZSBvZiBtZWRpYSBwbGF5ZWQgc28gZmFyICgwIHRvIDEpLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuICAgIHZhciBwZXJjZW50ID0gdGhpcy5nZXRDdXJyZW50VGltZV8oKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgcmV0dXJuIHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcodHJ1ZSk7XG5cbiAgICB0aGlzLnZpZGVvV2FzUGxheWluZyA9ICF0aGlzLnBsYXllcl8ucGF1c2VkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG5cbiAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24uY2FsbCh0aGlzLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBtb3ZlIG9uIHNlZWsgYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld1RpbWUgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSAqIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgLy8gRG9uJ3QgbGV0IHZpZGVvIGVuZCB3aGlsZSBzY3J1YmJpbmcuXG4gICAgaWYgKG5ld1RpbWUgPT09IHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XG4gICAgICBuZXdUaW1lID0gbmV3VGltZSAtIDAuMTtcbiAgICB9XG5cbiAgICAvLyBTZXQgbmV3IHRpbWUgKHRlbGwgcGxheWVyIHRvIHNlZWsgdG8gbmV3IHRpbWUpXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xuICB9O1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHRoaXMuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcblxuICAgIGlmICghbW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdXNlVGltZURpc3BsYXkuc2hvdygpO1xuICB9O1xuXG4gIFNlZWtCYXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHRoaXMuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcblxuICAgIGlmICghbW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vdXNlVGltZURpc3BsYXkuaGlkZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXAgb24gc2VlayBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2V1cGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICB0aGlzLnBsYXllcl8uc2NydWJiaW5nKGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdGltZXVwZGF0ZSBiZWNhdXNlIHdlJ3JlIGRvbmUgc2Vla2luZyBhbmQgdGhlIHRpbWUgaGFzIGNoYW5nZWQuXG4gICAgICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCB0byB0aW1lIHRoZSB0aW1lIGRpc3BsYXlzLlxuICAgICAqXG4gICAgICogQGV2ZW50IFRlY2gjdGltZXVwZGF0ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnBsYXllcl8udHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcbiAgICBpZiAodGhpcy52aWRlb1dhc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIG1vcmUgcXVpY2tseSBmYXN0IGZvcndhcmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSArIFNURVBfU0VDT05EUyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IHJld2luZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC0gU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHBsYXllclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gZW50ZXIgb3Igc3BhY2UgaXMgdXNlZCBvbiB0aGUgc2Vla2JhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUFjdGlvbiA9IGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhpcyBTZWVrQmFyIGhhcyBmb2N1cyBhbmQgYSBrZXkgZ2V0cyBwcmVzc2VkIGRvd24uIEJ5XG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUFjdGlvbmAgd2hlbiB0aGUga2V5IGlzIHNwYWNlIG9yIGVudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIFN1cHBvcnQgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24gdG8gZmlyZSBhIGNsaWNrIGV2ZW50XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmhhbmRsZUFjdGlvbihldmVudCk7XG4gICAgfSBlbHNlIGlmIChfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcykge1xuXG4gICAgICAvLyBQYXNzIGtleXByZXNzIGhhbmRsaW5nIHVwIGZvciB1bnN1cHBvcnRlZCBrZXlzXG4gICAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNlZWtCYXI7XG59KFNsaWRlcik7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFNlZWtCYXJgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TZWVrQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsnbG9hZFByb2dyZXNzQmFyJywgJ3BsYXlQcm9ncmVzc0JhciddLFxuICBiYXJOYW1lOiAncGxheVByb2dyZXNzQmFyJ1xufTtcblxuLy8gTW91c2VUaW1lRGlzcGxheSB0b29sdGlwcyBzaG91bGQgbm90IGJlIGFkZGVkIHRvIGEgcGxheWVyIG9uIG1vYmlsZSBkZXZpY2VzIG9yIElFOFxuaWYgKCghSUVfVkVSU0lPTiB8fCBJRV9WRVJTSU9OID4gOCkgJiYgIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xuICBTZWVrQmFyLnByb3RvdHlwZS5vcHRpb25zXy5jaGlsZHJlbi5zcGxpY2UoMSwgMCwgJ21vdXNlVGltZURpc3BsYXknKTtcbn1cblxuLyoqXG4gKiBDYWxsIHRoZSB1cGRhdGUgZXZlbnQgZm9yIHRoaXMgU2xpZGVyIHdoZW4gdGhpcyBldmVudCBoYXBwZW5zIG9uIHRoZSBwbGF5ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuU2Vla0Jhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndGltZXVwZGF0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU2Vla0JhcicsIFNlZWtCYXIpO1xuXG4vKipcbiAqIEBmaWxlIHByb2dyZXNzLWNvbnRyb2wuanNcbiAqL1xuLyoqXG4gKiBUaGUgUHJvZ3Jlc3MgQ29udHJvbCBjb21wb25lbnQgY29udGFpbnMgdGhlIHNlZWsgYmFyLCBsb2FkIHByb2dyZXNzLFxuICogYW5kIHBsYXkgcHJvZ3Jlc3MuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFByb2dyZXNzQ29udHJvbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFByb2dyZXNzQ29udHJvbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9ncmVzc0NvbnRyb2wocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3Jlc3NDb250cm9sKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuaGFuZGxlTW91c2VNb3ZlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKSwgMjUpO1xuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2VlayA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlU2VlayksIDI1KTtcblxuICAgIF90aGlzLmVuYWJsZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIGBQcm9ncmVzc0NvbnRyb2xgLCB0aGUgcG9pbnRlciBwb3NpdGlvblxuICAgKiBnZXRzIHBhc3NlZCBkb3duIHRvIHRoZSBgTW91c2VUaW1lRGlzcGxheWAgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgdmFyIHNlZWtCYXIgPSB0aGlzLmdldENoaWxkKCdzZWVrQmFyJyk7XG4gICAgdmFyIG1vdXNlVGltZURpc3BsYXkgPSBzZWVrQmFyLmdldENoaWxkKCdtb3VzZVRpbWVEaXNwbGF5Jyk7XG4gICAgdmFyIHNlZWtCYXJFbCA9IHNlZWtCYXIuZWwoKTtcbiAgICB2YXIgc2Vla0JhclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Vla0JhckVsKTtcbiAgICB2YXIgc2Vla0JhclBvaW50ID0gZ2V0UG9pbnRlclBvc2l0aW9uKHNlZWtCYXJFbCwgZXZlbnQpLng7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBza2luIGhhcyBhIGdhcCBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgYFNlZWtCYXJgLiBUaGlzIG1lYW5zXG4gICAgLy8gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIHRyaWdnZXIgdGhpcyBiZWhhdmlvciBvdXRzaWRlIHRoZSBib3VuZGFyaWVzIG9mXG4gICAgLy8gdGhlIGBTZWVrQmFyYC4gVGhpcyBlbnN1cmVzIHdlIHN0YXkgd2l0aGluIGl0IGF0IGFsbCB0aW1lcy5cbiAgICBpZiAoc2Vla0JhclBvaW50ID4gMSkge1xuICAgICAgc2Vla0JhclBvaW50ID0gMTtcbiAgICB9IGVsc2UgaWYgKHNlZWtCYXJQb2ludCA8IDApIHtcbiAgICAgIHNlZWtCYXJQb2ludCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG1vdXNlVGltZURpc3BsYXkpIHtcbiAgICAgIG1vdXNlVGltZURpc3BsYXkudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUge0BsaW5rIFByb2dyZXNzQ29udHJvbCNoYW5kbGVNb3VzZVNlZWt9IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIFByb2dyZXNzQ29udHJvbCN0aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWtcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vtb3ZlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbiBtb3VzZW1vdmVcbiAgICogQGxpc3RlbiB0b3VjaG1vdmVcbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vtb3ZlYCBvciBgdG91Y2htb3ZlYCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXG4gICAqIEBsaXN0ZW5zIHRvdWNobW92ZVxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VTZWVrID0gZnVuY3Rpb24gaGFuZGxlTW91c2VTZWVrKGV2ZW50KSB7XG4gICAgdmFyIHNlZWtCYXIgPSB0aGlzLmdldENoaWxkKCdzZWVrQmFyJyk7XG5cbiAgICBzZWVrQmFyLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFyZSBjb250cm9scyBhcmUgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgcHJvZ3Jlc3MgY29udHJvbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0cnVlIGlmIGNvbnRyb2xzIGFyZSBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmVuYWJsZWQgPSBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNhYmxlIGFsbCBjb250cm9scyBvbiB0aGUgcHJvZ3Jlc3MgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC5kaXNhYmxlICYmIGNoaWxkLmRpc2FibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9mZihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICB0aGlzLm9mZih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLmhhbmRsZU1vdXNlVXAoKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICB0aGlzLmVuYWJsZWRfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBhbGwgY29udHJvbHMgb24gdGhlIHByb2dyZXNzIGNvbnRyb2wgYW5kIGl0cyBjaGlsZHJlblxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIHRoaXMuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmVuYWJsZSAmJiBjaGlsZC5lbmFibGUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub24oWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbih0aGlzLmVsXywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub24oZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIHJldHVybiBQcm9ncmVzc0NvbnRyb2w7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgUHJvZ3Jlc3NDb250cm9sYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsnc2Vla0JhciddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Byb2dyZXNzQ29udHJvbCcsIFByb2dyZXNzQ29udHJvbCk7XG5cbi8qKlxuICogQGZpbGUgZnVsbHNjcmVlbi10b2dnbGUuanNcbiAqL1xuLyoqXG4gKiBUb2dnbGUgZnVsbHNjcmVlbiB2aWRlb1xuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBGdWxsc2NyZWVuVG9nZ2xlID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoRnVsbHNjcmVlblRvZ2dsZSwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBGdWxsc2NyZWVuVG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bGxzY3JlZW5Ub2dnbGUpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdmdWxsc2NyZWVuY2hhbmdlJywgX3RoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBGdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1mdWxsc2NyZWVuLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBmdWxsc2NyZWVuY2hhbmdlIG9uIHRoZSBwbGF5ZXIgYW5kIGNoYW5nZSBjb250cm9sIHRleHQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBGdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZShldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8uaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQoJ05vbi1GdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQoJ0Z1bGxzY3JlZW4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgRnVsbHNjcmVlblRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5leGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRnVsbHNjcmVlblRvZ2dsZTtcbn0oQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBGdWxsc2NyZWVuVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5GdWxsc2NyZWVuVG9nZ2xlLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRnVsbHNjcmVlbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRnVsbHNjcmVlblRvZ2dsZScsIEZ1bGxzY3JlZW5Ub2dnbGUpO1xuXG4vKipcbiAqIENoZWNrIGlmIHZvbHVtZSBjb250cm9sIGlzIHN1cHBvcnRlZCBhbmQgaWYgaXQgaXNuJ3QgaGlkZSB0aGVcbiAqIGBDb21wb25lbnRgIHRoYXQgd2FzIHBhc3NlZCAgdXNpbmcgdGhlIGB2anMtaGlkZGVuYCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gc2VsZlxuICogICAgICAgIFRoZSBjb21wb25lbnQgdGhhdCBzaG91bGQgYmUgaGlkZGVuIGlmIHZvbHVtZSBpcyB1bnN1cHBvcnRlZFxuICpcbiAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNoZWNrVm9sdW1lU3VwcG9ydCA9IGZ1bmN0aW9uIGNoZWNrVm9sdW1lU3VwcG9ydChzZWxmLCBwbGF5ZXIpIHtcbiAgLy8gaGlkZSB2b2x1bWUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgdGVjaFxuICBpZiAocGxheWVyLnRlY2hfICYmICFwbGF5ZXIudGVjaF8uZmVhdHVyZXNWb2x1bWVDb250cm9sKSB7XG4gICAgc2VsZi5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICB9XG5cbiAgc2VsZi5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwbGF5ZXIudGVjaF8uZmVhdHVyZXNWb2x1bWVDb250cm9sKSB7XG4gICAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtbGV2ZWwuanNcbiAqL1xuLyoqXG4gKiBTaG93cyB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lTGV2ZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhWb2x1bWVMZXZlbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVm9sdW1lTGV2ZWwoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lTGV2ZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIFZvbHVtZUxldmVsLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWxldmVsJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjwvc3Bhbj4nXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUxldmVsO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUxldmVsJywgVm9sdW1lTGV2ZWwpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogVGhlIGJhciB0aGF0IGNvbnRhaW5zIHRoZSB2b2x1bWUgbGV2ZWwgYW5kIGNhbiBiZSBjbGlja2VkIG9uIHRvIGFkanVzdCB0aGUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgVm9sdW1lQmFyID0gZnVuY3Rpb24gKF9TbGlkZXIpIHtcbiAgaW5oZXJpdHMoVm9sdW1lQmFyLCBfU2xpZGVyKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZUJhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVCYXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5vbignc2xpZGVyYWN0aXZlJywgX3RoaXMudXBkYXRlTGFzdFZvbHVtZV8pO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIF90aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcbiAgICBwbGF5ZXIucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWJhciB2anMtc2xpZGVyLWJhcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubG9jYWxpemUoJ1ZvbHVtZSBMZXZlbCcpLFxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIG9uIHZvbHVtZSBiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgbW91c2Vkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICBpZiAoIWlzU2luZ2xlTGVmdENsaWNrKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmVtZW50IGV2ZW50cyBvbiB0aGUge0BsaW5rIFZvbHVtZU1lbnVCdXR0b259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIGlmICghaXNTaW5nbGVMZWZ0Q2xpY2soZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwbGF5ZXIgaXMgbXV0ZWQgdW5tdXRlIGl0LlxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuY2hlY2tNdXRlZCA9IGZ1bmN0aW9uIGNoZWNrTXV0ZWQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHBlcmNlbnQgb2Ygdm9sdW1lIGxldmVsXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBWb2x1bWUgbGV2ZWwgcGVyY2VudCBhcyBhIGRlY2ltYWwgbnVtYmVyLlxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uIGdldFBlcmNlbnQoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVhc2Ugdm9sdW1lIGxldmVsIGZvciBrZXlib2FyZCB1c2Vyc1xuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuc3RlcEZvcndhcmQgPSBmdW5jdGlvbiBzdGVwRm9yd2FyZCgpIHtcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMucGxheWVyXy52b2x1bWUoKSArIDAuMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3JlYXNlIHZvbHVtZSBsZXZlbCBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgLSAwLjEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKGV2ZW50KSB7XG4gICAgdmFyIGFyaWFWYWx1ZSA9IHRoaXMucGxheWVyXy5tdXRlZCgpID8gMCA6IHRoaXMudm9sdW1lQXNQZXJjZW50YWdlXygpO1xuXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgYXJpYVZhbHVlKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgYXJpYVZhbHVlICsgJyUnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGxheWVyIHZvbHVtZSBhcyBhIHBlcmNlbnRhZ2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnZvbHVtZUFzUGVyY2VudGFnZV8gPSBmdW5jdGlvbiB2b2x1bWVBc1BlcmNlbnRhZ2VfKCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMucGxheWVyXy52b2x1bWUoKSAqIDEwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIFZvbHVtZUJhciwgc3RvcmUgdGhlIHZvbHVtZSBhbmQgbGlzdGVuIGZvclxuICAgKiB0aGUgZW5kIG9mIHRoZSBkcmFnLiBXaGVuIHRoZSBkcmFnIGVuZHMsIGlmIHRoZSB2b2x1bWUgd2FzIHNldCB0byB6ZXJvLFxuICAgKiBzZXQgbGFzdFZvbHVtZSB0byB0aGUgc3RvcmVkIHZvbHVtZS5cbiAgICpcbiAgICogQGxpc3RlbnMgc2xpZGVyYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVMYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIHVwZGF0ZUxhc3RWb2x1bWVfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHZvbHVtZUJlZm9yZURyYWcgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG5cbiAgICB0aGlzLm9uZSgnc2xpZGVyaW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMyLnBsYXllcl8udm9sdW1lKCkgPT09IDApIHtcbiAgICAgICAgX3RoaXMyLnBsYXllcl8ubGFzdFZvbHVtZV8odm9sdW1lQmVmb3JlRHJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUJhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVm9sdW1lQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lTGV2ZWwnXSxcbiAgYmFyTmFtZTogJ3ZvbHVtZUxldmVsJ1xufTtcblxuLyoqXG4gKiBDYWxsIHRoZSB1cGRhdGUgZXZlbnQgZm9yIHRoaXMgU2xpZGVyIHdoZW4gdGhpcyBldmVudCBoYXBwZW5zIG9uIHRoZSBwbGF5ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVm9sdW1lQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd2b2x1bWVjaGFuZ2UnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUJhcicsIFZvbHVtZUJhcik7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVm9sdW1lQ29udHJvbCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWb2x1bWVDb250cm9sKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVDb250cm9sKTtcblxuICAgIG9wdGlvbnMudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsIHx8IGZhbHNlO1xuXG4gICAgLy8gUGFzcyB0aGUgdmVydGljYWwgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUJhciBpZlxuICAgIC8vIHRoZSBWb2x1bWVCYXIgaXMgdHVybmVkIG9uLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52b2x1bWVCYXIgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW4ob3B0aW9ucy52b2x1bWVCYXIpKSB7XG4gICAgICBvcHRpb25zLnZvbHVtZUJhciA9IG9wdGlvbnMudm9sdW1lQmFyIHx8IHt9O1xuICAgICAgb3B0aW9ucy52b2x1bWVCYXIudmVydGljYWwgPSBvcHRpb25zLnZlcnRpY2FsO1xuICAgIH1cblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlTW92ZSksIDI1KTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSBvciBpbiBmb2N1cyB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnZm9jdXMnLCAnc2xpZGVyYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZvbHVtZUJhci5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVCYXIsIFsnYmx1cicsICdzbGlkZXJpbmFjdGl2ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy52b2x1bWVCYXIucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLWhvcml6b250YWwnO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udmVydGljYWwpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtY29udHJvbCB2anMtY29udHJvbCAnICsgb3JpZW50YXRpb25DbGFzc1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub24oZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMudm9sdW1lQmFyLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFZvbHVtZUNvbnRyb2w7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVDb250cm9sLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsndm9sdW1lQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xuXG4vKipcbiAqIEBmaWxlIG11dGUtdG9nZ2xlLmpzXG4gKi9cbi8qKlxuICogQSBidXR0b24gY29tcG9uZW50IGZvciBtdXRpbmcgdGhlIGF1ZGlvLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBNdXRlVG9nZ2xlID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcbiAgaW5oZXJpdHMoTXV0ZVRvZ2dsZSwgX0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBNdXRlVG9nZ2xlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE11dGVUb2dnbGUpO1xuXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ2xvYWRzdGFydCcsICd2b2x1bWVjaGFuZ2UnXSwgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLW11dGUtY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYE11dGVUb2dnbGVgIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB2YXIgbGFzdFZvbHVtZSA9IHRoaXMucGxheWVyXy5sYXN0Vm9sdW1lXygpO1xuXG4gICAgaWYgKHZvbCA9PT0gMCkge1xuICAgICAgdmFyIHZvbHVtZVRvU2V0ID0gbGFzdFZvbHVtZSA8IDAuMSA/IDAuMSA6IGxhc3RWb2x1bWU7XG5cbiAgICAgIHRoaXMucGxheWVyXy52b2x1bWUodm9sdW1lVG9TZXQpO1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKHRoaXMucGxheWVyXy5tdXRlZCgpID8gZmFsc2UgOiB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYE11dGVUb2dnbGVgIGJ1dHRvbiBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgYHZvbHVtZWAgYW5kIGBtdXRlZGBcbiAgICogb24gdGhlIHBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjbG9hZHN0YXJ0fSBldmVudCBpZiB0aGlzIGZ1bmN0aW9uIHdhcyBjYWxsZWRcbiAgICogICAgICAgIHRocm91Z2ggYW4gZXZlbnQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgICogQGxpc3RlbnMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHRoaXMudXBkYXRlSWNvbl8oKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xUZXh0XygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGBNdXRlVG9nZ2xlYCBpY29uLlxuICAgKlxuICAgKiBQb3NzaWJsZSBzdGF0ZXMgKGdpdmVuIGBsZXZlbGAgdmFyaWFibGUgYmVsb3cpOlxuICAgKiAtIDA6IGNyb3NzZWQgb3V0XG4gICAqIC0gMTogemVybyBiYXJzIG9mIHZvbHVtZVxuICAgKiAtIDI6IG9uZSBiYXIgb2Ygdm9sdW1lXG4gICAqIC0gMzogdHdvIGJhcnMgb2Ygdm9sdW1lXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlSWNvbl8gPSBmdW5jdGlvbiB1cGRhdGVJY29uXygpIHtcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuICAgIHZhciBsZXZlbCA9IDM7XG5cbiAgICBpZiAodm9sID09PSAwIHx8IHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XG4gICAgICBsZXZlbCA9IDA7XG4gICAgfSBlbHNlIGlmICh2b2wgPCAwLjMzKSB7XG4gICAgICBsZXZlbCA9IDE7XG4gICAgfSBlbHNlIGlmICh2b2wgPCAwLjY3KSB7XG4gICAgICBsZXZlbCA9IDI7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBpbXByb3ZlIG11dGVkIGljb24gY2xhc3Nlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsXywgJ3Zqcy12b2wtJyArIGkpO1xuICAgIH1cbiAgICBhZGRDbGFzcyh0aGlzLmVsXywgJ3Zqcy12b2wtJyArIGxldmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgYG11dGVkYCBoYXMgY2hhbmdlZCBvbiB0aGUgcGxheWVyLCB1cGRhdGUgdGhlIGNvbnRyb2wgdGV4dFxuICAgKiAoYHRpdGxlYCBhdHRyaWJ1dGUgb24gYHZqcy1tdXRlLWNvbnRyb2xgIGVsZW1lbnQgYW5kIGNvbnRlbnQgb2ZcbiAgICogYHZqcy1jb250cm9sLXRleHRgIGVsZW1lbnQpLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZUNvbnRyb2xUZXh0XyA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xUZXh0XygpIHtcbiAgICB2YXIgc291bmRPZmYgPSB0aGlzLnBsYXllcl8ubXV0ZWQoKSB8fCB0aGlzLnBsYXllcl8udm9sdW1lKCkgPT09IDA7XG4gICAgdmFyIHRleHQgPSBzb3VuZE9mZiA/ICdVbm11dGUnIDogJ011dGUnO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbFRleHQoKSAhPT0gdGV4dCkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCh0ZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE11dGVUb2dnbGU7XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgTXV0ZVRvZ2dsZWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuTXV0ZVRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ011dGUnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ011dGVUb2dnbGUnLCBNdXRlVG9nZ2xlKTtcblxuLyoqXG4gKiBAZmlsZSB2b2x1bWUtY29udHJvbC5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBBIENvbXBvbmVudCB0byBjb250YWluIHRoZSBNdXRlVG9nZ2xlIGFuZCBWb2x1bWVDb250cm9sIHNvIHRoYXRcbiAqIHRoZXkgY2FuIHdvcmsgdG9nZXRoZXIuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFZvbHVtZVBhbmVsID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVm9sdW1lUGFuZWwsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lUGFuZWwocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZVBhbmVsKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmxpbmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLmlubGluZSA9IG9wdGlvbnMuaW5saW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmlubGluZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gcGFzcyB0aGUgaW5saW5lIG9wdGlvbiBkb3duIHRvIHRoZSBWb2x1bWVDb250cm9sIGFzIHZlcnRpY2FsIGlmXG4gICAgLy8gdGhlIFZvbHVtZUNvbnRyb2wgaXMgb24uXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW4ob3B0aW9ucy52b2x1bWVDb250cm9sKSkge1xuICAgICAgb3B0aW9ucy52b2x1bWVDb250cm9sID0gb3B0aW9ucy52b2x1bWVDb250cm9sIHx8IHt9O1xuICAgICAgb3B0aW9ucy52b2x1bWVDb250cm9sLnZlcnRpY2FsID0gIW9wdGlvbnMuaW5saW5lO1xuICAgIH1cblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIC8vIHdoaWxlIHRoZSBzbGlkZXIgaXMgYWN0aXZlICh0aGUgbW91c2UgaGFzIGJlZW4gcHJlc3NlZCBkb3duIGFuZFxuICAgIC8vIGlzIGRyYWdnaW5nKSBvciBpbiBmb2N1cyB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJBY3RpdmVfKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tdXRlVG9nZ2xlLCAnZm9jdXMnLCBfdGhpcy5zbGlkZXJBY3RpdmVfKTtcblxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyaW5hY3RpdmUnXSwgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tdXRlVG9nZ2xlLCAnYmx1cicsIF90aGlzLnNsaWRlckluYWN0aXZlXyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB2anMtc2xpZGVyLWFjdGl2ZSBjbGFzcyB0byB0aGUgVm9sdW1lUGFuZWxcbiAgICpcbiAgICogQGxpc3RlbnMgVm9sdW1lQ29udHJvbCNzbGlkZXJhY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUuc2xpZGVyQWN0aXZlXyA9IGZ1bmN0aW9uIHNsaWRlckFjdGl2ZV8oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB2anMtc2xpZGVyLWFjdGl2ZSBjbGFzcyB0byB0aGUgVm9sdW1lUGFuZWxcbiAgICpcbiAgICogQGxpc3RlbnMgVm9sdW1lQ29udHJvbCNzbGlkZXJpbmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5zbGlkZXJJbmFjdGl2ZV8gPSBmdW5jdGlvbiBzbGlkZXJJbmFjdGl2ZV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICB2YXIgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLXBhbmVsLWhvcml6b250YWwnO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLmlubGluZSkge1xuICAgICAgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLXBhbmVsLXZlcnRpY2FsJztcbiAgICB9XG5cbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1wYW5lbCB2anMtY29udHJvbCAnICsgb3JpZW50YXRpb25DbGFzc1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVQYW5lbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQ29udHJvbGBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblZvbHVtZVBhbmVsLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFsnbXV0ZVRvZ2dsZScsICd2b2x1bWVDb250cm9sJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lUGFuZWwnLCBWb2x1bWVQYW5lbCk7XG5cbi8qKlxuICogQGZpbGUgbWVudS5qc1xuICovXG4vKipcbiAqIFRoZSBNZW51IGNvbXBvbmVudCBpcyB1c2VkIHRvIGJ1aWxkIHBvcHVwIG1lbnVzLCBpbmNsdWRpbmcgc3VidGl0bGUgYW5kXG4gKiBjYXB0aW9ucyBzZWxlY3Rpb24gbWVudXMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIHRoZSBwbGF5ZXIgdGhhdCB0aGlzIGNvbXBvbmVudCBzaG91bGQgYXR0YWNoIHRvXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIF90aGlzLm1lbnVCdXR0b25fID0gb3B0aW9ucy5tZW51QnV0dG9uO1xuICAgIH1cblxuICAgIF90aGlzLmZvY3VzZWRDaGlsZF8gPSAtMTtcblxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB7QGxpbmsgTWVudUl0ZW19IHRvIHRoZSBtZW51LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgdGhlIGBNZW51SXRlbWAgdG8gYWRkLlxuICAgKlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiBhZGRJdGVtKGNvbXBvbmVudCkge1xuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcbiAgICBjb21wb25lbnQub24oJ2NsaWNrJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIFVucHJlc3MgdGhlIGFzc29jaWF0ZWQgTWVudUJ1dHRvbiwgYW5kIG1vdmUgZm9jdXMgYmFjayB0byBpdFxuICAgICAgaWYgKHRoaXMubWVudUJ1dHRvbl8pIHtcbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy51bnByZXNzQnV0dG9uKCk7XG5cbiAgICAgICAgLy8gZG9uJ3QgZm9jdXMgbWVudSBidXR0b24gaWYgaXRlbSBpcyBhIGNhcHRpb24gc2V0dGluZ3MgaXRlbVxuICAgICAgICAvLyBiZWNhdXNlIGZvY3VzIHdpbGwgbW92ZSBlbHNld2hlcmUgYW5kIGl0IGxvZ3MgYW4gZXJyb3Igb24gSUU4XG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSgpICE9PSAnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nKSB7XG4gICAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51YHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgdGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZFxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGNvbnRlbnRFbFR5cGUgPSB0aGlzLm9wdGlvbnNfLmNvbnRlbnRFbFR5cGUgfHwgJ3VsJztcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKGNvbnRlbnRFbFR5cGUsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWNvbnRlbnQnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnUnKTtcblxuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGFwcGVuZDogdGhpcy5jb250ZW50RWxfLFxuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuXG4gICAgLy8gUHJldmVudCBjbGlja3MgZnJvbSBidWJibGluZyB1cC4gTmVlZGVkIGZvciBNZW51IEJ1dHRvbnMsXG4gICAgLy8gd2hlcmUgYSBjbGljayBvbiB0aGUgcGFyZW50IGlzIHNpZ25pZmljYW50XG4gICAgb24oZWwsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIE1lbnUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsXyA9IG51bGw7XG5cbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiB0aGlzIG1lbnUuIFRoaXMgbGlzdGVuZXIgaXMgYWRkZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgQSBga2V5ZG93bmAgZXZlbnQgdGhhdCBoYXBwZW5lZCBvbiB0aGUgbWVudS5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwRm9yd2FyZCgpO1xuXG4gICAgICAvLyBVcCBhbmQgUmlnaHQgQXJyb3dzXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDM5KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5zdGVwQmFjaygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0byBuZXh0IChsb3dlcikgbWVudSBpdGVtIGZvciBrZXlib2FyZCB1c2Vycy5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xuICAgIHZhciBzdGVwQ2hpbGQgPSAwO1xuXG4gICAgaWYgKHRoaXMuZm9jdXNlZENoaWxkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGVwQ2hpbGQgPSB0aGlzLmZvY3VzZWRDaGlsZF8gKyAxO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzKHN0ZXBDaGlsZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgdG8gcHJldmlvdXMgKGhpZ2hlcikgbWVudSBpdGVtIGZvciBrZXlib2FyZCB1c2Vycy5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xuICAgIHZhciBzdGVwQ2hpbGQgPSAwO1xuXG4gICAgaWYgKHRoaXMuZm9jdXNlZENoaWxkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGVwQ2hpbGQgPSB0aGlzLmZvY3VzZWRDaGlsZF8gLSAxO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzKHN0ZXBDaGlsZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBmb2N1cyBvbiBhIHtAbGluayBNZW51SXRlbX0gaW4gdGhlIGBNZW51YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbaXRlbT0wXVxuICAgKiAgICAgICAgSW5kZXggb2YgY2hpbGQgaXRlbSBzZXQgZm9jdXMgb24uXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICB2YXIgaXRlbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKS5zbGljZSgpO1xuICAgIHZhciBoYXZlVGl0bGUgPSBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bMF0uY2xhc3NOYW1lICYmIC92anMtbWVudS10aXRsZS8udGVzdChjaGlsZHJlblswXS5jbGFzc05hbWUpO1xuXG4gICAgaWYgKGhhdmVUaXRsZSkge1xuICAgICAgY2hpbGRyZW4uc2hpZnQoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGl0ZW0gPCAwKSB7XG4gICAgICAgIGl0ZW0gPSAwO1xuICAgICAgfSBlbHNlIGlmIChpdGVtID49IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1c2VkQ2hpbGRfID0gaXRlbTtcblxuICAgICAgY2hpbGRyZW5baXRlbV0uZWxfLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNZW51O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnUnLCBNZW51KTtcblxuLyoqXG4gKiBAZmlsZSBtZW51LWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIEEgYE1lbnVCdXR0b25gIGNsYXNzIGZvciBhbnkgcG9wdXAge0BsaW5rIE1lbnV9LlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZW51QnV0dG9uID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudUJ1dHRvbiwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBNZW51QnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubWVudUJ1dHRvbl8gPSBuZXcgQnV0dG9uKHBsYXllciwgb3B0aW9ucyk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dChfdGhpcy5jb250cm9sVGV4dF8pO1xuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCAndHJ1ZScpO1xuXG4gICAgLy8gQWRkIGJ1aWxkQ1NTQ2xhc3MgdmFsdWVzIHRvIHRoZSBidXR0b24sIG5vdCB0aGUgd3JhcHBlclxuICAgIHZhciBidXR0b25DbGFzcyA9IEJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcygpO1xuXG4gICAgX3RoaXMubWVudUJ1dHRvbl8uZWxfLmNsYXNzTmFtZSA9IF90aGlzLmJ1aWxkQ1NTQ2xhc3MoKSArICcgJyArIGJ1dHRvbkNsYXNzO1xuICAgIF90aGlzLm1lbnVCdXR0b25fLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbCcpO1xuXG4gICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMubWVudUJ1dHRvbl8pO1xuXG4gICAgX3RoaXMudXBkYXRlKCk7XG5cbiAgICBfdGhpcy5lbmFibGVkXyA9IHRydWU7XG5cbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ3RhcCcsIF90aGlzLmhhbmRsZUNsaWNrKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2NsaWNrJywgX3RoaXMuaGFuZGxlQ2xpY2spO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnZm9jdXMnLCBfdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdibHVyJywgX3RoaXMuaGFuZGxlQmx1cik7XG5cbiAgICBfdGhpcy5vbigna2V5ZG93bicsIF90aGlzLmhhbmRsZVN1Ym1lbnVLZXlQcmVzcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbWVudSBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiBpdHMgaXRlbXMuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBtZW51ID0gdGhpcy5jcmVhdGVNZW51KCk7XG5cbiAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICB0aGlzLm1lbnUuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLm1lbnUpO1xuICAgIH1cblxuICAgIHRoaXMubWVudSA9IG1lbnU7XG4gICAgdGhpcy5hZGRDaGlsZChtZW51KTtcblxuICAgIC8qKlxuICAgICAqIFRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgbWVudSBidXR0b25cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPD0gdGhpcy5oaWRlVGhyZXNob2xkXykge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBtZW51IGFuZCBhZGQgYWxsIGl0ZW1zIHRvIGl0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtNZW51fVxuICAgKiAgICAgICAgIFRoZSBjb25zdHJ1Y3RlZCBtZW51XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgdmFyIG1lbnUgPSBuZXcgTWVudSh0aGlzLnBsYXllcl8sIHsgbWVudUJ1dHRvbjogdGhpcyB9KTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIG1lbnUgaWYgdGhlIG51bWJlciBvZiBpdGVtcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhpcyB0aHJlc2hvbGQuIFRoaXMgZGVmYXVsdHNcbiAgICAgKiB0byAwIGFuZCB3aGVuZXZlciB3ZSBhZGQgaXRlbXMgd2hpY2ggY2FuIGJlIGhpZGRlbiB0byB0aGUgbWVudSB3ZSdsbCBpbmNyZW1lbnQgaXQuIFdlIGxpc3RcbiAgICAgKiBpdCBoZXJlIGJlY2F1c2UgZXZlcnkgdGltZSB3ZSBydW4gYGNyZWF0ZU1lbnVgIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWRlVGhyZXNob2xkXyA9IDA7XG5cbiAgICAvLyBBZGQgYSB0aXRsZSBsaXN0IGl0ZW0gdG8gdGhlIHRvcFxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnRpdGxlKSB7XG4gICAgICB2YXIgdGl0bGUgPSBjcmVhdGVFbCgnbGknLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LXRpdGxlJyxcbiAgICAgICAgaW5uZXJIVE1MOiB0b1RpdGxlQ2FzZSh0aGlzLm9wdGlvbnNfLnRpdGxlKSxcbiAgICAgICAgdGFiSW5kZXg6IC0xXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuXG4gICAgICBtZW51LmNoaWxkcmVuXy51bnNoaWZ0KHRpdGxlKTtcbiAgICAgIHByZXBlbmRUbyh0aXRsZSwgbWVudS5jb250ZW50RWwoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtcyA9IHRoaXMuY3JlYXRlSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICAvLyBBZGQgbWVudSBpdGVtcyB0byB0aGUgbWVudVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lbnUuYWRkSXRlbSh0aGlzLml0ZW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVudTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBsaXN0IG9mIG1lbnUgaXRlbXMuIFNwZWNpZmljIHRvIGVhY2ggc3ViY2xhc3MuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7fTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudUJ1dHRvbnNgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKVxuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzIGZvciB0aGUgd3JhcHBlciBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgd3JhcHBlciBET00gYGNsYXNzTmFtZWBcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHZhciBtZW51QnV0dG9uQ2xhc3MgPSAndmpzLW1lbnUtYnV0dG9uJztcblxuICAgIC8vIElmIHRoZSBpbmxpbmUgb3B0aW9uIGlzIHBhc3NlZCwgd2Ugd2FudCB0byB1c2UgZGlmZmVyZW50IHN0eWxlcyBhbHRvZ2V0aGVyLlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLmlubGluZSA9PT0gdHJ1ZSkge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctaW5saW5lJztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctcG9wdXAnO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZpeCB0aGUgQ1NTIHNvIHRoYXQgdGhpcyBpc24ndCBuZWNlc3NhcnlcbiAgICB2YXIgYnV0dG9uQ2xhc3MgPSBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MoKTtcblxuICAgIHJldHVybiAndmpzLW1lbnUtYnV0dG9uICcgKyBtZW51QnV0dG9uQ2xhc3MgKyAnICcgKyBidXR0b25DbGFzcyArICcgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHZhciBtZW51QnV0dG9uQ2xhc3MgPSAndmpzLW1lbnUtYnV0dG9uJztcblxuICAgIC8vIElmIHRoZSBpbmxpbmUgb3B0aW9uIGlzIHBhc3NlZCwgd2Ugd2FudCB0byB1c2UgZGlmZmVyZW50IHN0eWxlcyBhbHRvZ2V0aGVyLlxuICAgIGlmICh0aGlzLm9wdGlvbnNfLmlubGluZSA9PT0gdHJ1ZSkge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctaW5saW5lJztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctcG9wdXAnO1xuICAgIH1cblxuICAgIHJldHVybiAndmpzLW1lbnUtYnV0dG9uICcgKyBtZW51QnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvY2FsaXplZCBjb250cm9sIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqID4gTk9URTogVGhpcyB3aWxsIGNvbWUgZnJvbSB0aGUgaW50ZXJuYWwgYG1lbnVCdXR0b25fYCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAqICAgICAgICBDb250cm9sIHRleHQgZm9yIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsPXRoaXMubWVudUJ1dHRvbl8uZWwoKV1cbiAgICogICAgICAgIEVsZW1lbnQgdG8gc2V0IHRoZSB0aXRsZSBvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIC0gVGhlIGNvbnRyb2wgdGV4dCB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcbiAgICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMubWVudUJ1dHRvbl8uZWwoKTtcblxuICAgIHJldHVybiB0aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KHRleHQsIGVsKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgY2xpY2sgb24gYSBgTWVudUJ1dHRvbmAuXG4gICAqIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgLy8gV2hlbiB5b3UgY2xpY2sgdGhlIGJ1dHRvbiBpdCBhZGRzIGZvY3VzLCB3aGljaCB3aWxsIHNob3cgdGhlIG1lbnUuXG4gICAgLy8gU28gd2UnbGwgcmVtb3ZlIGZvY3VzIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgYnV0dG9uLiBGb2N1cyBpcyBuZWVkZWRcbiAgICAvLyBmb3IgdGFiIG5hdmlnYXRpb24uXG5cbiAgICB0aGlzLm9uZSh0aGlzLm1lbnUuY29udGVudEVsKCksICdtb3VzZWxlYXZlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgICB0aGlzLmVsXy5ibHVyKCk7XG4gICAgfSkpO1xuICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBmb2N1cyB0byB0aGUgYWN0dWFsIGJ1dHRvbiwgbm90IHRvIHRoaXMgZWxlbWVudFxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5mb2N1cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGZvY3VzIGZyb20gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gYmx1cigpIHtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmJsdXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYE1lbnVCdXR0b25gIGdhaW5zIGZvY3VzIHZpYSBhIGBmb2N1c2AgZXZlbnQuXG4gICAqIFR1cm5zIG9uIGxpc3RlbmluZyBmb3IgYGtleWRvd25gIGV2ZW50cy4gV2hlbiB0aGV5IGhhcHBlbiBpdFxuICAgKiBjYWxscyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGZvY3VzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgZm9jdXNcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIGhhbmRsZUZvY3VzKCkge1xuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBsb3NlcyBmb2N1cy4gVHVybnMgb2ZmIHRoZSBsaXN0ZW5lciBmb3JcbiAgICogYGtleWRvd25gIGV2ZW50cy4gV2hpY2ggU3RvcHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgIGZyb20gZ2V0dGluZyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBibHVyXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGFiLCBlc2NhcGUsIGRvd24gYXJyb3csIGFuZCB1cCBhcnJvdyBrZXlzIGZvciBgTWVudUJ1dHRvbmAuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIFVwICgzOCkga2V5IG9yIERvd24gKDQwKSBrZXkgcHJlc3MgdGhlICdidXR0b24nXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XG4gICAgICBpZiAoIXRoaXMuYnV0dG9uUHJlc3NlZF8pIHtcbiAgICAgICAgdGhpcy5wcmVzc0J1dHRvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIGEgc3ViLW1lbnUuIFRoZSBsaXN0ZW5lciBmb3IgdGhpcyBpcyBhZGRlZCBpblxuICAgKiB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBLZXkgcHJlc3MgZXZlbnRcbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZVN1Ym1lbnVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVN1Ym1lbnVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gRXNjYXBlICgyNykga2V5IG9yIFRhYiAoOSkga2V5IHVucHJlc3MgdGhlICdidXR0b24nXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAyNyB8fCBldmVudC53aGljaCA9PT0gOSkge1xuICAgICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pIHtcbiAgICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBwcmV2ZW50RGVmYXVsdCBmb3IgVGFiIGtleSAtIHdlIHN0aWxsIHdhbnQgdG8gbG9zZSBmb2N1c1xuICAgICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIFNldCBmb2N1cyBiYWNrIHRvIHRoZSBtZW51IGJ1dHRvbidzIGJ1dHRvblxuICAgICAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHV0IHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBpbnRvIGEgcHJlc3NlZCBzdGF0ZS5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5wcmVzc0J1dHRvbiA9IGZ1bmN0aW9uIHByZXNzQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWRfKSB7XG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMubWVudS5sb2NrU2hvd2luZygpO1xuICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcblxuICAgICAgLy8gc2V0IHRoZSBmb2N1cyBpbnRvIHRoZSBzdWJtZW51LCBleGNlcHQgb24gaU9TIHdoZXJlIGl0IGlzIHJlc3VsdGluZyBpblxuICAgICAgLy8gdW5kZXNpcmVkIHNjcm9sbGluZyBiZWhhdmlvciB3aGVuIHRoZSBwbGF5ZXIgaXMgaW4gYW4gaWZyYW1lXG4gICAgICBpZiAoSVNfSU9TICYmIGlzSW5GcmFtZSgpKSB7XG4gICAgICAgIC8vIFJldHVybiBlYXJseSBzbyB0aGF0IHRoZSBtZW51IGlzbid0IGZvY3VzZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1lbnUuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2UgdGhlIGN1cnJlbnQgYE1lbnVCdXR0b25gIG91dCBvZiBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUudW5wcmVzc0J1dHRvbiA9IGZ1bmN0aW9uIHVucHJlc3NCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZF8pIHtcbiAgICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICAgIHRoaXMubWVudS51bmxvY2tTaG93aW5nKCk7XG4gICAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIGBNZW51QnV0dG9uYC4gRG9uJ3QgYWxsb3cgaXQgdG8gYmUgY2xpY2tlZC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcblxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZGlzYWJsZWQnKTtcblxuICAgIHRoaXMubWVudUJ1dHRvbl8uZGlzYWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIGBNZW51QnV0dG9uYC4gQWxsb3cgaXQgdG8gYmUgY2xpY2tlZC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWRpc2FibGVkJyk7XG5cbiAgICB0aGlzLm1lbnVCdXR0b25fLmVuYWJsZSgpO1xuICB9O1xuXG4gIHJldHVybiBNZW51QnV0dG9uO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVCdXR0b24nLCBNZW51QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyAgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9NZW51QnV0dG9uKSB7XG4gIGluaGVyaXRzKFRyYWNrQnV0dG9uLCBfTWVudUJ1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUcmFja0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0J1dHRvbik7XG5cbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51QnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoX3RoaXMuaXRlbXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIF90aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrcykge1xuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlKTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIF90aGlzLnBsYXllcl8ub24oJ3JlYWR5JywgdXBkYXRlSGFuZGxlcik7XG5cbiAgICBfdGhpcy5wbGF5ZXJfLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVHJhY2tCdXR0b247XG59KE1lbnVCdXR0b24pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1RyYWNrQnV0dG9uJywgVHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGEgbWVudSBpdGVtLiBgPGxpPmBcbiAqXG4gKiBAZXh0ZW5kcyBDbGlja2FibGVDb21wb25lbnRcbiAqL1xuXG52YXIgTWVudUl0ZW0gPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51SXRlbSwgX0NsaWNrYWJsZUNvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUl0ZW0pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5zZWxlY3RhYmxlID0gb3B0aW9ucy5zZWxlY3RhYmxlO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWQob3B0aW9ucy5zZWxlY3RlZCk7XG5cbiAgICBpZiAoX3RoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgLy8gVE9ETzogTWF5IG5lZWQgdG8gYmUgZWl0aGVyIG1lbnVpdGVtY2hlY2tib3ggb3IgbWVudWl0ZW1yYWRpbyxcbiAgICAgIC8vICAgICAgIGFuZCBtYXkgbmVlZCBsb2dpY2FsIGdyb3VwaW5nIG9mIG1lbnUgaXRlbXMuXG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtY2hlY2tib3gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudUl0ZW0ncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9bGldXG4gICAqICAgICAgICBFbGVtZW50J3Mgbm9kZSB0eXBlLCBub3QgYWN0dWFsbHkgdXNlZCwgYWx3YXlzIHNldCB0byBgbGlgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0eXBlLCBwcm9wcywgYXR0cnMpIHtcbiAgICAvLyBUaGUgY29udHJvbCBpcyB0ZXh0dWFsLCBub3QganVzdCBhbiBpY29uXG4gICAgdGhpcy5ub25JY29uQ29udHJvbCA9IHRydWU7XG5cbiAgICByZXR1cm4gX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnbGknLCBhc3NpZ24oe1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtaXRlbScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpICsgJzwvc3Bhbj4nLFxuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFueSBjbGljayBvbiBhIGBNZW51SXRlbWAgcHV0cyBpbnQgaW50byB0aGUgc2VsZWN0ZWQgc3RhdGUuXG4gICAqIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgZm9yIHRoaXMgbWVudSBpdGVtIGFzIHNlbGVjdGVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiAgICAgICAgaWYgdGhlIG1lbnUgaXRlbSBpcyBzZWxlY3RlZCBvciBub3RcbiAgICovXG5cblxuICBNZW51SXRlbS5wcm90b3R5cGUuc2VsZWN0ZWQgPSBmdW5jdGlvbiBzZWxlY3RlZChfc2VsZWN0ZWQpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICBpZiAoX3NlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zZWxlY3RlZCcpO1xuICAgICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsICd0cnVlJyk7XG4gICAgICAgIC8vIGFyaWEtY2hlY2tlZCBpc24ndCBmdWxseSBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMvc2NyZWVuIHJlYWRlcnMsXG4gICAgICAgIC8vIHNvIGluZGljYXRlIHNlbGVjdGVkIHN0YXRlIHRvIHNjcmVlbiByZWFkZXIgaW4gdGhlIGNvbnRyb2wgdGV4dC5cbiAgICAgICAgdGhpcy5jb250cm9sVGV4dCgnLCBzZWxlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ2ZhbHNlJyk7XG4gICAgICAgIC8vIEluZGljYXRlIHVuLXNlbGVjdGVkIHN0YXRlIHRvIHNjcmVlbiByZWFkZXJcbiAgICAgICAgdGhpcy5jb250cm9sVGV4dCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNZW51SXRlbTtcbn0oQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZW51SXRlbScsIE1lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBzcGVjaWZpYyBtZW51IGl0ZW0gdHlwZSBmb3Igc2VsZWN0aW5nIGEgbGFuZ3VhZ2Ugd2l0aGluIGEgdGV4dCB0cmFjayBraW5kXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgVGV4dFRyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFRleHRUcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgdHJhY2tzID0gcGxheWVyLnRleHRUcmFja3MoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMubGFiZWwgPSB0cmFjay5sYWJlbCB8fCB0cmFjay5sYW5ndWFnZSB8fCAnVW5rbm93bic7XG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJztcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24gY2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZS5hcHBseShfdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICB2YXIgc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZS5hcHBseShfdGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHBsYXllci5vbihbJ2xvYWRzdGFydCcsICd0ZXh0dHJhY2tjaGFuZ2UnXSwgY2hhbmdlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGxhbmd1YWdlY2hhbmdlJywgc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcGxheWVyLm9mZihbJ2xvYWRzdGFydCcsICd0ZXh0dHJhY2tjaGFuZ2UnXSwgY2hhbmdlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIC8vIGlPUzcgZG9lc24ndCBkaXNwYXRjaCBjaGFuZ2UgZXZlbnRzIHRvIFRleHRUcmFja0xpc3RzIHdoZW4gYW5cbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXG4gICAgLy8gT2JqZWN0Lm9ic2VydmUoKSAoYWxzbyBub3QgcHJlc2VudCBvbiBpT1M3KSwgaXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgbW9kZSBhdHRyaWJ1dGUgYW5kIHBvbHlmaWxsXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXG4gICAgLy8gY2hhbmdlIGV2ZW50cyB3aGVuZXZlciB0aGUgY29udHJvbHMgbW9kaWZ5IHRoZSBtb2RlLlxuICAgIGlmICh0cmFja3Mub25jaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gdm9pZCAwO1xuXG4gICAgICBfdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy5FdmVudCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2NoYW5nZScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGRlZmF1bHQgc3RhdGUgYmFzZWQgb24gY3VycmVudCB0cmFja3NcbiAgICBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBUZXh0VHJhY2tNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciBraW5kID0gdGhpcy50cmFjay5raW5kO1xuICAgIHZhciBraW5kcyA9IHRoaXMudHJhY2sua2luZHM7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG5cbiAgICBpZiAoIWtpbmRzKSB7XG4gICAgICBraW5kcyA9IFtraW5kXTtcbiAgICB9XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgaWYgKCF0cmFja3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sgPT09IHRoaXMudHJhY2sgJiYga2luZHMuaW5kZXhPZih0cmFjay5raW5kKSA+IC0xKSB7XG4gICAgICAgIGlmICh0cmFjay5tb2RlICE9PSAnc2hvd2luZycpIHtcbiAgICAgICAgICB0cmFjay5tb2RlID0gJ3Nob3dpbmcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLm1vZGUgIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgdHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGV4dCB0cmFjayBsaXN0IGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKTtcbiAgfTtcblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UoZXZlbnQpIHtcbiAgICBpZiAodGhpcy50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgIHZhciBzZWxlY3RlZExhbmd1YWdlID0gdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlO1xuXG4gICAgICAvLyBEb24ndCByZXBsYWNlIHRoZSBraW5kIG9mIHRyYWNrIGFjcm9zcyB0aGUgc2FtZSBsYW5ndWFnZVxuICAgICAgaWYgKHNlbGVjdGVkTGFuZ3VhZ2UgJiYgc2VsZWN0ZWRMYW5ndWFnZS5lbmFibGVkICYmIHNlbGVjdGVkTGFuZ3VhZ2UubGFuZ3VhZ2UgPT09IHRoaXMudHJhY2subGFuZ3VhZ2UgJiYgc2VsZWN0ZWRMYW5ndWFnZS5raW5kICE9PSB0aGlzLnRyYWNrLmtpbmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGxhbmd1YWdlOiB0aGlzLnRyYWNrLmxhbmd1YWdlLFxuICAgICAgICBraW5kOiB0aGlzLnRyYWNrLmtpbmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIFRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRyYWNrIG9iamVjdCBvbiBkaXNwb3NlXG4gICAgdGhpcy50cmFjayA9IG51bGw7XG5cbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBvZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBBIHNwZWNpYWwgbWVudSBpdGVtIGZvciB0dXJuaW5nIG9mIGEgc3BlY2lmaWMgdHlwZSBvZiB0ZXh0IHRyYWNrXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKE9mZlRleHRUcmFja01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gT2ZmVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gICAgLy8gQ3JlYXRlIHBzZXVkbyB0cmFjayBpbmZvXG4gICAgLy8gUmVxdWlyZXMgb3B0aW9uc1sna2luZCddXG4gICAgb3B0aW9ucy50cmFjayA9IHtcbiAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAga2luZHM6IG9wdGlvbnMua2luZHMsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMua2luZHMpIHtcbiAgICAgIG9wdGlvbnMua2luZHMgPSBbb3B0aW9ucy5raW5kXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmtpbmRzLmpvaW4oJyBhbmQgJykgKyAnIG9mZic7XG4gICAgfVxuXG4gICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGV4dCB0cmFjayBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1blxuICAgKi9cblxuXG4gIE9mZlRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHNlbGVjdGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5raW5kcy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICB9O1xuXG4gIE9mZlRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgYWxsSGlkZGVuID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAoWydjYXB0aW9ucycsICdkZXNjcmlwdGlvbnMnLCAnc3VidGl0bGVzJ10uaW5kZXhPZih0cmFjay5raW5kKSA+IC0xICYmIHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICBhbGxIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsbEhpZGRlbikge1xuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9mZlRleHRUcmFja01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnT2ZmVGV4dFRyYWNrTWVudUl0ZW0nLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFRleHRUcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tCdXR0b24pO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2tNZW51SXRlbVtdfSBbaXRlbXM9W11dXG4gICAqICAgICAgICBFeGlzdGluZyBhcnJheSBvZiBpdGVtcyB0byB1c2UgZHVyaW5nIGNyZWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtcyB0aGF0IHdlcmUgY3JlYXRlZFxuICAgKi9cblxuXG4gIFRleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHZhciBUcmFja01lbnVJdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUZXh0VHJhY2tNZW51SXRlbTtcblxuXG4gICAgLy8gTGFiZWwgaXMgYW4gb3ZlcmlkZSBmb3IgdGhlIFt0cmFja10gb2ZmIGxhYmVsXG4gICAgLy8gVVNlZCB0byBsb2NhbGlzZSBjYXB0aW9ucy9zdWJ0aXRsZXNcbiAgICB2YXIgbGFiZWwgPSB2b2lkIDA7XG5cbiAgICBpZiAodGhpcy5sYWJlbF8pIHtcbiAgICAgIGxhYmVsID0gdGhpcy5sYWJlbF8gKyAnIG9mZic7XG4gICAgfVxuICAgIC8vIEFkZCBhbiBPRkYgbWVudSBpdGVtIHRvIHR1cm4gYWxsIHRyYWNrcyBvZmZcbiAgICBpdGVtcy5wdXNoKG5ldyBPZmZUZXh0VHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgIGtpbmRzOiB0aGlzLmtpbmRzXyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZF8sXG4gICAgICBsYWJlbDogbGFiZWxcbiAgICB9KSk7XG5cbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmtpbmRzXykpIHtcbiAgICAgIHRoaXMua2luZHNfID0gW3RoaXMua2luZF9dO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHRyYWNrcyB0aGF0IGFyZSBvZiBhbiBhcHByb3ByaWF0ZSBraW5kIGFuZCBoYXZlIGEgbGFiZWxcbiAgICAgIGlmICh0aGlzLmtpbmRzXy5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEpIHtcblxuICAgICAgICB2YXIgaXRlbSA9IG5ldyBUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLmFkZENsYXNzKCd2anMtJyArIHRyYWNrLmtpbmQgKyAnLW1lbnUtaXRlbScpO1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrQnV0dG9uO1xufShUcmFja0J1dHRvbik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrQnV0dG9uJywgVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgY2hhcHRlciB0cmFjayBtZW51IGl0ZW1cbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBDaGFwdGVyc1RyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKENoYXB0ZXJzVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIENoYXB0ZXJzVHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0pO1xuXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcbiAgICB2YXIgY3VlID0gb3B0aW9ucy5jdWU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcGxheWVyLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIG9wdGlvbnMubGFiZWwgPSBjdWUudGV4dDtcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgX3RoaXMuY3VlID0gY3VlO1xuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYENoYXB0ZXJzVHJhY2tNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENoYXB0ZXJzVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5jdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2hhcHRlciBtZW51IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBjdWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjY3VlY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgY3VlID0gdGhpcy5jdWU7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyB2anMubG9nKGN1cnJlbnRUaW1lLCBjdWUuc3RhcnRUaW1lKTtcbiAgICB0aGlzLnNlbGVjdGVkKGN1ZS5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUgJiYgY3VycmVudFRpbWUgPCBjdWUuZW5kVGltZSk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXB0ZXJzVHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NoYXB0ZXJzVHJhY2tNZW51SXRlbScsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2hhcHRlcnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2hhcHRlcnNcbiAqIENoYXB0ZXJzIGFjdCBtdWNoIGRpZmZlcmVudGx5IHRoYW4gb3RoZXIgdGV4dCB0cmFja3NcbiAqIEN1ZXMgYXJlIG5hdmlnYXRpb24gdnMuIG90aGVyIHRyYWNrcyBvZiBhbHRlcm5hdGl2ZSBsYW5ndWFnZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2hhcHRlcnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDaGFwdGVyc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIENoYXB0ZXJzQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFwdGVyc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNoYXB0ZXJzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNoYXB0ZXJzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIGl0cyBpdGVtcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgQW4gZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjYWRkdHJhY2tcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMudHJhY2tfIHx8IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnYWRkdHJhY2snIHx8IGV2ZW50LnR5cGUgPT09ICdyZW1vdmV0cmFjaycpKSB7XG4gICAgICB0aGlzLnNldFRyYWNrKHRoaXMuZmluZENoYXB0ZXJzVHJhY2soKSk7XG4gICAgfVxuICAgIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0cmFjayBmb3IgdGhlIGNoYXB0ZXJzIGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgbmV3IHRyYWNrIHRvIHNlbGVjdC4gTm90aGluZyB3aWxsIGNoYW5nZSBpZiB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICogICAgICAgIHRyYWNrLlxuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5zZXRUcmFjayA9IGZ1bmN0aW9uIHNldFRyYWNrKHRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2tfID09PSB0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy51cGRhdGVIYW5kbGVyXykge1xuICAgICAgdGhpcy51cGRhdGVIYW5kbGVyXyA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gaGVyZSB0aGlzLnRyYWNrXyByZWZlcnMgdG8gdGhlIG9sZCB0cmFjayBpbnN0YW5jZVxuICAgIGlmICh0aGlzLnRyYWNrXykge1xuICAgICAgdmFyIHJlbW90ZVRleHRUcmFja0VsID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRoaXMudHJhY2tfKTtcblxuICAgICAgaWYgKHJlbW90ZVRleHRUcmFja0VsKSB7XG4gICAgICAgIHJlbW90ZVRleHRUcmFja0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFja18gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2tfID0gdHJhY2s7XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgbmV3IHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB0aGlzLnRyYWNrXy5tb2RlID0gJ2hpZGRlbic7XG5cbiAgICAgIHZhciBfcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAoX3JlbW90ZVRleHRUcmFja0VsKSB7XG4gICAgICAgIF9yZW1vdGVUZXh0VHJhY2tFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy51cGRhdGVIYW5kbGVyXyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSB0cmFjayBvYmplY3QgdGhhdCBpcyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoaXMgQ2hhcHRlcnNCdXR0b25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB0cmFjayBvciB1bmRlZmluZWQgaWYgbm9uZSB3YXMgZm91bmQuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmZpbmRDaGFwdGVyc1RyYWNrID0gZnVuY3Rpb24gZmluZENoYXB0ZXJzVHJhY2soKSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCkgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gdHJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyBXZSB3aWxsIGFsd2F5cyBjaG9vc2UgdGhlIGxhc3QgdHJhY2sgYXMgb3VyIGNoYXB0ZXJzVHJhY2tcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IHRoaXMua2luZF8pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjYXB0aW9uIGZvciB0aGUgQ2hhcHRlcnNCdXR0b24gYmFzZWQgb24gdGhlIHRyYWNrIGxhYmVsLiBUaGlzIHdpbGwgYWxzb1xuICAgKiB1c2UgdGhlIGN1cnJlbnQgdHJhY2tzIGxvY2FsaXplZCBraW5kIGFzIGEgZmFsbGJhY2sgaWYgYSBsYWJlbCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB0cmFja3MgY3VycmVudCBsYWJlbCBvciB0aGUgbG9jYWxpemVkIHRyYWNrIGtpbmQuXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmdldE1lbnVDYXB0aW9uID0gZnVuY3Rpb24gZ2V0TWVudUNhcHRpb24oKSB7XG4gICAgaWYgKHRoaXMudHJhY2tfICYmIHRoaXMudHJhY2tfLmxhYmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja18ubGFiZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRvVGl0bGVDYXNlKHRoaXMua2luZF8pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIG1lbnUgZnJvbSBjaGFwdGVyIHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgTmV3IG1lbnUgZm9yIHRoZSBjaGFwdGVyIGJ1dHRvbnNcbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XG4gICAgdGhpcy5vcHRpb25zXy50aXRsZSA9IHRoaXMuZ2V0TWVudUNhcHRpb24oKTtcbiAgICByZXR1cm4gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIEFycmF5IG9mIG1lbnUgaXRlbXNcbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghdGhpcy50cmFja18pIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICB2YXIgY3VlcyA9IHRoaXMudHJhY2tfLmN1ZXM7XG5cbiAgICBpZiAoIWN1ZXMpIHtcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY3VlID0gY3Vlc1tpXTtcbiAgICAgIHZhciBtaSA9IG5ldyBDaGFwdGVyc1RyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IHRyYWNrOiB0aGlzLnRyYWNrXywgY3VlOiBjdWUgfSk7XG5cbiAgICAgIGl0ZW1zLnB1c2gobWkpO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2hhcHRlcnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENoYXB0ZXJzQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2hhcHRlcnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NoYXB0ZXJzQnV0dG9uJywgQ2hhcHRlcnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGRlc2NyaXB0aW9ucy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBkZXNjcmlwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgRGVzY3JpcHRpb25zQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoRGVzY3JpcHRpb25zQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIERlc2NyaXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzY3JpcHRpb25zQnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIHdoZXRoZXIgYSB0cmFjayBvZiBhIGRpZmZlcmVudCBraW5kIGlzIHNob3dpbmdcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrLmtpbmQgIT09IHRoaXMua2luZF8gJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYW5vdGhlciB0cmFjayBpcyBzaG93aW5nLCBkaXNhYmxlIHRoaXMgbWVudSBidXR0b25cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kZXNjcmlwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBEZXNjcmlwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ2Rlc2NyaXB0aW9ucyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRGVzY3JpcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkRlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0Rlc2NyaXB0aW9ucyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRGVzY3JpcHRpb25zQnV0dG9uJywgRGVzY3JpcHRpb25zQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBzdWJ0aXRsZXMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3Rpbmcgc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnRpdGxlc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFN1YnRpdGxlc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBTdWJ0aXRsZXNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnRpdGxlc0J1dHRvbik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJ0aXRsZXMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnRpdGxlc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnc3VidGl0bGVzJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJ0aXRsZXNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnU3VidGl0bGVzJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIG1lbnUgaXRlbSBmb3IgY2FwdGlvbiB0cmFjayBzZXR0aW5ncyBtZW51XG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKENhcHRpb25TZXR0aW5nc01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuXG4gICAgb3B0aW9ucy50cmFjayA9IHtcbiAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAgbGFiZWw6IG9wdGlvbnMua2luZCArICcgc2V0dGluZ3MnLFxuICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICAvLyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSBoYXMgbm8gY29uY2VwdCBvZiAnc2VsZWN0ZWQnXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gZmFsc2U7XG5cbiAgICBvcHRpb25zLm5hbWUgPSAnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdGV4dHRyYWNrLXNldHRpbmdzJyk7XG4gICAgX3RoaXMuY29udHJvbFRleHQoJywgb3BlbnMgJyArIG9wdGlvbnMua2luZCArICcgc2V0dGluZ3MgZGlhbG9nJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHRoaXMucGxheWVyKCkuZ2V0Q2hpbGQoJ3RleHRUcmFja1NldHRpbmdzJykub3BlbigpO1xuICB9O1xuXG4gIHJldHVybiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIGNhcHRpb25zLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNhcHRpb25zXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIENhcHRpb25zQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvbnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRpb25zQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2FwdGlvbiBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XG4gICAqICAgICAgICAgVGhlIGFycmF5IG9mIGN1cnJlbnQgbWVudSBpdGVtcy5cbiAgICovXG5cblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghKHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpKSB7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsga2luZDogdGhpcy5raW5kXyB9KSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMuY2FsbCh0aGlzLCBpdGVtcyk7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25zQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ2NhcHRpb25zJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBDYXB0aW9uc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0NhcHRpb25zJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDYXB0aW9uc0J1dHRvbicsIENhcHRpb25zQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBzdWJzLWNhcHMtbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogU3Vic0NhcHNNZW51SXRlbSBoYXMgYW4gW2NjXSBpY29uIHRvIGRpc3Rpbmd1aXNoIGNhcHRpb25zIGZyb20gc3VidGl0bGVzXG4gKiBpbiB0aGUgU3Vic0NhcHNNZW51LlxuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXG4gKi9cblxudmFyIFN1YnNDYXBzTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFN1YnNDYXBzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgZnVuY3Rpb24gU3Vic0NhcHNNZW51SXRlbSgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc01lbnVJdGVtKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrTWVudUl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBTdWJzQ2Fwc01lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIHZhciBpbm5lckhUTUwgPSAnPHNwYW4gY2xhc3M9XCJ2anMtbWVudS1pdGVtLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLmxhYmVsKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpIHtcbiAgICAgIGlubmVySFRNTCArPSAnXFxuICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+ICcgKyB0aGlzLmxvY2FsaXplKCdDYXB0aW9ucycpICsgJzwvc3Bhbj5cXG4gICAgICAnO1xuICAgIH1cblxuICAgIGlubmVySFRNTCArPSAnPC9zcGFuPic7XG5cbiAgICB2YXIgZWwgPSBfVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgYXNzaWduKHtcbiAgICAgIGlubmVySFRNTDogaW5uZXJIVE1MXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNDYXBzTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJzQ2Fwc01lbnVJdGVtJywgU3Vic0NhcHNNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgc3ViLWNhcHMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnMgYW5kL29yIHN1YnRpdGxlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBTdWJzQ2Fwc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKFN1YnNDYXBzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc0J1dHRvbihwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic0NhcHNCdXR0b24pO1xuXG4gICAgLy8gQWx0aG91Z2ggTm9ydGggQW1lcmljYSB1c2VzIFwiY2FwdGlvbnNcIiBpbiBtb3N0IGNhc2VzIGZvclxuICAgIC8vIFwiY2FwdGlvbnMgYW5kIHN1YnRpdGxlc1wiIG90aGVyIGxvY2FsZXMgdXNlIFwic3VidGl0bGVzXCJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmxhYmVsXyA9ICdzdWJ0aXRsZXMnO1xuICAgIGlmIChbJ2VuJywgJ2VuLXVzJywgJ2VuLWNhJywgJ2ZyLWNhJ10uaW5kZXhPZihfdGhpcy5wbGF5ZXJfLmxhbmd1YWdlXykgPiAtMSkge1xuICAgICAgX3RoaXMubGFiZWxfID0gJ2NhcHRpb25zJztcbiAgICB9XG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQodG9UaXRsZUNhc2UoX3RoaXMubGFiZWxfKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnMtY2Fwcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uL3N1YnRpdGxlcyBtZW51IGl0ZW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XG4gICAqICAgICAgICAgVGhlIGFycmF5IG9mIGN1cnJlbnQgbWVudSBpdGVtcy5cbiAgICovXG5cblxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICghKHRoaXMucGxheWVyKCkudGVjaF8gJiYgdGhpcy5wbGF5ZXIoKS50ZWNoXy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpKSB7XG4gICAgICBpdGVtcy5wdXNoKG5ldyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsga2luZDogdGhpcy5sYWJlbF8gfSkpO1xuXG4gICAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XG4gICAgfVxuXG4gICAgaXRlbXMgPSBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcy5jYWxsKHRoaXMsIGl0ZW1zLCBTdWJzQ2Fwc01lbnVJdGVtKTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNDYXBzQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYHMgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7YXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmtpbmRzXyA9IFsnY2FwdGlvbnMnLCAnc3VidGl0bGVzJ107XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgU3Vic0NhcHNCdXR0b25gcyBjb250cm9scy5cbiAqXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnU3VidGl0bGVzJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJzQ2Fwc0J1dHRvbicsIFN1YnNDYXBzQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBBbiB7QGxpbmsgQXVkaW9UcmFja30ge0BsaW5rIE1lbnVJdGVtfVxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIEF1ZGlvVHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQXVkaW9UcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIuYXVkaW9UcmFja3MoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMubGFiZWwgPSB0cmFjay5sYWJlbCB8fCB0cmFjay5sYW5ndWFnZSB8fCAnVW5rbm93bic7XG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IHRyYWNrLmVuYWJsZWQ7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIHZhciBjaGFuZ2VIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMuaGFuZGxlVHJhY2tzQ2hhbmdlKTtcblxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICBfdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBBdWRpb1RyYWNrTWVudUl0ZW0gaXMgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxuICAgKiBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcblxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICB0cmFjay5lbmFibGVkID0gdHJhY2sgPT09IHRoaXMudHJhY2s7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW55IHtAbGluayBBdWRpb1RyYWNrfSBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgQXVkaW9UcmFja0xpc3QjY2hhbmdlfSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgQXVkaW9UcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKHRoaXMudHJhY2suZW5hYmxlZCk7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0F1ZGlvVHJhY2tNZW51SXRlbScsIEF1ZGlvVHJhY2tNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgYXVkaW8tdHJhY2stYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGJ1dHRvbnMgdGhhdCB0b2dnbGUgc3BlY2lmaWMge0BsaW5rIEF1ZGlvVHJhY2t9IHR5cGVzLlxuICpcbiAqIEBleHRlbmRzIFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIEF1ZGlvVHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX1RyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKEF1ZGlvVHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrQnV0dG9uKTtcblxuICAgIG9wdGlvbnMudHJhY2tzID0gcGxheWVyLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYXVkaW8tYnV0dG9uICcgKyBfVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWF1ZGlvLWJ1dHRvbiAnICsgX1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggYXVkaW8gdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrTWVudUl0ZW1bXX0gW2l0ZW1zPVtdXVxuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgZXhpc3RpbmcgbWVudSBpdGVtcyB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0F1ZGlvVHJhY2tNZW51SXRlbVtdfVxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIG1lbnUgaXRlbXNcbiAgICovXG5cblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICAvLyBpZiB0aGVyZSdzIG9ubHkgb25lIGF1ZGlvIHRyYWNrLCB0aGVyZSBubyBwb2ludCBpbiBzaG93aW5nIGl0XG4gICAgdGhpcy5oaWRlVGhyZXNob2xkXyA9IDE7XG5cbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLmF1ZGlvVHJhY2tzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpdGVtcy5wdXNoKG5ldyBBdWRpb1RyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrQnV0dG9uO1xufShUcmFja0J1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQXVkaW9UcmFja0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0F1ZGlvIFRyYWNrJztcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja0J1dHRvbicsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBwbGF5YmFjayByYXRlLlxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhQbGF5YmFja1JhdGVNZW51SXRlbSwgX01lbnVJdGVtKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXliYWNrUmF0ZU1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXliYWNrUmF0ZU1lbnVJdGVtKTtcblxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMucmF0ZTtcbiAgICB2YXIgcmF0ZSA9IHBhcnNlRmxvYXQobGFiZWwsIDEwKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMubGFiZWwgPSBsYWJlbDtcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gcmF0ZSA9PT0gMTtcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgX3RoaXMucmF0ZSA9IHJhdGU7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdyYXRlY2hhbmdlJywgX3RoaXMudXBkYXRlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKHRoaXMucmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgUGxheWJhY2tSYXRlTWVudUl0ZW0gd2hlbiB0aGUgcGxheWJhY2tyYXRlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSA9PT0gdGhpcy5yYXRlKTtcbiAgfTtcblxuICByZXR1cm4gUGxheWJhY2tSYXRlTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBQbGF5YmFja1JhdGVNZW51SXRlbWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmNvbnRlbnRFbFR5cGUgPSAnYnV0dG9uJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5YmFja1JhdGVNZW51SXRlbScsIFBsYXliYWNrUmF0ZU1lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5YmFjay1yYXRlLW1lbnUtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHBsYXliYWNrIHJhdGUuXG4gKlxuICogQGV4dGVuZHMgTWVudUJ1dHRvblxuICovXG5cbnZhciBQbGF5YmFja1JhdGVNZW51QnV0dG9uID0gZnVuY3Rpb24gKF9NZW51QnV0dG9uKSB7XG4gIGluaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVCdXR0b24sIF9NZW51QnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWJhY2tSYXRlTWVudUJ1dHRvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51QnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgX3RoaXMudXBkYXRlTGFiZWwoKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGVMYWJlbCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICB2YXIgZWwgPSBfTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMubGFiZWxFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXBsYXliYWNrLXJhdGUtdmFsdWUnLFxuICAgICAgaW5uZXJIVE1MOiAnMXgnXG4gICAgfSk7XG5cbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsRWxfKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmxhYmVsRWxfID0gbnVsbDtcblxuICAgIF9NZW51QnV0dG9uLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheWJhY2stcmF0ZSAnICsgX01lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgcGxheWJhY2sgcmF0ZSBtZW51XG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgTWVudSBvYmplY3QgcG9wdWxhdGVkIHdpdGgge0BsaW5rIFBsYXliYWNrUmF0ZU1lbnVJdGVtfXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyKCkpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgaWYgKHJhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gcmF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWVudS5hZGRDaGlsZChuZXcgUGxheWJhY2tSYXRlTWVudUl0ZW0odGhpcy5wbGF5ZXIoKSwgeyByYXRlOiByYXRlc1tpXSArICd4JyB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgIC8vIEN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51QnV0dG9uYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIHNlbGVjdCBuZXh0IHJhdGUgb3B0aW9uXG4gICAgdmFyIGN1cnJlbnRSYXRlID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKTtcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcblxuICAgIC8vIHRoaXMgd2lsbCBzZWxlY3QgZmlyc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICB2YXIgbmV3UmF0ZSA9IHJhdGVzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcbiAgICAgICAgbmV3UmF0ZSA9IHJhdGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUobmV3UmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBBbGwgcG9zc2libGUgcGxheWJhY2sgcmF0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVzID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5wbGF5YmFja1JhdGVzIHx8IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGxheWJhY2tSYXRlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgcGxheWJhY2sgcmF0ZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSB0ZWNoXG4gICAqIGFuZCBhbiBhcnJheSBvZiBwbGF5YmFjayByYXRlcyBleGlzdHNcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGNoYW5naW5nIHBsYXliYWNrIHJhdGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUucGxheWJhY2tSYXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkubGVuZ3RoID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSBwbGF5YmFjayByYXRlIGNvbnRyb2xzIHdoZW4gdGhleSdyZSBubyBwbGF5YmFjayByYXRlIG9wdGlvbnMgdG8gc2VsZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGJ1dHRvbiBsYWJlbCB3aGVuIHJhdGUgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbChldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLmxhYmVsRWxfLmlubmVySFRNTCA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgKyAneCc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51QnV0dG9uO1xufShNZW51QnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBGdWxsc2NyZWVuVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheWJhY2sgUmF0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUJ1dHRvbicsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHNwYWNlci5qc1xuICovXG4vKipcbiAqIEp1c3QgYW4gZW1wdHkgc3BhY2VyIGVsZW1lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcHBlbmQgcG9pbnQgZm9yIHBsdWdpbnMsIGV0Yy5cbiAqIEFsc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFNwYWNlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFNwYWNlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3BhY2VyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYWNlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuICBTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXNwYWNlciAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTcGFjZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3BhY2VyJywgU3BhY2VyKTtcblxuLyoqXG4gKiBAZmlsZSBjdXN0b20tY29udHJvbC1zcGFjZXIuanNcbiAqL1xuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBleHRlbmRzIFNwYWNlclxuICovXG5cbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gZnVuY3Rpb24gKF9TcGFjZXIpIHtcbiAgaW5oZXJpdHMoQ3VzdG9tQ29udHJvbFNwYWNlciwgX1NwYWNlcik7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tQ29udHJvbFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3BhY2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAnICsgX1NwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX1NwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG5cbiAgICAvLyBOby1mbGV4L3RhYmxlLWNlbGwgbW9kZSByZXF1aXJlcyB0aGVyZSBiZSBzb21lIGNvbnRlbnRcbiAgICAvLyBpbiB0aGUgY2VsbCB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2Ugb2YgdGhlIHRhYmxlLlxuICAgIGVsLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tQ29udHJvbFNwYWNlcjtcbn0oU3BhY2VyKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXN0b21Db250cm9sU3BhY2VyJywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY29udHJvbC1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENvbnRyb2xCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWJhcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSwge1xuICAgICAgLy8gVGhlIGNvbnRyb2wgYmFyIGlzIGEgZ3JvdXAsIGJ1dCB3ZSBkb24ndCBhcmlhLWxhYmVsIGl0IHRvIGF2b2lkXG4gICAgICAvLyAgb3Zlci1hbm5vdW5jaW5nIGJ5IEpBV1NcbiAgICAgIHJvbGU6ICdncm91cCdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udHJvbEJhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb250cm9sQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3BsYXlUb2dnbGUnLCAndm9sdW1lUGFuZWwnLCAnY3VycmVudFRpbWVEaXNwbGF5JywgJ3RpbWVEaXZpZGVyJywgJ2R1cmF0aW9uRGlzcGxheScsICdwcm9ncmVzc0NvbnRyb2wnLCAnbGl2ZURpc3BsYXknLCAncmVtYWluaW5nVGltZURpc3BsYXknLCAnY3VzdG9tQ29udHJvbFNwYWNlcicsICdwbGF5YmFja1JhdGVNZW51QnV0dG9uJywgJ2NoYXB0ZXJzQnV0dG9uJywgJ2Rlc2NyaXB0aW9uc0J1dHRvbicsICdzdWJzQ2Fwc0J1dHRvbicsICdhdWRpb1RyYWNrQnV0dG9uJywgJ2Z1bGxzY3JlZW5Ub2dnbGUnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5cbi8qKlxuICogQGZpbGUgZXJyb3ItZGlzcGxheS5qc1xuICovXG4vKipcbiAqIEEgZGlzcGxheSB0aGF0IGluZGljYXRlcyBhbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlkZW9cbiAqIGlzIHVucGxheWFibGUuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Nb2RhbERpYWxvZy5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZXJyb3InLCBfdGhpcy5vcGVuKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1lcnJvci1kaXNwbGF5ICcgKyBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxpemVkIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGBQbGF5ZXJgcyBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYHMgZXJyb3IgbWVzc2FnZSBsb2NhbGl6ZWQgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XG59KE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbiBgRXJyb3JEaXNwbGF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyhNb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18sIHtcbiAgcGF1c2VPbk9wZW46IGZhbHNlLFxuICBmaWxsQWx3YXlzOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IGZhbHNlLFxuICB1bmNsb3NlYWJsZTogdHJ1ZVxufSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cbnZhciBMT0NBTF9TVE9SQUdFX0tFWSA9ICd2anMtdGV4dC10cmFjay1zZXR0aW5ncyc7XG5cbnZhciBDT0xPUl9CTEFDSyA9IFsnIzAwMCcsICdCbGFjayddO1xudmFyIENPTE9SX0JMVUUgPSBbJyMwMEYnLCAnQmx1ZSddO1xudmFyIENPTE9SX0NZQU4gPSBbJyMwRkYnLCAnQ3lhbiddO1xudmFyIENPTE9SX0dSRUVOID0gWycjMEYwJywgJ0dyZWVuJ107XG52YXIgQ09MT1JfTUFHRU5UQSA9IFsnI0YwRicsICdNYWdlbnRhJ107XG52YXIgQ09MT1JfUkVEID0gWycjRjAwJywgJ1JlZCddO1xudmFyIENPTE9SX1dISVRFID0gWycjRkZGJywgJ1doaXRlJ107XG52YXIgQ09MT1JfWUVMTE9XID0gWycjRkYwJywgJ1llbGxvdyddO1xuXG52YXIgT1BBQ0lUWV9PUEFRVUUgPSBbJzEnLCAnT3BhcXVlJ107XG52YXIgT1BBQ0lUWV9TRU1JID0gWycwLjUnLCAnU2VtaS1UcmFuc3BhcmVudCddO1xudmFyIE9QQUNJVFlfVFJBTlMgPSBbJzAnLCAnVHJhbnNwYXJlbnQnXTtcblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZhcmlvdXMgPHNlbGVjdD4gZWxlbWVudHMgaW4gdGhlIERPTSBvZiB0aGlzIGNvbXBvbmVudC5cbi8vXG4vLyBQb3NzaWJsZSBrZXlzIGluY2x1ZGU6XG4vL1xuLy8gYGRlZmF1bHRgOlxuLy8gICBUaGUgZGVmYXVsdCBvcHRpb24gaW5kZXguIE9ubHkgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaWYgbm90IHplcm8uXG4vLyBgcGFyc2VyYDpcbi8vICAgQSBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIHBhcnNlIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3RlZCBvcHRpb24gaW5cbi8vICAgYSBjdXN0b21pemVkIHdheS5cbi8vIGBzZWxlY3RvcmA6XG4vLyAgIFRoZSBzZWxlY3RvciB1c2VkIHRvIGZpbmQgdGhlIGFzc29jaWF0ZWQgPHNlbGVjdD4gZWxlbWVudC5cbnZhciBzZWxlY3RDb25maWdzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX0JMQUNLLCBDT0xPUl9XSElURSwgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGJhY2tncm91bmRPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUksIE9QQUNJVFlfVFJBTlNdXG4gIH0sXG5cbiAgY29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX1dISVRFLCBDT0xPUl9CTEFDSywgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGVkZ2VTdHlsZToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1lZGdlLXN0eWxlID4gc2VsZWN0JyxcbiAgICBpZDogJyVzJyxcbiAgICBsYWJlbDogJ1RleHQgRWRnZSBTdHlsZScsXG4gICAgb3B0aW9uczogW1snbm9uZScsICdOb25lJ10sIFsncmFpc2VkJywgJ1JhaXNlZCddLCBbJ2RlcHJlc3NlZCcsICdEZXByZXNzZWQnXSwgWyd1bmlmb3JtJywgJ1VuaWZvcm0nXSwgWydkcm9wc2hhZG93JywgJ0Ryb3BzaGFkb3cnXV1cbiAgfSxcblxuICBmb250RmFtaWx5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtZmFtaWx5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtZmFtaWx5LSVzJyxcbiAgICBsYWJlbDogJ0ZvbnQgRmFtaWx5JyxcbiAgICBvcHRpb25zOiBbWydwcm9wb3J0aW9uYWxTYW5zU2VyaWYnLCAnUHJvcG9ydGlvbmFsIFNhbnMtU2VyaWYnXSwgWydtb25vc3BhY2VTYW5zU2VyaWYnLCAnTW9ub3NwYWNlIFNhbnMtU2VyaWYnXSwgWydwcm9wb3J0aW9uYWxTZXJpZicsICdQcm9wb3J0aW9uYWwgU2VyaWYnXSwgWydtb25vc3BhY2VTZXJpZicsICdNb25vc3BhY2UgU2VyaWYnXSwgWydjYXN1YWwnLCAnQ2FzdWFsJ10sIFsnc2NyaXB0JywgJ1NjcmlwdCddLCBbJ3NtYWxsLWNhcHMnLCAnU21hbGwgQ2FwcyddXVxuICB9LFxuXG4gIGZvbnRQZXJjZW50OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtcGVyY2VudCA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb250LXNpemUtJXMnLFxuICAgIGxhYmVsOiAnRm9udCBTaXplJyxcbiAgICBvcHRpb25zOiBbWycwLjUwJywgJzUwJSddLCBbJzAuNzUnLCAnNzUlJ10sIFsnMS4wMCcsICcxMDAlJ10sIFsnMS4yNScsICcxMjUlJ10sIFsnMS41MCcsICcxNTAlJ10sIFsnMS43NScsICcxNzUlJ10sIFsnMi4wMCcsICcyMDAlJ10sIFsnMy4wMCcsICczMDAlJ10sIFsnNC4wMCcsICc0MDAlJ11dLFxuICAgICdkZWZhdWx0JzogMixcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gJzEuMDAnID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtb3BhY2l0eS0lcycsXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy13aW5kb3ctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJ1xuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLXdpbmRvdy1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXG4gIH1cbn07XG5cbnNlbGVjdENvbmZpZ3Mud2luZG93Q29sb3Iub3B0aW9ucyA9IHNlbGVjdENvbmZpZ3MuYmFja2dyb3VuZENvbG9yLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgdmFsdWUgb2YgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgVGhlIHZhbHVlIHRvIGdldFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxuICogICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgZXhpc3RzXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJub25lXCIuXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHBhcnNlcikge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xuICB2YXIgdmFsdWUgPSBlbC5vcHRpb25zW2VsLm9wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBsb29rIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgIHRoZSBwcm9wZXJ0eSB0byBsb29rIG9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZSBiZWZvcmUgY29tcGFyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIFRleHQgVHJhY2tzIHNldHRpbmdzLlxuICpcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXG4gKi9cblxudmFyIFRleHRUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhUZXh0VHJhY2tTZXR0aW5ncywgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrU2V0dGluZ3MocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrU2V0dGluZ3MpO1xuXG4gICAgb3B0aW9ucy50ZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVEaXNwbGF5ID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSk7XG5cbiAgICAvLyBmaWxsIHRoZSBtb2RhbCBhbmQgcHJldGVuZCB3ZSBoYXZlIG9wZW5lZCBpdFxuICAgIF90aGlzLmZpbGwoKTtcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLmVuZERpYWxvZyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogX3RoaXMubG9jYWxpemUoJ0VuZCBvZiBkaWFsb2cgd2luZG93LicpXG4gICAgfSk7XG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xuXG4gICAgX3RoaXMuc2V0RGVmYXVsdHMoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xuICAgIH1cblxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgX3RoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICBfdGhpcy5vbihfdGhpcy4kKGNvbmZpZy5zZWxlY3RvciksICdjaGFuZ2UnLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcbiAgICB9KTtcblxuICAgIGlmIChfdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5lbmREaWFsb2cgPSBudWxsO1xuXG4gICAgX01vZGFsRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIDxzZWxlY3Q+IGVsZW1lbnQgd2l0aCBjb25maWd1cmVkIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogICAgICAgIENvbmZpZ3VyYXRpb24ga2V5IHRvIHVzZSBkdXJpbmcgY3JlYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxTZWxlY3RfID0gZnVuY3Rpb24gY3JlYXRlRWxTZWxlY3RfKGtleSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGxlZ2VuZElkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2xhYmVsJztcblxuICAgIHZhciBjb25maWcgPSBzZWxlY3RDb25maWdzW2tleV07XG4gICAgdmFyIGlkID0gY29uZmlnLmlkLnJlcGxhY2UoJyVzJywgdGhpcy5pZF8pO1xuXG4gICAgcmV0dXJuIFsnPCcgKyB0eXBlICsgJyBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cIicgKyAodHlwZSA9PT0gJ2xhYmVsJyA/ICd2anMtbGFiZWwnIDogJycpICsgJ1wiPicsIHRoaXMubG9jYWxpemUoY29uZmlnLmxhYmVsKSwgJzwvJyArIHR5cGUgKyAnPicsICc8c2VsZWN0IGFyaWEtbGFiZWxsZWRieT1cIicgKyAobGVnZW5kSWQgIT09ICcnID8gbGVnZW5kSWQgKyAnICcgOiAnJykgKyBpZCArICdcIj4nXS5jb25jYXQoY29uZmlnLm9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgb3B0aW9uSWQgPSBpZCArICctJyArIG9bMV07XG5cbiAgICAgIHJldHVybiBbJzxvcHRpb24gaWQ9XCInICsgb3B0aW9uSWQgKyAnXCIgdmFsdWU9XCInICsgb1swXSArICdcIiAnLCAnYXJpYS1sYWJlbGxlZGJ5PVwiJyArIChsZWdlbmRJZCAhPT0gJycgPyBsZWdlbmRJZCArICcgJyA6ICcnKSArIGlkICsgJyAnICsgb3B0aW9uSWQgKyAnXCI+JywgX3RoaXMyLmxvY2FsaXplKG9bMV0pLCAnPC9vcHRpb24+J10uam9pbignJyk7XG4gICAgfSkpLmNvbmNhdCgnPC9zZWxlY3Q+Jykuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb3JlZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxGZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtdGV4dC1sZWdlbmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnVGV4dCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2NvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtdGV4dC1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3RleHRPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYmFja2dyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxCZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQmdDb2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLWJhY2tncm91bmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWJnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnQmFja2dyb3VuZCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB3aW5kb3cgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsV2luQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxXaW5Db2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLXdpbmRvdy0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtd2luZG93LWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnV2luZG93JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0Xygnd2luZG93Q29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy13aW5kb3ctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29sb3IgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29sb3JzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29sb3JzXygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb2xvcnMnLFxuICAgICAgaW5uZXJIVE1MOiBbdGhpcy5jcmVhdGVFbEZnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxCZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsV2luQ29sb3JfKCldLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGb250XyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRm9udF8oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtZm9udFwiPicsXG4gICAgICBpbm5lckhUTUw6IFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdmb250UGVyY2VudCcsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZWRnZS1zdHlsZSB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdlZGdlU3R5bGUnLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nLCAnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRGYW1pbHknLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29udHJvbHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbnRyb2xzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29udHJvbHNfKCkge1xuICAgIHZhciBkZWZhdWx0c0Rlc2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6ZSgncmVzdG9yZSBhbGwgc2V0dGluZ3MgdG8gdGhlIGRlZmF1bHQgdmFsdWVzJyk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb250cm9scycsXG4gICAgICBpbm5lckhUTUw6IFsnPGJ1dHRvbiBjbGFzcz1cInZqcy1kZWZhdWx0LWJ1dHRvblwiIHRpdGxlPVwiJyArIGRlZmF1bHRzRGVzY3JpcHRpb24gKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnUmVzZXQnKSwgJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICc8L3NwYW4+JywgJzwvYnV0dG9uPicsICc8YnV0dG9uIGNsYXNzPVwidmpzLWRvbmUtYnV0dG9uXCI+JyArIHRoaXMubG9jYWxpemUoJ0RvbmUnKSArICc8L2J1dHRvbj4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICByZXR1cm4gW3RoaXMuY3JlYXRlRWxDb2xvcnNfKCksIHRoaXMuY3JlYXRlRWxGb250XygpLCB0aGlzLmNyZWF0ZUVsQ29udHJvbHNfKCldO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdDYXB0aW9uIFNldHRpbmdzIERpYWxvZycpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gX01vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcykgKyAnIHZqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdGV4dCB0cmFjayBzZXR0aW5ncyAob3IgbnVsbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoX3RoaXMzLiQoY29uZmlnLnNlbGVjdG9yKSwgY29uZmlnLnBhcnNlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICAgIHNldFNlbGVjdGVkT3B0aW9uKF90aGlzNC4kKGNvbmZpZy5zZWxlY3RvciksIHZhbHVlc1trZXldLCBjb25maWcucGFyc2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbGwgYDxzZWxlY3Q+YCBlbGVtZW50cyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGVhY2goc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XG5cbiAgICAgIF90aGlzNS4kKGNvbmZpZy5zZWxlY3Rvcikuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5yZXN0b3JlU2V0dGluZ3MgPSBmdW5jdGlvbiByZXN0b3JlU2V0dGluZ3MoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRleHQgdHJhY2sgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnNhdmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRpc3BsYXkgb2YgdGV4dCB0cmFjayBzZXR0aW5nc1xuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHREaXNwbGF5ID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCd0ZXh0VHJhY2tEaXNwbGF5Jyk7XG5cbiAgICBpZiAodHREaXNwbGF5KSB7XG4gICAgICB0dERpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBjYXB0aW9ucyBidXR0b25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY29uZGl0aW9uYWxCbHVyXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmNvbnRyb2xCYXI7XG4gICAgdmFyIHN1YnNDYXBzQnRuID0gY2IgJiYgY2Iuc3Vic0NhcHNCdXR0b247XG4gICAgdmFyIGNjQnRuID0gY2IgJiYgY2IuY2FwdGlvbnNCdXR0b247XG5cbiAgICBpZiAoc3Vic0NhcHNCdG4pIHtcbiAgICAgIHN1YnNDYXBzQnRuLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChjY0J0bikge1xuICAgICAgY2NCdG4uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja1NldHRpbmdzO1xufShNb2RhbERpYWxvZyk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrU2V0dGluZ3MnLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMiA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSwgWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sNS5qc1xuICovXG4vKipcbiAqIEhUTUw1IE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBIVE1MNSBNZWRpYSBBUElcbiAqXG4gKiBAbWl4ZXMgVGVjaH5Tb3VjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgSHRtbDUgPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbDUob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAoX3RoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgb3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSB7XG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGFuZGxlTGF0ZUluaXRfKF90aGlzLmVsXyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgdmFyIG5vZGVzID0gX3RoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XG4gICAgICAgICAgICAgIGNyb3Nzb3JpZ2luVHJhY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xuICAgIGlmIChfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgJiYgY3Jvc3NvcmlnaW5UcmFja3MpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIC8vIHByZXZlbnQgaU9TIFNhZmFyaSBmcm9tIGRpc2FibGluZyBtZXRhZGF0YSB0ZXh0IHRyYWNrcyBkdXJpbmcgbmF0aXZlIHBsYXliYWNrXG4gICAgX3RoaXMucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSB1c2VkXG4gICAgLy8gT3VyIGdvYWwgc2hvdWxkIGJlIHRvIGdldCB0aGUgY3VzdG9tIGNvbnRyb2xzIG9uIG1vYmlsZSBzb2xpZCBldmVyeXdoZXJlXG4gICAgLy8gc28gd2UgY2FuIHJlbW92ZSB0aGlzIGFsbCB0b2dldGhlci4gUmlnaHQgbm93IHRoaXMgd2lsbCBibG9jayBjdXN0b21cbiAgICAvLyBjb250cm9scyBvbiB0b3VjaCBlbmFibGVkIGxhcHRvcHMgbGlrZSB0aGUgQ2hyb21lIFBpeGVsXG4gICAgaWYgKChUT1VDSF9FTkFCTEVEIHx8IElTX0lQSE9ORSB8fCBJU19OQVRJVkVfQU5EUk9JRCkgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5zZXRDb250cm9scyh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBvbiBpT1MsIHdlIHdhbnQgdG8gcHJveHkgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYFxuICAgIC8vIGludG8gYSBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRcbiAgICBfdGhpcy5wcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCk7XG5cbiAgICBfdGhpcy50cmlnZ2VyUmVhZHkoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSBvZiBgSFRNTDVgIG1lZGlhIGVsZW1lbnQgYW5kIHJlbW92ZSBhbGwgdHJhY2tzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMuZWxfKTtcbiAgICB0aGlzLm9wdGlvbnNfID0gbnVsbDtcblxuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcbiAgICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIGEgY2FwdGlvbnMgdHJhY2sgaXMgZW5hYmxlZCBpbiB0aGUgaU9TIFNhZmFyaSBuYXRpdmUgcGxheWVyLCBhbGwgb3RoZXJcbiAgICogdHJhY2tzIGFyZSBkaXNhYmxlZCAoaW5jbHVkaW5nIG1ldGFkYXRhIHRyYWNrcyksIHdoaWNoIG51bGxzIGFsbCBvZiB0aGVpclxuICAgKiBhc3NvY2lhdGVkIGN1ZSBwb2ludHMuIFRoaXMgd2lsbCByZXN0b3JlIG1ldGFkYXRhIHRyYWNrcyB0byB0aGVpciBwcmUtZnVsbHNjcmVlblxuICAgKiBzdGF0ZSBpbiB0aG9zZSBjYXNlcyBzbyB0aGF0IGN1ZSBwb2ludHMgYXJlIG5vdCBuZWVkbGVzc2x5IGxvc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc3RvcmVNZXRhZGF0YVRyYWNrc0luSU9TTmF0aXZlUGxheWVyXyA9IGZ1bmN0aW9uIHJlc3RvcmVNZXRhZGF0YVRyYWNrc0luSU9TTmF0aXZlUGxheWVyXygpIHtcbiAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xuICAgIHZhciBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZSA9IHZvaWQgMDtcblxuICAgIC8vIGNhcHR1cmVzIGEgc25hcHNob3Qgb2YgZXZlcnkgbWV0YWRhdGEgdHJhY2sncyBjdXJyZW50IHN0YXRlXG4gICAgdmFyIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QgPSBmdW5jdGlvbiB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KCkge1xuICAgICAgbWV0YWRhdGFUcmFja3NQcmVGdWxsc2NyZWVuU3RhdGUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRleHRUcmFja3NbaV07XG5cbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgICBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAgIHN0b3JlZE1vZGU6IHRyYWNrLm1vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzbmFwc2hvdCBlYWNoIG1ldGFkYXRhIHRyYWNrJ3MgaW5pdGlhbCBzdGF0ZSwgYW5kIHVwZGF0ZSB0aGUgc25hcHNob3RcbiAgICAvLyBlYWNoIHRpbWUgdGhlcmUgaXMgYSB0cmFjayAnY2hhbmdlJyBldmVudFxuICAgIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKTtcbiAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlc3RvcmVUcmFja01vZGUgPSBmdW5jdGlvbiByZXN0b3JlVHJhY2tNb2RlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RvcmVkVHJhY2sgPSBtZXRhZGF0YVRyYWNrc1ByZUZ1bGxzY3JlZW5TdGF0ZVtpXTtcblxuICAgICAgICBpZiAoc3RvcmVkVHJhY2sudHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJyAmJiBzdG9yZWRUcmFjay50cmFjay5tb2RlICE9PSBzdG9yZWRUcmFjay5zdG9yZWRNb2RlKSB7XG4gICAgICAgICAgc3RvcmVkVHJhY2sudHJhY2subW9kZSA9IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHdlIG9ubHkgd2FudCB0aGlzIGhhbmRsZXIgdG8gYmUgZXhlY3V0ZWQgb24gdGhlIGZpcnN0ICdjaGFuZ2UnIGV2ZW50XG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH07XG5cbiAgICAvLyB3aGVuIHdlIGVudGVyIGZ1bGxzY3JlZW4gcGxheWJhY2ssIHN0b3AgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFuZFxuICAgIC8vIHJlc3RvcmUgYWxsIHRyYWNrIG1vZGVzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuIHN0YXRlXG4gICAgdGhpcy5vbignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBiZWZvcmUgYWRkaW5nIGl0IGp1c3QgaW4gY2FzZSBpdCB3YXNuJ3QgcHJldmlvdXNseSByZW1vdmVkXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByZXN0b3JlVHJhY2tNb2RlKTtcbiAgICB9KTtcblxuICAgIC8vIHN0YXJ0IHVwZGF0aW5nIHRoZSBzbmFwc2hvdCBhZ2FpbiBhZnRlciBsZWF2aW5nIGZ1bGxzY3JlZW5cbiAgICB0aGlzLm9uKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBiZWZvcmUgYWRkaW5nIGl0IGp1c3QgaW4gY2FzZSBpdCB3YXNuJ3QgcHJldmlvdXNseSByZW1vdmVkXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QpO1xuICAgICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSByZXN0b3JlVHJhY2tNb2RlIGhhbmRsZXIgaW4gY2FzZSBpdCB3YXNuJ3QgdHJpZ2dlcmVkIGR1cmluZyBmdWxsc2NyZWVuIHBsYXliYWNrXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhbGwgbmF0aXZlIHRyYWNrIGxpc3QgZXZlbnRzIHRvIG91ciB0cmFjayBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZ1xuICAgKiBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlOYXRpdmVUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciBlbFRyYWNrcyA9IF90aGlzMi5lbCgpW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgdmFyIHRlY2hUcmFja3MgPSBfdGhpczJbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgaWYgKCFfdGhpczJbJ2ZlYXR1cmVzTmF0aXZlJyArIHByb3BzLmNhcGl0YWxOYW1lICsgJ1RyYWNrcyddIHx8ICFlbFRyYWNrcyB8fCAhZWxUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcbiAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgdGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcbiAgICAgICAgICAgIHNyY0VsZW1lbnQ6IHRlY2hUcmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkdHJhY2s6IGZ1bmN0aW9uIGFkZHRyYWNrKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmV0cmFjazogZnVuY3Rpb24gcmVtb3ZldHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVtb3ZlT2xkVHJhY2tzID0gZnVuY3Rpb24gcmVtb3ZlT2xkVHJhY2tzKCkge1xuICAgICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWNoVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZWxUcmFja3Nbal0gPT09IHRlY2hUcmFja3NbaV0pIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFja3MucHVzaCh0ZWNoVHJhY2tzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVtb3ZlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2socmVtb3ZlVHJhY2tzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICBfdGhpczIub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlbFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgKG5hdGl2ZSkgdHJhY2tzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgIF90aGlzMi5vbignbG9hZHN0YXJ0JywgcmVtb3ZlT2xkVHJhY2tzKTtcbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub2ZmKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEh0bWw1YCBUZWNoJ3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICAvLyBJZiB3ZSBpbmdlc3RlZCB0aGUgcGxheWVyIGRpdiwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8ICEodGhpcy5vcHRpb25zXy5wbGF5ZXJFbEluZ2VzdCB8fCB0aGlzLm1vdmluZ01lZGlhRWxlbWVudEluRE9NKSkge1xuXG4gICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdGFnIGlzIHN0aWxsIHRoZXJlLCBjbG9uZSBhbmQgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudChlbCk7XG4gICAgICAgIGVsID0gY2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICB2YXIgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIGdldEF0dHJpYnV0ZXModGhpcy5vcHRpb25zXy50YWcpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlT3B0aW9ucyh7fSwgdGFnQXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKCFUT1VDSF9FTkFCTEVEIHx8IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhlbCwgYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXG4gICAgICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsYXllcklkID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJJZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ucHJlbG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShlbCwgJ3ByZWxvYWQnLCB0aGlzLm9wdGlvbnNfLnByZWxvYWQpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzcGVjaWZpYyB0YWcgc2V0dGluZ3MsIGluIGNhc2UgdGhleSB3ZXJlIG92ZXJyaWRkZW5cbiAgICAvLyBgYXV0b3BsYXlgIGhhcyB0byBiZSAqbGFzdCogc28gdGhhdCBgbXV0ZWRgIGFuZCBgcGxheXNpbmxpbmVgIGFyZSBwcmVzZW50XG4gICAgLy8gd2hlbiBpT1MvU2FmYXJpIG9yIG90aGVyIGJyb3dzZXJzIGF0dGVtcHQgdG8gYXV0b3BsYXkuXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2xvb3AnLCAnbXV0ZWQnLCAncGxheXNpbmxpbmUnLCAnYXV0b3BsYXknXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3NBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBzZXR0aW5nc0F0dHJzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb25zX1thdHRyXTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKGVsLCBhdHRyLCBhdHRyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsW2F0dHJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHRoZSBsb2Fkc3RhcnQgZXZlbnQgaGFzIGFscmVhZHkgZmlyZWQsIGJlZm9yZSB2aWRlb2pzIHdhc1xuICAgKiByZWFkeS4gVHdvIGtub3duIGV4YW1wbGVzIG9mIHdoZW4gdGhpcyBjYW4gaGFwcGVuIGFyZTpcbiAgICogMS4gSWYgd2UncmUgbG9hZGluZyB0aGUgcGxheWJhY2sgb2JqZWN0IGFmdGVyIGl0IGhhcyBzdGFydGVkIGxvYWRpbmdcbiAgICogMi4gVGhlIG1lZGlhIGlzIGFscmVhZHkgcGxheWluZyB0aGUgKG9mdGVuIHdpdGggYXV0b3BsYXkgb24pIHRoZW5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGZpcmUgYW5vdGhlciBsb2Fkc3RhcnQgc28gdGhhdCB2aWRlb2pzIGNhbiBjYXRjaHVwLlxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCNsb2Fkc3RhcnRcbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHJldHVybnMgbm90aGluZy5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGFuZGxlTGF0ZUluaXRfID0gZnVuY3Rpb24gaGFuZGxlTGF0ZUluaXRfKGVsKSB7XG4gICAgaWYgKGVsLm5ldHdvcmtTdGF0ZSA9PT0gMCB8fCBlbC5uZXR3b3JrU3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIFRoZSB2aWRlbyBlbGVtZW50IGhhc24ndCBzdGFydGVkIGxvYWRpbmcgdGhlIHNvdXJjZSB5ZXRcbiAgICAgIC8vIG9yIGRpZG4ndCBmaW5kIGEgc291cmNlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgIC8vIE5ldHdvcmtTdGF0ZSBpcyBzZXQgc3luY2hyb25vdXNseSBCVVQgbG9hZHN0YXJ0IGlzIGZpcmVkIGF0IHRoZVxuICAgICAgLy8gZW5kIG9mIHRoZSBjdXJyZW50IHN0YWNrLCB1c3VhbGx5IGJlZm9yZSBzZXRJbnRlcnZhbChmbiwgMCkuXG4gICAgICAvLyBTbyBhdCB0aGlzIHBvaW50IHdlIGtub3cgbG9hZHN0YXJ0IG1heSBoYXZlIGFscmVhZHkgZmlyZWQgb3IgaXNcbiAgICAgIC8vIGFib3V0IHRvIGZpcmUsIGFuZCBlaXRoZXIgd2F5IHRoZSBwbGF5ZXIgaGFzbid0IHNlZW4gaXQgeWV0LlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBmaXJlIGxvYWRzdGFydCBwcmVtYXR1cmVseSBoZXJlIGFuZCBjYXVzZSBhXG4gICAgICAvLyBkb3VibGUgbG9hZHN0YXJ0IHNvIHdlJ2xsIHdhaXQgYW5kIHNlZSBpZiBpdCBoYXBwZW5zIGJldHdlZW4gbm93XG4gICAgICAvLyBhbmQgdGhlIG5leHQgbG9vcCwgYW5kIGZpcmUgaXQgaWYgbm90LlxuICAgICAgLy8gSE9XRVZFUiwgd2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSBpdCBmaXJlcyBiZWZvcmUgbG9hZGVkbWV0YWRhdGFcbiAgICAgIC8vIHdoaWNoIGNvdWxkIGFsc28gaGFwcGVuIGJldHdlZW4gbm93IGFuZCB0aGUgbmV4dCBsb29wLCBzbyB3ZSdsbFxuICAgICAgLy8gd2F0Y2ggZm9yIHRoYXQgYWxzby5cbiAgICAgIHZhciBsb2Fkc3RhcnRGaXJlZCA9IGZhbHNlO1xuICAgICAgdmFyIHNldExvYWRzdGFydEZpcmVkID0gZnVuY3Rpb24gc2V0TG9hZHN0YXJ0RmlyZWQoKSB7XG4gICAgICAgIGxvYWRzdGFydEZpcmVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ2xvYWRzdGFydCcsIHNldExvYWRzdGFydEZpcmVkKTtcblxuICAgICAgdmFyIHRyaWdnZXJMb2Fkc3RhcnQgPSBmdW5jdGlvbiB0cmlnZ2VyTG9hZHN0YXJ0KCkge1xuICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbG9hZHN0YXJ0LiBNYWtlIHN1cmUgdGhlIHBsYXllclxuICAgICAgICAvLyBzZWVzIGxvYWRzdGFydCBiZWZvcmUgbG9hZGVkbWV0YWRhdGFcbiAgICAgICAgaWYgKCFsb2Fkc3RhcnRGaXJlZCkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMub24oJ2xvYWRlZG1ldGFkYXRhJywgdHJpZ2dlckxvYWRzdGFydCk7XG5cbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9mZignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuICAgICAgICB0aGlzLm9mZignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgLy8gV2UgZGlkIG1pc3MgdGhlIG9yaWdpbmFsIG5hdGl2ZSBsb2Fkc3RhcnQuIEZpcmUgaXQgbm93LlxuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRnJvbSBoZXJlIG9uIHdlIGtub3cgdGhhdCBsb2Fkc3RhcnQgYWxyZWFkeSBmaXJlZCBhbmQgd2UgbWlzc2VkIGl0LlxuICAgIC8vIFRoZSBvdGhlciByZWFkeVN0YXRlIGV2ZW50cyBhcmVuJ3QgYXMgbXVjaCBvZiBhIHByb2JsZW0gaWYgd2UgZG91YmxlXG4gICAgLy8gdGhlbSwgc28gbm90IGdvaW5nIHRvIGdvIHRvIGFzIG11Y2ggdHJvdWJsZSBhcyBsb2Fkc3RhcnQgdG8gcHJldmVudFxuICAgIC8vIHRoYXQgdW5sZXNzIHdlIGZpbmQgcmVhc29uIHRvLlxuICAgIHZhciBldmVudHNUb1RyaWdnZXIgPSBbJ2xvYWRzdGFydCddO1xuXG4gICAgLy8gbG9hZGVkbWV0YWRhdGE6IG5ld2x5IGVxdWFsIHRvIEhBVkVfTUVUQURBVEEgKDEpIG9yIGdyZWF0ZXJcbiAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnbG9hZGVkbWV0YWRhdGEnKTtcblxuICAgIC8vIGxvYWRlZGRhdGE6IG5ld2x5IGluY3JlYXNlZCB0byBIQVZFX0NVUlJFTlRfREFUQSAoMikgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDIpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRkYXRhJyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfRlVUVVJFX0RBVEEgKDMpIG9yIGdyZWF0ZXJcbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA+PSAzKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnY2FucGxheScpO1xuICAgIH1cblxuICAgIC8vIGNhbnBsYXl0aHJvdWdoOiBuZXdseSBlcXVhbCB0byBIQVZFX0VOT1VHSF9EQVRBICg0KVxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDQpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5dGhyb3VnaCcpO1xuICAgIH1cblxuICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gZ2l2ZSB0aGUgcGxheWVyIHRpbWUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHR5cGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBjdXJyZW50IHRpbWUgZm9yIHRoZSBgSFRNTDVgIHRlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzXG4gICAqICAgICAgICBTZXQgdGhlIGN1cnJlbnQgdGltZSBvZiB0aGUgbWVkaWEgdG8gdGhpcy5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZWxfLmN1cnJlbnRUaW1lID0gc2Vjb25kcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2ckMShlLCAnVmlkZW8gaXMgbm90IHJlYWR5LiAoVmlkZW8uanMpJyk7XG4gICAgICAvLyB0aGlzLndhcm5pbmcoVmlkZW9KUy53YXJuaW5ncy52aWRlb05vdFJlYWR5KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkdXJhdGlvbiBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgb3IgMCBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIEFuZHJvaWQgQ2hyb21lIHdpbGwgcmVwb3J0IGR1cmF0aW9uIGFzIEluZmluaXR5IGZvciBWT0QgSExTIHVudGlsIGFmdGVyXG4gICAgLy8gcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHdoaWNoIHRyaWdnZXJzIHRoZSBsaXZlIGRpc3BsYXkgZXJyb25lb3VzbHkuXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBwbGF5YmFjayBoYXMgbm90IHN0YXJ0ZWQgYW5kIHRyaWdnZXIgYSBkdXJhdGlvbnVwZGF0ZSBvbmNlXG4gICAgLy8gdGhlIGR1cmF0aW9uIGNhbiBiZSByZWxpYWJseSBrbm93bi5cbiAgICBpZiAodGhpcy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5ICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIHRoaXMuZWxfLmN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgZmlyc3QgYHRpbWV1cGRhdGVgIHdpdGggY3VycmVudFRpbWUgPiAwIC0gdGhlcmUgbWF5IGJlXG4gICAgICAvLyBzZXZlcmFsIHdpdGggMFxuICAgICAgdmFyIGNoZWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiBjaGVja1Byb2dyZXNzKCkge1xuICAgICAgICBpZiAoX3RoaXMzLmVsXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgICAgICAvLyBUcmlnZ2VyIGR1cmF0aW9uY2hhbmdlIGZvciBnZW51aW5lbHkgbGl2ZSB2aWRlb1xuICAgICAgICAgIGlmIChfdGhpczMuZWxfLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgX3RoaXMzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5vZmYoJ3RpbWV1cGRhdGUnLCBjaGVja1Byb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWxfLmR1cmF0aW9uIHx8IE5hTjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBoZWlndGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF8ub2Zmc2V0SGVpZ2h0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBpT1MgYHdlYmtpdGJlZ2luZnVsbHNjcmVlbmAgYW5kIGB3ZWJraXRlbmRmdWxsc2NyZWVuYCBpbnRvXG4gICAqIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGZpcmVzIGZ1bGxzY3JlZW5jaGFuZ2VcbiAgICogQGxpc3RlbnMgd2Via2l0ZW5kZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICogQGxpc3RlbnMgd2Via2l0YmVnaW5mdWxsc2NyZWVuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnByb3h5V2Via2l0RnVsbHNjcmVlbl8gPSBmdW5jdGlvbiBwcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKCEoJ3dlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuJyBpbiB0aGlzLmVsXykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW5kRm4gPSBmdW5jdGlvbiBlbmRGbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiBmYWxzZSB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGJlZ2luRm4gPSBmdW5jdGlvbiBiZWdpbkZuKCkge1xuICAgICAgaWYgKCd3ZWJraXRQcmVzZW50YXRpb25Nb2RlJyBpbiB0aGlzLmVsXyAmJiB0aGlzLmVsXy53ZWJraXRQcmVzZW50YXRpb25Nb2RlICE9PSAncGljdHVyZS1pbi1waWN0dXJlJykge1xuICAgICAgICB0aGlzLm9uZSgnd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB7IGlzRnVsbHNjcmVlbjogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC5vZmYoJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGJlZ2luRm4pO1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0ZW5kZnVsbHNjcmVlbicsIGVuZEZuKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgZnVsbHNjcmVlbiBpcyBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgcGxheWJhY2sgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZC5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIGZ1bGxzY3JlZW4gaXMgbm90IHN1cHBvcnRlZC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbF8ud2Via2l0RW50ZXJGdWxsU2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcblxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxuICAgICAgaWYgKC9BbmRyb2lkLy50ZXN0KHVzZXJBZ2VudCkgfHwgIS9DaHJvbWV8TWFjIE9TIFggMTAuNS8udGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGVudGVyIGZ1bGxzY3JlZW4uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmVudGVyRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGVudGVyRnVsbFNjcmVlbigpIHtcbiAgICB2YXIgdmlkZW8gPSB0aGlzLmVsXztcblxuICAgIGlmICh2aWRlby5wYXVzZWQgJiYgdmlkZW8ubmV0d29ya1N0YXRlIDw9IHZpZGVvLkhBVkVfTUVUQURBVEEpIHtcbiAgICAgIC8vIGF0dGVtcHQgdG8gcHJpbWUgdGhlIHZpZGVvIGVsZW1lbnQgZm9yIHByb2dyYW1tYXRpYyBhY2Nlc3NcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxuICAgICAgdGhpcy5lbF8ucGxheSgpO1xuXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cbiAgICAgIC8vIGNhbiBnZXQgaU9TIH42LjEgZGV2aWNlcyBpbnRvIGEgcGxheS9wYXVzZSBsb29wXG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlby53ZWJraXRFbnRlckZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGV4aXQgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZXhpdEZ1bGxTY3JlZW4gPSBmdW5jdGlvbiBleGl0RnVsbFNjcmVlbigpIHtcbiAgICB0aGlzLmVsXy53ZWJraXRFeGl0RnVsbFNjcmVlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgSHRtbDVgIFRlY2gncyBzb3VyY2Ugb2JqZWN0LlxuICAgKiA+IE5vdGU6IFBsZWFzZSB1c2Uge0BsaW5rIEh0bWw1I3NldFNvdXJjZX1cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHlvdSB3YW50IHRvIHNldCBvbiB0aGUgYEhUTUw1YCB0ZWNocyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHdoZW4gYSBzb3VyY2UgaXMgbm90IHBhc3NlZCBpbi5cbiAgICogICAgICAgICAtIHVuZGVmaW5lZCB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgU2luY2UgdmVyc2lvbiA1LlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zcmMgPSBmdW5jdGlvbiBzcmMoX3NyYykge1xuICAgIGlmIChfc3JjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsXy5zcmM7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyBzcmMgdGhyb3VnaCBgc3JjYCBpbnN0ZWFkIG9mIGBzZXRTcmNgIHdpbGwgYmUgZGVwcmVjYXRlZFxuICAgIHRoaXMuc2V0U3JjKF9zcmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCBieSByZW1vdmluZyBhbGwgc291cmNlcyBhbmQgdGhlbiBjYWxsaW5nXG4gICAqIHtAbGluayBIdG1sNS5yZXNldE1lZGlhRWxlbWVudH0uXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc291cmNlIG9uIHRoZSBgSFRNTDVgIFRlY2guIEZhbGxzIGJhY2sgdG8gcmV0dXJuaW5nIHRoZSBzb3VyY2UgZnJvbVxuICAgKiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdCBmcm9tIHRoZSBIVE1MNSB0ZWNoLiBXaXRoIGEgZmFsbGJhY2sgdG8gdGhlXG4gICAqICAgICAgICAgZWxlbWVudHMgc291cmNlLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jdXJyZW50U3JjID0gZnVuY3Rpb24gY3VycmVudFNyYygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uY3VycmVudFNyYztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZSBmb3IgdGhlIEhUTUw1IG1lZGlhIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgY29udHJvbHMgYXR0cmlidXRlIHRvXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNldENvbnRyb2xzID0gZnVuY3Rpb24gc2V0Q29udHJvbHModmFsKSB7XG4gICAgdGhpcy5lbF8uY29udHJvbHMgPSAhIXZhbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja31cbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBlaXRoZXIgbmF0aXZlIFRleHRUcmFjayBvciBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZGVwZW5kaW5nXG4gICAqIG9uIHRoZSB2YWx1ZSBvZiBgZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbnRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZF1cbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXS5cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV1cbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXG4gICAqICAgICAgICBEZWZhdWx0IHRoaXMgdHJhY2sgdG8gb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAgICogICAgICAgIFRoZSBpbnRlcm5hbCBpZCB0byBhc3NpZ24gdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cbiAgICogICAgICAgIEEgc291cmNlIHVybCBmb3IgdGhlIHRyYWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHJldHVybiBfVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICAgIGlmIChvcHRpb25zLmtpbmQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQua2luZCA9IG9wdGlvbnMua2luZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQubGFiZWwgPSBvcHRpb25zLmxhYmVsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjbGFuZyA9IG9wdGlvbnMubGFuZ3VhZ2UgfHwgb3B0aW9ucy5zcmNsYW5nO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZGVmYXVsdCddKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSBvcHRpb25zWydkZWZhdWx0J107XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3JjKSB7XG4gICAgICBodG1sVHJhY2tFbGVtZW50LnNyYyA9IG9wdGlvbnMuc3JjO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB2YWx1ZXMgZm9yXG4gICAqIGtpbmQsIGxhbmd1YWdlLCBsYWJlbCwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fSBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXG4gICAqIFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gX1RlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmVsKCkuYXBwZW5kQ2hpbGQoaHRtbFRyYWNrRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZW1vdGUgYFRleHRUcmFja2AgZnJvbSBgVGV4dFRyYWNrTGlzdGAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2Agb2JqZWN0IHRvIHJlbW92ZVxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcbiAgICBfVGVjaC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgdHJhY2spO1xuXG4gICAgaWYgKHRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy4kJCgndHJhY2snKTtcblxuICAgICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdHJhY2tzW2ldIHx8IHRyYWNrID09PSB0cmFja3NbaV0udHJhY2spIHtcbiAgICAgICAgICB0aGlzLmVsKCkucmVtb3ZlQ2hpbGQodHJhY2tzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgIH1cblxuICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQ7XG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS50b3RhbFZpZGVvRnJhbWVzID0gdGhpcy5lbCgpLndlYmtpdERlY29kZWRGcmFtZUNvdW50O1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmNyZWF0aW9uVGltZSA9IHdpbmRvdy5EYXRlLm5vdygpIC0gd2luZG93LnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZGVvUGxheWJhY2tRdWFsaXR5O1xuICB9O1xuXG4gIHJldHVybiBIdG1sNTtcbn0oVGVjaCk7XG5cbi8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmlmIChpc1JlYWwoKSkge1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IGZvciB0ZXN0aW5nIGJyb3dzZXIgSFRNTDUgbWVkaWEgY2FwYWJpbGl0aWVzXG4gICAqXG4gICAqIEB0eXBlIHtFbGVtZW50fVxuICAgKiBAY29uc3RhbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEh0bWw1LlRFU1RfVklEID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgdmFyIHRyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcblxuICB0cmFjay5raW5kID0gJ2NhcHRpb25zJztcbiAgdHJhY2suc3JjbGFuZyA9ICdlbic7XG4gIHRyYWNrLmxhYmVsID0gJ0VuZ2xpc2gnO1xuICBIdG1sNS5URVNUX1ZJRC5hcHBlbmRDaGlsZCh0cmFjayk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIEhUTUw1IG1lZGlhIGlzIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpZiBIVE1MNSBtZWRpYSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5IdG1sNS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU5IHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXG4gIHRyeSB7XG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gMC41O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IHNyY09ialxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xuICByZXR1cm4gSHRtbDUuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdm9sdW1lIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKiBWb2x1bWUgY2Fubm90IGJlIGNoYW5nZWQgaW4gYSBsb3Qgb2YgbW9iaWxlIGRldmljZXMuXG4gKiBTcGVjaWZpY2FsbHksIGl0IGNhbid0IGJlIGNoYW5nZWQgZnJvbSAxIG9uIGlPUy5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSB2b2x1bWUgLyAyICsgMC4xO1xuICAgIHJldHVybiB2b2x1bWUgIT09IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGxheWJhY2sgcmF0ZSBjYW4gYmUgY2hhbmdlZCBpbiB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBwbGF5YmFjayByYXRlIGNhbiBiZSBjb250cm9sbGVkXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFBsYXliYWNrIHJhdGUgQVBJIGlzIGltcGxlbWVudGVkIGluIEFuZHJvaWQgQ2hyb21lLCBidXQgZG9lc24ndCBkbyBhbnl0aGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMzE4MFxuICBpZiAoSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgQ0hST01FX1ZFUlNJT04gPCA1OCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJRSB3aWxsIGVycm9yIGlmIFdpbmRvd3MgTWVkaWEgUGxheWVyIG5vdCBpbnN0YWxsZWQgIzMzMTVcbiAgdHJ5IHtcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xuXG4gICAgSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlIC8gMiArIDAuMTtcbiAgICByZXR1cm4gcGxheWJhY2tSYXRlICE9PSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFRleHRUcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIElTX0FOWV9TQUZBUkk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC52aWRlb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYEF1ZGlvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbkh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC5hdWRpb1RyYWNrcyk7XG59O1xuXG4vKipcbiAqIEFuIGFycmF5IG9mIGV2ZW50cyBhdmFpbGFibGUgb24gdGhlIEh0bWw1IHRlY2guXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuSHRtbDUuRXZlbnRzID0gWydsb2Fkc3RhcnQnLCAnc3VzcGVuZCcsICdhYm9ydCcsICdlcnJvcicsICdlbXB0aWVkJywgJ3N0YWxsZWQnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkZGF0YScsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzZWVraW5nJywgJ3NlZWtlZCcsICdlbmRlZCcsICdkdXJhdGlvbmNoYW5nZScsICd0aW1ldXBkYXRlJywgJ3Byb2dyZXNzJywgJ3BsYXknLCAncGF1c2UnLCAncmF0ZWNoYW5nZScsICdyZXNpemUnLCAndm9sdW1lY2hhbmdlJ107XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sVm9sdW1lfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gSHRtbDUuY2FuQ29udHJvbFZvbHVtZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgY2hhbmdpbmcgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSBtZWRpYVxuICogcGxheXMuIEV4YW1wbGVzOlxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAyeCAodHdpY2UpIGFzIGZhc3RcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMC41eCAoaGFsZikgYXMgZmFzdFxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1BsYXliYWNrUmF0ZSA9IEh0bWw1LmNhbkNvbnRyb2xQbGF5YmFja1JhdGUoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgbWVkaWEgZWxlbWVudFxuICogbW92aW5nIGluIHRoZSBET00uIGlPUyBicmVha3MgaWYgeW91IG1vdmUgdGhlIG1lZGlhIGVsZW1lbnQsIHNvIHRoaXMgaXMgc2V0IHRoaXMgdG9cbiAqIGZhbHNlIHRoZXJlLiBFdmVyeXdoZXJlIGVsc2UgdGhpcyBzaG91bGQgYmUgdHJ1ZS5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5tb3ZpbmdNZWRpYUVsZW1lbnRJbkRPTSA9ICFJU19JT1M7XG5cbi8vIFRPRE86IFByZXZpb3VzIGNvbW1lbnQ6IE5vIGxvbmdlciBhcHBlYXJzIHRvIGJlIHVzZWQuIENhbiBwcm9iYWJseSBiZSByZW1vdmVkLlxuLy8gICAgICAgSXMgdGhpcyB0cnVlP1xuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBhdXRvbWF0aWMgbWVkaWEgcmVzaXplXG4gKiB3aGVuIGdvaW5nIGludG8gZnVsbHNjcmVlbi5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSB0cnVlO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBwcm9ncmVzcyBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgcHJvZ3Jlc3NgIGV2ZW50cyB3aWxsIGJlIHRyaWdncmVkIGluc3RlYWQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHRpbWV1cGRhdGUgZXZlbnQuXG4gKiBJZiB0aGlzIGlzIGZhbHNlLCBtYW51YWwgYHRpbWV1cGRhdGVgIGV2ZW50cyB3aWxsIGJlIHRyaWdncmVkIGluc3RlYWQuXG4gKlxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBUZXh0VHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3MoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFZpZGVvVHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZVZpZGVvVHJhY2tzfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVWaWRlb1RyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MoKTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYEF1ZGlvVHJhY2tgcy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzfVxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVBdWRpb1RyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MoKTtcblxuLy8gSFRNTDUgRmVhdHVyZSBkZXRlY3Rpb24gYW5kIERldmljZSBGaXhlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbnZhciBjYW5QbGF5VHlwZSA9IEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcbnZhciBtcGVndXJsUkUgPSAvXmFwcGxpY2F0aW9uXFwvKD86eC18dm5kXFwuYXBwbGVcXC4pbXBlZ3VybC9pO1xudmFyIG1wNFJFID0gL152aWRlb1xcL21wNC9pO1xuXG5IdG1sNS5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIEFuZHJvaWQgNC4wIGFuZCBhYm92ZSBjYW4gcGxheSBITFMgdG8gc29tZSBleHRlbnQgYnV0IGl0IHJlcG9ydHMgYmVpbmcgdW5hYmxlIHRvIGRvIHNvXG4gIGlmIChBTkRST0lEX1ZFUlNJT04gPj0gNC4wICYmICFJU19GSVJFRk9YKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcblxuICAgIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cbiAgfSBlbHNlIGlmIChJU19PTERfQU5EUk9JRCkge1xuICAgIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAodHlwZSAmJiBtcDRSRS50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnbWF5YmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XG4gICAgfTtcbiAgfVxufTtcblxuSHRtbDUudW5wYXRjaENhblBsYXlUeXBlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcblxuICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBjYW5QbGF5VHlwZTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBieSBkZWZhdWx0LCBwYXRjaCB0aGUgbWVkaWEgZWxlbWVudFxuSHRtbDUucGF0Y2hDYW5QbGF5VHlwZSgpO1xuXG5IdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXG4gIHdoaWxlIChlbC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS4gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IGNhdXNlcyBhIHdhcm5pbmdcbiAgLy8gaW4gZmlyZWZveFxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIC8vIGZvcmNlIHRoZSBtZWRpYSBlbGVtZW50IHRvIHVwZGF0ZSBpdHMgbG9hZGluZyBzdGF0ZSBieSBjYWxsaW5nIGxvYWQoKVxuICAvLyBob3dldmVyIElFIG9uIFdpbmRvd3MgN04gaGFzIGEgYnVnIHRoYXQgdGhyb3dzIGFuIGVycm9yIHNvIG5lZWQgYSB0cnkvY2F0Y2ggKCM3OTMpXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG59O1xuXG5IdG1sNS5yZXNldE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNvdXJjZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgdmFyIGkgPSBzb3VyY2VzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoc291cmNlc1tpXSk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuXG4gIC8vIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgZWwucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcblxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyB3cmFwcGluZyBpbiBhbiBpaWZlIHNvIGl0J3Mgbm90IGRlb3B0aW1pemVkICgjMTA2MCNkaXNjdXNzaW9uX3IxMDMyNDQ3MylcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWwubG9hZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzYXRpc2Z5IGxpbnRlclxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbi8qIE5hdGl2ZSBIVE1MNSBlbGVtZW50IHByb3BlcnR5IHdyYXBwaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4vLyBXcmFwIG5hdGl2ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2l0aCBnZXR0ZXJzIHRoYXQgY2hlY2sgYm90aCBwcm9wZXJ0eSBhbmQgYXR0cmlidXRlXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZDpcbi8vIG11dGVkLCBkZWZhdWx0TXV0ZWQsIGF1dG9wbGF5LCBjb250cm9scywgbG9vcCwgcGxheXNpbmxpbmVcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBtdXRlZGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB2b2x1bWUgZm9yIHRoZSBtZWRpYSBzaG91bGQgYmUgc2V0IHRvIHNpbGVudC4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2VcbiAqIHRoZSBgdm9sdW1lYCBhdHRyaWJ1dGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNtdXRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgaWdub3JlZCBhbmQgdGhlIGF1ZGlvIHNldCB0byBzaWxlbnQuXG4gKiAgICAgICAgIC0gRmFsc2UgaWYgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIHNob3VsZCBiZSB1c2VkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XG4gKi9cbidtdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcbiAqIG1lZGlhLiBgbXV0ZWRgIGFuZCBgZGVmYXVsdE11dGVkYCBjYW4gaGF2ZSBkaWZmZXJlbnQgdmFsdWVzLiB7QGxpbmsgSHRtbDUjbXV0ZWR9IGluZGljYXRlcyB0aGVcbiAqIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNkZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IG11dGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHN0YXJ0IG11dGVkXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0bXV0ZWR9XG4gKi9cbidkZWZhdWx0TXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2F1dG9wbGF5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGNvbnRyb2xzYCBpbmRpY2F0ZXNcbiAqIHdoZXRoZXIgdGhlIG5hdGl2ZSBtZWRpYSBjb250cm9scyBzaG91bGQgYmUgc2hvd24gb3IgaGlkZGVuLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY29udHJvbHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBjb250cm9sc2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgc2hvd2luZy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIGhpZGRlbi5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1jb250cm9sc31cbiAqL1xuJ2NvbnRyb2xzJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9vcFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXlzaW5saW5lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSB8fCB0aGlzLmVsXy5oYXNBdHRyaWJ1dGUocHJvcCk7XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdpdGggc2V0dGVycyB0aGF0IHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcbi8vIFRoZSBsaXN0IGlzIGFzIGZvbGxvd2VkOlxuLy8gc2V0TXV0ZWQsIHNldERlZmF1bHRNdXRlZCwgc2V0QXV0b3BsYXksIHNldExvb3AsIHNldFBsYXlzaW5saW5lXG4vLyBzZXRDb250cm9scyBpcyBzcGVjaWFsLWNhc2VkIGFib3ZlXG5bXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudCwgYnV0IHdpbGwgb25seSBlZmZlY3QgdGhlIG11dGVkIGxldmVsIG9uIGludGlhbCBwbGF5YmFjay4uXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRNdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0QXV0b3BsYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b3BsYXlcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGxvb3BgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcmV0dXJuIHRvIHRoZSBzdGFydCBvZiB0aGUgbWVkaWEgYW5kIGNvbnRpbnVlIHBsYXlpbmcgb25jZVxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0TG9vcFxuICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgbm90IGxvb3AgYmFjayB0byB0aGUgc3RhcnQgd2hlbiB0aGVcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtbG9vcH1cbiAqL1xuJ2xvb3AnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xuICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBsYXlzaW5saW5lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgbm90IHBsYXkgaW5saW5lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gKi9cbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlWydzZXQnICsgdG9UaXRsZUNhc2UocHJvcCldID0gZnVuY3Rpb24gKHYpIHtcbiAgICB0aGlzLmVsX1twcm9wXSA9IHY7XG5cbiAgICBpZiAodikge1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKHByb3AsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWRcbi8vIHBhdXNlZCwgY3VycmVudFRpbWUsIGJ1ZmZlcmVkLCB2b2x1bWUsIHBvc3RlciwgcHJlbG9hZCwgZXJyb3IsIHNlZWtpbmdcbi8vIHNlZWthYmxlLCBlbmRlZCwgcGxheWJhY2tSYXRlLCBkZWZhdWx0UGxheWJhY2tSYXRlLCBwbGF5ZWQsIG5ldHdvcmtTdGF0ZVxuLy8gcmVhZHlTdGF0ZSwgdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHRcbltcbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGF1c2VkYCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVkaWEgZWxlbWVudFxuICogaXMgY3VycmVudGx5IHBhdXNlZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2VkfVxuICovXG4ncGF1c2VkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGN1cnJlbnRUaW1lYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHNlY29uZCB0aGF0IHRoZSBtZWRpYSBpcyBhdCBpbiBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2N1cnJlbnRUaW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgY3VycmVudFRpbWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1jdXJyZW50dGltZX1cbiAqL1xuJ2N1cnJlbnRUaW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGJ1ZmZlcmVkYCBpcyBhIGBUaW1lUmFuZ2VgXG4gKiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0cyBvZiB0aGUgbWVkaWEgdGhhdCBhcmUgYWxyZWFkeSBkb3dubG9hZGVkIGFuZFxuICogYXZhaWxhYmxlIGZvciBwbGF5YmFjay5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2J1ZmZlcmVkXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgYnVmZmVyZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAqL1xuJ2J1ZmZlcmVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2b2x1bWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgcGxheWJhY2sgdm9sdW1lIG9mIGF1ZGlvIGZvciBhIG1lZGlhLiBgdm9sdW1lYCB3aWxsIGJlIGEgdmFsdWUgZnJvbSAwXG4gKiAoc2lsZW50KSB0byAxIChsb3VkZXN0IGFuZCBkZWZhdWx0KS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZvbHVtZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBiZXR3ZWVuIDAtMS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLWEtdm9sdW1lfVxuICovXG4ndm9sdW1lJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwb3N0ZXJgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdXJsIG9mIGFuIGltYWdlIGZpbGUgdGhhdCBjYW4vd2lsbCBiZSBzaG93biB3aGVuIG5vIG1lZGlhIGRhdGEgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcG9zdGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGEgdXJsIHRvIGFuXG4gKiAgICAgICAgIGltYWdlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLXZpZGVvLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHByZWxvYWRgIGluZGljYXRlc1xuICogd2hhdCBzaG91bGQgZG93bmxvYWQgYmVmb3JlIHRoZSBtZWRpYSBpcyBpbnRlcmFjdGVkIHdpdGguIEl0IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmdcbiAqIHZhbHVlczpcbiAqIC0gbm9uZTogbm90aGluZyBzaG91bGQgYmUgZG93bmxvYWRlZFxuICogLSBtZXRhZGF0YTogcG9zdGVyIGFuZCB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgbWVkaWEgbWF5IGJlIGRvd25sb2FkZWQgdG8gZ2V0XG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXG4gKiAtIGF1dG86IGFsbG93IHRoZSBtZWRpYSBhbmQgbWV0YWRhdGEgZm9yIHRoZSBtZWRpYSB0byBiZSBkb3dubG9hZGVkIGJlZm9yZVxuICogICAgaW50ZXJhY3Rpb25cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ByZWxvYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlICdub25lJywgJ21ldGFkYXRhJyxcbiAqICAgICAgICAgb3IgJ2F1dG8nLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XG4gKi9cbidwcmVsb2FkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBgZXJyb3JgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBlcnJvcmAgaW5kaWNhdGVzIGFueVxuICogTWVkaWFFcnJvciB0aGF0IG1heSBoYXZlIG9jY3VyZWQgZHVyaW5nIHBsYXliYWNrLiBJZiBlcnJvciByZXR1cm5zIG51bGwgdGhlcmUgaXMgbm9cbiAqIGN1cnJlbnQgZXJyb3IuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlcnJvclxuICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlIGBNZWRpYUVycm9yYCBpZiB0aGVyZVxuICogICAgICAgICBpcyBhIGN1cnJlbnQgZXJyb3IgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZXJyb3J9XG4gKi9cbidlcnJvcicsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2luZ2AgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHNlZWtpbmdgIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICogbWVkaWEgaXMgY3VycmVudGx5IHNlZWtpbmcgdG8gYSBuZXcgcG9zaXRpb24gb3Igbm90LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2Vla2luZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHNlZWtpbmcgdG8gYSBuZXcgcG9zaXRpb24uXG4gKiAgICAgICAgIC0gRmxhc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIG5vdCBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIGF0IHRoaXMgdGltZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWtpbmd9XG4gKi9cbidzZWVraW5nJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBzZWVrYWJsZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHNlZWthYmxlYCByZXR1cm5zIGFcbiAqIGBUaW1lUmFuZ2VgIG9iamVjdCBpbmRpY2F0aW5nIHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGN1cnJlbnRseSBiZSBgc2Vla2VkYCB0by5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWthYmxlXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgYFRpbWVSYW5nZWAgb2JqZWN0XG4gKiAgICAgICAgIGluZGljYXRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCBjYW4gYmUgc2Vla2VkIHRvLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc2Vla2FibGV9XG4gKi9cbidzZWVrYWJsZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBlbmRlZGAgaW5kaWNhdGVzIHdoZXRoZXJcbiAqIHRoZSBtZWRpYSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I2VuZGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIGVuZGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBoYXMgbm90IGVuZGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZW5kZWR9XG4gKi9cbidlbmRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZyBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgcGxheWluZyBiYWNrLiBUaGlzIHZhbHVlIHdpbGwgbm90IGluZGljYXRlIHRoZSBjdXJyZW50XG4gKiBgcGxheWJhY2tSYXRlYCBhZnRlciBwbGF5YmFjayBoYXMgc3RhcnRlZCwgdXNlIHtAbGluayBIdG1sNSNwbGF5YmFja1JhdGV9IGZvciB0aGF0LlxuICpcbiAqIEV4YW1wbGVzOlxuICogICAtIGlmIGRlZmF1bHRQbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIGRlZmF1bHRQbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5kZWZhdWx0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4nZGVmYXVsdFBsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWVkYCByZXR1cm5zIGEgYFRpbWVSYW5nZWBcbiAqIG9iamVjdCByZXByZXNlbnRpbmcgcG9pbnRzIGluIHRoZSBtZWRpYSB0aW1lbGluZSB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5ZWRcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgYFRpbWVSYW5nZWAgb2JqZWN0IGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIHJhbmdlcyBvZiB0aW1lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXllZH1cbiAqL1xuJ3BsYXllZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbmV0d29ya1N0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbmV0d29ya1N0YXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IG5ldHdvcmsgc3RhdGUuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gKiAtIDA6IE5FVFdPUktfRU1QVFlcbiAqIC0gMTogTkVXT1JLX0lETEVcbiAqIC0gMjogTkVUV09SS19MT0FESU5HXG4gKiAtIDM6IE5FVFdPUktfTk9fU09VUkNFXG4gKlxuICogQG1ldGhvZCBIdG1sNSNuZXR3b3JrU3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxuICogICAgICAgICBmcm9tIHRoZSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1uZXR3b3Jrc3RhdGV9XG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGByZWFkeVN0YXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZWRpYSBlbGVtZW50LiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlXG4gKiBmb2xsb3dpbmcgbGlzdDpcbiAqIC0gMDogSEFWRV9OT1RISU5HXG4gKiAtIDE6IEhBVkVfTUVUQURBVEFcbiAqIC0gMjogSEFWRV9DVVJSRU5UX0RBVEFcbiAqIC0gMzogSEFWRV9GVVRVUkVfREFUQVxuICogLSA0OiBIQVZFX0VOT1VHSF9EQVRBXG4gKlxuICogQG1ldGhvZCBIdG1sNSNyZWFkeVN0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjcmVhZHktc3RhdGVzfVxuICovXG4ncmVhZHlTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9XaWR0aGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gYHZpZGVvV2lkdGhgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb1dpZHRoXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdmlkZW9XaWR0aGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tdmlkZW8tdmlkZW93aWR0aH1cbiAqL1xuJ3ZpZGVvV2lkdGgnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9IZWlndGhgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB2aWRlbyBpbiBjc3MgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdmlkZW9IZWlnaHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb0hlaWdodGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tdmlkZW8tdmlkZW93aWR0aH1cbiAqL1xuJ3ZpZGVvSGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdO1xuICB9O1xufSk7XG5cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIHNldHRlciBpbiB0aGlzIGZvcm1hdDpcbi8vIHNldCArIHRvVGl0bGVDYXNlKG5hbWUpXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dzOlxuLy8gc2V0Vm9sdW1lLCBzZXRTcmMsIHNldFBvc3Rlciwgc2V0UHJlbG9hZCwgc2V0UGxheWJhY2tSYXRlLCBzZXREZWZhdWx0UGxheWJhY2tSYXRlXG5bXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlcyB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgYXMgYSBwZXJjZW50YWdlIGluIGRlY2ltYWwgZm9ybS4gVGhpcyBtZWFucyB0aGF0IDEgaXMgMTAwJSwgMC41IGlzIDUwJSwgYW5kXG4gKiBzbyBvbi5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFZvbHVtZVxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmNlbnRBc0RlY2ltYWxcbiAqICAgICAgICBUaGUgdm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsLiBWYWxpZCByYW5nZSBpcyBmcm9tIDAtMS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLWEtdm9sdW1lfVxuICovXG4ndm9sdW1lJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBzcmNgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgc3JjYCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnRcbiAqIHtAbGluayBUZWNoflNvdXJjZU9iamVjdH0gZm9yIHRoZSBtZWRpYS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFNyY1xuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNyY31cbiAqL1xuJ3NyYycsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBvc3RlcmAgaXMgdGhlIHVybCB0b1xuICogYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQb3N0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3N0ZXJcbiAqICAgICAgICBUaGUgdXJsIHRvIGFuIGltYWdlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGBwb3N0ZXJgIGZvciB0aGUgbWVkaWFcbiAqICAgICAgICBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQcmVsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZFxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIHRvIHNldCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gTXVzdCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjay4gRXhhbXBsZXM6XG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBudW1iZXIgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlfVxuICovXG4ncGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIHNob3VsZCBwbGF5IGJhY2sgdXBvbiBpbml0aWFsIHN0YXJ0dXAuIENoYW5naW5nIHRoaXMgdmFsdWVcbiAqIGFmdGVyIGEgdmlkZW8gaGFzIHN0YXJ0ZWQgd2lsbCBkbyBub3RoaW5nLiBJbnN0ZWFkIHlvdSBzaG91bGQgdXNlZCB7QGxpbmsgSHRtbDUjc2V0UGxheWJhY2tSYXRlfS5cbiAqXG4gKiBFeGFtcGxlIFZhbHVlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLnNldERlZmF1bHRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0cGxheWJhY2tyYXRlfVxuICovXG4nZGVmYXVsdFBsYXliYWNrUmF0ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlWydzZXQnICsgdG9UaXRsZUNhc2UocHJvcCldID0gZnVuY3Rpb24gKHYpIHtcbiAgICB0aGlzLmVsX1twcm9wXSA9IHY7XG4gIH07XG59KTtcblxuLy8gd3JhcCBuYXRpdmUgZnVuY3Rpb25zIHdpdGggYSBmdW5jdGlvblxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93czpcbi8vIHBhdXNlLCBsb2FkIHBsYXlcbltcbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBhdXNlYCBmdW5jdGlvbi4gVGhpcyB3aWxsIGNhbGwgdGhlIGBIVE1MNWBcbiAqIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwYXVzZVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZX1cbiAqL1xuJ3BhdXNlJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgbG9hZGAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgbG9hZGAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb2FkXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWxvYWR9XG4gKi9cbidsb2FkJyxcblxuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBtZWRpYSBlbGVtZW50cyBgcGxheWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgc1xuICogbWVkaWEgZWxlbWVudCBgcGxheWAgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5XG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXl9XG4gKi9cbidwbGF5J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfW3Byb3BdKCk7XG4gIH07XG59KTtcblxuVGVjaC53aXRoU291cmNlSGFuZGxlcnMoSHRtbDUpO1xuXG4vKipcbiAqIE5hdGl2ZSBzb3VyY2UgaGFuZGxlciBmb3IgSHRtbDUsIHNpbXBseSBwYXNzZXMgdGhlIHNvdXJjZSB0byB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAcHJvcHJldHkge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwcm9wcmV0eSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEhUTUw1IHRlY2guXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIgPSB7fTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgbWVkaWEgZWxlbWVudCBjYW4gcGxheSB0aGUgZ2l2ZW4gbWltZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgLy8gSUU5IG9uIFdpbmRvd3MgNyB3aXRob3V0IE1lZGlhUGxheWVyIHRocm93cyBhbiBlcnJvciBoZXJlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy81MTlcbiAgdHJ5IHtcbiAgICByZXR1cm4gSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUodHlwZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIGhhbmRsZSBhIHNvdXJjZSBuYXRpdmVseS5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgIE9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIHRoZSB0ZWNoLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZykuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuSGFuZGxlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gIC8vIElmIGEgdHlwZSB3YXMgcHJvdmlkZWQgd2Ugc2hvdWxkIHJlbHkgb24gdGhhdFxuICBpZiAoc291cmNlLnR5cGUpIHtcbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZShzb3VyY2UudHlwZSk7XG5cbiAgICAvLyBJZiBubyB0eXBlLCBmYWxsIGJhY2sgdG8gY2hlY2tpbmcgJ3ZpZGVvL1tFWFRFTlNJT05dJ1xuICB9IGVsc2UgaWYgKHNvdXJjZS5zcmMpIHtcbiAgICB2YXIgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcblxuICAgIHJldHVybiBIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlKCd2aWRlby8nICsgZXh0KTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBuYXRpdmUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzb3VyY2VcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7SHRtbDV9IHRlY2hcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEh0bWw1IHRlY2hcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuaGFuZGxlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdGVjaCwgb3B0aW9ucykge1xuICB0ZWNoLnNldFNyYyhzb3VyY2Uuc3JjKTtcbn07XG5cbi8qKlxuICogQSBub29wIGZvciB0aGUgbmF0aXZlIGRpc3Bvc2UgZnVuY3Rpb24sIGFzIGNsZWFudXAgaXMgbm90IG5lZWRlZC5cbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbi8vIFJlZ2lzdGVyIHRoZSBuYXRpdmUgc291cmNlIGhhbmRsZXJcbkh0bWw1LnJlZ2lzdGVyU291cmNlSGFuZGxlcihIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyKTtcblxuVGVjaC5yZWdpc3RlclRlY2goJ0h0bWw1JywgSHRtbDUpO1xuXG52YXIgX3RlbXBsYXRlT2JqZWN0JDEgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1xcbiAgICAgICAgVXNpbmcgdGhlIHRlY2ggZGlyZWN0bHkgY2FuIGJlIGRhbmdlcm91cy4gSSBob3BlIHlvdSBrbm93IHdoYXQgeW91XFwncmUgZG9pbmcuXFxuICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzI2MTcgZm9yIG1vcmUgaW5mby5cXG4gICAgICAnXSwgWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXllci5qc1xuICovXG4vLyBTdWJjbGFzc2VzIENvbXBvbmVudFxuLy8gVGhlIGZvbGxvd2luZyBpbXBvcnRzIGFyZSB1c2VkIG9ubHkgdG8gZW5zdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmcgbW9kdWxlc1xuLy8gYXJlIGFsd2F5cyBpbmNsdWRlZCBpbiB0aGUgdmlkZW8uanMgcGFja2FnZS4gSW1wb3J0aW5nIHRoZSBtb2R1bGVzIHdpbGxcbi8vIGV4ZWN1dGUgdGhlbSBhbmQgdGhleSB3aWxsIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB2aWRlby5qcy5cbi8vIEltcG9ydCBIdG1sNSB0ZWNoLCBhdCBsZWFzdCBmb3IgZGlzcG9zaW5nIHRoZSBvcmlnaW5hbCB2aWRlbyB0YWcuXG4vLyBUaGUgZm9sbG93aW5nIHRlY2ggZXZlbnRzIGFyZSBzaW1wbHkgcmUtdHJpZ2dlcmVkXG4vLyBvbiB0aGUgcGxheWVyIHdoZW4gdGhleSBoYXBwZW5cbnZhciBURUNIX0VWRU5UU19SRVRSSUdHRVIgPSBbXG4vKipcbiAqIEZpcmVkIHdoaWxlIHRoZSB1c2VyIGFnZW50IGlzIGRvd25sb2FkaW5nIG1lZGlhIGRhdGEuXG4gKlxuICogQGV2ZW50IFBsYXllciNwcm9ncmVzc1xuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHByb2dyZXNzYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFByb2dyZXNzX1xuICogQGZpcmVzIFBsYXllciNwcm9ncmVzc1xuICogQGxpc3RlbnMgVGVjaCNwcm9ncmVzc1xuICovXG4ncHJvZ3Jlc3MnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGxvYWRpbmcgb2YgYW4gYXVkaW8vdmlkZW8gaXMgYWJvcnRlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2Fib3J0XG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgYWJvcnRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoQWJvcnRfXG4gKiBAZmlyZXMgUGxheWVyI2Fib3J0XG4gKiBAbGlzdGVucyBUZWNoI2Fib3J0XG4gKi9cbidhYm9ydCcsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyBpbnRlbnRpb25hbGx5IG5vdCBnZXR0aW5nIG1lZGlhIGRhdGEuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdXNwZW5kXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3VzcGVuZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdXNwZW5kX1xuICogQGZpcmVzIFBsYXllciNzdXNwZW5kXG4gKiBAbGlzdGVucyBUZWNoI3N1c3BlbmRcbiAqL1xuJ3N1c3BlbmQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHkuXG4gKlxuICogQGV2ZW50IFBsYXllciNlbXB0aWVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgZW1wdGllZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hFbXB0aWVkX1xuICogQGZpcmVzIFBsYXllciNlbXB0aWVkXG4gKiBAbGlzdGVucyBUZWNoI2VtcHRpZWRcbiAqL1xuJ2VtcHRpZWQnLFxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGlzIHRyeWluZyB0byBnZXQgbWVkaWEgZGF0YSwgYnV0IGRhdGEgaXMgbm90IGF2YWlsYWJsZS5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3N0YWxsZWRcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBzdGFsbGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFN0YWxsZWRfXG4gKiBAZmlyZXMgUGxheWVyI3N0YWxsZWRcbiAqIEBsaXN0ZW5zIFRlY2gjc3RhbGxlZFxuICovXG4nc3RhbGxlZCcsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBoYXMgbG9hZGVkIG1ldGEgZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBzdGFsbGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaExvYWRlZG1ldGFkYXRhX1xuICogQGZpcmVzIFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICogQGxpc3RlbnMgVGVjaCNsb2FkZWRtZXRhZGF0YVxuICovXG4nbG9hZGVkbWV0YWRhdGEnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCB0aGUgY3VycmVudCBmcmFtZSBvZiB0aGUgYXVkaW8vdmlkZW8uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgbG9hZGVkZGF0YWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZGVkZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQGxpc3RlbnMgVGVjaCNsb2FkZWRkYXRhXG4gKi9cbidsb2FkZWRkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGltZVVwZGF0ZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQGxpc3RlbnMgVGVjaCN0aW1ldXBkYXRlXG4gKi9cbid0aW1ldXBkYXRlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBwbGF5aW5nIHNwZWVkIG9mIHRoZSBhdWRpby92aWRlbyBpcyBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciNyYXRlY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hSYXRlY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciNyYXRlY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3JhdGVjaGFuZ2VcbiAqL1xuJ3JhdGVjaGFuZ2UnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHZpZGVvJ3MgaW50cmluc2ljIGRpbWVuc2lvbnMgY2hhbmdlXG4gKlxuICogQGV2ZW50IFBsYXllciNyZXNpemVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGByZXNpemVgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoUmVzaXplX1xuICogQGZpcmVzIFBsYXllciNyZXNpemVcbiAqIEBsaXN0ZW5zIFRlY2gjcmVzaXplXG4gKi9cbidyZXNpemUnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHZvbHVtZSBoYXMgYmVlbiBjaGFuZ2VkXG4gKlxuICogQGV2ZW50IFBsYXllciN2b2x1bWVjaGFuZ2VcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVm9sdW1lY2hhbmdlX1xuICogQGZpcmVzIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAqIEBsaXN0ZW5zIFRlY2gjdm9sdW1lY2hhbmdlXG4gKi9cbid2b2x1bWVjaGFuZ2UnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIHRleHQgdHJhY2sgaGFzIGJlZW4gY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgdGV4dHRyYWNrY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRleHR0cmFja2NoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3RleHR0cmFja2NoYW5nZVxuICovXG4ndGV4dHRyYWNrY2hhbmdlJ107XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIGBQbGF5ZXJgIGNsYXNzIGlzIGNyZWF0ZWQgd2hlbiBhbnkgb2YgdGhlIFZpZGVvLmpzIHNldHVwIG1ldGhvZHNcbiAqIGFyZSB1c2VkIHRvIGluaXRpYWxpemUgYSB2aWRlby5cbiAqXG4gKiBBZnRlciBhbiBpbnN0YW5jZSBoYXMgYmVlbiBjcmVhdGVkIGl0IGNhbiBiZSBhY2Nlc3NlZCBnbG9iYWxseSBpbiB0d28gd2F5czpcbiAqIDEuIEJ5IGNhbGxpbmcgYHZpZGVvanMoJ2V4YW1wbGVfdmlkZW9fMScpO2BcbiAqIDIuIEJ5IHVzaW5nIGl0IGRpcmVjdGx5IHZpYSAgYHZpZGVvanMucGxheWVycy5leGFtcGxlX3ZpZGVvXzE7YFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBQbGF5ZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhQbGF5ZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWdcbiAgICogICAgICAgIFRoZSBvcmlnaW5hbCB2aWRlbyBET00gZWxlbWVudCB1c2VkIGZvciBjb25maWd1cmluZyBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFJlYWR5IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWVyKHRhZywgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5ZXIpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcbiAgICB0YWcuaWQgPSB0YWcuaWQgfHwgJ3Zqc192aWRlb18nICsgbmV3R1VJRCgpO1xuXG4gICAgLy8gU2V0IE9wdGlvbnNcbiAgICAvLyBUaGUgb3B0aW9ucyBhcmd1bWVudCBvdmVycmlkZXMgb3B0aW9ucyBzZXQgaW4gdGhlIHZpZGVvIHRhZ1xuICAgIC8vIHdoaWNoIG92ZXJyaWRlcyBnbG9iYWxseSBzZXQgb3B0aW9ucy5cbiAgICAvLyBUaGlzIGxhdHRlciBwYXJ0IGNvaW5jaWRlcyB3aXRoIHRoZSBsb2FkIG9yZGVyXG4gICAgLy8gKHRhZyBtdXN0IGV4aXN0IGJlZm9yZSBQbGF5ZXIpXG4gICAgb3B0aW9ucyA9IGFzc2lnbihQbGF5ZXIuZ2V0VGFnU2V0dGluZ3ModGFnKSwgb3B0aW9ucyk7XG5cbiAgICAvLyBEZWxheSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGRyZW4gYmVjYXVzZSB3ZSBuZWVkIHRvIHNldCB1cFxuICAgIC8vIHBsYXllciBwcm9wZXJ0aWVzIGZpcnN0LCBhbmQgY2FuJ3QgdXNlIGB0aGlzYCBiZWZvcmUgYHN1cGVyKClgXG4gICAgb3B0aW9ucy5pbml0Q2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8vIFNhbWUgd2l0aCBjcmVhdGluZyB0aGUgZWxlbWVudFxuICAgIG9wdGlvbnMuY3JlYXRlRWwgPSBmYWxzZTtcblxuICAgIC8vIGRvbid0IGF1dG8gbWl4aW4gdGhlIGV2ZW50ZWQgbWl4aW5cbiAgICBvcHRpb25zLmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHBsYXllciB0byByZXBvcnQgdG91Y2ggYWN0aXZpdHkgb24gaXRzZWxmXG4gICAgLy8gc2VlIGVuYWJsZVRvdWNoQWN0aXZpdHkgaW4gQ29tcG9uZW50XG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBJZiBsYW5ndWFnZSBpcyBub3Qgc2V0LCBnZXQgdGhlIGNsb3Nlc3QgbGFuZyBhdHRyaWJ1dGVcbiAgICBpZiAoIW9wdGlvbnMubGFuZ3VhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnLmNsb3Nlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSB0YWcuY2xvc2VzdCgnW2xhbmddJyk7XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gY2xvc2VzdC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0YWc7XG5cbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpLmhhc093blByb3BlcnR5KCdsYW5nJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbGFuZycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdW4gYmFzZSBjb21wb25lbnQgaW5pdGlhbGl6aW5nIHdpdGggbmV3IG9wdGlvbnNcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIF90aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvLyBJbml0IHN0YXRlIGhhc1N0YXJ0ZWRfXG4gICAgX3RoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcblxuICAgIC8vIEluaXQgc3RhdGUgdXNlckFjdGl2ZV9cbiAgICBfdGhpcy51c2VyQWN0aXZlXyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghX3RoaXMub3B0aW9uc18gfHwgIV90aGlzLm9wdGlvbnNfLnRlY2hPcmRlciB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICsgJ3ZpZGVvanMub3B0aW9ucyBpbnN0ZWFkIG9mIGp1c3QgY2hhbmdpbmcgdGhlICcgKyAncHJvcGVydGllcyB5b3Ugd2FudCB0byBvdmVycmlkZT8nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgdGFnIHVzZWQgdG8gc2V0IG9wdGlvbnNcbiAgICBfdGhpcy50YWcgPSB0YWc7XG5cbiAgICAvLyBTdG9yZSB0aGUgdGFnIGF0dHJpYnV0ZXMgdXNlZCB0byByZXN0b3JlIGh0bWw1IGVsZW1lbnRcbiAgICBfdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIGdldEF0dHJpYnV0ZXModGFnKTtcblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IGxhbmd1YWdlXG4gICAgX3RoaXMubGFuZ3VhZ2UoX3RoaXMub3B0aW9uc18ubGFuZ3VhZ2UpO1xuXG4gICAgLy8gVXBkYXRlIFN1cHBvcnRlZCBMYW5ndWFnZXNcbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZXMpIHtcbiAgICAgIC8vIE5vcm1hbGlzZSBwbGF5ZXIgb3B0aW9uIGxhbmd1YWdlcyB0byBsb3dlcmNhc2VcbiAgICAgIHZhciBsYW5ndWFnZXNUb0xvd2VyID0ge307XG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMubGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGxhbmd1YWdlc1RvTG93ZXJbbmFtZSQkMS50b0xvd2VyQ2FzZSgpXSA9IG9wdGlvbnMubGFuZ3VhZ2VzW25hbWUkJDFdO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gbGFuZ3VhZ2VzVG9Mb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xuICAgIH1cblxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgX3RoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgX3RoaXMucG9zdGVyXyA9IG9wdGlvbnMucG9zdGVyIHx8ICcnO1xuXG4gICAgLy8gU2V0IGNvbnRyb2xzXG4gICAgX3RoaXMuY29udHJvbHNfID0gISFvcHRpb25zLmNvbnRyb2xzO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBsYXN0Vm9sdW1lXG4gICAgX3RoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSAxO1xuXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXG4gICAgLy8gbm93IHJlbW92ZSBpbW1lZGlhdGVseSBzbyBuYXRpdmUgY29udHJvbHMgZG9uJ3QgZmxhc2guXG4gICAgLy8gTWF5IGJlIHR1cm5lZCBiYWNrIG9uIGJ5IEhUTUw1IHRlY2ggaWYgbmF0aXZlQ29udHJvbHNGb3JUb3VjaCBpcyB0cnVlXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnY29udHJvbHMnKTtcblxuICAgIC8qXG4gICAgICogU3RvcmUgdGhlIGludGVybmFsIHN0YXRlIG9mIHNjcnViYmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHNjcnViYmluZ1xuICAgICAqL1xuICAgIF90aGlzLnNjcnViYmluZ18gPSBmYWxzZTtcblxuICAgIF90aGlzLmVsXyA9IF90aGlzLmNyZWF0ZUVsKCk7XG5cbiAgICAvLyBNYWtlIHRoaXMgYW4gZXZlbnRlZCBvYmplY3QgYW5kIHVzZSBgZWxfYCBhcyBpdHMgZXZlbnQgYnVzLlxuICAgIGV2ZW50ZWQoX3RoaXMsIHsgZXZlbnRCdXNLZXk6ICdlbF8nIH0pO1xuXG4gICAgLy8gV2UgYWxzbyB3YW50IHRvIHBhc3MgdGhlIG9yaWdpbmFsIHBsYXllciBvcHRpb25zIHRvIGVhY2ggY29tcG9uZW50IGFuZCBwbHVnaW5cbiAgICAvLyBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0byByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gZG8gYW5vdGhlciBjb3B5IG9mIHRoaXMub3B0aW9uc18gc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGhcbiAgICAvLyBhbiBpbmZpbml0ZSBsb29wLlxuICAgIHZhciBwbGF5ZXJPcHRpb25zQ29weSA9IG1lcmdlT3B0aW9ucyhfdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBMb2FkIHBsdWdpbnNcbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucztcblxuICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbbmFtZSQkMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzW25hbWUkJDFdKHBsdWdpbnNbbmFtZSQkMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGx1Z2luIFwiJyArIG5hbWUkJDEgKyAnXCIgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuICAgICAgfSwgX3RoaXMpO1xuICAgIH1cblxuICAgIF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMgPSBwbGF5ZXJPcHRpb25zQ29weTtcblxuICAgIF90aGlzLm1pZGRsZXdhcmVfID0gW107XG5cbiAgICBfdGhpcy5pbml0Q2hpbGRyZW4oKTtcblxuICAgIC8vIFNldCBpc0F1ZGlvIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGFuIGF1ZGlvIHRhZyB3YXMgdXNlZFxuICAgIF90aGlzLmlzQXVkaW8odGFnLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpbycpO1xuXG4gICAgLy8gVXBkYXRlIGNvbnRyb2xzIGNsYXNzTmFtZS4gQ2FuJ3QgZG8gdGhpcyB3aGVuIHRoZSBjb250cm9scyBhcmUgaW5pdGlhbGx5XG4gICAgLy8gc2V0IGJlY2F1c2UgdGhlIGVsZW1lbnQgZG9lc24ndCBleGlzdCB5ZXQuXG4gICAgaWYgKF90aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IEFSSUEgbGFiZWwgYW5kIHJlZ2lvbiByb2xlIGRlcGVuZGluZyBvbiBwbGF5ZXIgdHlwZVxuICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XG4gICAgaWYgKF90aGlzLmlzQXVkaW8oKSkge1xuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF90aGlzLmxvY2FsaXplKCdBdWRpbyBQbGF5ZXInKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnVmlkZW8gUGxheWVyJykpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtYXVkaW8nKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuZmxleE5vdFN1cHBvcnRlZF8oKSkge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1uby1mbGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHNtYXJ0ZXIuIFRvZ2dsZSB1c2VyIHN0YXRlIGJldHdlZW4gdG91Y2hpbmcvbW91c2luZ1xuICAgIC8vIHVzaW5nIGV2ZW50cywgc2luY2UgZGV2aWNlcyBjYW4gaGF2ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHMuXG4gICAgLy8gaWYgKGJyb3dzZXIuVE9VQ0hfRU5BQkxFRCkge1xuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcbiAgICAvLyB9XG5cbiAgICAvLyBpT1MgU2FmYXJpIGhhcyBicm9rZW4gaG92ZXIgaGFuZGxpbmdcbiAgICBpZiAoIUlTX0lPUykge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy13b3JraW5naG92ZXInKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHBsYXllciBlYXNpbHkgZmluZGFibGUgYnkgSURcbiAgICBQbGF5ZXIucGxheWVyc1tfdGhpcy5pZF9dID0gX3RoaXM7XG5cbiAgICAvLyBBZGQgYSBtYWpvciB2ZXJzaW9uIGNsYXNzIHRvIGFpZCBjc3MgaW4gcGx1Z2luc1xuICAgIHZhciBtYWpvclZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KCcuJylbMF07XG5cbiAgICBfdGhpcy5hZGRDbGFzcygndmpzLXYnICsgbWFqb3JWZXJzaW9uKTtcblxuICAgIC8vIFdoZW4gdGhlIHBsYXllciBpcyBmaXJzdCBpbml0aWFsaXplZCwgdHJpZ2dlciBhY3Rpdml0eSBzbyBjb21wb25lbnRzXG4gICAgLy8gbGlrZSB0aGUgY29udHJvbCBiYXIgc2hvdyB0aGVtc2VsdmVzIGlmIG5lZWRlZFxuICAgIF90aGlzLnVzZXJBY3RpdmUodHJ1ZSk7XG4gICAgX3RoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gICAgX3RoaXMubGlzdGVuRm9yVXNlckFjdGl2aXR5XygpO1xuXG4gICAgX3RoaXMub24oJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgX3RoaXMub24oJ3N0YWdlY2xpY2snLCBfdGhpcy5oYW5kbGVTdGFnZUNsaWNrXyk7XG5cbiAgICBfdGhpcy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICBfdGhpcy5wbGF5V2FpdGluZ0ZvclJlYWR5XyA9IGZhbHNlO1xuICAgIF90aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBudWxsO1xuXG4gICAgX3RoaXMuZm9yY2VBdXRvcGxheUluQ2hyb21lXygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgdmlkZW8gcGxheWVyIGFuZCBkb2VzIGFueSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IGhlbHBmdWwgaWYgeW91IGFyZSBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIHZpZGVvc1xuICAgKiB0by9mcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHBsYXllciBpcyBiZWluZyBkaXNwb3NlZCBvZi5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZGlzcG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcbiAgICAvLyBwcmV2ZW50IGRpc3Bvc2UgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICB0aGlzLm9mZignZGlzcG9zZScpO1xuXG4gICAgaWYgKHRoaXMuc3R5bGVFbF8gJiYgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdHlsZUVsXyk7XG4gICAgICB0aGlzLnN0eWxlRWxfID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllckVsSW5nZXN0Xykge1xuICAgICAgdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRhZykge1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHRoZSBhY3R1YWwgLmVsXyBpcyByZW1vdmVkIGhlcmVcbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYFBsYXllcmAncyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZztcbiAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgdmFyIHBsYXllckVsSW5nZXN0ID0gdGhpcy5wbGF5ZXJFbEluZ2VzdF8gPSB0YWcucGFyZW50Tm9kZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUgJiYgdGFnLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXZqcy1wbGF5ZXInKTtcbiAgICB2YXIgZGl2RW1iZWQgPSB0aGlzLnRhZy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby1qcyc7XG5cbiAgICBpZiAocGxheWVyRWxJbmdlc3QpIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSB0YWcucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCFkaXZFbWJlZCkge1xuICAgICAgZWwgPSB0aGlzLmVsXyA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicpO1xuICAgIH1cblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnO1xuICAgICAgdGFnID0gdGhpcy50YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzQ2xhc3MoZWwsICd2aWRlby1qcycpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsLCAndmlkZW8tanMnKTtcbiAgICAgIH1cblxuICAgICAgZWwuYXBwZW5kQ2hpbGQodGFnKTtcblxuICAgICAgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IGVsO1xuICAgIH1cblxuICAgIC8vIHNldCB0YWJpbmRleCB0byAtMSBzbyB3ZSBjb3VsZCBmb2N1cyBvbiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICB0YWcuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuXG4gICAgLy8gUmVtb3ZlIHdpZHRoL2hlaWdodCBhdHRycyBmcm9tIHRhZyBzbyBDU1MgY2FuIG1ha2UgaXQgMTAwJSB3aWR0aC9oZWlnaHRcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGF0dHJzW2F0dHJdO1xuXG4gICAgICAgIGlmIChkaXZFbWJlZCkge1xuICAgICAgICAgIHRhZy5jbGFzc05hbWUgKz0gJyAnICsgYXR0cnNbYXR0cl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG5cbiAgICAgICAgaWYgKGRpdkVtYmVkKSB7XG4gICAgICAgICAgdGFnLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5wbGF5ZXJJZCA9IHRhZy5pZDtcbiAgICB0YWcuaWQgKz0gJ19odG1sNV9hcGknO1xuICAgIHRhZy5jbGFzc05hbWUgPSAndmpzLXRlY2gnO1xuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZmluZGFibGUgb24gZWxlbWVudHNcbiAgICB0YWcucGxheWVyID0gZWwucGxheWVyID0gdGhpcztcbiAgICAvLyBEZWZhdWx0IHN0YXRlIG9mIHZpZGVvIGlzIHBhdXNlZFxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcblxuICAgIC8vIEFkZCBhIHN0eWxlIGVsZW1lbnQgaW4gdGhlIHBsYXllciB0aGF0IHdlJ2xsIHVzZSB0byBzZXQgdGhlIHdpZHRoL2hlaWdodFxuICAgIC8vIG9mIHRoZSBwbGF5ZXIgaW4gYSB3YXkgdGhhdCdzIHN0aWxsIG92ZXJyaWRlYWJsZSBieSBDU1MsIGp1c3QgbGlrZSB0aGVcbiAgICAvLyB2aWRlbyBlbGVtZW50XG4gICAgaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGltZW5zaW9ucycpO1xuICAgICAgdmFyIGRlZmF1bHRzU3R5bGVFbCA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZUVsXywgZGVmYXVsdHNTdHlsZUVsID8gZGVmYXVsdHNTdHlsZUVsLm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGluIHRoZSB3aWR0aC9oZWlnaHQvYXNwZWN0UmF0aW8gb3B0aW9ucyB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc3R5bGUgZWxcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0KHRoaXMub3B0aW9uc18uaGVpZ2h0KTtcbiAgICB0aGlzLmZsdWlkKHRoaXMub3B0aW9uc18uZmx1aWQpO1xuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XG5cbiAgICAvLyBIaWRlIGFueSBsaW5rcyB3aXRoaW4gdGhlIHZpZGVvL2F1ZGlvIHRhZywgYmVjYXVzZSBJRSBkb2Vzbid0IGhpZGUgdGhlbSBjb21wbGV0ZWx5LlxuICAgIHZhciBsaW5rcyA9IHRhZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XG5cbiAgICAgIGFkZENsYXNzKGxpbmtFbCwgJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIGxpbmtFbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRFbEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlICYmICFwbGF5ZXJFbEluZ2VzdCkge1xuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xuICAgIH1cblxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCBpdCB0byB0aGUgY2hpbGRyZW4gYXJyYXkgc28gdGhhdCB0aGlzLmFkZENoaWxkXG4gICAgLy8gd2lsbCB3b3JrIHByb3Blcmx5IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgLy9cbiAgICAvLyBCcmVha3MgaVBob25lLCBmaXhlZCBpbiBIVE1MNSBzZXR1cC5cbiAgICBwcmVwZW5kVG8odGFnLCBlbCk7XG4gICAgdGhpcy5jaGlsZHJlbl8udW5zaGlmdCh0YWcpO1xuXG4gICAgLy8gU2V0IGxhbmcgYXR0ciBvbiBwbGF5ZXIgdG8gZW5zdXJlIENTUyA6bGFuZygpIGluIGNvbnNpc3RlbnQgd2l0aCBwbGF5ZXJcbiAgICAvLyBpZiBpdCdzIGJlZW4gc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdG8gdGhlIGRvY1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnbGFuZycsIHRoaXMubGFuZ3VhZ2VfKTtcblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGguIFJldHVybnMgdGhlIHBsYXllcidzIGNvbmZpZ3VyZWQgdmFsdWUuXG4gICAqIFRvIGdldCB0aGUgY3VycmVudCB3aWR0aCB1c2UgYGN1cnJlbnRXaWR0aCgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBwbGF5ZXJyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgodmFsdWUsIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgdmFsdWUsIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGhlaWdodC4gUmV0dXJucyB0aGUgcGxheWVyJ3MgY29uZmlndXJlZCB2YWx1ZS5cbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IGhlaWdodCB1c2UgYGN1cnJlbnRoZWlnaHQoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIHBsYXllcnJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCh2YWx1ZSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgdmFsdWUsIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIHdpZHRoICYgaGVpZ2h0LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXllcnJlc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXG4gICAqICAgICAgICBUaGlzIHN0cmluZyBjYW4gYmU6XG4gICAqICAgICAgICAtICd3aWR0aCdcbiAgICogICAgICAgIC0gJ2hlaWdodCdcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cbiAgICogICAgICAgIFZhbHVlIGZvciBkaW1lbnNpb24gc3BlY2lmaWVkIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cbiAgICogICAgICAgIFNraXAgdGhlIHBsYXllcnJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9uIGFyZ3VtZW50cyB2YWx1ZSB3aGVuIGdldHRpbmcgKHdpZHRoL2hlaWdodCkuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaW1lbnNpb24gPSBmdW5jdGlvbiBkaW1lbnNpb24oX2RpbWVuc2lvbiwgdmFsdWUsIHNraXBMaXN0ZW5lcnMpIHtcbiAgICB2YXIgcHJpdkRpbWVuc2lvbiA9IF9kaW1lbnNpb24gKyAnXyc7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXNbcHJpdkRpbWVuc2lvbl0gfHwgMDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAvLyBJZiBhbiBlbXB0eSBzdHJpbmcgaXMgZ2l2ZW4sIHJlc2V0IHRoZSBkaW1lbnNpb24gdG8gYmUgYXV0b21hdGljXG4gICAgICB0aGlzW3ByaXZEaW1lbnNpb25dID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRWYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIGlmIChpc05hTihwYXJzZWRWYWwpKSB7XG4gICAgICBsb2ckMS5lcnJvcignSW1wcm9wZXIgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgc3VwcGxpZWQgZm9yIGZvciAnICsgX2RpbWVuc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG5cbiAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgIGlmICh0aGlzLmlzUmVhZHlfICYmICFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBwbGF5ZXIgaXMgcmVzaXplZC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXllcnJlc2l6ZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3BsYXllcnJlc2l6ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyL3RvZ2dsZXIgZm9yIHRoZSB2anMtZmx1aWQgYGNsYXNzTmFtZWAgb24gdGhlIGBQbGF5ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIEEgdmFsdWUgb2YgZmFsc2UgcmVtb3ZlcyB0aGUgY2xhc3MuXG4gICAqICAgICAgICAtIE5vIHZhbHVlIHdpbGwgdG9nZ2xlIHRoZSBmbHVpZCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgZmx1aWQgd2hlbiBnZXR0aW5nLlxuICAgKiAgICAgICAgIC0gYHVuZGVmaW5lZGAgd2hlbiBzZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmx1aWQgPSBmdW5jdGlvbiBmbHVpZChib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5mbHVpZF87XG4gICAgfVxuXG4gICAgdGhpcy5mbHVpZF8gPSAhIWJvb2w7XG5cbiAgICBpZiAoYm9vbCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZsdWlkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mbHVpZCcpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L1NldCB0aGUgYXNwZWN0IHJhdGlvXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBBc3BlY3QgcmF0aW8gZm9yIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHJldHVybnMgdGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuICAvKipcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYFBsYXllcmAncyBhc3BlY3QgcmF0aW8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyJ3MgYXNwZWN0IHJhdGlvIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIG9mIHRoZSBgUGxheWVyYCB3aGVuIGdldHRpbmcuXG4gICAqICAgICAgICAgLSB1bmRlZmluZWQgd2hlbiBzZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gICAgaWYgKHJhdGlvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd2lkdGg6aGVpZ2h0IGZvcm1hdFxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltcHJvcGVyIHZhbHVlIHN1cHBsaWVkIGZvciBhc3BlY3QgcmF0aW8uIFRoZSBmb3JtYXQgc2hvdWxkIGJlIHdpZHRoOmhlaWdodCwgZm9yIGV4YW1wbGUgMTY6OS4nKTtcbiAgICB9XG4gICAgdGhpcy5hc3BlY3RSYXRpb18gPSByYXRpbztcblxuICAgIC8vIFdlJ3JlIGFzc3VtaW5nIGlmIHlvdSBzZXQgYW4gYXNwZWN0IHJhdGlvIHlvdSB3YW50IGZsdWlkIG1vZGUsXG4gICAgLy8gYmVjYXVzZSBpbiBmaXhlZCBtb2RlIHlvdSBjb3VsZCBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCB5b3Vyc2VsZi5cbiAgICB0aGlzLmZsdWlkKHRydWUpO1xuXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3R5bGVzIG9mIHRoZSBgUGxheWVyYCBlbGVtZW50IChoZWlnaHQsIHdpZHRoIGFuZCBhc3BlY3QgcmF0aW8pLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51cGRhdGVTdHlsZUVsXyA9IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlRWxfKCkge1xuICAgIGlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFID09PSB0cnVlKSB7XG4gICAgICB2YXIgX3dpZHRoID0gdHlwZW9mIHRoaXMud2lkdGhfID09PSAnbnVtYmVyJyA/IHRoaXMud2lkdGhfIDogdGhpcy5vcHRpb25zXy53aWR0aDtcbiAgICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIHRoaXMuaGVpZ2h0XyA9PT0gJ251bWJlcicgPyB0aGlzLmhlaWdodF8gOiB0aGlzLm9wdGlvbnNfLmhlaWdodDtcbiAgICAgIHZhciB0ZWNoRWwgPSB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZWwoKTtcblxuICAgICAgaWYgKHRlY2hFbCkge1xuICAgICAgICBpZiAoX3dpZHRoID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwud2lkdGggPSBfd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9oZWlnaHQgPj0gMCkge1xuICAgICAgICAgIHRlY2hFbC5oZWlnaHQgPSBfaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XG4gICAgdmFyIGhlaWdodCA9IHZvaWQgMDtcbiAgICB2YXIgYXNwZWN0UmF0aW8gPSB2b2lkIDA7XG4gICAgdmFyIGlkQ2xhc3MgPSB2b2lkIDA7XG5cbiAgICAvLyBUaGUgYXNwZWN0IHJhdGlvIGlzIGVpdGhlciB1c2VkIGRpcmVjdGx5IG9yIHRvIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXNwZWN0UmF0aW9fICE9PSAnYXV0bycpIHtcbiAgICAgIC8vIFVzZSBhbnkgYXNwZWN0UmF0aW8gdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvXztcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9XaWR0aCgpID4gMCkge1xuICAgICAgLy8gT3RoZXJ3aXNlIHRyeSB0byBnZXQgdGhlIGFzcGVjdCByYXRpbyBmcm9tIHRoZSB2aWRlbyBtZXRhZGF0YVxuICAgICAgYXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvV2lkdGgoKSArICc6JyArIHRoaXMudmlkZW9IZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIGEgZGVmYXVsdC4gVGhlIHZpZGVvIGVsZW1lbnQncyBpcyAyOjEsIGJ1dCAxNjo5IGlzIG1vcmUgY29tbW9uLlxuICAgICAgYXNwZWN0UmF0aW8gPSAnMTY6OSc7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSByYXRpbyBhcyBhIGRlY2ltYWwgd2UgY2FuIHVzZSB0byBjYWxjdWxhdGUgZGltZW5zaW9uc1xuICAgIHZhciByYXRpb1BhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICB2YXIgcmF0aW9NdWx0aXBsaWVyID0gcmF0aW9QYXJ0c1sxXSAvIHJhdGlvUGFydHNbMF07XG5cbiAgICBpZiAodGhpcy53aWR0aF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSB3aWR0aCB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGhfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9yIGNhbHVsYXRlIHRoZSB3aWR0aCBmcm9tIHRoZSBhc3BlY3QgcmF0aW8gaWYgYSBoZWlnaHQgaGFzIGJlZW4gc2V0XG4gICAgICB3aWR0aCA9IHRoaXMuaGVpZ2h0XyAvIHJhdGlvTXVsdGlwbGllcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3IgdXNlIHRoZSB2aWRlbydzIG1ldGFkYXRhLCBvciB1c2UgdGhlIHZpZGVvIGVsJ3MgZGVmYXVsdCBvZiAzMDBcbiAgICAgIHdpZHRoID0gdGhpcy52aWRlb1dpZHRoKCkgfHwgMzAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhlaWdodF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVXNlIGFueSBoZWlnaHQgdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHRfO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBoZWlnaHQgZnJvbSB0aGUgcmF0aW8gYW5kIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gd2lkdGggKiByYXRpb011bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBDU1MgY2xhc3MgaXMgdmFsaWQgYnkgc3RhcnRpbmcgd2l0aCBhbiBhbHBoYSBjaGFyYWN0ZXJcbiAgICBpZiAoL15bXmEtekEtWl0vLnRlc3QodGhpcy5pZCgpKSkge1xuICAgICAgaWRDbGFzcyA9ICdkaW1lbnNpb25zLScgKyB0aGlzLmlkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkQ2xhc3MgPSB0aGlzLmlkKCkgKyAnLWRpbWVuc2lvbnMnO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcmlnaHQgY2xhc3MgaXMgc3RpbGwgb24gdGhlIHBsYXllciBmb3IgdGhlIHN0eWxlIGVsZW1lbnRcbiAgICB0aGlzLmFkZENsYXNzKGlkQ2xhc3MpO1xuXG4gICAgc2V0VGV4dENvbnRlbnQodGhpcy5zdHlsZUVsXywgJ1xcbiAgICAgIC4nICsgaWRDbGFzcyArICcge1xcbiAgICAgICAgd2lkdGg6ICcgKyB3aWR0aCArICdweDtcXG4gICAgICAgIGhlaWdodDogJyArIGhlaWdodCArICdweDtcXG4gICAgICB9XFxuXFxuICAgICAgLicgKyBpZENsYXNzICsgJy52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6ICcgKyByYXRpb011bHRpcGxpZXIgKiAxMDAgKyAnJTtcXG4gICAgICB9XFxuICAgICcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB7QGxpbmsgVGVjaH0gaW5jbHVkaW5nIGVsZW1lbnRcbiAgICogYW5kIEFQSSBtZXRob2RzLiBUaGVuIGFwcGVuZCB0aGUgYFRlY2hgIGVsZW1lbnQgaW4gYFBsYXllcmAgYXMgYSBjaGlsZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlY2hOYW1lXG4gICAqICAgICAgICBuYW1lIG9mIHRoZSBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogICAgICAgIHZpZGVvIHNvdXJjZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZFRlY2hfID0gZnVuY3Rpb24gbG9hZFRlY2hfKHRlY2hOYW1lLCBzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIFBhdXNlIGFuZCByZW1vdmUgY3VycmVudCBwbGF5YmFjayB0ZWNobm9sb2d5XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudW5sb2FkVGVjaF8oKTtcbiAgICB9XG5cbiAgICB2YXIgdGl0bGVUZWNoTmFtZSA9IHRvVGl0bGVDYXNlKHRlY2hOYW1lKTtcbiAgICB2YXIgY2FtZWxUZWNoTmFtZSA9IHRlY2hOYW1lLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgdGVjaE5hbWUuc2xpY2UoMSk7XG5cbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBIVE1MNSB2aWRlbyB0YWcgYXMgc29vbiBhcyB3ZSBhcmUgdXNpbmcgYW5vdGhlciB0ZWNoXG4gICAgaWYgKHRpdGxlVGVjaE5hbWUgIT09ICdIdG1sNScgJiYgdGhpcy50YWcpIHtcbiAgICAgIFRlY2guZ2V0VGVjaCgnSHRtbDUnKS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMudGFnKTtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoTmFtZV8gPSB0aXRsZVRlY2hOYW1lO1xuXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICAvLyBHcmFiIHRlY2gtc3BlY2lmaWMgb3B0aW9ucyBmcm9tIHBsYXllciBvcHRpb25zIGFuZCBhZGQgc291cmNlIGFuZCBwYXJlbnQgZWxlbWVudCB0byB1c2UuXG4gICAgdmFyIHRlY2hPcHRpb25zID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAnbmF0aXZlQ29udHJvbHNGb3JUb3VjaCc6IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCxcbiAgICAgICdwbGF5ZXJJZCc6IHRoaXMuaWQoKSxcbiAgICAgICd0ZWNoSWQnOiB0aGlzLmlkKCkgKyAnXycgKyB0aXRsZVRlY2hOYW1lICsgJ19hcGknLFxuICAgICAgJ2F1dG9wbGF5JzogdGhpcy5vcHRpb25zXy5hdXRvcGxheSxcbiAgICAgICdwbGF5c2lubGluZSc6IHRoaXMub3B0aW9uc18ucGxheXNpbmxpbmUsXG4gICAgICAncHJlbG9hZCc6IHRoaXMub3B0aW9uc18ucHJlbG9hZCxcbiAgICAgICdsb29wJzogdGhpcy5vcHRpb25zXy5sb29wLFxuICAgICAgJ211dGVkJzogdGhpcy5vcHRpb25zXy5tdXRlZCxcbiAgICAgICdwb3N0ZXInOiB0aGlzLnBvc3RlcigpLFxuICAgICAgJ2xhbmd1YWdlJzogdGhpcy5sYW5ndWFnZSgpLFxuICAgICAgJ3BsYXllckVsSW5nZXN0JzogdGhpcy5wbGF5ZXJFbEluZ2VzdF8gfHwgZmFsc2UsXG4gICAgICAndnR0LmpzJzogdGhpcy5vcHRpb25zX1sndnR0LmpzJ11cbiAgICB9O1xuXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgdGVjaE9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV0gPSBfdGhpczJbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICAgIH0pO1xuXG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW3RpdGxlVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bY2FtZWxUZWNoTmFtZV0pO1xuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG5cbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRlY2hPcHRpb25zLnRhZyA9IHRoaXMudGFnO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgJiYgc291cmNlLnNyYyA9PT0gdGhpcy5jYWNoZV8uc3JjICYmIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgdGVjaE9wdGlvbnMuc3RhcnRUaW1lID0gdGhpcy5jYWNoZV8uY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0ZWNoIGluc3RhbmNlXG4gICAgdmFyIFRlY2hDbGFzcyA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XG5cbiAgICBpZiAoIVRlY2hDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBUZWNoIG5hbWVkIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBleGlzdHMhIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaCgpXFwnJyk7XG4gICAgfVxuXG4gICAgdGhpcy50ZWNoXyA9IG5ldyBUZWNoQ2xhc3ModGVjaE9wdGlvbnMpO1xuXG4gICAgLy8gcGxheWVyLnRyaWdnZXJSZWFkeSBpcyBhbHdheXMgYXN5bmMsIHNvIGRvbid0IG5lZWQgdGhpcyB0byBiZSBhc3luY1xuICAgIHRoaXMudGVjaF8ucmVhZHkoYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRlY2hSZWFkeV8pLCB0cnVlKTtcblxuICAgIHRleHRUcmFja0NvbnZlcnRlci5qc29uVG9UZXh0VHJhY2tzKHRoaXMudGV4dFRyYWNrc0pzb25fIHx8IFtdLCB0aGlzLnRlY2hfKTtcblxuICAgIC8vIExpc3RlbiB0byBhbGwgSFRNTDUtZGVmaW5lZCBldmVudHMgYW5kIHRyaWdnZXIgdGhlbSBvbiB0aGUgcGxheWVyXG4gICAgVEVDSF9FVkVOVFNfUkVUUklHR0VSLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpczIub24oX3RoaXMyLnRlY2hfLCBldmVudCwgX3RoaXMyWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10pO1xuICAgIH0pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRzdGFydCcsIHRoaXMuaGFuZGxlVGVjaExvYWRTdGFydF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3dhaXRpbmcnLCB0aGlzLmhhbmRsZVRlY2hXYWl0aW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnY2FucGxheScsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheWluZycsIHRoaXMuaGFuZGxlVGVjaFBsYXlpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlbmRlZCcsIHRoaXMuaGFuZGxlVGVjaEVuZGVkXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnc2Vla2luZycsIHRoaXMuaGFuZGxlVGVjaFNlZWtpbmdfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVrZWQnLCB0aGlzLmhhbmRsZVRlY2hTZWVrZWRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwbGF5JywgdGhpcy5oYW5kbGVUZWNoUGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2ZpcnN0cGxheScsIHRoaXMuaGFuZGxlVGVjaEZpcnN0UGxheV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BhdXNlJywgdGhpcy5oYW5kbGVUZWNoUGF1c2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdkdXJhdGlvbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnbG9hZGVkbWV0YWRhdGEnLCB0aGlzLnVwZGF0ZVN0eWxlRWxfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwb3N0ZXJjaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0ZXh0ZGF0YScsIHRoaXMuaGFuZGxlVGVjaFRleHREYXRhXyk7XG5cbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHModGhpcy50ZWNoR2V0XygnY29udHJvbHMnKSk7XG5cbiAgICBpZiAodGhpcy5jb250cm9scygpICYmICF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgdGhpcy5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSB0ZWNoIGVsZW1lbnQgaW4gdGhlIERPTSBpZiBpdCB3YXMgbm90IGFscmVhZHkgdGhlcmVcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxuICAgIGlmICh0aGlzLnRlY2hfLmVsKCkucGFyZW50Tm9kZSAhPT0gdGhpcy5lbCgpICYmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnIHx8ICF0aGlzLnRhZykpIHtcbiAgICAgIHByZXBlbmRUbyh0aGlzLnRlY2hfLmVsKCksIHRoaXMuZWwoKSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHJpZCBvZiB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnIHJlZmVyZW5jZSBhZnRlciB0aGUgZmlyc3QgdGVjaCBpcyBsb2FkZWRcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XG4gICAgICB0aGlzLnRhZyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbmxvYWQgYW5kIGRpc3Bvc2Ugb2YgdGhlIGN1cnJlbnQgcGxheWJhY2sge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudW5sb2FkVGVjaF8gPSBmdW5jdGlvbiB1bmxvYWRUZWNoXygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgdGV4dCB0cmFja3Mgc28gdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGV4dCB0cmFja3Mgd2l0aCB0aGUgbmV4dCB0ZWNoXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICAgICAgX3RoaXMzW3Byb3BzLnByaXZhdGVOYW1lXSA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dFRyYWNrc0pzb25fID0gdGV4dFRyYWNrQ29udmVydGVyLnRleHRUcmFja3NUb0pzb24odGhpcy50ZWNoXyk7XG5cbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XG5cbiAgICB0aGlzLnRlY2hfLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMudGVjaF8gPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHtAbGluayBUZWNofS5cbiAgICogSXQgd2lsbCBwcmludCBhIHdhcm5pbmcgYnkgZGVmYXVsdCBhYm91dCB0aGUgZGFuZ2VyIG9mIHVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5XG4gICAqIGJ1dCBhbnkgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgaW4gd2lsbCBzaWxlbmNlIHRoZSB3YXJuaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtzYWZldHldXG4gICAqICAgICAgICBBbnl0aGluZyBwYXNzZWQgaW4gdG8gc2lsZW5jZSB0aGUgd2FybmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNofVxuICAgKiAgICAgICAgIFRoZSBUZWNoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoID0gZnVuY3Rpb24gdGVjaChzYWZldHkpIHtcbiAgICBpZiAoc2FmZXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlY2hfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgY2xpY2sgYW5kIHRvdWNoIGxpc3RlbmVycyBmb3IgdGhlIHBsYXliYWNrIGVsZW1lbnRcbiAgICpcbiAgICogLSBPbiBkZXNrdG9wczogYSBjbGljayBvbiB0aGUgdmlkZW8gaXRzZWxmIHdpbGwgdG9nZ2xlIHBsYXliYWNrXG4gICAqIC0gT24gbW9iaWxlIGRldmljZXM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIHRvZ2dsZXMgY29udHJvbHNcbiAgICogICB3aGljaCBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxuICAgKiAgIGluYWN0aXZlXG4gICAqIC0gQSB0YXAgY2FuIHNpZ25hbCB0aGF0IGEgdXNlciBoYXMgYmVjb21lIGFjdGl2ZSBvciBoYXMgYmVjb21lIGluYWN0aXZlXG4gICAqICAgZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcbiAgICogICBxdWljayB0YXAgc2hvdWxkIGhpZGUgdGhlbSBhZ2FpbiAoc2lnbmFsaW5nIHRoZSB1c2VyIGlzIGluIGFuIGluYWN0aXZlXG4gICAqICAgdmlld2luZyBzdGF0ZSlcbiAgICogLSBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcbiAgICogICBhIGZldyBzZWNvbmRzIG9mIGluYWN0aXZpdHkuXG4gICAqXG4gICAqID4gTm90ZTogdGhlIG9ubHkgcGFydCBvZiBpT1MgaW50ZXJhY3Rpb24gd2UgY2FuJ3QgbWltaWMgd2l0aCB0aGlzIHNldHVwXG4gICAqIGlzIGEgdG91Y2ggYW5kIGhvbGQgb24gdGhlIHZpZGVvIGVsZW1lbnQgY291bnRpbmcgYXMgYWN0aXZpdHkgaW4gb3JkZXIgdG9cbiAgICoga2VlcCB0aGUgY29udHJvbHMgc2hvd2luZywgYnV0IHRoYXQgc2hvdWxkbid0IGJlIGFuIGlzc3VlLiBBIHRvdWNoIGFuZCBob2xkXG4gICAqIG9uIGFueSBjb250cm9scyB3aWxsIHN0aWxsIGtlZXAgdGhlIHVzZXIgYWN0aXZlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBNYWtlIHN1cmUgdG8gcmVtb3ZlIGFsbCB0aGUgcHJldmlvdXMgbGlzdGVuZXJzIGluIGNhc2Ugd2UgYXJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcblxuICAgIC8vIFNvbWUgYnJvd3NlcnMgKENocm9tZSAmIElFKSBkb24ndCB0cmlnZ2VyIGEgY2xpY2sgb24gYSBmbGFzaCBzd2YsIGJ1dCBkb1xuICAgIC8vIHRyaWdnZXIgbW91c2Vkb3duL3VwLlxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcbiAgICAvLyBBbnkgdG91Y2ggZXZlbnRzIGFyZSBzZXQgdG8gYmxvY2sgdGhlIG1vdXNlZG93biBldmVudCBmcm9tIGhhcHBlbmluZ1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XG5cbiAgICAvLyBJZiB0aGUgY29udHJvbHMgd2VyZSBoaWRkZW4gd2UgZG9uJ3Qgd2FudCB0aGF0IHRvIGNoYW5nZSB3aXRob3V0IGEgdGFwIGV2ZW50XG4gICAgLy8gc28gd2UnbGwgY2hlY2sgaWYgdGhlIGNvbnRyb2xzIHdlcmUgYWxyZWFkeSBzaG93aW5nIGJlZm9yZSByZXBvcnRpbmcgdXNlclxuICAgIC8vIGFjdGl2aXR5XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XG5cbiAgICAvLyBUaGUgdGFwIGxpc3RlbmVyIG5lZWRzIHRvIGNvbWUgYWZ0ZXIgdGhlIHRvdWNoZW5kIGxpc3RlbmVyIGJlY2F1c2UgdGhlIHRhcFxuICAgIC8vIGxpc3RlbmVyIGNhbmNlbHMgb3V0IGFueSByZXBvcnRlZFVzZXJBY3Rpdml0eSB3aGVuIHNldHRpbmcgdXNlckFjdGl2ZShmYWxzZSlcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdXNlZCBmb3IgY2xpY2sgYW5kIHRhcCBjb250cm9scy4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18gPSBmdW5jdGlvbiByZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8ganVzdCB1c2UgYHRoaXMub2ZmKClgIGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbmVlZGVkXG4gICAgLy8gbGlzdGVuZXJzIGFkZGVkIGJ5IHRlY2hzIHRoYXQgZXh0ZW5kIHRoaXMuXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaE1vdmVfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQbGF5ZXIgd2FpdHMgZm9yIHRoZSB0ZWNoIHRvIGJlIHJlYWR5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUmVhZHlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFJlYWR5XygpIHtcbiAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xuXG4gICAgLy8gS2VlcCB0aGUgc2FtZSB2b2x1bWUgYXMgYmVmb3JlXG4gICAgaWYgKHRoaXMuY2FjaGVfLnZvbHVtZSkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFZvbHVtZScsIHRoaXMuY2FjaGVfLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gTG9vayBpZiB0aGUgdGVjaCBmb3VuZCBhIGhpZ2hlciByZXNvbHV0aW9uIHBvc3RlciB3aGlsZSBsb2FkaW5nXG4gICAgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBkdXJhdGlvbiBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKTtcblxuICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIGJvdGggaGF2ZSBpc3N1ZXMgd2l0aCBhdXRvcGxheS5cbiAgICAvLyBJbiBTYWZhcmkgKDUuMS4xKSwgd2hlbiB3ZSBtb3ZlIHRoZSB2aWRlbyBlbGVtZW50IGludG8gdGhlIGNvbnRhaW5lciBkaXYsIGF1dG9wbGF5IGRvZXNuJ3Qgd29yay5cbiAgICAvLyBJbiBDaHJvbWUgKDE1KSwgaWYgeW91IGhhdmUgYXV0b3BsYXkgKyBhIHBvc3RlciArIG5vIGNvbnRyb2xzLCB0aGUgdmlkZW8gZ2V0cyBoaWRkZW4gKGJ1dCBhdWRpbyBwbGF5cylcbiAgICAvLyBUaGlzIGZpeGVzIGJvdGggaXNzdWVzLiBOZWVkIHRvIHdhaXQgZm9yIEFQSSwgc28gaXQgdXBkYXRlcyBkaXNwbGF5cyBjb3JyZWN0bHlcbiAgICBpZiAoKHRoaXMuc3JjKCkgfHwgdGhpcy5jdXJyZW50U3JjKCkpICYmIHRoaXMudGFnICYmIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgJiYgdGhpcy5wYXVzZWQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hyb21lIEZpeC4gRml4ZWQgaW4gQ2hyb21lIHYxNi5cbiAgICAgICAgZGVsZXRlIHRoaXMudGFnLnBvc3RlcjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nJDEoJ2RlbGV0aW5nIHRhZy5wb3N0ZXIgdGhyb3dzIGluIHNvbWUgYnJvd3NlcnMnLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGxvYWRzdGFydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uIFRoaXNcbiAgICogZnVuY3Rpb24gd2lsbCBhbHNvIHRyaWdnZXIge0BsaW5rIFBsYXllciNmaXJzdHBsYXl9IGlmIGl0IGlzIHRoZSBmaXJzdCBsb2Fkc3RhcnRcbiAgICogZm9yIGEgdmlkZW8uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkU3RhcnRfKCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG5cbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVycm9yKG51bGwpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cbiAgICAvLyBUaGUgZmlyc3RwbGF5IGV2ZW50IHJlbGllcyBvbiBib3RoIHRoZSBwbGF5IGFuZCBsb2Fkc3RhcnQgZXZlbnRzXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBpbiBhbnkgb3JkZXIgZm9yIGEgbmV3IHNvdXJjZVxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGFnZW50IGJlZ2lucyBsb29raW5nIGZvciBtZWRpYSBkYXRhXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciNsb2Fkc3RhcnRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBoYXNTdGFydGVkIHN0YXRlXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUgdGhlIHZqcy1oYXMtc3RhcnRlZCBjbGFzc1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVlc3RcbiAgICogICAgICAgIC0gdHJ1ZTogYWRkcyB0aGUgY2xhc3NcbiAgICogICAgICAgIC0gZmFsc2U6IHJlbW92ZSB0aGUgY2xhc3NcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBoYXNTdGFydGVkX1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uIGhhc1N0YXJ0ZWQocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXIsIGlmIHdlIGhhdmUgbm8gcmVxdWVzdCB0byBjaGFuZ2VcbiAgICAgIHJldHVybiB0aGlzLmhhc1N0YXJ0ZWRfO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0ID09PSB0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNTdGFydGVkXyA9IHJlcXVlc3Q7XG5cbiAgICBpZiAodGhpcy5oYXNTdGFydGVkXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXl9XG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheVxuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5XygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcblxuICAgIC8vIGhpZGUgdGhlIHBvc3RlciB3aGVuIHRoZSB1c2VyIGhpdHMgcGxheVxuICAgIHRoaXMuaGFzU3RhcnRlZCh0cnVlKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbmV2ZXIgYW4ge0BsaW5rIFRlY2gjcGxheX0gZXZlbnQgaGFwcGVucy4gSW5kaWNhdGVzIHRoYXRcbiAgICAgKiBwbGF5YmFjayBoYXMgc3RhcnRlZCBvciByZXN1bWVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNwbGF5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGB3YWl0aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN3YWl0aW5nXG4gICAqIEBsaXN0ZW5zIFRlY2gjd2FpdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFdhaXRpbmdfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFdhaXRpbmdfKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBBIHJlYWR5U3RhdGUgY2hhbmdlIG9uIHRoZSBET00gZWxlbWVudCBoYXMgY2F1c2VkIHBsYXliYWNrIHRvIHN0b3AuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3dhaXRpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XG4gICAgdGhpcy5vbmUoJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXM0LnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBjYW5wbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBjb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnMuIFNlZSAjMTM1MVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2NhbnBsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNjYW5wbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2FuUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaGFzIGEgcmVhZHlTdGF0ZSBvZiBIQVZFX0ZVVFVSRV9EQVRBIG9yIGdyZWF0ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXlcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXl0aHJvdWdoYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5dGhyb3VnaFxuICAgKiBAbGlzdGVucyBUZWNoI2NhbnBsYXl0aHJvdWdoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRU5PVUdIX0RBVEEgb3IgZ3JlYXRlci4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAqIGVudGlyZSBtZWRpYSBmaWxlIGNhbiBiZSBwbGF5ZWQgd2l0aG91dCBidWZmZXJpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXl0aHJvdWdoXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignY2FucGxheXRocm91Z2gnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGxheWluZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheWluZ1xuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5aW5nXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtd2FpdGluZycpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZWRpYSBpcyBubyBsb25nZXIgYmxvY2tlZCBmcm9tIHBsYXliYWNrLCBhbmQgaGFzIHN0YXJ0ZWQgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheWluZ1xuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXlpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2luZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2luZ1xuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVraW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVraW5nXygpIHtcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBwbGF5ZXIgaXMganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3NlZWtpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdzZWVraW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNlZWtlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjc2Vla2VkXG4gICAqIEBsaXN0ZW5zIFRlY2gjc2Vla2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hTZWVrZWRfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBmaW5pc2hlZCBqdW1waW5nIHRvIGEgbmV3IHRpbWVcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2VkXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGZpcnN0cGxheWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjZmlyc3RwbGF5XG4gICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIHBhc3NpbmcgdGhlIGBzdGFydHRpbWVgIG9wdGlvbiB0byB0aGUgcGxheWVyIGFuZCB0aGUgZmlyc3RwbGF5IGV2ZW50IGFyZSBkZXByZWNhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZpcnN0UGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRmlyc3RQbGF5XygpIHtcbiAgICAvLyBJZiB0aGUgZmlyc3Qgc3RhcnR0aW1lIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWRcbiAgICAvLyB0aGVuIHdlIHdpbGwgc3RhcnQgYXQgdGhlIGdpdmVuIG9mZnNldCBpbiBzZWNvbmRzXG4gICAgaWYgKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKSB7XG4gICAgICBsb2ckMS53YXJuKCdQYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gNi4wJyk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lKHRoaXMub3B0aW9uc18uc3RhcnR0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB0aGUgZmlyc3QgdGltZSBhIHZpZGVvIGlzIHBsYXllZC4gTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgdGhpcyBpc1xuICAgICAqIHByb2JhYmx5IG5vdCB0aGUgYmVzdCBpbXBsZW1lbnRhdGlvbiB5ZXQsIHNvIHVzZSBzcGFyaW5nbHkuIElmIHlvdSBkb24ndCBoYXZlIGFcbiAgICAgKiByZWFzb24gdG8gcHJldmVudCBwbGF5YmFjaywgdXNlIGBteVBsYXllci5vbmUoJ3BsYXknKTtgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2ZpcnN0cGxheVxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBmaXJzdHBsYXkgZXZlbnQgaXMgZGVwcmVjYXRlZC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGF1c2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BhdXNlXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGF1c2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQYXVzZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGF1c2VfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGF1c2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW5kZWRcbiAgICogQGxpc3RlbnMgVGVjaCNlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVuZGVkXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFbmRlZF8oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgaWYgKHRoaXMub3B0aW9uc18ubG9vcCkge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSgwKTtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNlbmRlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2VuZGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBmaXJzdCBrbm93biBvciBjaGFuZ2VkXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCkge1xuICAgIHRoaXMuZHVyYXRpb24odGhpcy50ZWNoR2V0XygnZHVyYXRpb24nKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIHBsYXkvcGF1c2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHRyaWdnZXJcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNtb3VzZWRvd25cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoQ2xpY2tfKGV2ZW50KSB7XG4gICAgaWYgKCFpc1NpbmdsZUxlZnRDbGljayhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvbnRyb2xzIGFyZSBkaXNhYmxlZCBhIGNsaWNrIHNob3VsZCBub3QgdG9nZ2xlIHBsYXliYWNrIGJlY2F1c2VcbiAgICAvLyB0aGUgY2xpY2sgaXMgY29uc2lkZXJlZCBhIGNvbnRyb2xcbiAgICBpZiAoIXRoaXMuY29udHJvbHNfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSB0YXAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHdpbGwgdG9nZ2xlIHRoZSB1c2VyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RhcFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRhcF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGFwXygpIHtcbiAgICB0aGlzLnVzZXJBY3RpdmUoIXRoaXMudXNlckFjdGl2ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIHN0YXJ0XG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2hzdGFydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoU3RhcnRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoU3RhcnRfKCkge1xuICAgIHRoaXMudXNlcldhc0FjdGl2ZSA9IHRoaXMudXNlckFjdGl2ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG91Y2ggdG8gbW92ZVxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNobW92ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hNb3ZlXygpIHtcbiAgICBpZiAodGhpcy51c2VyV2FzQWN0aXZlKSB7XG4gICAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIGVuZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgdGhlIHRvdWNoZW5kIGV2ZW50IHRoYXQgdHJpZ2dlcmVkXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjdG91Y2hlbmRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaEVuZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hFbmRfKGV2ZW50KSB7XG4gICAgLy8gU3RvcCB0aGUgbW91c2UgZXZlbnRzIGZyb20gYWxzbyBoYXBwZW5pbmdcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgc3dpdGNoZXMgaW4gb3Igb3V0IG9mIGZ1bGxzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlXygpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZ1bGxzY3JlZW4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIG5hdGl2ZSBjbGljayBldmVudHMgb24gdGhlIFNXRiBhcmVuJ3QgdHJpZ2dlcmVkIG9uIElFMTEsIFdpbjguMVJUXG4gICAqIHVzZSBzdGFnZWNsaWNrIGV2ZW50cyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgdGhlIFNXRiBpbnN0ZWFkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIHN0YWdlY2xpY2tcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVN0YWdlQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlU3RhZ2VDbGlja18oKSB7XG4gICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIFRlY2ggRnVsbHNjcmVlbiBDaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogICAgICAgIHRoZSBkYXRhIHRoYXQgd2FzIHNlbnQgd2l0aCB0aGUgZXZlbnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNmdWxsc2NyZWVuY2hhbmdlXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEZ1bGxzY3JlZW5DaGFuZ2VfKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuKGRhdGEuaXNGdWxsc2NyZWVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBnb2luZyBpbiBhbmQgb3V0IG9mIGZ1bGxzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmVzIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBUZWNoI2Vycm9yXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRXJyb3JfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEVycm9yXygpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnRlY2hfLmVycm9yKCk7XG5cbiAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgdGV4dGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3RleHRkYXRhXG4gICAqIEBsaXN0ZW5zIFRlY2gjdGV4dGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUZXh0RGF0YV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVGV4dERhdGFfKCkge1xuICAgIHZhciBkYXRhID0gbnVsbDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB3aGVuIHdlIGdldCBhIHRleHRkYXRhIGV2ZW50IGZyb20gdGVjaFxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciN0ZXh0ZGF0YVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3RleHRkYXRhJywgZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvYmplY3QgZm9yIGNhY2hlZCB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBnZXQgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5nZXRDYWNoZSA9IGZ1bmN0aW9uIGdldENhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXztcbiAgfTtcblxuICAvKipcbiAgICogUGFzcyB2YWx1ZXMgdG8gdGhlIHBsYXliYWNrIHRlY2hcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2RdXG4gICAqICAgICAgICB0aGUgbWV0aG9kIHRvIGNhbGxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICAgKiAgICAgICAgdGhlIGFyZ3VtZW50IHRvIHBhc3NcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hDYWxsXyA9IGZ1bmN0aW9uIHRlY2hDYWxsXyhtZXRob2QsIGFyZykge1xuICAgIC8vIElmIGl0J3Mgbm90IHJlYWR5IHlldCwgY2FsbCBtZXRob2Qgd2hlbiBpdCBpc1xuXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWV0aG9kIGluIGFsbG93ZWRTZXR0ZXJzKSB7XG4gICAgICAgIHJldHVybiBzZXQkMSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QsIGFyZyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICAgICAgdGhpcy50ZWNoX1ttZXRob2RdKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nJDEoZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAqICAgICAgICBUZWNoIG1ldGhvZFxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqICAgICAgICAgdGhlIG1ldGhvZCBvciB1bmRlZmluZWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hHZXRfID0gZnVuY3Rpb24gdGVjaEdldF8obWV0aG9kKSB7XG4gICAgaWYgKCF0aGlzLnRlY2hfIHx8ICF0aGlzLnRlY2hfLmlzUmVhZHlfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkR2V0dGVycykge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgIC8vIEluIHRoZXNlIGNhc2VzIHRoZSBvYmplY3QgbWV0aG9kcyBnbyBhd2F5IGFuZCB3ZSBnZXQgZXJyb3JzLlxuICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfW21ldGhvZF0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIFdoZW4gYnVpbGRpbmcgYWRkaXRpb25hbCB0ZWNoIGxpYnMsIGFuIGV4cGVjdGVkIG1ldGhvZCBtYXkgbm90IGJlIGRlZmluZWQgeWV0XG4gICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyBtZXRob2Qgbm90IGRlZmluZWQgZm9yICcgKyB0aGlzLnRlY2hOYW1lXyArICcgcGxheWJhY2sgdGVjaG5vbG9neS4nLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGxvZyQxKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgdW5hdmFpbGFibGUgb24gJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuJywgZSk7XG4gICAgICAgIHRoaXMudGVjaF8uaXNSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXJyb3IgdW5rbm93biwganVzdCBsb2cgYW5kIHRocm93XG4gICAgICBsb2ckMShlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGJlZ2luIHBsYXliYWNrIGF0IHRoZSBmaXJzdCBvcHBvcnR1bml0eS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9XG4gICAqICAgICAgICAgUmV0dXJucyBhIGBQcm9taXNlYCBvbmx5IGlmIHRoZSBicm93c2VyIHJldHVybnMgb25lIGFuZCB0aGUgcGxheWVyXG4gICAqICAgICAgICAgaXMgcmVhZHkgdG8gYmVnaW4gcGxheWJhY2suIEZvciBzb21lIGJyb3dzZXJzIGFuZCBhbGwgbm9uLXJlYWR5XG4gICAqICAgICAgICAgc2l0dWF0aW9ucywgdGhpcyB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgd2hpbGUgd2UgaGF2ZSBhIHBsYXkgcXVldWVkIHVwIG9uIGEgbG9hZHN0YXJ0LCByZW1vdmVcbiAgICAvLyB0aGF0IGxpc3RlbmVyIHRvIGF2b2lkIGdldHRpbmcgaW4gYSBwb3RlbnRpYWxseSBiYWQgc3RhdGUuXG4gICAgaWYgKHRoaXMucGxheU9uTG9hZHN0YXJ0Xykge1xuICAgICAgdGhpcy5vZmYoJ2xvYWRzdGFydCcsIHRoaXMucGxheU9uTG9hZHN0YXJ0Xyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIG5vdCByZWFkeSwgcXVldWUgdXAgYW5vdGhlciBjYWxsIHRvIGBwbGF5KClgIGZvclxuICAgIC8vIHdoZW4gaXQgaXMuIFRoaXMgd2lsbCBsb29wIGJhY2sgaW50byB0aGlzIG1ldGhvZCBmb3IgYW5vdGhlciBhdHRlbXB0IGF0XG4gICAgLy8gcGxheWJhY2sgd2hlbiB0aGUgdGVjaCBpcyByZWFkeS5cbiAgICBpZiAoIXRoaXMuaXNSZWFkeV8pIHtcblxuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYWxyZWFkeSB3YWl0aW5nIGZvciBgcmVhZHlgIVxuICAgICAgaWYgKHRoaXMucGxheVdhaXRpbmdGb3JSZWFkeV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBsYXlXYWl0aW5nRm9yUmVhZHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUucGxheVdhaXRpbmdGb3JSZWFkeV8gPSBmYWxzZTtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM1LnBsYXkoKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlIHBsYXllci90ZWNoIGlzIHJlYWR5IGFuZCB3ZSBoYXZlIGEgc291cmNlLCB3ZSBjYW4gYXR0ZW1wdCBwbGF5YmFjay5cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNoYW5naW5nU3JjXyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XG5cbiAgICAgIC8vIElmIHRoZSB0ZWNoIGlzIHJlYWR5LCBidXQgd2UgZG8gbm90IGhhdmUgYSBzb3VyY2UsIHdlJ2xsIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gZm9yIGJvdGggdGhlIGByZWFkeWAgYW5kIGEgYGxvYWRzdGFydGAgd2hlbiB0aGUgc291cmNlIGlzIGZpbmFsbHlcbiAgICAgIC8vIHJlc29sdmVkIGJ5IG1pZGRsZXdhcmUgYW5kIHNldCBvbiB0aGUgcGxheWVyLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgcGxheSgpYCBpcyBjYWxsZWQgd2hpbGUgY2hhbmdpbmcgc291cmNlcyBvciBiZWZvcmVcbiAgICAgIC8vIG9uZSBoYXMgYmVlbiBzZXQgb24gdGhlIHBsYXllci5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLnBsYXlPbkxvYWRzdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5wbGF5T25Mb2Fkc3RhcnRfID0gbnVsbDtcbiAgICAgICAgc2lsZW5jZVByb21pc2UoX3RoaXM1LnBsYXkoKSk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uZSgnbG9hZHN0YXJ0JywgdGhpcy5wbGF5T25Mb2Fkc3RhcnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBvYmplY3QgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMudGVjaENhbGxfKCdwYXVzZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCBvciBoYXMgeWV0IHRvIHBsYXlcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIGZhbHNlOiBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmdcbiAgICogICAgICAgICAtIHRydWU6IGlmIG1lZGlhIGlzIG5vdCBjdXJyZW50bHkgcGxheWluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKCkge1xuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BhdXNlZCcpID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCB0aGUgdXNlclxuICAgKiBoYXMgcGxheWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgQSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYWxsIHRoZSBpbmNyZW1lbnRzIG9mIHRpbWUgdGhhdCBoYXZlXG4gICAqICAgICAgICAgYmVlbiBwbGF5ZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ZWQgPSBmdW5jdGlvbiBwbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXllZCcpIHx8IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgXCJzY3J1YmJpbmdcIi4gU2NydWJiaW5nIGlzXG4gICAqIHdoZW4gdGhlIHVzZXIgaGFzIGNsaWNrZWQgdGhlIHByb2dyZXNzIGJhciBoYW5kbGUgYW5kIGlzXG4gICAqIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2NydWJiaW5nXVxuICAgKiAgICAgICAgd2V0aGVyIHRoZSB1c2VyIGlzIG9yIGlzIG5vdCBzY3J1YmJpbmdcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgdmFsdWUgb2Ygc2NydWJiaW5nIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2NydWJiaW5nID0gZnVuY3Rpb24gc2NydWJiaW5nKGlzU2NydWJiaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBpc1NjcnViYmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcnViYmluZ187XG4gICAgfVxuICAgIHRoaXMuc2NydWJiaW5nXyA9ICEhaXNTY3J1YmJpbmc7XG5cbiAgICBpZiAoaXNTY3J1YmJpbmcpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNjcnViYmluZycpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIHRpbWUgdG8gc2VlayB0byBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRUaW1lID0gZnVuY3Rpb24gY3VycmVudFRpbWUoc2Vjb25kcykge1xuICAgIGlmICh0eXBlb2Ygc2Vjb25kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIGxhc3QgY3VycmVudFRpbWUgYW5kIHJldHVybi4gZGVmYXVsdCB0byAwIHNlY29uZHNcbiAgICAvL1xuICAgIC8vIENhY2hpbmcgdGhlIGN1cnJlbnRUaW1lIGlzIG1lYW50IHRvIHByZXZlbnQgYSBtYXNzaXZlIGFtb3VudCBvZiByZWFkcyBvbiB0aGUgdGVjaCdzXG4gICAgLy8gY3VycmVudFRpbWUgd2hlbiBzY3J1YmJpbmcsIGJ1dCBtYXkgbm90IHByb3ZpZGUgbXVjaCBwZXJmb3JtYW5jZSBiZW5lZml0IGFmdGVyYWxsLlxuICAgIC8vIFNob3VsZCBiZSB0ZXN0ZWQuIEFsc28gc29tZXRoaW5nIGhhcyB0byByZWFkIHRoZSBhY3R1YWwgY3VycmVudCB0aW1lIG9yIHRoZSBjYWNoZSB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IHVwZGF0ZWQuXG4gICAgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPSB0aGlzLnRlY2hHZXRfKCdjdXJyZW50VGltZScpIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb3JtYWxseSBnZXRzIHRoZSBsZW5ndGggaW4gdGltZSBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcztcbiAgICogaW4gYWxsIGJ1dCB0aGUgcmFyZXN0IHVzZSBjYXNlcyBhbiBhcmd1bWVudCB3aWxsIE5PVCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKlxuICAgKiA+ICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxuICAgKiBrbm93biwgYW5kIGluIHRoZSBjYXNlIG9mIEZsYXNoLCBtYXkgbm90IGJlIGtub3duIHVudGlsIHRoZSB2aWRlbyBzdGFydHNcbiAgICogcGxheWluZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHNdXG4gICAqICAgICAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIHRvIHNldCBpbiBzZWNvbmRzXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBOYU4gaWYgdGhlIGR1cmF0aW9uIGlzIG5vdCBrbm93blxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLmNhY2hlXy5kdXJhdGlvbiA6IE5hTjtcbiAgICB9XG5cbiAgICBzZWNvbmRzID0gcGFyc2VGbG9hdChzZWNvbmRzKTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG9uIEluaWZpdHkgZm9yIHNpZ25hbGluZyB2aWRlbyBpcyBsaXZlXG4gICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICBzZWNvbmRzID0gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKHNlY29uZHMgIT09IHRoaXMuY2FjaGVfLmR1cmF0aW9uKSB7XG4gICAgICAvLyBDYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWUgZm9yIG9wdGltaXplZCBzY3J1YmJpbmcgKGVzcC4gRmxhc2gpXG4gICAgICB0aGlzLmNhY2hlXy5kdXJhdGlvbiA9IHNlY29uZHM7XG5cbiAgICAgIGlmIChzZWNvbmRzID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtbGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNkdXJhdGlvbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBpbiB0aGUgdmlkZW8uIE5vdCBwYXJ0XG4gICAqIG9mIHRoZSBuYXRpdmUgdmlkZW8gQVBJLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmVtYWluaW5nIGluIHNlY29uZHNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbWFpbmluZ1RpbWUgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uKCkgLSB0aGlzLmN1cnJlbnRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcmVtYWluaW5nIHRpbWUgZnVuY3Rpb24gdGhhdCBpcyBpbnRlbnRlZCB0byBiZSB1c2VkIHdoZW5cbiAgICogdGhlIHRpbWUgaXMgdG8gYmUgZGlzcGxheWVkIGRpcmVjdGx5IHRvIHRoZSB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIHJvdW5kZWQgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiByZW1haW5pbmdUaW1lRGlzcGxheSgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmR1cmF0aW9uKCkpIC0gTWF0aC5mbG9vcih0aGlzLmN1cnJlbnRUaW1lKCkpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW9cbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcbiAgICogdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCwgdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICpcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG5hdGl2ZSBIVE1MIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50XG4gICAqICAgICAgICAgdGhhdCBpcyBidWZmZXJyZWQgMCBiZWluZyAwJSBhbmQgMSBiZWluZyAxMDAlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cbiAgICogICAgICAgICBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUgYXMgYSBwZXJjZW50IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICB2YXIgdm9sID0gdm9pZCAwO1xuXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7XG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgaWYgKHZvbCA+IDApIHtcbiAgICAgICAgdGhpcy5sYXN0Vm9sdW1lXyh2b2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIG11dGVcbiAgICogICAgICAgIC0gZmFsc2UgdG8gdW5tdXRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIG11dGUgaXMgb24gYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKF9tdXRlZCkge1xuICAgIGlmIChfbXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkZWZhdWx0TXV0ZWQgc3RhdGUsIG9yIHR1cm4gZGVmYXVsdE11dGVkIG9uIG9yIG9mZi4gZGVmYXVsdE11dGVkXG4gICAqIGluZGljYXRlcyB0aGUgc3RhdGUgb2YgbXV0ZWQgb24gaW50aWFsIHBsYXliYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgIHZhciBteVBsYXllciA9IHZpZGVvanMoJ3NvbWUtcGxheWVyLWlkJyk7XG4gICAqXG4gICAqICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogICAvLyBzZXQgdG8gdHJ1ZVxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcbiAgICogICAvLyBnZXQgc2hvdWxkIGJlIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhteVBsYXllci5kZWZhdWx0TXV0ZWQoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0TXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGRlZmF1bHRNdXRlZCBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZGVmYXVsdE11dGVkIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdE11dGVkID0gZnVuY3Rpb24gZGVmYXVsdE11dGVkKF9kZWZhdWx0TXV0ZWQpIHtcbiAgICBpZiAoX2RlZmF1bHRNdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdE11dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkICYmIHBlcmNlbnRBc0RlY2ltYWwgIT09IDApIHtcbiAgICAgIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8ubGFzdFZvbHVtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gICAqIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIGlmIG5hdGl2ZSBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGUgb3IgdGVsbCB0aGUgcGxheWVyIHRoYXQgaXRcbiAgICogaXMgb3IgaXMgbm90IGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICpcbiAgICogPiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtpc0ZTXVxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBvbihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGxfKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlXG4gICAqIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZW50ZXJGdWxsV2luZG93ID0gZnVuY3Rpb24gZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlbnRlckZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3JcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2V4aXRGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3ZpZGVvLmh0bWwjZG9tLW5hdmlnYXRvci1jYW5wbGF5dHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0galtpXTtcbiAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICBpZiAodGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNhbiA9IHRlY2guY2FuUGxheVR5cGUodHlwZSk7XG5cbiAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgIHJldHVybiBjYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzb3VyY2UgYmFzZWQgb24gdGVjaC1vcmRlciBvciBzb3VyY2Utb3JkZXJcbiAgICogVXNlcyBzb3VyY2Utb3JkZXIgc2VsZWN0aW9uIGlmIGBvcHRpb25zLnNvdXJjZU9yZGVyYCBpcyB0cnV0aHkuIE90aGVyd2lzZSxcbiAgICogZGVmYXVsdHMgdG8gdGVjaC1vcmRlciBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlc1xuICAgKiAgICAgICAgVGhlIHNvdXJjZXMgZm9yIGEgbWVkaWEgYXNzZXRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fGJvb2xlYW59XG4gICAqICAgICAgICAgT2JqZWN0IG9mIHNvdXJjZSBhbmQgdGVjaCBvcmRlciBvciBmYWxzZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2VsZWN0U291cmNlID0gZnVuY3Rpb24gc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIEdldCBvbmx5IHRoZSB0ZWNocyBzcGVjaWZpZWQgaW4gYHRlY2hPcmRlcmAgdGhhdCBleGlzdCBhbmQgYXJlIHN1cHBvcnRlZCBieSB0aGVcbiAgICAvLyBjdXJyZW50IHBsYXRmb3JtXG4gICAgdmFyIHRlY2hzID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubWFwKGZ1bmN0aW9uICh0ZWNoTmFtZSkge1xuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgVGVjaC5nZXRUZWNoKHRlY2hOYW1lKV07XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmWzFdO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICh0ZWNoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICByZXR1cm4gdGVjaC5pc1N1cHBvcnRlZCgpO1xuICAgICAgfVxuXG4gICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYGlubmVyQXJyYXlgIGVsZW1lbnQgb25jZSBwZXIgYG91dGVyQXJyYXlgIGVsZW1lbnQgYW5kIGV4ZWN1dGVcbiAgICAvLyBgdGVzdGVyYCB3aXRoIGJvdGguIElmIGB0ZXN0ZXJgIHJldHVybnMgYSBub24tZmFsc3kgdmFsdWUsIGV4aXQgZWFybHkgYW5kIHJldHVyblxuICAgIC8vIHRoYXQgdmFsdWUuXG4gICAgdmFyIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpciA9IGZ1bmN0aW9uIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihvdXRlckFycmF5LCBpbm5lckFycmF5LCB0ZXN0ZXIpIHtcbiAgICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcblxuICAgICAgb3V0ZXJBcnJheS5zb21lKGZ1bmN0aW9uIChvdXRlckNob2ljZSkge1xuICAgICAgICByZXR1cm4gaW5uZXJBcnJheS5zb21lKGZ1bmN0aW9uIChpbm5lckNob2ljZSkge1xuICAgICAgICAgIGZvdW5kID0gdGVzdGVyKG91dGVyQ2hvaWNlLCBpbm5lckNob2ljZSk7XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICB2YXIgZm91bmRTb3VyY2VBbmRUZWNoID0gdm9pZCAwO1xuICAgIHZhciBmbGlwID0gZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbihiLCBhKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZmluZGVyID0gZnVuY3Rpb24gZmluZGVyKF9yZWYyLCBzb3VyY2UpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKHRlY2guY2FuUGxheVNvdXJjZShzb3VyY2UsIF90aGlzNi5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgdHJ1dGhpbmVzcyBvZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAsIHdlIHN3YXAgdGhlIG9yZGVyIG9mIHRlY2hzIGFuZCBzb3VyY2VzXG4gICAgLy8gdG8gc2VsZWN0IGZyb20gdGhlbSBiYXNlZCBvbiB0aGVpciBwcmlvcml0eS5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VPcmRlcikge1xuICAgICAgLy8gU291cmNlLWZpcnN0IG9yZGVyaW5nXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIoc291cmNlcywgdGVjaHMsIGZsaXAoZmluZGVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRlY2gtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcih0ZWNocywgc291cmNlcywgZmluZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRTb3VyY2VBbmRUZWNoIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB2aWRlbyBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXXxzdHJpbmd9IFtzb3VyY2VdXG4gICAqICAgICAgICBBIFNvdXJjZU9iamVjdCwgYW4gYXJyYXkgb2YgU291cmNlT2JqZWN0cywgb3IgYSBzdHJpbmcgcmVmZXJlbmNpbmdcbiAgICogICAgICAgIGEgVVJMIHRvIGEgbWVkaWEgc291cmNlLiBJdCBpcyBfaGlnaGx5IHJlY29tbWVuZGVkXyB0aGF0IGFuIG9iamVjdFxuICAgKiAgICAgICAgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpcyB1c2VkIGhlcmUsIHNvIHRoYXQgc291cmNlIHNlbGVjdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtcyBjYW4gdGFrZSB0aGUgYHR5cGVgIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgYWN0cyBhcyBhIGdldHRlci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBJZiB0aGUgYHNvdXJjZWAgYXJndW1lbnQgaXMgbWlzc2luZywgcmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2VcbiAgICogICAgICAgICBVUkwuIE90aGVyd2lzZSwgcmV0dXJucyBub3RoaW5nL3VuZGVmaW5lZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYyB8fCAnJztcbiAgICB9XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHNvdXJjZXMgYW5kIHR1cm4gb3VyIHNvdXJjZSBpbnRvXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICB2YXIgc291cmNlcyA9IGZpbHRlclNvdXJjZShzb3VyY2UpO1xuXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxuICAgIC8vIGl0IHdhcyBmaWx0ZXJlZCB0byBhIHplcm8gbGVuZ3RoIEFycmF5LiBTbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2hvdyBhbiBlcnJvclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbnRpYWwgc291cmNlc1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgIC8vIGludGlhbCBzb3VyY2VcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSBzb3VyY2VzWzBdO1xuXG4gICAgLy8gbWlkZGxld2FyZVNvdXJjZSBpcyB0aGUgc291cmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNoYW5nZWQgYnkgbWlkZGxld2FyZVxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XG4gICAgICBfdGhpczcubWlkZGxld2FyZV8gPSBtd3M7XG5cbiAgICAgIHZhciBlcnIgPSBfdGhpczcuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNy5zcmMoc291cmNlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgX3RoaXM3LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgICAvLyB0aGlzIG5lZWRzIGEgYmV0dGVyIGNvbW1lbnQgYWJvdXQgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICAgIF90aGlzNy50cmlnZ2VyUmVhZHkoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNy5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIC8vIHZpZGVvIGVsZW1lbnQgbGlzdGVkIHNvdXJjZVxuICAgICAgX3RoaXM3LmNhY2hlXy5zcmMgPSBtaWRkbGV3YXJlU291cmNlLnNyYztcblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzNy50ZWNoXyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9iamVjdCBvbiB0aGUgdGVjaCwgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2V0aGVyXG4gICAqIHRoZXJlIGlzIGEgdGVjaCB0aGF0IGNhbiBwbGF5IHRoZSBzb3VyY2Ugb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZXJlIGlzIG5vIFRlY2ggdG8gcGxheWJhY2sgdGhpcyBzb3VyY2VcbiAgICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjXyA9IGZ1bmN0aW9uIHNyY18oc291cmNlKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShbc291cmNlXSk7XG5cbiAgICBpZiAoIXNvdXJjZVRlY2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGl0bGVDYXNlRXF1YWxzKHNvdXJjZVRlY2gudGVjaCwgdGhpcy50ZWNoTmFtZV8pKSB7XG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IHRydWU7XG5cbiAgICAgIC8vIGxvYWQgdGhpcyB0ZWNobm9sb2d5IHdpdGggdGhlIGNob3NlbiBzb3VyY2VcbiAgICAgIHRoaXMubG9hZFRlY2hfKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGRpcmVjdCBwcm90b3R5cGUgZm9yIHRoZSBjYXNlIHdoZXJlIHN1YmNsYXNzZXNcbiAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xuICAgICAgaWYgKHRoaXMudGVjaF8uY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZXRTb3VyY2UnKSkge1xuICAgICAgICB0aGlzLnRlY2hDYWxsXygnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzcmMnLCBzb3VyY2Uuc3JjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGlmIHBvc3NpYmxlICgjMjMyNilcbiAgICB9LCB0cnVlKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQmVnaW4gbG9hZGluZyB0aGUgc3JjIGRhdGEuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCgpIHtcbiAgICB0aGlzLnRlY2hDYWxsXygnbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcGxheWVyLiBMb2FkcyB0aGUgZmlyc3QgdGVjaCBpbiB0aGUgdGVjaE9yZGVyLFxuICAgKiBhbmQgY2FsbHMgYHJlc2V0YCBvbiB0aGUgdGVjaGAuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMubG9hZFRlY2hfKHRoaXMub3B0aW9uc18udGVjaE9yZGVyWzBdLCBudWxsKTtcbiAgICB0aGlzLnRlY2hDYWxsXygncmVzZXQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgb2YgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdHNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2VzID0gZnVuY3Rpb24gY3VycmVudFNvdXJjZXMoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuY3VycmVudFNvdXJjZSgpO1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICAvLyBhc3N1bWUgYHt9YCBvciBgeyBzcmMgfWBcbiAgICBpZiAoT2JqZWN0LmtleXMoc291cmNlKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2VzIHx8IHNvdXJjZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgc291cmNlIG9iamVjdFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNvdXJjZSA9IGZ1bmN0aW9uIGN1cnJlbnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNvdXJjZSB8fCB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIFVSTCBvZiB0aGUgY3VycmVudCBzb3VyY2UgdmFsdWUgZS5nLiBodHRwOi8vbXlzaXRlLmNvbS92aWRlby5tcDRcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIGBjdXJyZW50VHlwZWAgdG8gYXNzaXN0IGluIHJlYnVpbGRpbmcgdGhlIGN1cnJlbnQgc291cmNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNyYyA9IGZ1bmN0aW9uIGN1cnJlbnRTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZSgpICYmIHRoaXMuY3VycmVudFNvdXJjZSgpLnNyYyB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHNvdXJjZSB0eXBlIGUuZy4gdmlkZW8vbXA0XG4gICAqIFRoaXMgY2FuIGFsbG93IHlvdSByZWJ1aWxkIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgc28gdGhhdCB5b3UgY291bGQgbG9hZCB0aGUgc2FtZVxuICAgKiBzb3VyY2UgYW5kIHRlY2ggbGF0ZXJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBzb3VyY2UgTUlNRSB0eXBlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VHlwZSA9IGZ1bmN0aW9uIGN1cnJlbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS50eXBlIHx8ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwcmVsb2FkIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBwcmVsb2FkXG4gICAqICAgICAgICAtIGZhbHNlIG1hZW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBwcmVsb2FkXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgcHJlbG9hZCBhdHRyaWJ1dGUgdmFsdWUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gcHJlbG9hZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UHJlbG9hZCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ucHJlbG9hZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncHJlbG9hZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgLSB0cnVlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGF1dG9wbGF5XG4gICAqICAgICAgICAtIGZhbHNlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBhdXRvcGxheVxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgYXV0b3BsYXkgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5hdXRvcGxheSA9IGZ1bmN0aW9uIGF1dG9wbGF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRBdXRvcGxheScsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgPSB2YWx1ZTtcbiAgICAgIHRoaXMucmVhZHkodGhpcy5mb3JjZUF1dG9wbGF5SW5DaHJvbWVfKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2F1dG9wbGF5JywgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBjaHJvbWUgc3RhcnRlZCBwYXVzaW5nIHRoZSB2aWRlbyB3aGVuIG1vdmluZyBpbiB0aGUgRE9NXG4gICAqIGNhdXNpbmcgYXV0b3BsYXkgdG8gbm90IGNvbnRpbnVlIGR1ZSB0byBob3cgVmlkZW8uanMgZnVuY3Rpb25zLlxuICAgKiBTZWUgIzQ3MjAgZm9yIG1vcmUgaW5mby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZvcmNlQXV0b3BsYXlJbkNocm9tZV8gPSBmdW5jdGlvbiBmb3JjZUF1dG9wbGF5SW5DaHJvbWVfKCkge1xuICAgIGlmICh0aGlzLnBhdXNlZCgpICYmIChcbiAgICAvLyByZWFkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgb3Igb3B0aW9uc1xuICAgIHRoaXMuYXV0b3BsYXkoKSB8fCB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5KSAmJlxuICAgIC8vIG9ubHkgdGFyZ2V0IGRlc2t0b3AgY2hyb21lXG4gICAgSVNfQ0hST01FICYmICFJU19BTkRST0lEKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciB1bnNldCB0aGUgcGxheXNpbmxpbmUgYXR0cmlidXRlLlxuICAgKiBQbGF5c2lubGluZSB0ZWxscyB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdHJ5IHRvIHBsYXkgaW5saW5lIGJ5IGRlZmF1bHRcbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgdXNlIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBwbGF5YmFjayBtb2RlLFxuICAgKiAgICAgICAgICB3aGljaCBpbiBtb3N0IGNhc2VzIGlzIGlubGluZS4gaU9TIFNhZmFyaSBpcyBhIG5vdGFibGUgZXhjZXB0aW9uXG4gICAqICAgICAgICAgIGFuZCBwbGF5cyBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB2YWx1ZSBvZiBwbGF5c2lubGluZVxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBsYXlzaW5saW5lJywgdmFsdWUpO1xuICAgICAgdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5c2lubGluZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb29wIGF0dHJpYnV0ZSBvbiB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbG9vcCB0aGUgdmlkZW9cbiAgICogICAgICAgIC0gZmFsc2UgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxvb3AgdGhlIHZpZGVvXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBsb29wIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uIGxvb3AodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldExvb3AnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLmxvb3AgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2xvb3AnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcG9zdGVyIGltYWdlIHNvdXJjZSB1cmxcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdXG4gICAqICAgICAgICBQb3N0ZXIgaW1hZ2Ugc291cmNlIFVSTFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgcG9zdGVyIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKHNyYykge1xuICAgIGlmIChzcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zdGVyXztcbiAgICB9XG5cbiAgICAvLyBUaGUgY29ycmVjdCB3YXkgdG8gcmVtb3ZlIGEgcG9zdGVyIGlzIHRvIHNldCBhcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHNyYyA9ICcnO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcG9zdGVyIHZhcmlhYmxlXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xuXG4gICAgLy8gdXBkYXRlIHRoZSB0ZWNoJ3MgcG9zdGVyXG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBvc3RlcicsIHNyYyk7XG5cbiAgICAvLyBhbGVydCBjb21wb25lbnRzIHRoYXQgdGhlIHBvc3RlciBoYXMgYmVlbiBzZXRcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGZpcmVzIHdoZW4gdGhlIHBvc3RlciBpbWFnZSBpcyBjaGFuZ2VkIG9uIHRoZSBwbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb21lIHRlY2hzIChlLmcuIFlvdVR1YmUpIGNhbiBwcm92aWRlIGEgcG9zdGVyIHNvdXJjZSBpbiBhblxuICAgKiBhc3luY2hyb25vdXMgd2F5LiBXZSB3YW50IHRoZSBwb3N0ZXIgY29tcG9uZW50IHRvIHVzZSB0aGlzXG4gICAqIHBvc3RlciBzb3VyY2Ugc28gdGhhdCBpdCBjb3ZlcnMgdXAgdGhlIHRlY2gncyBjb250cm9scy5cbiAgICogKFlvdVR1YmUncyBwbGF5IGJ1dHRvbikuIEhvd2V2ZXIgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzXG4gICAqIHNvdXJjZSBpZiB0aGUgcGxheWVyIHVzZXIgaGFzbid0IHNldCBhIHBvc3RlciB0aHJvdWdoXG4gICAqIHRoZSBub3JtYWwgQVBJcy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwb3N0ZXJjaGFuZ2VcbiAgICogQGxpc3RlbnMgVGVjaCNwb3N0ZXJjaGFuZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKSB7XG4gICAgaWYgKCF0aGlzLnBvc3Rlcl8gJiYgdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnBvc3Rlcikge1xuICAgICAgdGhpcy5wb3N0ZXJfID0gdGhpcy50ZWNoXy5wb3N0ZXIoKSB8fCAnJztcblxuICAgICAgLy8gTGV0IGNvbXBvbmVudHMga25vdyB0aGUgcG9zdGVyIGhhcyBjaGFuZ2VkXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbHMgYXJlIHNob3dpbmcuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgdG8gdHVybiBjb250cm9scyBvblxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIGNvbnRyb2xzIG9mZlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGNvbnRyb2xzIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY29udHJvbHMgPSBmdW5jdGlvbiBjb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5jb250cm9sc187XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIC8vIERvbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgdW5sZXNzIGl0IGFjdHVhbGx5IGNoYW5nZWRcbiAgICBpZiAodGhpcy5jb250cm9sc18gPT09IGJvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xzXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRyb2xzXykge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZW5hYmxlZFxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZW5hYmxlZCcpO1xuICAgICAgaWYgKCF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgICAgLyoqXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZGlzYWJsZWRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2Rpc2FibGVkJyk7XG4gICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVG9nZ2xlIG5hdGl2ZSBjb250cm9scyBvbi9vZmYuIE5hdGl2ZSBjb250cm9scyBhcmUgdGhlIGNvbnRyb2xzIGJ1aWx0IGludG9cbiAgICogZGV2aWNlcyAoZS5nLiBkZWZhdWx0IGlQaG9uZSBjb250cm9scyksIEZsYXNoLCBvciBvdGhlciB0ZWNoc1xuICAgKiAoZS5nLiBWaW1lbyBDb250cm9scylcbiAgICogKipUaGlzIHNob3VsZCBvbmx5IGJlIHNldCBieSB0aGUgY3VycmVudCB0ZWNoLCBiZWNhdXNlIG9ubHkgdGhlIHRlY2gga25vd3NcbiAgICogaWYgaXQgY2FuIHN1cHBvcnQgbmF0aXZlIGNvbnRyb2xzKipcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNpbmdjdXN0b21jb250cm9sc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIHR1cm4gbmF0aXZlIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gbmF0aXZlIGNvbnRyb2xzIG9mZlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIG5hdGl2ZSBjb250cm9scyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVzaW5nTmF0aXZlQ29udHJvbHMgPSBmdW5jdGlvbiB1c2luZ05hdGl2ZUNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfO1xuICAgIH1cblxuICAgIGJvb2wgPSAhIWJvb2w7XG5cbiAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gPT09IGJvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfID0gYm9vbDtcblxuICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHNfKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBuYXRpdmUgZGV2aWNlIGNvbnRyb2xzXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ25hdGl2ZWNvbnRyb2xzXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNpbmduYXRpdmVjb250cm9scycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICpcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNpbmdjdXN0b21jb250cm9sc1xuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VzaW5nY3VzdG9tY29udHJvbHMnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgTWVkaWFFcnJvclxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Vycm9yXG4gICAqXG4gICAqIEBwYXJhbSAge01lZGlhRXJyb3J8c3RyaW5nfG51bWJlcn0gW2Vycl1cbiAgICogICAgICAgICBBIE1lZGlhRXJyb3Igb3IgYSBzdHJpbmcvbnVtYmVyIHRvIGJlIHR1cm5lZFxuICAgKiAgICAgICAgIGludG8gYSBNZWRpYUVycm9yXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBNZWRpYUVycm9yIHdoZW4gZ2V0dGluZyAob3IgbnVsbClcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICBpZiAodGhpcy5lcnJvckRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG5cbiAgICAvLyBhZGQgdGhlIHZqcy1lcnJvciBjbGFzc25hbWUgdG8gdGhlIHBsYXllclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lcnJvcicpO1xuXG4gICAgLy8gbG9nIHRoZSBuYW1lIG9mIHRoZSBlcnJvciB0eXBlIGFuZCBhbnkgbWVzc2FnZVxuICAgIC8vIGllOCBqdXN0IGxvZ3MgXCJbb2JqZWN0IG9iamVjdF1cIiBpZiB5b3UganVzdCBsb2cgdGhlIGVycm9yIG9iamVjdFxuICAgIGxvZyQxLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXBvcnRVc2VyQWN0aXZpdHkgPSBmdW5jdGlvbiByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgKiAgICAgICAgLSBmYWxzZSBpZiB0aGUgdXNlciBpcyBpbmFjdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHVzZXJBY3RpdmUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMudXNlckFjdGl2ZV87XG4gICAgfVxuXG4gICAgYm9vbCA9ICEhYm9vbDtcblxuICAgIGlmIChib29sID09PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZlXyA9IGJvb2w7XG5cbiAgICBpZiAodGhpcy51c2VyQWN0aXZlXykge1xuICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyYWN0aXZlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENocm9tZS9TYWZhcmkvSUUgaGF2ZSBidWdzIHdoZXJlIHdoZW4geW91IGNoYW5nZSB0aGUgY3Vyc29yIGl0IGNhblxuICAgIC8vIHRyaWdnZXIgYSBtb3VzZW1vdmUgZXZlbnQuIFRoaXMgY2F1c2VzIGFuIGlzc3VlIHdoZW4geW91J3JlIGhpZGluZ1xuICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxuICAgIC8vIGFjdGl2aXR5LiBNYWtpbmcgaXQgaW1wb3NzaWJsZSB0byBnbyBpbnRvIGluYWN0aXZlIG1vZGUuIFNwZWNpZmljYWxseVxuICAgIC8vIHRoaXMgaGFwcGVucyBpbiBmdWxsc2NyZWVuIHdoZW4gd2UgcmVhbGx5IG5lZWQgdG8gaGlkZSB0aGUgY3Vyc29yLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGlzIGdldHMgcmVzb2x2ZWQgaW4gQUxMIGJyb3dzZXJzIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwMzA0MVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnRlY2hfLm9uZSgnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItaW5hY3RpdmUnKTtcbiAgICAvKipcbiAgICAgKiBAZXZlbnQgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3VzZXJpbmFjdGl2ZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZm9yIHVzZXIgYWN0aXZpdHkgYmFzZWQgb24gdGltZW91dCB2YWx1ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGlzdGVuRm9yVXNlckFjdGl2aXR5XyA9IGZ1bmN0aW9uIGxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKSB7XG4gICAgdmFyIG1vdXNlSW5Qcm9ncmVzcyA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVYID0gdm9pZCAwO1xuICAgIHZhciBsYXN0TW92ZVkgPSB2b2lkIDA7XG4gICAgdmFyIGhhbmRsZUFjdGl2aXR5ID0gYmluZCh0aGlzLCB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgIC8vICMxMDY4IC0gUHJldmVudCBtb3VzZW1vdmUgc3BhbW1pbmdcbiAgICAgIC8vIENocm9tZSBCdWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNjY5NzBcbiAgICAgIGlmIChlLnNjcmVlblggIT09IGxhc3RNb3ZlWCB8fCBlLnNjcmVlblkgIT09IGxhc3RNb3ZlWSkge1xuICAgICAgICBsYXN0TW92ZVggPSBlLnNjcmVlblg7XG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcbiAgICAgICAgaGFuZGxlQWN0aXZpdHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bigpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXG4gICAgICAvLyB3ZSBjb25zaWRlciB0aGVtIGFjdGl2ZSBldmVuIGlmIHRoZXkncmUgbm90IG1vdmluZyB0aGVpciBmaW5nZXIgb3IgbW91c2UuXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBTZXR0aW5nIHVzZXJBY3Rpdml0eT10cnVlIG5vdyBhbmQgc2V0dGluZyB0aGUgaW50ZXJ2YWwgdG8gdGhlIHNhbWUgdGltZVxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxuICAgICAgLy8gbmV4dCBhY3Rpdml0eUNoZWNrXG4gICAgICBtb3VzZUluUHJvZ3Jlc3MgPSB0aGlzLnNldEludGVydmFsKGhhbmRsZUFjdGl2aXR5LCAyNTApO1xuICAgIH07XG5cbiAgICB2YXIgaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICAvLyBTdG9wIHRoZSBpbnRlcnZhbCB0aGF0IG1haW50YWlucyBhY3Rpdml0eSBpZiB0aGUgbW91c2UvdG91Y2ggaXMgZG93blxuICAgICAgdGhpcy5jbGVhckludGVydmFsKG1vdXNlSW5Qcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIC8vIEFueSBtb3VzZSBtb3ZlbWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgdXNlciBhY3Rpdml0eVxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAvLyBTaG91bGRuJ3QgbmVlZCB0byB1c2UgaW5Qcm9ncmVzcyBpbnRlcnZhbCBiZWNhdXNlIG9mIGtleSByZXBlYXRcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xuICAgIHRoaXMub24oJ2tleXVwJywgaGFuZGxlQWN0aXZpdHkpO1xuXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cbiAgICAvLyB0aGUgbW91c2Vtb3ZlL3RvdWNobW92ZSBmdW5jdGlvbiBpdHNlbGYsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gICAgLy8gYHRoaXMucmVwb3J0VXNlckFjdGl2aXR5YCBzaW1wbHkgc2V0cyB0aGlzLnVzZXJBY3Rpdml0eV8gdG8gdHJ1ZSwgd2hpY2hcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9sZWFybmluZy1mcm9tLXR3aXR0ZXIvXG4gICAgdmFyIGluYWN0aXZpdHlUaW1lb3V0ID0gdm9pZCAwO1xuXG4gICAgdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgbW91c2UvdG91Y2ggYWN0aXZpdHkgaGFzIGhhcHBlbmVkXG4gICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBhY3Rpdml0eSB0cmFja2VyXG4gICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIHVzZXIgc3RhdGUgd2FzIGluYWN0aXZlLCBzZXQgdGhlIHN0YXRlIHRvIGFjdGl2ZVxuICAgICAgdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IHRvIHN0YXJ0IHRoZSB0aW1lciBvdmVyXG4gICAgICB0aGlzLmNsZWFyVGltZW91dChpbmFjdGl2aXR5VGltZW91dCk7XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5vcHRpb25zXy5pbmFjdGl2aXR5VGltZW91dDtcblxuICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxuICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgIGluYWN0aXZpdHlUaW1lb3V0ID0gdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XG4gICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxuICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxuICAgICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0sIDI1MCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLiBBIHBsYXliYWNrIHJhdGUgb2ZcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxuICAgKiBwbGF5YmFjaywgZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmF0ZV1cbiAgICogICAgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRQbGF5YmFja1JhdGUnLCByYXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBkZWZhdWx0IHBsYXliYWNrIHJhdGUuIEEgZGVmYXVsdCBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWQgcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICogZGVmYXVsdFBsYXliYWNrUmF0ZSB3aWxsIG9ubHkgcmVwcmVzZW50IHdoYXQgdGhlIGludGlhbCBwbGF5YmFja1JhdGUgb2YgYSB2aWRlbyB3YXMsIG5vdFxuICAgKiBub3QgdGhlIGN1cnJlbnQgcGxheWJhY2tSYXRlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtZGVmYXVsdHBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBkZWZhdWx0IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8UGxheWVyfVxuICAgKiAgICAgICAgIC0gVGhlIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRQbGF5YmFja1JhdGUocmF0ZSkge1xuICAgIGlmIChyYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hDYWxsXygnc2V0RGVmYXVsdFBsYXliYWNrUmF0ZScsIHJhdGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0UGxheWJhY2tSYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiAxLjA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJvb2xcbiAgICogICAgICAgIC0gdHJ1ZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBhbiBhdWRpbyBwbGF5ZXJcbiAgICogICAgICAgIC0gZmFsc2Ugc2lnbmFscyB0aGF0IHRoaXMgaXMgbm90IGFuIGF1ZGlvIHBsYXllclxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGlzQXVkaW8gd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5pc0F1ZGlvID0gZnVuY3Rpb24gaXNBdWRpbyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0F1ZGlvXyA9ICEhYm9vbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmlzQXVkaW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBhIHtAbGluayBUZXh0VHJhY2t9IHRvIG91clxuICAgKiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWFkZHRleHR0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdXG4gICAqICAgICAgICB0aGUga2luZCBvZiBUZXh0VHJhY2sgeW91IGFyZSBhZGRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAgICogICAgICAgIHRoZSBsYWJlbCB0byBnaXZlIHRoZSBUZXh0VHJhY2sgbGFiZWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICogICAgICAgIHRoZSBsYW5ndWFnZSB0byBzZXQgb24gdGhlIFRleHRUcmFja1xuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBUZXh0VHJhY2sgdGhhdCB3YXMgYWRkZWQgb3IgdW5kZWZpbmVkXG4gICAqICAgICAgICAgaWYgdGhlcmUgaXMgbm8gdGVjaFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBhbmQgYW4ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9LiBJdCB3aWxsXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlcywgdW5sZXNzXG4gICAqIG1hbnVhbENsZWFudXAgaXMgc2V0IHRvIGZhbHNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgT3B0aW9ucyB0byBwYXNzIHRvIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBkdXJpbmcgY3JlYXRpb24uIFNlZVxuICAgKiAgICAgICAge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGZvciBvYmplY3QgcHJvcGVydGllcyB0aGF0IHlvdSBzaG91bGQgdXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdIGlmIHNldCB0byBmYWxzZSwgdGhlIFRleHRUcmFjayB3aWxsIGJlXG4gICAqXG4gICAqIEByZXR1cm4ge0h0bWxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgdGhlIEhUTUxUcmFja0VsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZCBhbmQgYWRkZWRcbiAgICogICAgICAgICB0byB0aGUgSHRtbFRyYWNrRWxlbWVudExpc3QgYW5kIHRoZSByZW1vdGVcbiAgICogICAgICAgICBUZXh0VHJhY2tMaXN0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBcIm1hbnVhbENsZWFudXBcIiBwYXJhbWV0ZXIgd2lsbCBkZWZhdWx0XG4gICAqICAgICAgICAgICAgIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IGZyb20gdGhlIHJlc3BlY3RpdmVcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGFuZCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhY2tcbiAgICogICAgICAgIFJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSB0byByZW1vdmVcbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIGRvZXMgbm90IHJldHVybiBhbnl0aGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVtb3ZlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYzJHRyYWNrID0gX3JlZjMudHJhY2ssXG4gICAgICAgIHRyYWNrID0gX3JlZjMkdHJhY2sgPT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9yZWYzJHRyYWNrO1xuXG4gICAgLy8gZGVzdHJ1Y3R1cmUgdGhlIGlucHV0IGludG8gYW4gb2JqZWN0IHdpdGggYSB0cmFjayBhcmd1bWVudCwgZGVmYXVsdGluZyB0byBhcmd1bWVudHNbMF1cbiAgICAvLyBkZWZhdWx0IHRoZSB3aG9sZSBhcmd1bWVudCB0byBhbiBlbXB0eSBvYmplY3QgaWYgbm90aGluZyB3YXMgcGFzc2VkIGluXG5cbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8ucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXG4gICAqIFBsYXliYWNrIFF1YWxpdHkgQVBJLlxuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBvciB1bmRlZmluZWQgaWYgdGhlcmVcbiAgICogICAgICAgICBpcyBubyB0ZWNoIG9yIHRoZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdnZXRWaWRlb1BsYXliYWNrUXVhbGl0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gd2lkdGhcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gd2lkdGhcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvV2lkdGggPSBmdW5jdGlvbiB2aWRlb1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGgoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdmlkZW8gaGVpZ2h0XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBjdXJyZW50IHZpZGVvIGhlaWdodFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudmlkZW9IZWlnaHQgPSBmdW5jdGlvbiB2aWRlb0hlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0ICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQoKSB8fCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyJ3MgbGFuZ3VhZ2UgY29kZVxuICAgKiBOT1RFOiBUaGUgbGFuZ3VhZ2Ugc2hvdWxkIGJlIHNldCBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaWYgeW91IHdhbnQgdGhlXG4gICAqIHRoZSBjb250cm9scyB0byBiZSBidWlsdCB3aXRoIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuIENoYW5naW5nIHRoZSBsYW51Z2FnZVxuICAgKiBsYXRlciB3aWxsIG5vdCB1cGRhdGUgY29udHJvbHMgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXVxuICAgKiAgICAgICAgdGhlIGxhbmd1YWdlIGNvZGUgdG8gc2V0IHRoZSBwbGF5ZXIgdG9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGxhbmd1YWdlIGNvZGUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZSA9IGZ1bmN0aW9uIGxhbmd1YWdlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYW5ndWFnZV87XG4gICAgfVxuXG4gICAgdGhpcy5sYW5ndWFnZV8gPSBTdHJpbmcoY29kZSkudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwbGF5ZXIncyBsYW5ndWFnZSBkaWN0aW9uYXJ5XG4gICAqIE1lcmdlIGV2ZXJ5IHRpbWUsIGJlY2F1c2UgYSBuZXdseSBhZGRlZCBwbHVnaW4gbWlnaHQgY2FsbCB2aWRlb2pzLmFkZExhbmd1YWdlKCkgYXQgYW55IHRpbWVcbiAgICogTGFuZ3VhZ2VzIHNwZWNpZmllZCBkaXJlY3RseSBpbiB0aGUgcGxheWVyIG9wdGlvbnMgaGF2ZSBwcmVjZWRlbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIG9mIHN1cHBvcnRlZCBsYW5ndWFnZXNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxhbmd1YWdlcyA9IGZ1bmN0aW9uIGxhbmd1YWdlcygpIHtcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzLCB0aGlzLmxhbmd1YWdlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgSmF2YVNjcmlwdCBvYmplY3QgcmVwZXJlc2VudGluZyB0aGUgY3VycmVudCB0cmFja1xuICAgKiBpbmZvcm1hdGlvbi4gKipET0VTIG5vdCByZXR1cm4gaXQgYXMgSlNPTioqXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG9mIHRyYWNrIGluZm9cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfKTtcbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gZGVlcCBtZXJnZSB0cmFja3MgYW5kIG51bGwgb3V0IHBsYXllciBzbyBubyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICB0cmFjayA9IG1lcmdlT3B0aW9ucyh0cmFjayk7XG4gICAgICB0cmFjay5wbGF5ZXIgPSB1bmRlZmluZWQ7XG4gICAgICBvcHRpb25zLnRyYWNrc1tpXSA9IHRyYWNrO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2ltcGxlIG1vZGFsIGRpYWxvZyAoYW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBNb2RhbERpYWxvZ31cbiAgICogY29tcG9uZW50KSB0aGF0IGltbWVkaWF0ZWx5IG92ZXJsYXlzIHRoZSBwbGF5ZXIgd2l0aCBhcmJpdHJhcnlcbiAgICogY29udGVudCBhbmQgcmVtb3ZlcyBpdHNlbGYgd2hlbiBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufEVsZW1lbnR8QXJyYXl8bnVsbH0gY29udGVudFxuICAgKiAgICAgICAgU2FtZSBhcyB7QGxpbmsgTW9kYWxEaWFsb2cjY29udGVudH0ncyBwYXJhbSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgKiAgICAgICAgVGhlIG1vc3Qgc3RyYWlnaHQtZm9yd2FyZCB1c2FnZSBpcyB0byBwcm92aWRlIGEgc3RyaW5nIG9yIERPTVxuICAgKiAgICAgICAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgRXh0cmEgb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfS5cbiAgICpcbiAgICogQHJldHVybiB7TW9kYWxEaWFsb2d9XG4gICAqICAgICAgICAgdGhlIHtAbGluayBNb2RhbERpYWxvZ30gdGhhdCB3YXMgY3JlYXRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3JlYXRlTW9kYWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RhbChjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNvbnRlbnQgPSBjb250ZW50IHx8ICcnO1xuXG4gICAgdmFyIG1vZGFsID0gbmV3IE1vZGFsRGlhbG9nKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hZGRDaGlsZChtb2RhbCk7XG4gICAgbW9kYWwub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczgucmVtb3ZlQ2hpbGQobW9kYWwpO1xuICAgIH0pO1xuXG4gICAgbW9kYWwub3BlbigpO1xuICAgIHJldHVybiBtb2RhbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0YWcgc2V0dGluZ3NcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWdcbiAgICogICAgICAgIFRoZSBwbGF5ZXIgdGFnXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzXG4gICAqICAgICAgICAgZm9yIGEgcGxheWVyIHRhZ1xuICAgKi9cblxuXG4gIFBsYXllci5nZXRUYWdTZXR0aW5ncyA9IGZ1bmN0aW9uIGdldFRhZ1NldHRpbmdzKHRhZykge1xuICAgIHZhciBiYXNlT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgdHJhY2tzOiBbXVxuICAgIH07XG5cbiAgICB2YXIgdGFnT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXModGFnKTtcbiAgICB2YXIgZGF0YVNldHVwID0gdGFnT3B0aW9uc1snZGF0YS1zZXR1cCddO1xuXG4gICAgaWYgKGhhc0NsYXNzKHRhZywgJ3Zqcy1mbHVpZCcpKSB7XG4gICAgICB0YWdPcHRpb25zLmZsdWlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxuICAgIGlmIChkYXRhU2V0dXAgIT09IG51bGwpIHtcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnMgSlNPTlxuICAgICAgLy8gSWYgZW1wdHkgc3RyaW5nLCBtYWtlIGl0IGEgcGFyc2FibGUganNvbiBvYmplY3QuXG4gICAgICB2YXIgX3NhZmVQYXJzZVR1cGxlID0gc2FmZVBhcnNlVHVwbGUoZGF0YVNldHVwIHx8ICd7fScpLFxuICAgICAgICAgIGVyciA9IF9zYWZlUGFyc2VUdXBsZVswXSxcbiAgICAgICAgICBkYXRhID0gX3NhZmVQYXJzZVR1cGxlWzFdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGxvZyQxLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBhc3NpZ24odGFnT3B0aW9ucywgZGF0YSk7XG4gICAgfVxuXG4gICAgYXNzaWduKGJhc2VPcHRpb25zLCB0YWdPcHRpb25zKTtcblxuICAgIC8vIEdldCB0YWcgY2hpbGRyZW4gc2V0dGluZ3NcbiAgICBpZiAodGFnLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGFnLmNoaWxkTm9kZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBDaGFuZ2UgY2FzZSBuZWVkZWQ6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9ub2RlbmFtZS1jYXNlLXNlbnNpdGl2aXR5L1xuICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnc291cmNlJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnNvdXJjZXMucHVzaChnZXRBdHRyaWJ1dGVzKGNoaWxkKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSAndHJhY2snKSB7XG4gICAgICAgICAgYmFzZU9wdGlvbnMudHJhY2tzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VPcHRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2V0aGVyIG9yIG5vdCBmbGV4Ym94IGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBmbGV4Ym94IGlzIHN1cHBvcnRlZFxuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZmxleGJveCBpcyBub3Qgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5mbGV4Tm90U3VwcG9ydGVkXyA9IGZ1bmN0aW9uIGZsZXhOb3RTdXBwb3J0ZWRfKCkge1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXG4gICAgLy8gTm90ZTogV2UgZG9uJ3QgYWN0dWFsbHkgdXNlIGZsZXhCYXNpcyAob3IgZmxleE9yZGVyKSwgYnV0IGl0J3Mgb25lIG9mIHRoZSBtb3JlXG4gICAgLy8gY29tbW9uIGZsZXggZmVhdHVyZXMgdGhhdCB3ZSBjYW4gcmVseSBvbiB3aGVuIGNoZWNraW5nIGZvciBmbGV4IHN1cHBvcnQuXG4gICAgcmV0dXJuICEoJ2ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtb3pGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21zRmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XG4gICAgLy8gSUUxMC1zcGVjaWZpYyAoMjAxMiBmbGV4IHNwZWMpXG4gICAgJ21zRmxleE9yZGVyJyBpbiBlbGVtLnN0eWxlKTtcbiAgfTtcblxuICByZXR1cm4gUGxheWVyO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7VmlkZW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHZpZGVvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudmlkZW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxuICogQGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2F1ZGlvdHJhY2tsaXN0XG4gKlxuICogQHJldHVybiB7QXVkaW9UcmFja0xpc3R9XG4gKiAgICAgICAgIHRoZSBjdXJyZW50IGF1ZGlvIHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUuYXVkaW9UcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQGxpbmsgaHR0cDovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXRleHR0cmFja3NcbiAqXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9IHRyYWNrcy5cbiAqXG4gKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqICAgICAgICAgVGhlIGN1cnJlbnQgcmVtb3RlIHRleHQgdHJhY2sgZWxlbWVudCBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcblxuICBQbGF5ZXIucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoX1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkVGVjaF8sIHdlIGNyZWF0ZSB7dmlkZW8sYXVkaW8sdGV4dH1UcmFja3NfXG4gICAgLy8gdGhlc2Ugd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlY2ggZHVyaW5nIGxvYWRpbmdcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBHbG9iYWwgcGxheWVyIGxpc3RcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5QbGF5ZXIucGxheWVycyA9IHt9O1xuXG52YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxuLypcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXG4gKiBvcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zX1xuICogTWFrZSBjaGFuZ2VzIGluIG9wdGlvbnMsIG5vdCBoZXJlLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICAvLyBEZWZhdWx0IG9yZGVyIG9mIGZhbGxiYWNrIHRlY2hub2xvZ3lcbiAgdGVjaE9yZGVyOiBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLFxuXG4gIGh0bWw1OiB7fSxcbiAgZmxhc2g6IHt9LFxuXG4gIC8vIGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gIGluYWN0aXZpdHlUaW1lb3V0OiAyMDAwLFxuXG4gIC8vIGRlZmF1bHQgcGxheWJhY2sgcmF0ZXNcbiAgcGxheWJhY2tSYXRlczogW10sXG4gIC8vIEFkZCBwbGF5YmFjayByYXRlIHNlbGVjdGlvbiBieSBhZGRpbmcgcmF0ZXNcbiAgLy8gJ3BsYXliYWNrUmF0ZXMnOiBbMC41LCAxLCAxLjUsIDJdLFxuXG4gIC8vIEluY2x1ZGVkIGNvbnRyb2wgc2V0c1xuICBjaGlsZHJlbjogWydtZWRpYUxvYWRlcicsICdwb3N0ZXJJbWFnZScsICd0ZXh0VHJhY2tEaXNwbGF5JywgJ2xvYWRpbmdTcGlubmVyJywgJ2JpZ1BsYXlCdXR0b24nLCAnY29udHJvbEJhcicsICdlcnJvckRpc3BsYXknLCAndGV4dFRyYWNrU2V0dGluZ3MnXSxcblxuICBsYW5ndWFnZTogbmF2aWdhdG9yICYmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UpIHx8ICdlbicsXG5cbiAgLy8gbG9jYWxlcyBhbmQgdGhlaXIgbGFuZ3VhZ2UgdHJhbnNsYXRpb25zXG4gIGxhbmd1YWdlczoge30sXG5cbiAgLy8gRGVmYXVsdCBtZXNzYWdlIHRvIHNob3cgd2hlbiBhIHZpZGVvIGNhbm5vdCBiZSBwbGF5ZWQuXG4gIG5vdFN1cHBvcnRlZE1lc3NhZ2U6ICdObyBjb21wYXRpYmxlIHNvdXJjZSB3YXMgZm91bmQgZm9yIHRoaXMgbWVkaWEuJ1xufTtcblxuW1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwiZW5kZWRcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIGVuZGVkIHN0YXRlLCBmYWxzZSBpZiBub3QuXG4gKiBAbWV0aG9kIFBsYXllciNlbmRlZFxuICovXG4nZW5kZWQnLFxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwic2Vla2luZ1wiIHN0YXRlLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgc2Vla2luZyBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2luZ1xuICovXG4nc2Vla2luZycsXG4vKipcbiAqIFJldHVybnMgdGhlIFRpbWVSYW5nZXMgb2YgdGhlIG1lZGlhIHRoYXQgYXJlIGN1cnJlbnRseSBhdmFpbGFibGVcbiAqIGZvciBzZWVraW5nIHRvLlxuICpcbiAqIEByZXR1cm4ge1RpbWVSYW5nZXN9IHRoZSBzZWVrYWJsZSBpbnRlcnZhbHMgb2YgdGhlIG1lZGlhIHRpbWVsaW5lXG4gKiBAbWV0aG9kIFBsYXllciNzZWVrYWJsZVxuICovXG4nc2Vla2FibGUnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIG5ldHdvcmsgYWN0aXZpdHkgZm9yIHRoZSBlbGVtZW50LCBmcm9tXG4gKiB0aGUgY29kZXMgaW4gdGhlIGxpc3QgYmVsb3cuXG4gKiAtIE5FVFdPUktfRU1QVFkgKG51bWVyaWMgdmFsdWUgMClcbiAqICAgVGhlIGVsZW1lbnQgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZC4gQWxsIGF0dHJpYnV0ZXMgYXJlIGluXG4gKiAgIHRoZWlyIGluaXRpYWwgc3RhdGVzLlxuICogLSBORVRXT1JLX0lETEUgKG51bWVyaWMgdmFsdWUgMSlcbiAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSBhbmQgaGFzXG4gKiAgIHNlbGVjdGVkIGEgcmVzb3VyY2UsIGJ1dCBpdCBpcyBub3QgYWN0dWFsbHkgdXNpbmcgdGhlIG5ldHdvcmsgYXRcbiAqICAgdGhpcyB0aW1lLlxuICogLSBORVRXT1JLX0xPQURJTkcgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgVGhlIHVzZXIgYWdlbnQgaXMgYWN0aXZlbHkgdHJ5aW5nIHRvIGRvd25sb2FkIGRhdGEuXG4gKiAtIE5FVFdPUktfTk9fU09VUkNFIChudW1lcmljIHZhbHVlIDMpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUsIGJ1dCBpdCBoYXNcbiAqICAgbm90IHlldCBmb3VuZCBhIHJlc291cmNlIHRvIHVzZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNuZXR3b3JrLXN0YXRlc1xuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCBuZXR3b3JrIGFjdGl2aXR5IHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNuZXR3b3JrU3RhdGVcbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxuICogd2l0aCByZXNwZWN0IHRvIHJlbmRlcmluZyB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiwgZnJvbSB0aGVcbiAqIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcbiAqICAgTm8gaW5mb3JtYXRpb24gcmVnYXJkaW5nIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBhdmFpbGFibGUuXG4gKiAtIEhBVkVfTUVUQURBVEEgKG51bWVyaWMgdmFsdWUgMSlcbiAqICAgRW5vdWdoIG9mIHRoZSByZXNvdXJjZSBoYXMgYmVlbiBvYnRhaW5lZCB0aGF0IHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAqICAgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX0NVUlJFTlRfREFUQSAobnVtZXJpYyB2YWx1ZSAyKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX0ZVVFVSRV9EQVRBIChudW1lcmljIHZhbHVlIDMpXG4gKiAgIERhdGEgZm9yIHRoZSBpbW1lZGlhdGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBpcyBhdmFpbGFibGUsIGFzXG4gKiAgIHdlbGwgYXMgZW5vdWdoIGRhdGEgZm9yIHRoZSB1c2VyIGFnZW50IHRvIGFkdmFuY2UgdGhlIGN1cnJlbnRcbiAqICAgcGxheWJhY2sgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiBvZiBwbGF5YmFjay5cbiAqIC0gSEFWRV9FTk9VR0hfREFUQSAobnVtZXJpYyB2YWx1ZSA0KVxuICogICBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgZm9yXG4gKiAgIHBsYXliYWNrIHRvIHByb2NlZWQgdW5pbnRlcnJ1cHRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcmVhZHlzdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY3VycmVudCBwbGF5YmFjayByZW5kZXJpbmcgc3RhdGVcbiAqIEBtZXRob2QgUGxheWVyI3JlYWR5U3RhdGVcbiAqL1xuJ3JlYWR5U3RhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICBQbGF5ZXIucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0Xyhmbik7XG4gIH07XG59KTtcblxuVEVDSF9FVkVOVFNfUkVUUklHR0VSLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFBsYXllci5wcm90b3R5cGVbJ2hhbmRsZVRlY2gnICsgdG9UaXRsZUNhc2UoZXZlbnQpICsgJ18nXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyKGV2ZW50KTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgaW5pdGlhbCBkdXJhdGlvbiBhbmQgZGltZW5zaW9uIGluZm9ybWF0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRtZXRhZGF0YVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBkb3dubG9hZGVkIGRhdGEgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb25cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaGFzIGNoYW5nZWQgKlxuICogRHVyaW5nIHBsYXliYWNrIHRoaXMgaXMgZmlyZWQgZXZlcnkgMTUtMjUwIG1pbGxpc2Vjb25kcywgZGVwZW5kaW5nIG9uIHRoZVxuICogcGxheWJhY2sgdGVjaG5vbG9neSBpbiB1c2UuXG4gKlxuICogQGV2ZW50IFBsYXllciN0aW1ldXBkYXRlXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSB2b2x1bWUgY2hhbmdlc1xuICpcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGhhcyBhIHBsdWdpbiBhdmFpbGFibGUuXG4gKlxuICogVGhpcyBkb2VzIG5vdCByZXBvcnQgd2hldGhlciBvciBub3QgdGhlIHBsdWdpbiBoYXMgZXZlciBiZWVuIGluaXRpYWxpemVkXG4gKiBvbiB0aGlzIHBsYXllci4gRm9yIHRoYXQsIFt1c2luZ1BsdWdpbl17QGxpbmsgUGxheWVyI3VzaW5nUGx1Z2lufS5cbiAqXG4gKiBAbWV0aG9kIFBsYXllciNoYXNQbHVnaW5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaGFzIHRoZSByZXF1ZXN0ZWQgcGx1Z2luIGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbGF5ZXIgaXMgdXNpbmcgYSBwbHVnaW4gYnkgbmFtZS5cbiAqXG4gKiBGb3IgYmFzaWMgcGx1Z2lucywgdGhpcyBvbmx5IHJlcG9ydHMgd2hldGhlciB0aGUgcGx1Z2luIGhhcyBfZXZlcl8gYmVlblxuICogaW5pdGlhbGl6ZWQgb24gdGhpcyBwbGF5ZXIuXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjdXNpbmdQbHVnaW5cbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGlzIHBsYXllciBpcyB1c2luZyB0aGUgcmVxdWVzdGVkIHBsdWdpbi5cbiAqL1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXllcicsIFBsYXllcik7XG5cbi8qKlxuICogQGZpbGUgcGx1Z2luLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgcGx1Z2luIG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIEJBU0VfUExVR0lOX05BTUUgPSAncGx1Z2luJztcblxuLyoqXG4gKiBUaGUga2V5IG9uIHdoaWNoIGEgcGxheWVyJ3MgYWN0aXZlIHBsdWdpbnMgY2FjaGUgaXMgc3RvcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlICAgICB7c3RyaW5nfVxuICovXG52YXIgUExVR0lOX0NBQ0hFX0tFWSA9ICdhY3RpdmVQbHVnaW5zXyc7XG5cbi8qKlxuICogU3RvcmVzIHJlZ2lzdGVyZWQgcGx1Z2lucyBpbiBhIHByaXZhdGUgc3BhY2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlICAgIHtPYmplY3R9XG4gKi9cbnZhciBwbHVnaW5TdG9yYWdlID0ge307XG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqL1xudmFyIHBsdWdpbkV4aXN0cyA9IGZ1bmN0aW9uIHBsdWdpbkV4aXN0cyhuYW1lKSB7XG4gIHJldHVybiBwbHVnaW5TdG9yYWdlLmhhc093blByb3BlcnR5KG5hbWUpO1xufTtcblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgcmVnaXN0ZXJlZCBwbHVnaW4gYnkgbmFtZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgIFRoZSBwbHVnaW4gKG9yIHVuZGVmaW5lZCkuXG4gKi9cbnZhciBnZXRQbHVnaW4gPSBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICByZXR1cm4gcGx1Z2luRXhpc3RzKG5hbWUpID8gcGx1Z2luU3RvcmFnZVtuYW1lXSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwbHVnaW4gYXMgXCJhY3RpdmVcIiBvbiBhIHBsYXllci5cbiAqXG4gKiBBbHNvLCBlbnN1cmVzIHRoYXQgdGhlIHBsYXllciBoYXMgYW4gb2JqZWN0IGZvciB0cmFja2luZyBhY3RpdmUgcGx1Z2lucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqL1xudmFyIG1hcmtQbHVnaW5Bc0FjdGl2ZSA9IGZ1bmN0aW9uIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIG5hbWUpIHtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldID0gcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldIHx8IHt9O1xuICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyBhIHBhaXIgb2YgcGx1Z2luIHNldHVwIGV2ZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAqICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH0gaGFzaFxuICogICAgICAgICBBIHBsdWdpbiBldmVudCBoYXNoLlxuICpcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtiZWZvcmVdXG4gKiAgICAgICAgIElmIHRydWUsIHByZWZpeGVzIHRoZSBldmVudCBuYW1lIHdpdGggXCJiZWZvcmVcIi4gSW4gb3RoZXIgd29yZHMsXG4gKiAgICAgICAgIHVzZSB0aGlzIHRvIHRyaWdnZXIgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGluc3RlYWQgb2YgXCJwbHVnaW5zZXR1cFwiLlxuICovXG52YXIgdHJpZ2dlclNldHVwRXZlbnQgPSBmdW5jdGlvbiB0cmlnZ2VyU2V0dXBFdmVudChwbGF5ZXIsIGhhc2gsIGJlZm9yZSkge1xuICB2YXIgZXZlbnROYW1lID0gKGJlZm9yZSA/ICdiZWZvcmUnIDogJycpICsgJ3BsdWdpbnNldHVwJztcblxuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGhhc2gpO1xuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUgKyAnOicgKyBoYXNoLm5hbWUsIGhhc2gpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGJhc2ljIHBsdWdpbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggbWFya3NcbiAqIG9uIHRoZSBwbGF5ZXIgdGhhdCB0aGUgcGx1Z2luIGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICAgVGhlIGJhc2ljIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKiAgICAgICAgICBBIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBwbHVnaW4uXG4gKi9cbnZhciBjcmVhdGVCYXNpY1BsdWdpbiA9IGZ1bmN0aW9uIGNyZWF0ZUJhc2ljUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICB2YXIgYmFzaWNQbHVnaW5XcmFwcGVyID0gZnVuY3Rpb24gYmFzaWNQbHVnaW5XcmFwcGVyKCkge1xuXG4gICAgLy8gV2UgdHJpZ2dlciB0aGUgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGFuZCBcInBsdWdpbnNldHVwXCIgZXZlbnRzIG9uIHRoZSBwbGF5ZXJcbiAgICAvLyByZWdhcmRsZXNzLCBidXQgd2Ugd2FudCB0aGUgaGFzaCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlIGhhc2ggcHJvdmlkZWRcbiAgICAvLyBmb3IgYWR2YW5jZWQgcGx1Z2lucy5cbiAgICAvL1xuICAgIC8vIFRoZSBvbmx5IHBvdGVudGlhbGx5IGNvdW50ZXItaW50dWl0aXZlIHRoaW5nIGhlcmUgaXMgdGhlIGBpbnN0YW5jZWAgaW5cbiAgICAvLyB0aGUgXCJwbHVnaW5zZXR1cFwiIGV2ZW50IGlzIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgYHBsdWdpbmAgZnVuY3Rpb24uXG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IG51bGwgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5zdGFuY2UgPSBwbHVnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZSh0aGlzLCBuYW1lKTtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogcGx1Z2luLCBpbnN0YW5jZTogaW5zdGFuY2UgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMocGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYmFzaWNQbHVnaW5XcmFwcGVyW3Byb3BdID0gcGx1Z2luW3Byb3BdO1xuICB9KTtcblxuICByZXR1cm4gYmFzaWNQbHVnaW5XcmFwcGVyO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHBsdWdpbiBzdWItY2xhc3MgYW5kIHJldHVybnMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nXG4gKiBpbnN0YW5jZXMgb2YgaXQuXG4gKlxuICogVGhpcyBmYWN0b3J5IGZ1bmN0aW9uIHdpbGwgcmVwbGFjZSBpdHNlbGYgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGUgcmVxdWVzdGVkXG4gKiBzdWItY2xhc3Mgb2YgUGx1Z2luLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSAgIHtQbHVnaW59IFBsdWdpblN1YkNsYXNzXG4gKiAgICAgICAgICBUaGUgYWR2YW5jZWQgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xudmFyIGNyZWF0ZVBsdWdpbkZhY3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIFBsdWdpblN1YkNsYXNzKSB7XG5cbiAgLy8gQWRkIGEgYG5hbWVgIHByb3BlcnR5IHRvIHRoZSBwbHVnaW4gcHJvdG90eXBlIHNvIHRoYXQgZWFjaCBwbHVnaW4gY2FuXG4gIC8vIHJlZmVyIHRvIGl0c2VsZiBieSBuYW1lLlxuICBQbHVnaW5TdWJDbGFzcy5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogUGx1Z2luU3ViQ2xhc3MsIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShQbHVnaW5TdWJDbGFzcywgW251bGxdLmNvbmNhdChbdGhpc10uY29uY2F0KGFyZ3MpKSkpKCk7XG5cbiAgICAvLyBUaGUgcGx1Z2luIGlzIHJlcGxhY2VkIGJ5IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIGluc3RhbmNlLmdldEV2ZW50SGFzaCgpKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn07XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgYWR2YW5jZWQgcGx1Z2lucy5cbiAqXG4gKiBAbWl4ZXMgICBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW5cbiAqIEBtaXhlcyAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXBcbiAqIEBmaXJlcyAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBsaXN0ZW5zIFBsYXllciNkaXNwb3NlXG4gKiBAdGhyb3dzICB7RXJyb3J9XG4gKiAgICAgICAgICBJZiBhdHRlbXB0aW5nIHRvIGluc3RhbnRpYXRlIHRoZSBiYXNlIHtAbGluayBQbHVnaW59IGNsYXNzXG4gKiAgICAgICAgICBkaXJlY3RseSBpbnN0ZWFkIG9mIHZpYSBhIHN1Yi1jbGFzcy5cbiAqL1xuXG52YXIgUGx1Z2luID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIFN1Yi1jbGFzc2VzIHNob3VsZCBjYWxsIGBzdXBlcmAgdG8gZW5zdXJlIHBsdWdpbnMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFBsdWdpbihwbGF5ZXIpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IFBsdWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gbXVzdCBiZSBzdWItY2xhc3NlZDsgbm90IGRpcmVjdGx5IGluc3RhbnRpYXRlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcblxuICAgIC8vIE1ha2UgdGhpcyBvYmplY3QgZXZlbnRlZCwgYnV0IHJlbW92ZSB0aGUgYWRkZWQgYHRyaWdnZXJgIG1ldGhvZCBzbyB3ZVxuICAgIC8vIHVzZSB0aGUgcHJvdG90eXBlIHZlcnNpb24gaW5zdGVhZC5cbiAgICBldmVudGVkKHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnRyaWdnZXI7XG5cbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XG4gICAgbWFya1BsdWdpbkFzQWN0aXZlKHBsYXllciwgdGhpcy5uYW1lKTtcblxuICAgIC8vIEF1dG8tYmluZCB0aGUgZGlzcG9zZSBtZXRob2Qgc28gd2UgY2FuIHVzZSBpdCBhcyBhIGxpc3RlbmVyIGFuZCB1bmJpbmRcbiAgICAvLyBpdCBsYXRlciBlYXNpbHkuXG4gICAgdGhpcy5kaXNwb3NlID0gYmluZCh0aGlzLCB0aGlzLmRpc3Bvc2UpO1xuXG4gICAgLy8gSWYgdGhlIHBsYXllciBpcyBkaXNwb3NlZCwgZGlzcG9zZSB0aGUgcGx1Z2luLlxuICAgIHBsYXllci5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoZSBwbHVnaW4gdGhhdCB3YXMgc2V0IG9uIDxwbHVnaW5OYW1lPi5WRVJTSU9OXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS52ZXJzaW9uID0gZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5WRVJTSU9OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFYWNoIGV2ZW50IHRyaWdnZXJlZCBieSBwbHVnaW5zIGluY2x1ZGVzIGEgaGFzaCBvZiBhZGRpdGlvbmFsIGRhdGEgd2l0aFxuICAgKiBjb252ZW50aW9uYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIHRoYXQgb2JqZWN0IG9yIG11dGF0ZXMgYW4gZXhpc3RpbmcgaGFzaC5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFuIG9iamVjdCB0byBiZSB1c2VkIGFzIGV2ZW50IGFuIGV2ZW50IGhhc2guXG4gICAqXG4gICAqIEByZXR1cm5zIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICAgKiAgICAgICAgICBBbiBldmVudCBoYXNoIG9iamVjdCB3aXRoIHByb3ZpZGVkIHByb3BlcnRpZXMgbWl4ZWQtaW4uXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5nZXRFdmVudEhhc2ggPSBmdW5jdGlvbiBnZXRFdmVudEhhc2goKSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgaGFzaC5uYW1lID0gdGhpcy5uYW1lO1xuICAgIGhhc2gucGx1Z2luID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBoYXNoLmluc3RhbmNlID0gdGhpcztcbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYW4gZXZlbnQgb24gdGhlIHBsdWdpbiBvYmplY3QgYW5kIG92ZXJyaWRlc1xuICAgKiB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluLnRyaWdnZXJ8RXZlbnRlZE1peGluLnRyaWdnZXJ9LlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoPXt9XVxuICAgKiAgICAgICAgICBBZGRpdGlvbmFsIGRhdGEgaGFzaCB0byBtZXJnZSB3aXRoIGFcbiAgICogICAgICAgICAge0BsaW5rIFBsdWdpbn5QbHVnaW5FdmVudEhhc2h8UGx1Z2luRXZlbnRIYXNofS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGRlZmF1bHQgd2FzIHByZXZlbnRlZC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyJCQxKGV2ZW50KSB7XG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIHRoaXMuZ2V0RXZlbnRIYXNoKGhhc2gpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBcInN0YXRlY2hhbmdlZFwiIGV2ZW50cyBvbiB0aGUgcGx1Z2luLiBOby1vcCBieSBkZWZhdWx0LCBvdmVycmlkZSBieVxuICAgKiBzdWJjbGFzc2luZy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSAgICB7RXZlbnR9IGVcbiAgICogICAgICAgICAgIEFuIGV2ZW50IG9iamVjdCBwcm92aWRlZCBieSBhIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAgICB7T2JqZWN0fSBlLmNoYW5nZXNcbiAgICogICAgICAgICAgIEFuIG9iamVjdCBkZXNjcmliaW5nIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB3aXRoIHRoZSBcInN0YXRlY2hhbmdlZFwiXG4gICAqICAgICAgICAgICBldmVudC5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmhhbmRsZVN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlZChlKSB7fTtcblxuICAvKipcbiAgICogRGlzcG9zZXMgYSBwbHVnaW4uXG4gICAqXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgaWYgdGhleSB3YW50LCBidXQgZm9yIHRoZSBzYWtlIG9mIHNhZmV0eSxcbiAgICogaXQncyBwcm9iYWJseSBiZXN0IHRvIHN1YnNjcmliZSB0aGUgXCJkaXNwb3NlXCIgZXZlbnQuXG4gICAqXG4gICAqIEBmaXJlcyBQbHVnaW4jZGlzcG9zZVxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXG4gICAgICAgIHBsYXllciA9IHRoaXMucGxheWVyO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGF0IGEgYWR2YW5jZWQgcGx1Z2luIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsdWdpbiNkaXNwb3NlXG4gICAgICogQHR5cGUgIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIHRoaXMub2ZmKCk7XG4gICAgcGxheWVyLm9mZignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XG5cbiAgICAvLyBFbGltaW5hdGUgYW55IHBvc3NpYmxlIHNvdXJjZXMgb2YgbGVha2luZyBtZW1vcnkgYnkgY2xlYXJpbmcgdXBcbiAgICAvLyByZWZlcmVuY2VzIGJldHdlZW4gdGhlIHBsYXllciBhbmQgdGhlIHBsdWdpbiBpbnN0YW5jZSBhbmQgbnVsbGluZyBvdXRcbiAgICAvLyB0aGUgcGx1Z2luJ3Mgc3RhdGUgYW5kIHJlcGxhY2luZyBtZXRob2RzIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRocm93cy5cbiAgICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllciA9IHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgLy8gRmluYWxseSwgcmVwbGFjZSB0aGUgcGx1Z2luIG5hbWUgb24gdGhlIHBsYXllciB3aXRoIGEgbmV3IGZhY3RvcnlcbiAgICAvLyBmdW5jdGlvbiwgc28gdGhhdCB0aGUgcGx1Z2luIGlzIHJlYWR5IHRvIGJlIHNldCB1cCBhZ2Fpbi5cbiAgICBwbGF5ZXJbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpblN0b3JhZ2VbbmFtZV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luIChpLmUuIG5vdCBhIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCkuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBJZiBhIHN0cmluZywgbWF0Y2hlcyB0aGUgbmFtZSBvZiBhIHBsdWdpbi4gSWYgYSBmdW5jdGlvbiwgd2lsbCBiZVxuICAgKiAgICAgICAgICB0ZXN0ZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBhIHBsdWdpbiBpcyBhIGJhc2ljIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4uaXNCYXNpYyA9IGZ1bmN0aW9uIGlzQmFzaWMocGx1Z2luKSB7XG4gICAgdmFyIHAgPSB0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJyA/IGdldFBsdWdpbihwbHVnaW4pIDogcGx1Z2luO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnZnVuY3Rpb24nICYmICFQbHVnaW4ucHJvdG90eXBlLmlzUHJvdG90eXBlT2YocC5wcm90b3R5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHJlZ2lzdGVyZWQuIE11c3QgYmUgYSBzdHJpbmcgYW5kXG4gICAqICAgICAgICAgIG11c3Qgbm90IG1hdGNoIGFuIGV4aXN0aW5nIHBsdWdpbiBvciBhIG1ldGhvZCBvbiB0aGUgYFBsYXllcmBcbiAgICogICAgICAgICAgcHJvdG90eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHBsdWdpblxuICAgKiAgICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqICAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcbiAgICogICAgICAgICAgYmFzaWMgcGx1Z2lucywgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi5cbiAgICovXG5cblxuICBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIG11c3QgYmUgYSBzdHJpbmcsIHdhcyAnICsgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYW1lKSkgKyAnLicpO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW5FeGlzdHMobmFtZSkpIHtcbiAgICAgIGxvZyQxLndhcm4oJ0EgcGx1Z2luIG5hbWVkIFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuIFlvdSBtYXkgd2FudCB0byBhdm9pZCByZS1yZWdpc3RlcmluZyBwbHVnaW5zIScpO1xuICAgIH0gZWxzZSBpZiAoUGxheWVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBuYW1lLCBcIicgKyBuYW1lICsgJ1wiLCBjYW5ub3Qgc2hhcmUgYSBuYW1lIHdpdGggYW4gZXhpc3RpbmcgcGxheWVyIG1ldGhvZCEnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHBsdWdpbiBmb3IgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIGZ1bmN0aW9uLCB3YXMgJyArICh0eXBlb2YgcGx1Z2luID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwbHVnaW4pKSArICcuJyk7XG4gICAgfVxuXG4gICAgcGx1Z2luU3RvcmFnZVtuYW1lXSA9IHBsdWdpbjtcblxuICAgIC8vIEFkZCBhIHBsYXllciBwcm90b3R5cGUgbWV0aG9kIGZvciBhbGwgc3ViLWNsYXNzZWQgcGx1Z2lucyAoYnV0IG5vdCBmb3JcbiAgICAvLyB0aGUgYmFzZSBQbHVnaW4gY2xhc3MpLlxuICAgIGlmIChuYW1lICE9PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICBpZiAoUGx1Z2luLmlzQmFzaWMocGx1Z2luKSkge1xuICAgICAgICBQbGF5ZXIucHJvdG90eXBlW25hbWVdID0gY3JlYXRlQmFzaWNQbHVnaW4obmFtZSwgcGx1Z2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfTtcblxuICAvKipcbiAgICogRGUtcmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICovXG5cblxuICBQbHVnaW4uZGVyZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIGRlcmVnaXN0ZXJQbHVnaW4obmFtZSkge1xuICAgIGlmIChuYW1lID09PSBCQVNFX1BMVUdJTl9OQU1FKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1yZWdpc3RlciBiYXNlIHBsdWdpbi4nKTtcbiAgICB9XG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgZGVsZXRlIHBsdWdpblN0b3JhZ2VbbmFtZV07XG4gICAgICBkZWxldGUgUGxheWVyLnByb3RvdHlwZVtuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cbiAgICpcbiAgICogQHBhcmFtICAge0FycmF5fSBbbmFtZXNdXG4gICAqICAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICAgKiAgICAgICAgICBwbHVnaW4gbmFtZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcbiAgICogICAgICAgICAgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgcGx1Z2lucyBleGlzdCkuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpbnMgPSBmdW5jdGlvbiBnZXRQbHVnaW5zKCkge1xuICAgIHZhciBuYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0LmtleXMocGx1Z2luU3RvcmFnZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuXG4gICAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgICAgIHJlc3VsdFtuYW1lXSA9IHBsdWdpbjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogICAgICAgICAgVGhlIHBsdWdpbidzIHZlcnNpb24gb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uID0gZnVuY3Rpb24gZ2V0UGx1Z2luVmVyc2lvbihuYW1lKSB7XG4gICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcblxuICAgIHJldHVybiBwbHVnaW4gJiYgcGx1Z2luLlZFUlNJT04gfHwgJyc7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdpbjtcbn0oKTtcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgICBnZXRQbHVnaW5cbiAqIEBtZW1iZXJPZiBQbHVnaW5cbiAqIEBwYXJhbSAgICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMgIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxuICovXG5cblxuUGx1Z2luLmdldFBsdWdpbiA9IGdldFBsdWdpbjtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBwbHVnaW4gY2xhc3MgYXMgaXQgaXMgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5QbHVnaW4uQkFTRV9QTFVHSU5fTkFNRSA9IEJBU0VfUExVR0lOX05BTUU7XG5cblBsdWdpbi5yZWdpc3RlclBsdWdpbihCQVNFX1BMVUdJTl9OQU1FLCBQbHVnaW4pO1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLnVzaW5nUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICEhdGhpc1tQTFVHSU5fQ0FDSEVfS0VZXSAmJiB0aGlzW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID09PSB0cnVlO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudGVkIGluIHBsYXllci5qc1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5oYXNQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISFwbHVnaW5FeGlzdHMobmFtZSk7XG59O1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBpcyBhYm91dCB0byBiZSBzZXQgdXAgb24gYSBwbGF5ZXIuXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cFxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI3BsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaGFzIGp1c3QgYmVlbiBzZXQgdXAgb24gYSBwbGF5ZXIgLSBieSBuYW1lLiBUaGUgbmFtZVxuICogaXMgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI3BsdWdpbnNldHVwOiRuYW1lXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiAge09iamVjdH0gUGx1Z2luflBsdWdpbkV2ZW50SGFzaFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbnN0YW5jZVxuICogICAgICAgICAgIEZvciBiYXNpYyBwbHVnaW5zLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwbHVnaW4gZnVuY3Rpb24uIEZvclxuICogICAgICAgICAgIGFkdmFuY2VkIHBsdWdpbnMsIHRoZSBwbHVnaW4gaW5zdGFuY2Ugb24gd2hpY2ggdGhlIGV2ZW50IGlzIGZpcmVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGx1Z2luXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSBwbHVnaW4gZnVuY3Rpb24uIEZvciBhZHZhbmNlZCBwbHVnaW5zLCB0aGVcbiAqICAgICAgICAgICBwbHVnaW4gY2xhc3MvY29uc3RydWN0b3IuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBleHRlbmQuanNcbiAqIEBtb2R1bGUgZXh0ZW5kXG4gKi9cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIG5vZGUgaW5oZXJpdHMgYW5kIGJhYmVsJ3MgaW5oZXJpdHMgKGFmdGVyIHRyYW5zcGlsZSkuXG4gKiBCb3RoIHdvcmsgdGhlIHNhbWUgYnV0IG5vZGUgYWRkcyBgc3VwZXJfYCB0byB0aGUgc3ViQ2xhc3NcbiAqIGFuZCBCYWJsZSBhZGRzIHRoZSBzdXBlckNsYXNzIGFzIF9fcHJvdG9fXy4gQm90aCBzZWVtIHVzZWZ1bC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3ViQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCB0b1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfaW5oZXJpdHMgPSBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAvLyBub2RlXG4gICAgc3ViQ2xhc3Muc3VwZXJfID0gc3VwZXJDbGFzcztcbiAgfVxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBmb3Igc3ViY2xhc3NpbmcgdXNpbmcgdGhlIHNhbWUgaW5oZXJpdGFuY2UgdGhhdFxuICogdmlkZW9qcyB1c2VzIGludGVybmFsbHlcbiAqXG4gKiBAc3RhdGljXG4gKiBAY29uc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3VwZXJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3N1YkNsYXNzTWV0aG9kcz17fV1cbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCB0b1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIG5ldyBvYmplY3Qgd2l0aCBzdWJDbGFzc01ldGhvZHMgdGhhdCBpbmhlcml0ZWQgc3VwZXJDbGFzcy5cbiAqL1xudmFyIGV4dGVuZEZuID0gZnVuY3Rpb24gZXh0ZW5kRm4oc3VwZXJDbGFzcykge1xuICB2YXIgc3ViQ2xhc3NNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICB2YXIgc3ViQ2xhc3MgPSBmdW5jdGlvbiBzdWJDbGFzcygpIHtcbiAgICBzdXBlckNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fTtcblxuICBpZiAoKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN1YkNsYXNzTWV0aG9kcykpID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBtZXRob2RzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJDbGFzc01ldGhvZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJDbGFzcyA9IHN1YkNsYXNzTWV0aG9kcztcbiAgfVxuXG4gIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG5cbiAgLy8gRXh0ZW5kIHN1Yk9iaidzIHByb3RvdHlwZSB3aXRoIGZ1bmN0aW9ucyBhbmQgb3RoZXIgcHJvcGVydGllcyBmcm9tIHByb3BzXG4gIGZvciAodmFyIG5hbWUgaW4gbWV0aG9kcykge1xuICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBzdWJDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RzW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJDbGFzcztcbn07XG5cbi8qKlxuICogQGZpbGUgdmlkZW8uanNcbiAqIEBtb2R1bGUgdmlkZW9qc1xuICovXG4vLyBJbmNsdWRlIHRoZSBidWlsdC1pbiB0ZWNoc1xuLy8gSFRNTDUgRWxlbWVudCBTaGltIGZvciBJRThcbmlmICh0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgaXNSZWFsKCkpIHtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhY2snKTtcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8tanMnKTtcbn1cblxuLyoqXG4gKiBEb3VibGVzIGFzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciB1c2VycyB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2UgYW5kIGFsc29cbiAqIHRoZSBtYWluIGxpYnJhcnkgb2JqZWN0LlxuICogVGhlIGB2aWRlb2pzYCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBpbml0aWFsaXplIG9yIHJldHJpZXZlIGEgcGxheWVyLlxuICAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBpZFxuICogICAgICAgIFZpZGVvIGVsZW1lbnQgb3IgdmlkZW8gZWxlbWVudCBJRFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgICAgICBPcHRpb25hbCBvcHRpb25zIG9iamVjdCBmb3IgY29uZmlnL3NldHRpbmdzXG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICogICAgICAgIE9wdGlvbmFsIHJlYWR5IGNhbGxiYWNrXG4gKlxuICogQHJldHVybiB7UGxheWVyfVxuICogICAgICAgICBBIHBsYXllciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiB2aWRlb2pzKGlkLCBvcHRpb25zLCByZWFkeSkge1xuICB2YXIgdGFnID0gdm9pZCAwO1xuXG4gIC8vIEFsbG93IGZvciBlbGVtZW50IG9yIElEIHRvIGJlIHBhc3NlZCBpblxuICAvLyBTdHJpbmcgSURcbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgcGxheWVycyA9IHZpZGVvanMuZ2V0UGxheWVycygpO1xuXG4gICAgLy8gQWRqdXN0IGZvciBqUXVlcnkgSUQgc3ludGF4XG4gICAgaWYgKGlkLmluZGV4T2YoJyMnKSA9PT0gMCkge1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHBsYXllciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoaXMgSUQgcmV0dXJuIGl0LlxuICAgIGlmIChwbGF5ZXJzW2lkXSkge1xuXG4gICAgICAvLyBJZiBvcHRpb25zIG9yIHJlYWR5IGZ1bmN0aW9uIGFyZSBwYXNzZWQsIHdhcm5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGxvZyQxLndhcm4oJ1BsYXllciBcIicgKyBpZCArICdcIiBpcyBhbHJlYWR5IGluaXRpYWxpc2VkLiBPcHRpb25zIHdpbGwgbm90IGJlIGFwcGxpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFkeSkge1xuICAgICAgICBwbGF5ZXJzW2lkXS5yZWFkeShyZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwbGF5ZXJzW2lkXTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgZ2V0IGVsZW1lbnQgZm9yIElEXG4gICAgdGFnID0gJCgnIycgKyBpZCk7XG5cbiAgICAvLyBJRCBpcyBhIG1lZGlhIGVsZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBpZDtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBhIHVzZWFibGUgZWxlbWVudFxuICAvLyByZTogbm9kZU5hbWUsIGNvdWxkIGJlIGEgYm94IGRpdiBhbHNvXG4gIGlmICghdGFnIHx8ICF0YWcubm9kZU5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZWxlbWVudCBvciBJRCBzdXBwbGllZCBpcyBub3QgdmFsaWQuICh2aWRlb2pzKScpO1xuICB9XG5cbiAgLy8gRWxlbWVudCBtYXkgaGF2ZSBhIHBsYXllciBhdHRyIHJlZmVycmluZyB0byBhbiBhbHJlYWR5IGNyZWF0ZWQgcGxheWVyIGluc3RhbmNlLlxuICAvLyBJZiBzbyByZXR1cm4gdGhhdCBvdGhlcndpc2Ugc2V0IHVwIGEgbmV3IHBsYXllciBiZWxvd1xuICBpZiAodGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdKSB7XG4gICAgcmV0dXJuIHRhZy5wbGF5ZXIgfHwgUGxheWVyLnBsYXllcnNbdGFnLnBsYXllcklkXTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGVsZW1lbnQgaXMgaW5jbHVkZWQgaW4gdGhlIERPTVxuICBpZiAoaXNFbCh0YWcpICYmICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhZykpIHtcbiAgICBsb2ckMS53YXJuKCdUaGUgZWxlbWVudCBzdXBwbGllZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIERPTScpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmlkZW9qcy5ob29rcygnYmVmb3Jlc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICB2YXIgb3B0cyA9IGhvb2tGdW5jdGlvbih0YWcsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdHMpIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG4gIH0pO1xuXG4gIHZhciBQbGF5ZXJDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcbiAgLy8gSWYgbm90LCBzZXQgdXAgYSBuZXcgcGxheWVyXG4gIHZhciBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KHRhZywgb3B0aW9ucywgcmVhZHkpO1xuXG4gIHZpZGVvanMuaG9va3MoJ3NldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGhvb2tGdW5jdGlvbihwbGF5ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcGxheWVyO1xufVxuXG4vKipcbiAqIEFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGxpZmVjeWNsZSBob29rcyBhcyBrZXlzIHdoaWNoIHBvaW50IHRvIGFuIGFycmF5XG4gKiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgcnVuIHdoZW4gYSBsaWZlY3ljbGUgaXMgdHJpZ2dlcmVkXG4gKi9cbnZpZGVvanMuaG9va3NfID0ge307XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBob29rcyBmb3IgYSBzcGVjaWZpYyBsaWZlY3ljbGVcbiAqIEBmdW5jdGlvbiB2aWRlb2pzLmhvb2tzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5bGUgdG8gZ2V0IGhvb2tzIGZyb21cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119IFtmbl1cbiAqICAgICAgICBPcHRpb25hbGx5IGFkZCBhIGhvb2sgKG9yIGhvb2tzKSB0byB0aGUgbGlmZWN5Y2xlIHRoYXQgeW91ciBhcmUgZ2V0dGluZy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqICAgICAgICAgYW4gYXJyYXkgb2YgaG9va3MsIG9yIGFuIGVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBub25lLlxuICovXG52aWRlb2pzLmhvb2tzID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0gfHwgW107XG4gIGlmIChmbikge1xuICAgIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0uY29uY2F0KGZuKTtcbiAgfVxuICByZXR1cm4gdmlkZW9qcy5ob29rc19bdHlwZV07XG59O1xuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIGhvb2sgdG8gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdG8gaG9vayB0aGUgZnVuY3Rpb24gdG8uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYXR0YWNoLlxuICovXG52aWRlb2pzLmhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rcyh0eXBlLCBmbik7XG59O1xuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIGhvb2sgdGhhdCB3aWxsIG9ubHkgcnVuIG9uY2UgdG8gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdG8gaG9vayB0aGUgZnVuY3Rpb24gdG8uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxGdW5jdGlvbltdfVxuICogICAgICAgIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYXR0YWNoLlxuICovXG52aWRlb2pzLmhvb2tPbmNlID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gIHZpZGVvanMuaG9va3ModHlwZSwgW10uY29uY2F0KGZuKS5tYXAoZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgdmlkZW9qcy5yZW1vdmVIb29rKHR5cGUsIHdyYXBwZXIpO1xuICAgICAgb3JpZ2luYWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBob29rIGZyb20gYSBzcGVjaWZpYyB2aWRlb2pzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIHRoZSBsaWZlY3ljbGUgdGhhdCB0aGUgZnVuY3Rpb24gaG9va2VkIHRvXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgaG9va2VkIGZ1bmN0aW9uIHRvIHJlbW92ZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdhcyByZW1vdmVkIG9yIHVuZGVmXG4gKi9cbnZpZGVvanMucmVtb3ZlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2YXIgaW5kZXggPSB2aWRlb2pzLmhvb2tzKHR5cGUpLmluZGV4T2YoZm4pO1xuXG4gIGlmIChpbmRleCA8PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0uc2xpY2UoKTtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0uc3BsaWNlKGluZGV4LCAxKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFkZCBkZWZhdWx0IHN0eWxlc1xuaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUgJiYgaXNSZWFsKCkpIHtcbiAgdmFyIHN0eWxlID0gJCgnLnZqcy1zdHlsZXMtZGVmYXVsdHMnKTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGVmYXVsdHMnKTtcbiAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgIGlmIChoZWFkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc2V0VGV4dENvbnRlbnQoc3R5bGUsICdcXG4gICAgICAudmlkZW8tanMge1xcbiAgICAgICAgd2lkdGg6IDMwMHB4O1xcbiAgICAgICAgaGVpZ2h0OiAxNTBweDtcXG4gICAgICB9XFxuXFxuICAgICAgLnZqcy1mbHVpZCB7XFxuICAgICAgICBwYWRkaW5nLXRvcDogNTYuMjUlXFxuICAgICAgfVxcbiAgICAnKTtcbiAgfVxufVxuXG4vLyBSdW4gQXV0by1sb2FkIHBsYXllcnNcbi8vIFlvdSBoYXZlIHRvIHdhaXQgYXQgbGVhc3Qgb25jZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCBhZnRlciB5b3VyXG4vLyB2aWRlbyBpbiB0aGUgRE9NICh3ZWlyZCBiZWhhdmlvciBvbmx5IHdpdGggbWluaWZpZWQgdmVyc2lvbilcbmF1dG9TZXR1cFRpbWVvdXQoMSwgdmlkZW9qcyk7XG5cbi8qKlxuICogQ3VycmVudCBzb2Z0d2FyZSB2ZXJzaW9uLiBGb2xsb3dzIHNlbXZlci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52aWRlb2pzLlZFUlNJT04gPSB2ZXJzaW9uO1xuXG4vKipcbiAqIFRoZSBnbG9iYWwgb3B0aW9ucyBvYmplY3QuIFRoZXNlIGFyZSB0aGUgc2V0dGluZ3MgdGhhdCB0YWtlIGVmZmVjdFxuICogaWYgbm8gb3ZlcnJpZGVzIGFyZSBzcGVjaWZpZWQgd2hlbiB0aGUgcGxheWVyIGlzIGNyZWF0ZWQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmlkZW9qcy5vcHRpb25zID0gUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXztcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdpdGggdGhlIGN1cnJlbnRseSBjcmVhdGVkIHBsYXllcnMsIGtleWVkIGJ5IHBsYXllciBJRFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIGNyZWF0ZWQgcGxheWVyc1xuICovXG52aWRlb2pzLmdldFBsYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBQbGF5ZXIucGxheWVycztcbn07XG5cbi8qKlxuICogRXhwb3NlIHBsYXllcnMgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJPZiB2aWRlb2pzXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGxheWVyc1xuICovXG52aWRlb2pzLnBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcblxuLyoqXG4gKiBHZXQgYSBjb21wb25lbnQgY2xhc3Mgb2JqZWN0IGJ5IG5hbWVcbiAqXG4gKiBAYm9ycm93cyBDb21wb25lbnQuZ2V0Q29tcG9uZW50IGFzIHZpZGVvanMuZ2V0Q29tcG9uZW50XG4gKi9cbnZpZGVvanMuZ2V0Q29tcG9uZW50ID0gQ29tcG9uZW50LmdldENvbXBvbmVudDtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNvbXBvbmVudCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS4gVXNlZCB3aGVuIGFkZGluZyB0byBvdGhlclxuICogY29tcG9uZW50cywgZWl0aGVyIHRocm91Z2ggYWRkQ2hpbGQgYGNvbXBvbmVudC5hZGRDaGlsZCgnbXlDb21wb25lbnQnKWAgb3IgdGhyb3VnaFxuICogZGVmYXVsdCBjaGlsZHJlbiBvcHRpb25zICBgeyBjaGlsZHJlbjogWydteUNvbXBvbmVudCddIH1gLlxuICpcbiAqID4gTk9URTogWW91IGNvdWxkIGFsc28ganVzdCBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgYmVmb3JlIGFkZGluZy5cbiAqIGBjb21wb25lbnQuYWRkQ2hpbGQobmV3IE15Q29tcG9uZW50KCkpO2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICAgICAgIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcFxuICogICAgICAgIFRoZSBjb21wb25lbnQgY2xhc3NcbiAqXG4gKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gKiAgICAgICAgIFRoZSBuZXdseSByZWdpc3RlcmVkIGNvbXBvbmVudFxuICovXG52aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUkJDEsIGNvbXApIHtcbiAgaWYgKFRlY2guaXNUZWNoKGNvbXApKSB7XG4gICAgbG9nJDEud2FybignVGhlICcgKyBuYW1lJCQxICsgJyB0ZWNoIHdhcyByZWdpc3RlcmVkIGFzIGEgY29tcG9uZW50LiBJdCBzaG91bGQgaW5zdGVhZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XG4gIH1cblxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQuY2FsbChDb21wb25lbnQsIG5hbWUkJDEsIGNvbXApO1xufTtcblxuLyoqXG4gKiBHZXQgYSBUZWNoIGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgVGVjaC5nZXRUZWNoIGFzIHZpZGVvanMuZ2V0VGVjaFxuICovXG52aWRlb2pzLmdldFRlY2ggPSBUZWNoLmdldFRlY2g7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBUZWNoIHNvIGl0IGNhbiByZWZlcnJlZCB0byBieSBuYW1lLlxuICogVGhpcyBpcyB1c2VkIGluIHRoZSB0ZWNoIG9yZGVyIGZvciB0aGUgcGxheWVyLlxuICpcbiAqIEBib3Jyb3dzIFRlY2gucmVnaXN0ZXJUZWNoIGFzIHZpZGVvanMucmVnaXN0ZXJUZWNoXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJUZWNoID0gVGVjaC5yZWdpc3RlclRlY2g7XG5cbnZpZGVvanMudXNlID0gdXNlO1xuXG4vKipcbiAqIEEgc3VpdGUgb2YgYnJvd3NlciBhbmQgZGV2aWNlIHRlc3RzIGZyb20ge0BsaW5rIGJyb3dzZXJ9LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52aWRlb2pzLmJyb3dzZXIgPSBicm93c2VyO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBicm93c2VyIHN1cHBvcnRzIHRvdWNoIGV2ZW50cy4gSW5jbHVkZWQgZm9yIGJhY2t3YXJkXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggNC54LCBidXQgZGVwcmVjYXRlZC4gVXNlIGB2aWRlb2pzLmJyb3dzZXIuVE9VQ0hfRU5BQkxFRGBcbiAqIGluc3RlYWQgZ29pbmcgZm9yd2FyZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZpZGVvanMuVE9VQ0hfRU5BQkxFRCA9IFRPVUNIX0VOQUJMRUQ7XG5cbi8qKlxuICogU3ViY2xhc3MgYW4gZXhpc3RpbmcgY2xhc3NcbiAqIE1pbWljcyBFUzYgc3ViY2xhc3Npbmcgd2l0aCB0aGUgYGV4dGVuZGAga2V5d29yZFxuICpcbiAqIEBib3Jyb3dzIGV4dGVuZDpleHRlbmRGbiBhcyB2aWRlb2pzLmV4dGVuZFxuICovXG52aWRlb2pzLmV4dGVuZCA9IGV4dGVuZEZuO1xuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb25zIG9iamVjdHMgcmVjdXJzaXZlbHlcbiAqIFBlcmZvcm1zIGEgZGVlcCBtZXJnZSBsaWtlIGxvZGFzaC5tZXJnZSBidXQgKipvbmx5IG1lcmdlcyBwbGFpbiBvYmplY3RzKipcbiAqIChub3QgYXJyYXlzLCBlbGVtZW50cywgYW55dGhpbmcgZWxzZSlcbiAqIE90aGVyIHZhbHVlcyB3aWxsIGJlIGNvcGllZCBkaXJlY3RseSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0LlxuICpcbiAqIEBib3Jyb3dzIG1lcmdlLW9wdGlvbnM6bWVyZ2VPcHRpb25zIGFzIHZpZGVvanMubWVyZ2VPcHRpb25zXG4gKi9cbnZpZGVvanMubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xuXG4vKipcbiAqIENoYW5nZSB0aGUgY29udGV4dCAodGhpcykgb2YgYSBmdW5jdGlvblxuICpcbiAqID4gTk9URTogYXMgb2YgdjUuMCB3ZSByZXF1aXJlIGFuIEVTNSBzaGltLCBzbyB5b3Ugc2hvdWxkIHVzZSB0aGUgbmF0aXZlXG4gKiBgZnVuY3Rpb24oKSB7fS5iaW5kKG5ld0NvbnRleHQpO2AgaW5zdGVhZCBvZiB0aGlzLlxuICpcbiAqIEBib3Jyb3dzIGZuOmJpbmQgYXMgdmlkZW9qcy5iaW5kXG4gKi9cbnZpZGVvanMuYmluZCA9IGJpbmQ7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXG4gKlxuICogQGJvcnJvd3MgcGx1Z2luOnJlZ2lzdGVyUGx1Z2luIGFzIHZpZGVvanMucmVnaXN0ZXJQbHVnaW5cbiAqIEBtZXRob2QgcmVnaXN0ZXJQbHVnaW5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiB0byBiZSByZWdpc3RlcmVkLiBNdXN0IGJlIGEgc3RyaW5nIGFuZFxuICogICAgICAgICBtdXN0IG5vdCBtYXRjaCBhbiBleGlzdGluZyBwbHVnaW4gb3IgYSBtZXRob2Qgb24gdGhlIGBQbGF5ZXJgXG4gKiAgICAgICAgIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGx1Z2luXG4gKiAgICAgICAgIEEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gIG9yIGEgZnVuY3Rpb24gZm9yIGJhc2ljIHBsdWdpbnMuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcbiAqICAgICAgICAgYmFzaWMgcGx1Z2lucywgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIHBsdWdpbi5cbiAqL1xudmlkZW9qcy5yZWdpc3RlclBsdWdpbiA9IFBsdWdpbi5yZWdpc3RlclBsdWdpbjtcblxuLyoqXG4gKiBEZXByZWNhdGVkIG1ldGhvZCB0byByZWdpc3RlciBhIHBsdWdpbiB3aXRoIFZpZGVvLmpzXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqICAgICAgICB2aWRlb2pzLnBsdWdpbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCkgaW5zdGVhZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgVGhlIHBsdWdpbiBuYW1lXG4gKlxuICogQHBhcmFtIHtQbHVnaW58RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBUaGUgcGx1Z2luIHN1Yi1jbGFzcyBvciBmdW5jdGlvblxuICovXG52aWRlb2pzLnBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lJCQxLCBwbHVnaW4pIHtcbiAgbG9nJDEud2FybigndmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWQnKTtcbiAgcmV0dXJuIFBsdWdpbi5yZWdpc3RlclBsdWdpbihuYW1lJCQxLCBwbHVnaW4pO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIFZpZGVvLmpzIHBsdWdpbnMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IFtuYW1lc11cbiAqICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gKiAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcbiAqICAgICAgICAgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgcGx1Z2lucyBleGlzdCkuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2lucyA9IFBsdWdpbi5nZXRQbHVnaW5zO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxuICovXG52aWRlb2pzLmdldFBsdWdpbiA9IFBsdWdpbi5nZXRQbHVnaW47XG5cbi8qKlxuICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4ncyB2ZXJzaW9uIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW5WZXJzaW9uID0gUGx1Z2luLmdldFBsdWdpblZlcnNpb247XG5cbi8qKlxuICogQWRkaW5nIGxhbmd1YWdlcyBzbyB0aGF0IHRoZXkncmUgYXZhaWxhYmxlIHRvIGFsbCBwbGF5ZXJzLlxuICogRXhhbXBsZTogYHZpZGVvanMuYWRkTGFuZ3VhZ2UoJ2VzJywgeyAnSGVsbG8nOiAnSG9sYScgfSk7YFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiAgICAgICAgVGhlIGxhbmd1YWdlIGNvZGUgb3IgZGljdGlvbmFyeSBwcm9wZXJ0eVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiAgICAgICAgVGhlIGRhdGEgdmFsdWVzIHRvIGJlIHRyYW5zbGF0ZWRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSByZXN1bHRpbmcgbGFuZ3VhZ2UgZGljdGlvbmFyeSBvYmplY3RcbiAqL1xudmlkZW9qcy5hZGRMYW5ndWFnZSA9IGZ1bmN0aW9uIChjb2RlLCBkYXRhKSB7XG4gIHZhciBfbWVyZ2VPcHRpb25zO1xuXG4gIGNvZGUgPSAoJycgKyBjb2RlKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMgPSBtZXJnZU9wdGlvbnModmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlcywgKF9tZXJnZU9wdGlvbnMgPSB7fSwgX21lcmdlT3B0aW9uc1tjb2RlXSA9IGRhdGEsIF9tZXJnZU9wdGlvbnMpKTtcblxuICByZXR1cm4gdmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlc1tjb2RlXTtcbn07XG5cbi8qKlxuICogTG9nIG1lc3NhZ2VzXG4gKlxuICogQGJvcnJvd3MgbG9nOmxvZyBhcyB2aWRlb2pzLmxvZ1xuICovXG52aWRlb2pzLmxvZyA9IGxvZyQxO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW11bGF0ZWQgVGltZVJhbmdlIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyB0aW1lLXJhbmdlczpjcmVhdGVUaW1lUmFuZ2VzIGFzIHZpZGVvanMuY3JlYXRlVGltZVJhbmdlXG4gKi9cbi8qKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXNcbiAqL1xudmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2UgPSB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXMgPSBjcmVhdGVUaW1lUmFuZ2VzO1xuXG4vKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTU1xuICogU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICogdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGVcbiAqXG4gKiBAYm9ycm93cyBmb3JtYXQtdGltZTpmb3JtYXRUaW1lIGFzIHZpZGVvanMuZm9ybWF0VGltZVxuICovXG52aWRlb2pzLmZvcm1hdFRpbWUgPSBmb3JtYXRUaW1lO1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTFxuICpcbiAqIEBib3Jyb3dzIHVybDpwYXJzZVVybCBhcyB2aWRlb2pzLnBhcnNlVXJsXG4gKi9cbnZpZGVvanMucGFyc2VVcmwgPSBwYXJzZVVybDtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQGJvcnJvd3MgdXJsOmlzQ3Jvc3NPcmlnaW4gYXMgdmlkZW9qcy5pc0Nyb3NzT3JpZ2luXG4gKi9cbnZpZGVvanMuaXNDcm9zc09yaWdpbiA9IGlzQ3Jvc3NPcmlnaW47XG5cbi8qKlxuICogRXZlbnQgdGFyZ2V0IGNsYXNzLlxuICpcbiAqIEBib3Jyb3dzIEV2ZW50VGFyZ2V0IGFzIHZpZGVvanMuRXZlbnRUYXJnZXRcbiAqL1xudmlkZW9qcy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50XG4gKiBJdCBzdG9yZXMgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaW4gYSBzZXBhcmF0ZSBjYWNoZSBvYmplY3RcbiAqIGFuZCBhZGRzIGEgZ2VuZXJpYyBoYW5kbGVyIHRvIHRoZSBlbGVtZW50J3MgZXZlbnQsXG4gKiBhbG9uZyB3aXRoIGEgdW5pcXVlIGlkIChndWlkKSB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b24gYXMgdmlkZW9qcy5vblxuICovXG52aWRlb2pzLm9uID0gb247XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b25lIGFzIHZpZGVvanMub25lXG4gKi9cbnZpZGVvanMub25lID0gb25lO1xuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czpvZmYgYXMgdmlkZW9qcy5vZmZcbiAqL1xudmlkZW9qcy5vZmYgPSBvZmY7XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGV2ZW50czp0cmlnZ2VyIGFzIHZpZGVvanMudHJpZ2dlclxuICovXG52aWRlb2pzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXG4vKipcbiAqIEEgY3Jvc3MtYnJvd3NlciBYTUxIdHRwUmVxdWVzdCB3cmFwcGVyLiBIZXJlJ3MgYSBzaW1wbGUgZXhhbXBsZTpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAgICAgIHNldHRpbmdzIGZvciB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdHxYRG9tYWluUmVxdWVzdH1cbiAqICAgICAgICAgVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JheW5vcy94aHJcbiAqL1xudmlkZW9qcy54aHIgPSB4aHI7XG5cbi8qKlxuICogVGV4dFRyYWNrIGNsYXNzXG4gKlxuICogQGJvcnJvd3MgVGV4dFRyYWNrIGFzIHZpZGVvanMuVGV4dFRyYWNrXG4gKi9cbnZpZGVvanMuVGV4dFRyYWNrID0gVGV4dFRyYWNrO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgQXVkaW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBBdWRpb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBBdWRpb1RyYWNrTGlzdFxuICpcbiAqIEBib3Jyb3dzIEF1ZGlvVHJhY2sgYXMgdmlkZW9qcy5BdWRpb1RyYWNrXG4gKi9cbnZpZGVvanMuQXVkaW9UcmFjayA9IEF1ZGlvVHJhY2s7XG5cbi8qKlxuICogZXhwb3J0IHRoZSBWaWRlb1RyYWNrIGNsYXNzIHNvIHRoYXQgc291cmNlIGhhbmRsZXJzIGNhbiBjcmVhdGVcbiAqIFZpZGVvVHJhY2tzIGFuZCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBwbGF5ZXJzIFZpZGVvVHJhY2tMaXN0XG4gKlxuICogQGJvcnJvd3MgVmlkZW9UcmFjayBhcyB2aWRlb2pzLlZpZGVvVHJhY2tcbiAqL1xudmlkZW9qcy5WaWRlb1RyYWNrID0gVmlkZW9UcmFjaztcblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206aXNFbCBhcyB2aWRlb2pzLmlzRWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc0VsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgdGV4dCBub2RlLlxuICpcbiAqIEBib3Jyb3dzIGRvbTppc1RleHROb2RlIGFzIHZpZGVvanMuaXNUZXh0Tm9kZVxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmlzVGV4dE5vZGUoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVsZW1lbnQgYW5kIGFwcGxpZXMgcHJvcGVydGllcy5cbiAqXG4gKiBAYm9ycm93cyBkb206Y3JlYXRlRWwgYXMgdmlkZW9qcy5jcmVhdGVFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmNyZWF0ZUVsKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcbiAqXG4gKiBAYm9ycm93cyBkb206aGFzRWxDbGFzcyBhcyB2aWRlb2pzLmhhc0NsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaGFzQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZG9tOmFkZEVsQ2xhc3MgYXMgdmlkZW9qcy5hZGRDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmFkZENsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQGJvcnJvd3MgZG9tOnJlbW92ZUVsQ2xhc3MgYXMgdmlkZW9qcy5yZW1vdmVDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnJlbW92ZUNsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcbiAqIGNvbmRpdGlvbiBvciB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiB0aGUgY2xhc3MgbmFtZS5cbiAqXG4gKiBAYm9ycm93cyBkb206dG9nZ2xlRWxDbGFzcyBhcyB2aWRlb2pzLnRvZ2dsZUNsYXNzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20udG9nZ2xlQ2xhc3MoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBBcHBseSBhdHRyaWJ1dGVzIHRvIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAYm9ycm93cyBkb206c2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuc2V0QXR0cmlidXRlXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uc2V0QXR0cmlidXRlcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlcywgYXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0YWdcbiAqIEF0dHJpYnV0ZXMgYXJlIG5vdCB0aGUgc2FtZSBhcyBwcm9wZXJ0aWVzLiBUaGV5J3JlIGRlZmluZWQgb24gdGhlIHRhZ1xuICogb3Igd2l0aCBzZXRBdHRyaWJ1dGUgKHdoaWNoIHNob3VsZG4ndCBiZSB1c2VkIHdpdGggSFRNTClcbiAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBib3Jyb3dzIGRvbTpnZXRFbEF0dHJpYnV0ZXMgYXMgdmlkZW9qcy5nZXRBdHRyaWJ1dGVzXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uZ2V0QXR0cmlidXRlcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEVtcHRpZXMgdGhlIGNvbnRlbnRzIG9mIGFuIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOmVtcHR5RWwgYXMgdmlkZW9qcy5lbXB0eUVsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uZW1wdHlFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYW5kIGFwcGVuZHMgY29udGVudCB0byBhbiBlbGVtZW50LlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBTdHJpbmdcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICpcbiAqIC0gRWxlbWVudCwgVGV4dE5vZGVcbiAqICAgUGFzc2VkIHRocm91Z2guXG4gKlxuICogLSBBcnJheVxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxuICpcbiAqIC0gRnVuY3Rpb25cbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgIG5vZGUsIG9yIGFycmF5LlxuICpcbiAqIEBib3Jyb3dzIGRvbTphcHBlbmRDb250ZW50cyBhcyB2aWRlb2pzLmFwcGVuZENvbnRldFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmFwcGVuZENvbnRlbnQoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBpbnNlcnRzIGNvbnRlbnQgaW50byBhbiBlbGVtZW50OyB0aGlzIGlzIGlkZW50aWNhbCB0b1xuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxuICpcbiAqIFRoZSBjb250ZW50IGZvciBhbiBlbGVtZW50IGNhbiBiZSBwYXNzZWQgaW4gbXVsdGlwbGUgdHlwZXMgYW5kXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogLSBTdHJpbmdcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICpcbiAqIC0gRWxlbWVudCwgVGV4dE5vZGVcbiAqICAgUGFzc2VkIHRocm91Z2guXG4gKlxuICogLSBBcnJheVxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxuICpcbiAqIC0gRnVuY3Rpb25cbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgIG5vZGUsIG9yIGFycmF5LlxuICpcbiAqIEBib3Jyb3dzIGRvbTppbnNlcnRDb250ZW50IGFzIHZpZGVvanMuaW5zZXJ0Q29udGVudFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmluc2VydENvbnRlbnQoKSBpbnN0ZWFkXG4gKi9cblsnaXNFbCcsICdpc1RleHROb2RlJywgJ2NyZWF0ZUVsJywgJ2hhc0NsYXNzJywgJ2FkZENsYXNzJywgJ3JlbW92ZUNsYXNzJywgJ3RvZ2dsZUNsYXNzJywgJ3NldEF0dHJpYnV0ZXMnLCAnZ2V0QXR0cmlidXRlcycsICdlbXB0eUVsJywgJ2FwcGVuZENvbnRlbnQnLCAnaW5zZXJ0Q29udGVudCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgdmlkZW9qc1trXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2ckMS53YXJuKCd2aWRlb2pzLicgKyBrICsgJygpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLmRvbS4nICsgayArICcoKSBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIERvbVtrXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8qKlxuICogQSBzYWZlIGdldENvbXB1dGVkU3R5bGUgd2l0aCBhbiBJRTggZmFsbGJhY2suXG4gKlxuICogVGhpcyBpcyBiZWNhdXNlIGluIEZpcmVmb3gsIGlmIHRoZSBwbGF5ZXIgaXMgbG9hZGVkIGluIGFuIGlmcmFtZSB3aXRoIGBkaXNwbGF5Om5vbmVgLFxuICogdGhlbiBgZ2V0Q29tcHV0ZWRTdHlsZWAgcmV0dXJucyBgbnVsbGAsIHNvLCB3ZSBkbyBhIG51bGwtY2hlY2sgdG8gbWFrZSBzdXJlXG4gKiB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBicmVhayBpbiB0aGVzZSBjYXNlcy5cbiAqIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTcgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAYm9ycm93cyBjb21wdXRlZC1zdHlsZTpjb21wdXRlZFN0eWxlIGFzIHZpZGVvanMuY29tcHV0ZWRTdHlsZVxuICovXG52aWRlb2pzLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgRG9tIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcy5kb20gPSBEb207XG5cbi8qKlxuICogRXhwb3J0IHRoZSBVcmwgdXRpbGl0aWVzIGZvciB1c2UgaW4gZXh0ZXJuYWwgcGx1Z2luc1xuICogYW5kIFRlY2gnc1xuICovXG52aWRlb2pzLnVybCA9IFVybDtcblxubW9kdWxlLmV4cG9ydHMgPSB2aWRlb2pzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fdmlkZW8uanNANi42LjBAdmlkZW8uanMvZGlzdC92aWRlby5janMuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBWUE7OztBQWVBOzs7Ozs7QUFXQTtBQUdBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBa0JBO0FBcUJBOzs7QUF5SEE7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7OztBQWVBOzs7Ozs7Ozs7QUFnQ0E7Ozs7OztBQVdBOzs7QUFRQTtBQUdBO0FBR0E7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFTQTtBQUlBO0FBS0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBV0E7QUFDQTtBQUtBO0FBQ0E7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7O0FBbUJBOzs7QUFRQTs7QUFTQTs7QUFVQTs7Ozs7QUFZQTs7Ozs7QUFjQTs7Ozs7O0FBZUE7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7O0FBb0JBOzs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7O0FBZ0JBOzs7O0FBU0E7QUFJQTtBQUdBO0FBQ0E7Ozs7Ozs7OztBQWNBOzs7OztBQVVBO0FBR0E7QUFDQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBO0FBWUE7QUFDQTtBQUNBO0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7QUE4QkE7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7O0FBb0JBO0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFHQTtBQUNBO0FBQ0E7QUFXQTtBQUNBOzs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7QUF3QkE7QUFJQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBYUE7O0FBT0E7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7O0FBYUE7QUEwQkE7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7OztBQWdDQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7O0FBY0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFNQTtBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7OztBQXdDQTs7O0FBSUE7Ozs7O0FBUUE7OztBQVFBOzs7Ozs7Ozs7QUFVQTs7Ozs7O0FBU0E7Ozs7Ozs7O0FBV0E7Ozs7Ozs7OztBQXdCQTs7Ozs7QUFnQkE7QUFRQTtBQUdBO0FBT0E7Ozs7Ozs7QUFjQTs7Ozs7Ozs7QUFTQTtBQUlBO0FBR0E7QUFFQTtBQUNBO0FBUUE7QUFPQTs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFHQTs7Ozs7Ozs7QUFhQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBS0E7QUFLQTtBQVlBO0FBWUE7QUFXQTtBQVNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTs7QUFNQTtBQWNBOztBQU1BOzs7Ozs7Ozs7Ozs7OztBQWlCQTtBQVFBO0FBNkJBOzs7Ozs7Ozs7Ozs7QUE0Q0E7QUFFQTtBQU9BO0FBU0E7QUFNQTtBQVlBO0FBS0E7QUFNQTs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBSUE7QUFHQTtBQUtBO0FBQ0E7QUFJQTtBQUlBO0FBRUE7QUFFQTtBQUlBO0FBS0E7Ozs7Ozs7Ozs7O0FBZUE7QUFVQTs7Ozs7QUFrQkE7O0FBTUE7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXdCQTtBQU1BO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUVBO0FBS0E7QUFPQTs7Ozs7Ozs7O0FBZUE7Ozs7QUFnQkE7OztBQVNBOzs7Ozs7OztBQVNBOzs7Ozs7OztBQWlCQTs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUVBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBaUJBOztBQWtCQTs7Ozs7OztBQVFBOzs7OztBQVNBOzs7Ozs7Ozs7OztBQWFBOzs7Ozs7OztBQVNBOzs7Ozs7Ozs7QUFZQTtBQUVBO0FBQ0E7Ozs7OztBQWNBOzs7Ozs7Ozs7O0FBYUE7Ozs7OztBQVdBOzs7Ozs7Ozs7O0FBYUE7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7OztBQXNCQTs7O0FBTUE7Ozs7Ozs7O0FBU0E7Ozs7Ozs7OztBQWdCQTtBQUdBO0FBQ0E7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFHQTtBQUNBO0FBU0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQTs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFnQkE7QUFHQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBO0FBZ0JBO0FBSUE7QUFXQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFHQTtBQUlBO0FBS0E7QUFLQTtBQUdBO0FBQ0E7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBTUE7QUFZQTs7O0FBY0E7Ozs7O0FBTUE7Ozs7O0FBUUE7Ozs7Ozs7Ozs7OztBQWVBO0FBSUE7QUFTQTtBQUNBO0FBWUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBSUE7QUFDQTtBQUdBOzs7QUFZQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7QUFvQkE7OztBQVFBOzs7Ozs7Ozs7QUFVQTs7OztBQWtDQTs7Ozs7OztBQVNBOzs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUtBO0FBRUE7QUFLQTtBQUdBO0FBR0E7QUFHQTtBQUVBO0FBUUE7QUFPQTtBQUVBO0FBU0E7QUFNQTtBQUVBOzs7O0FBWUE7Ozs7Ozs7OztBQVlBO0FBR0E7QUFTQTtBQU1BO0FBU0E7Ozs7O0FBV0E7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENBOzs7Ozs7QUEwQ0E7Ozs7O0FBWUE7Ozs7OztBQWFBOzs7OztBQVlBOzs7Ozs7OztBQWVBOzs7Ozs7OztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQVFBO0FBTUE7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQVdBO0FBQ0E7QUFPQTtBQUNBO0FBUUE7Ozs7OztBQVlBOztBQXNDQTtBQU9BO0FBT0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBV0E7QUFGQTtBQXlCQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFpQkE7QUFFQTtBQUNBOzs7Ozs7O0FBYUE7QUFpQkE7Ozs7QUFXQTtBQUlBO0FBSUE7QUFTQTs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7QUFnQkE7Ozs7O0FBWUE7Ozs7O0FBWUE7Ozs7Ozs7Ozs7QUFpQkE7OztBQVVBOzs7QUFVQTs7Ozs7QUFZQTs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7QUFlQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7QUFHQTtBQUtBO0FBU0E7Ozs7O0FBT0E7QUFPQTtBQUNBO0FBS0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQWdCQTtBQWNBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQXNCQTs7Ozs7O0FBU0E7Ozs7O0FBZUE7Ozs7O0FBWUE7O0FBU0E7O0FBU0E7Ozs7Ozs7Ozs7OztBQW1CQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUVBO0FBS0E7QUFFQTtBQU1BO0FBSUE7QUFDQTtBQWVBO0FBSUE7QUFDQTtBQUdBO0FBRUE7QUFHQTtBQUVBOzs7OztBQU9BO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBRUE7QUFLQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBTUE7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBO0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFjQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBUUE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7Ozs7QUF5QkE7OztBQVNBOzs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkE7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUE4QkE7OztBQWFBOzs7Ozs7Ozs7OztBQVlBO0FBa0JBOzs7O0FBZUE7Ozs7OztBQU9BO0FBR0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQU1BO0FBRUE7QUFPQTs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUdBO0FBQ0E7QUFRQTtBQUlBO0FBQ0E7Ozs7QUFpQkE7Ozs7O0FBUUE7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7OztBQWVBOzs7OztBQVFBO0FBU0E7QUFDQTtBQUdBOzs7Ozs7OztBQVlBOzs7Ozs7OztBQWFBOzs7OztBQWFBOzs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7O0FBa0NBOzs7Ozs7Ozs7O0FBZ0NBOztBQW1CQTs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTtBQVdBO0FBQ0E7QUFDQTs7Ozs7QUF5QkE7Ozs7O0FBNEJBOzs7Ozs7OztBQWVBOzs7OztBQWNBOzs7Ozs7QUFhQTtBQUlBOzs7OztBQWVBOzs7OztBQVVBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFXQTs7Ozs7QUFhQTs7Ozs7Ozs7QUFnQkE7Ozs7OztBQWdCQTs7Ozs7QUFZQTs7Ozs7QUF3QkE7Ozs7Ozs7O0FBbUJBO0FBTUE7QUFHQTtBQUNBO0FBU0E7OztBQWVBOzs7Ozs7Ozs7QUFnQkE7Ozs7O0FBV0E7QUFJQTtBQUNBOzs7OztBQVNBO0FBR0E7QUFPQTs7Ozs7QUFlQTs7Ozs7QUFPQTs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7QUFjQTs7OztBQXNCQTs7OztBQWdCQTtBQUVBOzs7O0FBbUNBOzs7OztBQW1CQTs7QUFVQTs7Ozs7QUFPQTs7Ozs7Ozs7OztBQWNBO0FBWUE7Ozs7O0FBa0JBO0FBV0E7QUFDQTs7Ozs7OztBQWFBO0FBWUE7Ozs7Ozs7QUFVQTs7Ozs7OztBQWlCQTs7Ozs7OztBQTRCQTs7Ozs7OztBQWdCQTs7Ozs7QUF5QkE7Ozs7O0FBUUE7QUFPQTs7QUFPQTs7Ozs7Ozs7Ozs7QUFZQTtBQU1BOzs7OztBQVdBOzs7OztBQVNBO0FBU0E7QUFDQTtBQVFBO0FBQ0E7Ozs7Ozs7QUE4QkE7QUFTQTs7O0FBUUE7QUFFQTtBQUNBO0FBQ0E7O0FBZ0JBOzs7Ozs7Ozs7O0FBV0E7QUFNQTs7Ozs7QUFXQTs7Ozs7QUFTQTtBQVNBO0FBQ0E7QUFRQTtBQUNBOzs7QUFxQkE7Ozs7Ozs7QUF5QkE7QUFTQTs7O0FBUUE7O0FBaUJBOzs7OztBQU9BOzs7OztBQVNBO0FBU0E7QUFDQTs7Ozs7OztBQTRCQTs7O0FBT0E7O0FBb0JBOztBQUlBOzs7OztBQVFBO0FBTUE7Ozs7O0FBa0JBOzs7Ozs7O0FBeUJBO0FBWUE7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7O0FBd0JBOztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7OztBQU1BOzs7OztBQVFBO0FBS0E7Ozs7O0FBa0JBOzs7Ozs7OztBQXNCQTs7Ozs7Ozs7QUFzQ0E7O0FBc0JBOzs7Ozs7QUFPQTs7Ozs7O0FBZ0JBOzs7Ozs7QUFnQkE7Ozs7OztBQWVBOztBQVNBOzs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQVVBOzs7Ozs7O0FBeUJBOzs7Ozs7O0FBU0E7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFVQTs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7QUFTQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBUUE7QUFLQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOzs7Ozs7Ozs7OztBQStCQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7O0FBc0JBO0FBS0E7QUFHQTtBQUNBOztBQWVBOzs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUE4Q0E7QUFrQkE7QUFDQTs7Ozs7QUF5QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTtBQXFCQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7O0FBZ0JBOzs7Ozs7OztBQTBCQTs7Ozs7QUFVQTs7Ozs7QUFpQkE7QUFPQTs7Ozs7QUF1REE7QUFhQTs7Ozs7QUF3QkE7O0FBc0JBOzs7Ozs7QUFZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBVUE7QUFDQTs7Ozs7Ozs7QUFtQkE7QUFNQTs7Ozs7Ozs7O0FBZUE7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTtBQVdBO0FBQ0E7Ozs7Ozs7O0FBb0JBO0FBTUE7Ozs7Ozs7OztBQWVBO0FBS0E7QUFDQTtBQUNBOztBQWNBOzs7O0FBS0E7Ozs7O0FBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTtBQVNBOzs7OztBQXdCQTs7Ozs7O0FBYUE7OztBQVlBOzs7QUFrQ0E7O0FBa0RBOzs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7O0FBNkJBOzs7Ozs7OztBQVlBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFtQkE7QUFLQTtBQXlCQTtBQWFBOzs7O0FBT0E7QUFNQTs7O0FBU0E7Ozs7Ozs7Ozs7OztBQXNCQTtBQUtBOzs7OztBQVNBOzs7Ozs7OztBQXNCQTs7Ozs7QUFZQTs7Ozs7OztBQWNBOzs7OztBQVlBOzs7O0FBV0E7OztBQWFBOzs7Ozs7QUFnQkE7Ozs7O0FBV0E7QUFHQTs7Ozs7QUFXQTtBQUlBO0FBQ0E7Ozs7O0FBV0E7QUFHQTtBQUdBOzs7Ozs7Ozs7QUF1QkE7QUFLQTs7O0FBcUJBOzs7O0FBa0JBOzs7Ozs7OztBQWFBOzs7Ozs7Ozs7QUFvQkE7Ozs7O0FBZUE7QUFFQTs7Ozs7QUFPQTs7Ozs7Ozs7O0FBZ0JBOzs7OztBQVVBOzs7OztBQU9BOzs7OztBQU1BOzs7OztBQTBCQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7Ozs7O0FBVUE7Ozs7O0FBU0E7QUFPQTtBQUNBOzs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7QUF1RUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBO0FBVUE7QUFLQTtBQUtBOzs7OztBQWdCQTtBQUlBOzs7Ozs7Ozs7O0FBa0JBOzs7O0FBV0E7Ozs7QUFTQTs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7OztBQWdCQTs7Ozs7OztBQWNBOzs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7QUFlQTtBQXFCQTs7Ozs7Ozs7QUFnQkE7Ozs7O0FBMkJBOzs7OztBQU9BOzs7OztBQU9BOzs7OztBQU9BOzs7OztBQU9BOzs7Ozs7QUFpQkE7Ozs7OztBQVFBOzs7Ozs7QUFRQTs7Ozs7QUFNQTs7Ozs7O0FBU0E7Ozs7Ozs7O0FBV0E7Ozs7Ozs7QUFVQTs7Ozs7OztBQVVBOzs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7QUFXQTtBQVNBOzs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7Ozs7O0FBOEJBOzs7Ozs7Ozs7OztBQTJCQTs7O0FBY0E7Ozs7O0FBU0E7Ozs7O0FBT0E7Ozs7Ozs7QUF1QkE7QUFLQTtBQUNBO0FBUUE7Ozs7QUFnQkE7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQWNBO0FBQ0E7Ozs7QUFRQTtBQWlFQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBS0E7QUFHQTtBQUNBOztBQWNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUVBO0FBZ0JBO0FBR0E7QUFHQTs7QUFTQTs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7QUFlQTtBQUlBO0FBR0E7QUFFQTtBQVFBO0FBQ0E7QUFLQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQWFBOzs7OztBQU9BOzs7Ozs7OztBQVlBOzs7Ozs7Ozs7Ozs7OztBQTRCQTtBQWdCQTtBQUlBO0FBY0E7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7OztBQTRCQTtBQWFBOzs7OztBQVlBOztBQVNBOztBQW1CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBOzs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7QUFlQTtBQUdBO0FBTUE7Ozs7Ozs7O0FBZUE7O0FBWUE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7QUFlQTs7Ozs7QUFhQTtBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFrQkE7QUFNQTtBQUNBOzs7OztBQWVBO0FBT0E7QUFDQTs7Ozs7Ozs7OztBQXFCQTtBQUVBOztBQW1CQTs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUdBOzs7Ozs7Ozs7Ozs7OztBQWtCQTtBQU1BOzs7O0FBVUE7Ozs7Ozs7Ozs7O0FBZUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUE4QkE7QUFhQTtBQUdBO0FBS0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQW1CQTs7Ozs7QUFnQkE7O0FBY0E7Ozs7OztBQWVBO0FBTUE7QUFDQTtBQUVBOzs7OztBQXFDQTs7QUFpRkE7Ozs7QUFNQTs7Ozs7QUFjQTs7QUFlQTs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFZQTtBQUdBO0FBR0E7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQVFBOzs7QUFTQTs7O0FBV0E7Ozs7Ozs7O0FBZ0JBO0FBR0E7QUFLQTs7QUFXQTs7Ozs7QUFPQTs7Ozs7QUFzQkE7Ozs7Ozs7Ozs7QUFpQkE7QUFJQTs7Ozs7QUE0Q0E7O0FBT0E7Ozs7O0FBT0E7Ozs7Ozs7O0FBWUE7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7OztBQVlBOztBQVdBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBbUJBOzs7Ozs7Ozs7O0FBaUJBOzs7Ozs7OztBQW1CQTs7Ozs7OztBQW9CQTtBQUtBOzs7Ozs7O0FBYUE7QUFJQTs7Ozs7OztBQWFBO0FBSUE7QUFHQTs7Ozs7QUFjQTs7O0FBU0E7Ozs7Ozs7Ozs7OztBQWFBO0FBV0E7QUFFQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBR0E7O0FBUUE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFrQkE7QUFVQTs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBc0JBOzs7OztBQWFBOztBQU9BOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBaUJBOzs7Ozs7O0FBY0E7QUFFQTs7Ozs7Ozs7O0FBaUJBOzs7OztBQWtCQTs7QUFPQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7OztBQVlBOzs7Ozs7Ozs7O0FBaUJBOzs7OztBQW9CQTs7QUFPQTs7Ozs7QUFPQTs7Ozs7QUFjQTs7QUFlQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQWtCQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7QUFlQTtBQU1BO0FBQ0E7Ozs7Ozs7OztBQW1CQTs7Ozs7QUFrQkE7O0FBT0E7QUFFQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQWtCQTs7Ozs7Ozs7QUFpQ0E7O0FBZ0JBOzs7OztBQU9BOzs7Ozs7OztBQVlBO0FBSUE7QUFLQTs7Ozs7QUFjQTs7QUFTQTs7QUE0QkE7Ozs7Ozs7Ozs7Ozs7O0FBMkNBO0FBS0E7Ozs7Ozs7OztBQTRCQTs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7QUFjQTs7Ozs7QUFZQTs7Ozs7O0FBbUJBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBS0E7QUFJQTs7Ozs7Ozs7OztBQXNCQTs7Ozs7OztBQW1CQTs7Ozs7Ozs7O0FBZ0JBO0FBRUE7QUFLQTs7Ozs7OztBQWVBOzs7Ozs7QUFhQTs7Ozs7Ozs7OztBQWtCQTs7QUFzQkE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFrQkE7Ozs7Ozs7QUF1QkE7QUFPQTtBQUVBO0FBTUE7QUFHQTtBQVdBO0FBS0E7O0FBY0E7Ozs7QUFNQTs7Ozs7QUFjQTs7Ozs7Ozs7O0FBa0JBO0FBTUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTs7QUFrQkE7Ozs7O0FBT0E7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFvQkE7QUFJQTs7Ozs7QUEyQkE7QUFLQTs7QUFTQTs7Ozs7OztBQVNBOzs7Ozs7OztBQVlBOzs7OztBQWlCQTs7Ozs7Ozs7OztBQW1CQTtBQUlBOzs7OztBQXdCQTs7QUFTQTtBQUNBO0FBR0E7Ozs7O0FBU0E7Ozs7Ozs7O0FBWUE7QUFXQTtBQUNBOzs7OztBQTRCQTs7Ozs7Ozs7Ozs7QUFzQkE7QUFJQTtBQUdBO0FBR0E7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBa0JBOzs7Ozs7OztBQWVBOzs7OztBQVlBOzs7Ozs7O0FBZ0JBOzs7Ozs7O0FBdUJBO0FBUUE7QUFLQTs7Ozs7OztBQW1DQTs7Ozs7O0FBWUE7O0FBV0E7O0FBU0E7Ozs7Ozs7QUFjQTs7Ozs7Ozs7QUFtQkE7QUFHQTtBQU1BOzs7OztBQWVBO0FBTUE7Ozs7QUFTQTs7QUFPQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFZQTs7Ozs7QUFvQkE7Ozs7Ozs7O0FBaUJBO0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFzQkE7Ozs7Ozs7O0FBV0E7Ozs7O0FBY0E7O0FBU0E7O0FBdUJBOzs7Ozs7OztBQTJCQTs7Ozs7Ozs7QUFvQkE7Ozs7O0FBb0JBOztBQVNBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBaUJBOzs7Ozs7OztBQWVBOzs7Ozs7Ozs7O0FBcUJBOzs7OztBQW1CQTs7Ozs7Ozs7Ozs7QUFnQkE7QUFFQTs7QUFnQkE7Ozs7QUFNQTs7Ozs7QUFjQTs7QUFlQTtBQUNBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7Ozs7O0FBcUJBOzs7Ozs7O0FBbUJBOzs7Ozs7O0FBa0JBOztBQWNBOzs7OztBQWNBOztBQVlBOztBQVVBOzs7Ozs7O0FBZUE7Ozs7QUFjQTs7Ozs7OztBQWNBOzs7OztBQXVCQTs7OztBQVVBOztBQU9BO0FBQ0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQU9BO0FBQ0E7QUFNQTtBQVVBO0FBQ0E7Ozs7O0FBc0JBOzs7Ozs7OztBQXVCQTs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7O0FBb0JBOzs7OztBQWVBOztBQVNBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFJQTs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7QUFrQkE7QUFhQTs7Ozs7O0FBZUE7Ozs7O0FBb0JBOztBQU9BO0FBQ0E7Ozs7O0FBT0E7Ozs7Ozs7O0FBWUE7QUFXQTtBQUNBO0FBTUE7QUFLQTtBQUNBOzs7OztBQWdCQTs7Ozs7QUFZQTs7Ozs7QUFZQTs7Ozs7QUF1QkE7O0FBU0E7Ozs7O0FBT0E7Ozs7Ozs7OztBQWFBOzs7Ozs7QUF3QkE7QUFJQTtBQUlBO0FBQ0E7Ozs7O0FBZUE7QUFpQkE7QUFDQTs7Ozs7OztBQXdCQTtBQUVBO0FBS0E7O0FBV0E7O0FBY0E7Ozs7O0FBaUJBOztBQStCQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBWUE7O0FBeUJBOzs7OztBQWlCQTs7Ozs7QUFrQkE7Ozs7Ozs7QUFXQTtBQUdBO0FBaUJBOzs7O0FBZUE7Ozs7O0FBVUE7Ozs7O0FBY0E7QUFJQTtBQU9BOzs7OztBQWFBO0FBSUE7Ozs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7Ozs7QUFtQkE7QUFFQTtBQUNBO0FBRUE7O0FBZ0JBOztBQVNBOzs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBZUE7QUFHQTtBQUtBO0FBR0E7QUFHQTs7Ozs7Ozs7QUFtQkE7QUFHQTtBQUtBO0FBR0E7O0FBVUE7QUFPQTtBQUNBO0FBRUE7O0FBWUE7O0FBYUE7O0FBY0E7O0FBZUE7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTs7QUFvQ0E7Ozs7QUFNQTs7Ozs7Ozs7O0FBYUE7QUFXQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQXdCQTtBQUVBOzs7Ozs7Ozs7O0FBc0JBOzs7OztBQVlBO0FBTUE7QUFDQTtBQUtBOztBQWFBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFPQTtBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUlBO0FBYUE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7QUFzQ0E7QUFTQTtBQWNBOztBQWFBOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFJQTtBQUNBO0FBbUJBOzs7OztBQWFBOztBQTRDQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7Ozs7OztBQW9CQTtBQU1BO0FBQ0E7QUFNQTtBQWtCQTtBQUtBOztBQW1CQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBUUE7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7QUFnQkE7QUFLQTs7QUFXQTs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7O0FBZUE7Ozs7O0FBYUE7Ozs7Ozs7OztBQW9CQTs7Ozs7O0FBZ0JBO0FBVUE7QUFhQTs7Ozs7QUFtQkE7QUFLQTs7Ozs7O0FBaUJBOzs7OztBQWVBOzs7OztBQWFBOzs7OztBQWtDQTs7Ozs7QUFRQTs7QUFPQTs7OztBQU1BOzs7Ozs7Ozs7OztBQWVBOzs7Ozs7O0FBeUJBO0FBS0E7QUFVQTs7Ozs7QUFlQTs7Ozs7QUFtQkE7Ozs7O0FBUUE7O0FBT0E7Ozs7QUFNQTs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7QUFhQTs7Ozs7QUFtQkE7Ozs7O0FBUUE7O0FBT0E7Ozs7QUFNQTs7Ozs7Ozs7QUFZQTtBQWFBOzs7Ozs7Ozs7O0FBd0JBOztBQVlBOzs7O0FBTUE7Ozs7Ozs7Ozs7O0FBZUE7Ozs7O0FBYUE7Ozs7O0FBZ0JBOzs7OztBQXVCQTs7Ozs7QUFRQTs7QUFPQTs7Ozs7QUFPQTs7QUFnQ0E7Ozs7QUFNQTtBQVFBO0FBQ0E7Ozs7O0FBa0JBOzs7OztBQWdCQTs7Ozs7QUF3QkE7Ozs7OztBQVNBOztBQU9BOzs7O0FBTUE7Ozs7Ozs7O0FBWUE7QUFPQTs7Ozs7Ozs7OztBQTZCQTs7Ozs7OztBQXNCQTs7QUFZQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQWlCQTs7Ozs7Ozs7QUFtQkE7QUFJQTtBQVVBOzs7OztBQWtCQTs7QUFNQTs7OztBQU1BOzs7Ozs7OztBQVlBO0FBT0E7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7QUFlQTs7Ozs7QUFlQTs7QUFPQTs7OztBQU1BOzs7Ozs7OztBQVlBOzs7OztBQXFCQTs7Ozs7QUEyQkE7Ozs7O0FBZ0JBOztBQWtCQTtBQUVBOzs7Ozs7Ozs7O0FBZ0JBO0FBRUE7QUFJQTs7Ozs7QUFtQkE7Ozs7OztBQWFBOzs7Ozs7O0FBY0E7Ozs7Ozs7QUFrQkE7Ozs7O0FBaUJBOztBQU9BOzs7OztBQU9BOzs7OztBQWNBOzs7OztBQVlBOztBQWNBOzs7O0FBTUE7Ozs7O0FBY0E7Ozs7O0FBWUE7QUFNQTtBQUNBOztBQVlBO0FBQ0E7Ozs7QUFNQTs7Ozs7QUFjQTtBQU1BO0FBQ0E7Ozs7O0FBZUE7O0FBU0E7Ozs7O0FBT0E7Ozs7Ozs7O0FBWUE7Ozs7Ozs7QUFtQkE7Ozs7O0FBWUE7Ozs7QUFnQkE7O0FBWUE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVEQTtBQU9BOzs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7QUFtQkE7Ozs7Ozs7O0FBWUE7QUFVQTtBQVlBOzs7Ozs7Ozs7O0FBMkNBOzs7Ozs7O0FBMEJBOzs7Ozs7O0FBZ0JBOzs7Ozs7O0FBZ0JBOzs7Ozs7O0FBZ0JBOzs7Ozs7O0FBaUJBOzs7Ozs7O0FBaUJBOzs7OztBQWlDQTs7Ozs7QUFzQkE7O0FBYUE7O0FBZUE7O0FBbUJBOztBQXVCQTs7OztBQWVBOztBQXlCQTs7Ozs7QUFPQTs7Ozs7Ozs7QUFZQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFxQkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBV0E7QUFLQTs7Ozs7OztBQWFBO0FBS0E7QUFnQkE7QUFDQTtBQWdCQTtBQUlBO0FBQ0E7QUFJQTtBQUtBO0FBRUE7QUFJQTs7Ozs7QUFZQTtBQTREQTs7Ozs7QUFlQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFZQTtBQXFCQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWtDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFhQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUtBO0FBS0E7QUFLQTs7Ozs7QUFlQTtBQU1BOzs7OztBQVdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Ozs7O0FBcUJBOzs7OztBQVlBOzs7Ozs7Ozs7QUFnQkE7Ozs7OztBQW1DQTtBQUtBOztBQVlBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7O0FBY0E7Ozs7Ozs7Ozs7OztBQW1CQTtBQU1BOzs7QUFTQTs7Ozs7OztBQWNBOzs7OztBQWVBOzs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NBOzs7Ozs7Ozs7OztBQTBDQTs7Ozs7QUFrQkE7Ozs7Ozs7O0FBMkJBOzs7Ozs7QUFtQ0E7Ozs7OztBQWdCQTtBQUVBOzs7Ozs7QUFnQkE7Ozs7Ozs7QUFZQTs7Ozs7Ozs7QUFhQTtBQUVBOzs7Ozs7QUFpQkE7QUFFQTtBQUNBO0FBSUE7Ozs7OztBQWlCQTs7Ozs7O0FBV0E7Ozs7OztBQVdBOzs7OztBQVVBOzs7OztBQVFBOzs7Ozs7OztBQVdBOzs7Ozs7O0FBVUE7QUFHQTtBQUNBOzs7Ozs7QUFPQTs7Ozs7O0FBU0E7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7O0FBUUE7QUFHQTtBQU9BO0FBU0E7QUFrQkE7QUFZQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFLQTtBQWtCQTtBQUNBO0FBSUE7QUFLQTtBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7OztBQWVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7Ozs7O0FBY0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7O0FBYUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVlBOzs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7QUFlQTs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFRQTs7Ozs7O0FBU0E7Ozs7OztBQVNBOzs7Ozs7OztBQWlCQTs7Ozs7Ozs7QUFXQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBbUJBO0FBR0E7QUFJQTs7Ozs7Ozs7Ozs7QUFxQkE7O0FBT0E7QUFHQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU9BOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBT0E7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7QUFlQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBc0JBO0FBQ0E7QUFLQTtBQUdBO0FBR0E7QUFDQTtBQUtBO0FBR0E7QUFHQTtBQUdBO0FBRUE7QUFXQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFTQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQW1CQTtBQUdBO0FBQ0E7QUFPQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUdBO0FBS0E7QUFDQTs7Ozs7OztBQXlCQTs7Ozs7QUFPQTtBQUVBO0FBUUE7QUF1QkE7Ozs7O0FBV0E7QUFhQTtBQUNBO0FBbUJBO0FBR0E7QUFLQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFTQTtBQU1BO0FBVUE7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7Ozs7Ozs7OztBQXNCQTs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFTQTtBQWdCQTs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7O0FBMEJBOzs7Ozs7Ozs7QUFZQTtBQU1BO0FBTUE7QUFDQTs7Ozs7QUFhQTtBQXdCQTtBQUVBO0FBR0E7QUFHQTtBQUlBO0FBS0E7QUFHQTtBQUdBO0FBS0E7QUFHQTtBQUlBO0FBT0E7Ozs7Ozs7Ozs7O0FBbUJBO0FBSUE7QUFRQTtBQVNBO0FBR0E7QUFtQ0E7QUFTQTtBQUtBO0FBNEJBO0FBQ0E7QUFLQTs7OztBQWFBO0FBSUE7Ozs7Ozs7Ozs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7Ozs7O0FBV0E7QUFFQTtBQUNBOzs7O0FBY0E7QUFJQTtBQUtBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7QUFtQkE7QUFHQTtBQUlBO0FBR0E7QUFDQTtBQUNBOzs7OztBQU9BO0FBSUE7Ozs7Ozs7Ozs7O0FBbUJBO0FBR0E7Ozs7Ozs7QUEyQkE7QUFNQTs7Ozs7O0FBUUE7Ozs7OztBQVlBOzs7OztBQVVBOzs7Ozs7O0FBZ0JBOzs7OztBQVFBOzs7Ozs7QUFZQTs7Ozs7O0FBU0E7Ozs7OztBQVlBOzs7OztBQVFBOzs7Ozs7QUFZQTs7Ozs7QUFRQTs7Ozs7O0FBWUE7Ozs7O0FBUUE7Ozs7Ozs7O0FBY0E7QUFFQTtBQUNBOzs7Ozs7OztBQWVBOzs7Ozs7QUFZQTs7Ozs7QUFTQTs7Ozs7O0FBWUE7Ozs7O0FBZUE7Ozs7O0FBV0E7Ozs7Ozs7O0FBZUE7QUFNQTtBQUNBOzs7Ozs7QUFvQkE7Ozs7O0FBWUE7Ozs7O0FBWUE7Ozs7Ozs7OztBQWtCQTtBQUVBOzs7OztBQVdBOzs7Ozs7QUFpQkE7Ozs7Ozs7Ozs7OztBQW1CQTs7Ozs7QUFVQTs7Ozs7QUFXQTs7Ozs7O0FBZUE7Ozs7O0FBYUE7Ozs7O0FBV0E7Ozs7Ozs7Ozs7QUFpQkE7QUFHQTs7Ozs7Ozs7OztBQTZCQTtBQVVBO0FBQ0E7QUFDQTtBQUtBO0FBTUE7QUFPQTs7Ozs7OztBQWVBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBV0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBbUJBOzs7Ozs7QUFhQTtBQUVBOzs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7QUFpQkE7Ozs7Ozs7O0FBd0JBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFHQTtBQU1BO0FBTUE7OztBQVdBOzs7Ozs7QUFhQTs7Ozs7O0FBYUE7QUFLQTtBQUVBOzs7Ozs7Ozs7QUFZQTs7Ozs7OztBQW9CQTs7Ozs7O0FBYUE7Ozs7Ozs7Ozs7O0FBMEJBO0FBS0E7QUFZQTs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7O0FBaUJBOzs7Ozs7Ozs7Ozs7OztBQXFCQTs7Ozs7Ozs7OztBQXFCQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7OztBQU9BO0FBTUE7QUFDQTtBQUdBO0FBQ0E7OztBQUtBOzs7O0FBV0E7QUFNQTs7O0FBVUE7Ozs7O0FBWUE7QUFJQTtBQUdBO0FBR0E7QUFHQTs7O0FBTUE7Ozs7OztBQVlBOzs7O0FBaUJBO0FBS0E7QUFHQTtBQUdBO0FBQ0E7OztBQUlBOzs7Ozs7Ozs7O0FBZ0JBO0FBSUE7QUFLQTtBQUNBO0FBS0E7QUFNQTs7Ozs7Ozs7OztBQXlCQTtBQUlBO0FBQ0E7QUFPQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBZ0NBO0FBQ0E7QUFFQTtBQUdBOzs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUlBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBSUE7QUFHQTtBQVdBO0FBS0E7QUFDQTtBQU9BOzs7Ozs7Ozs7Ozs7QUFxQkE7QUFXQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTs7QUFVQTs7O0FBVUE7Ozs7O0FBYUE7QUFLQTs7Ozs7QUFlQTs7Ozs7O0FBYUE7Ozs7Ozs7QUFjQTs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7QUFxQkE7Ozs7OztBQW1CQTtBQUdBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTs7Ozs7Ozs7O0FBcUJBOzs7Ozs7Ozs7O0FBc0JBO0FBTUE7QUFDQTtBQUtBO0FBR0E7QUFHQTs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7QUFpQkE7QUFLQTs7Ozs7Ozs7Ozs7QUFrQkE7QUFRQTs7O0FBaUJBOzs7QUFXQTs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQTtBQVFBOzs7OztBQWVBOzs7OztBQVVBOzs7Ozs7Ozs7OztBQWtCQTtBQU1BO0FBWUE7QUFHQTtBQUNBOzs7QUFNQTs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7O0FBbUJBOzs7QUFxQkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFjQTs7OztBQVVBO0FBUUE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBSUE7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFHQTtBQUdBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBc0JBOzs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7O0FBdUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7Ozs7QUFrQkE7QUFNQTtBQUVBOzs7Ozs7Ozs7QUFpQkE7Ozs7O0FBWUE7Ozs7O0FBWUE7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7O0FBa0JBOzs7Ozs7QUFhQTtBQVVBOzs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7Ozs7Ozs7OztBQTZCQTtBQWNBO0FBRUE7QUFDQTtBQWFBO0FBTUE7Ozs7OztBQXNCQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFnQkE7Ozs7Ozs7O0FBVUE7Ozs7Ozs7OztBQVdBOzs7Ozs7O0FBU0E7Ozs7Ozs7QUFTQTtBQVNBO0FBQ0E7Ozs7QUFVQTs7Ozs7OztBQVlBO0FBRUE7QUFNQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBS0E7QUFHQTs7Ozs7QUFVQTs7Ozs7QUFPQTs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7O0FBbUJBOzs7OztBQU9BOzs7Ozs7O0FBU0E7Ozs7O0FBT0E7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7Ozs7QUFjQTs7QUFLQTs7Ozs7O0FBT0E7Ozs7OztBQVNBOzs7OztBQVFBOzs7Ozs7Ozs7QUFZQTs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7Ozs7O0FBbUJBOzs7Ozs7Ozs7Ozs7O0FBcUJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7QUFHQTtBQUNBO0FBWUE7Ozs7Ozs7Ozs7Ozs7QUF5QkE7Ozs7Ozs7QUFVQTtBQVVBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7O0FBUUE7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7OztBQW9CQTs7Ozs7OztBQVlBOzs7OztBQVdBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7Ozs7Ozs7O0FBdUJBO0FBa0JBO0FBQ0E7Ozs7O0FBbUJBOzs7Ozs7Ozs7O0FBdUJBOzs7Ozs7OztBQTRCQTs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7QUFPQTs7OztBQVNBOzs7O0FBU0E7Ozs7O0FBV0E7Ozs7OztBQVFBOzs7OztBQU9BOzs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7OztBQWVBOzs7QUFLQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFnQkE7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQXFCQTs7O0FBYUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBO0FBSUE7QUFDQTtBQUlBO0FBS0E7QUFHQTtBQVlBO0FBR0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBbUJBOzs7QUFhQTs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBaUJBOzs7Ozs7OztBQWFBOzs7Ozs7Ozs7OztBQXVCQTtBQWNBO0FBZUE7QUFDQTtBQUNBOzs7O0FBT0E7Ozs7O0FBUUE7Ozs7O0FBUUE7Ozs7O0FBVUE7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTs7OztBQWFBOzs7OztBQVFBOzs7OztBQVVBOzs7Ozs7O0FBVUE7Ozs7O0FBUUE7Ozs7Ozs7QUFVQTs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7OztBQWdCQTs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7QUFlQTs7OztBQU9BOztBQUdBOzs7Ozs7QUFTQTs7OztBQU9BOzs7O0FBT0E7Ozs7QUFPQTs7Ozs7OztBQVVBOzs7O0FBT0E7Ozs7QUFPQTs7OztBQU9BOzs7Ozs7Ozs7O0FBYUE7Ozs7QUFPQTs7Ozs7QUFRQTs7Ozs7QUFRQTs7Ozs7QUFTQTs7Ozs7QUFPQTs7Ozs7QUFPQTs7Ozs7QUFPQTs7Ozs7QUFPQTs7Ozs7QUFPQTs7Ozs7O0FBUUE7Ozs7O0FBT0E7Ozs7Ozs7O0FBVUE7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7Ozs7Ozs7QUFpQkE7OztBQU1BOzs7QUFNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///133\n");

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\nvar minDoc = __webpack_require__(135);\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fZ2xvYmFsQDQuMy4yQGdsb2JhbC9kb2N1bWVudC5qcz9jY2IxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL19nbG9iYWxANC4zLjJAZ2xvYmFsL2RvY3VtZW50LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///134\n");

/***/ }),

/***/ 135:
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL21pbi1kb2N1bWVudCAoaWdub3JlZCk/ZWQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBtaW4tZG9jdW1lbnQgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///135\n");

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction clean(s) {\n  return s.replace(/\\n\\r?\\s*/g, '');\n}\n\nmodule.exports = function tsml(sa) {\n  var s = '',\n      i = 0;\n\n  for (; i < arguments.length; i++) {\n    s += clean(sa[i]) + (arguments[i + 1] || '');\n  }return s;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdHNtbEAxLjAuMUB0c21sL3RzbWwuanM/ODJhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGVhbiAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXG5cXHI/XFxzKi9nLCAnJylcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRzbWwgKHNhKSB7XG4gIHZhciBzID0gJydcbiAgICAsIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgcyArPSBjbGVhbihzYVtpXSkgKyAoYXJndW1lbnRzW2kgKyAxXSB8fCAnJylcblxuICByZXR1cm4gc1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3RzbWxAMS4wLjFAdHNtbC90c21sLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFJQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///136\n");

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = SafeParseTuple;\n\nfunction SafeParseTuple(obj, reviver) {\n    var json;\n    var error = null;\n\n    try {\n        json = JSON.parse(obj, reviver);\n    } catch (err) {\n        error = err;\n    }\n\n    return [error, json];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fc2FmZS1qc29uLXBhcnNlQDQuMC4wQHNhZmUtanNvbi1wYXJzZS90dXBsZS5qcz9iNWExIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlVHVwbGVcblxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XG4gICAgdmFyIGpzb25cbiAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3NhZmUtanNvbi1wYXJzZUA0LjAuMEBzYWZlLWpzb24tcGFyc2UvdHVwbGUuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///137\n");

/***/ }),

/***/ 138:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar window = __webpack_require__(3);\nvar isFunction = __webpack_require__(125);\nvar parseHeaders = __webpack_require__(139);\nvar xtend = __webpack_require__(142);\n\nmodule.exports = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop;\ncreateXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n        options = initParams(uri, options, callback);\n        options.method = method.toUpperCase();\n        return _createXHR(options);\n    };\n});\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i]);\n    }\n}\n\nfunction isEmpty(obj) {\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) return false;\n    }\n    return true;\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri;\n\n    if (isFunction(options)) {\n        callback = options;\n        if (typeof uri === \"string\") {\n            params = { uri: uri };\n        }\n    } else {\n        params = xtend(options, { uri: uri });\n    }\n\n    params.callback = callback;\n    return params;\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback);\n    return _createXHR(options);\n}\n\nfunction _createXHR(options) {\n    if (typeof options.callback === \"undefined\") {\n        throw new Error(\"callback argument missing\");\n    }\n\n    var called = false;\n    var callback = function cbOnce(err, response, body) {\n        if (!called) {\n            called = true;\n            options.callback(err, response, body);\n        }\n    };\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0);\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined;\n\n        if (xhr.response) {\n            body = xhr.response;\n        } else {\n            body = xhr.responseText || getXml(xhr);\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body);\n            } catch (e) {}\n        }\n\n        return body;\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer);\n        if (!(evt instanceof Error)) {\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n        }\n        evt.statusCode = 0;\n        return callback(evt, failureResponse);\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return;\n        var status;\n        clearTimeout(timeoutTimer);\n        if (options.useXDR && xhr.status === undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200;\n        } else {\n            status = xhr.status === 1223 ? 204 : xhr.status;\n        }\n        var response = failureResponse;\n        var err = null;\n\n        if (status !== 0) {\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            };\n            if (xhr.getAllResponseHeaders) {\n                //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders());\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\");\n        }\n        return callback(err, response, response.body);\n    }\n\n    var xhr = options.xhr || null;\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest();\n        } else {\n            xhr = new createXHR.XMLHttpRequest();\n        }\n    }\n\n    var key;\n    var aborted;\n    var uri = xhr.url = options.uri || options.url;\n    var method = xhr.method = options.method || \"GET\";\n    var body = options.body || options.data;\n    var headers = xhr.headers = options.headers || {};\n    var sync = !!options.sync;\n    var isJson = false;\n    var timeoutTimer;\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    };\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true;\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json);\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange;\n    xhr.onload = loadFunc;\n    xhr.onerror = errorFunc;\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    };\n    xhr.onabort = function () {\n        aborted = true;\n    };\n    xhr.ontimeout = errorFunc;\n    xhr.open(method, uri, !sync, options.username, options.password);\n    //has to be after open\n    if (!sync) {\n        xhr.withCredentials = !!options.withCredentials;\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0) {\n        timeoutTimer = setTimeout(function () {\n            if (aborted) return;\n            aborted = true; //IE9 may still call readystatechange\n            xhr.abort(\"timeout\");\n            var e = new Error(\"XMLHttpRequest timeout\");\n            e.code = \"ETIMEDOUT\";\n            errorFunc(e);\n        }, options.timeout);\n    }\n\n    if (xhr.setRequestHeader) {\n        for (key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType;\n    }\n\n    if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n        options.beforeSend(xhr);\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null);\n\n    return xhr;\n}\n\nfunction getXml(xhr) {\n    if (xhr.responseType === \"document\") {\n        return xhr.responseXML;\n    }\n    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n    if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n        return xhr.responseXML;\n    }\n\n    return null;\n}\n\nfunction noop() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9feGhyQDIuNC4wQHhoci9pbmRleC5qcz9jODY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgICAgIGlmKCFjYWxsZWQpe1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IGdldFhtbCh4aHIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YVxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgfVxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbiA9PT0gdHJ1ZSA/IGJvZHkgOiBvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZClcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgaWYoIXN5bmMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZS8vSUU5IG1heSBzdGlsbCBjYWxsIHJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIilcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKVxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWlzRW1wdHkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG5cbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICAvLyBNaWNyb3NvZnQgRWRnZSBicm93c2VyIHNlbmRzIFwidW5kZWZpbmVkXCIgd2hlbiBzZW5kIGlzIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAvLyBYTUxIdHRwUmVxdWVzdCBzcGVjIHNheXMgdG8gcGFzcyBudWxsIGFzIGJvZHkgdG8gaW5kaWNhdGUgbm8gYm9keVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHIvaXNzdWVzLzEwMC5cbiAgICB4aHIuc2VuZChib2R5IHx8IG51bGwpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgfVxuICAgIHZhciBmaXJlZm94QnVnVGFrZW5FZmZlY3QgPSB4aHIucmVzcG9uc2VYTUwgJiYgeGhyLnJlc3BvbnNlWE1MLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSA9PT0gXCJwYXJzZXJlcnJvclwiXG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgJiYgIWZpcmVmb3hCdWdUYWtlbkVmZmVjdCkge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL194aHJAMi40LjBAeGhyL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///138\n");

/***/ }),

/***/ 139:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar trim = __webpack_require__(140),\n    forEach = __webpack_require__(141),\n    isArray = function isArray(arg) {\n  return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nmodule.exports = function (headers) {\n  if (!headers) return {};\n\n  var result = {};\n\n  forEach(trim(headers).split('\\n'), function (row) {\n    var index = row.indexOf(':'),\n        key = trim(row.slice(0, index)).toLowerCase(),\n        value = trim(row.slice(index + 1));\n\n    if (typeof result[key] === 'undefined') {\n      result[key] = value;\n    } else if (isArray(result[key])) {\n      result[key].push(value);\n    } else {\n      result[key] = [result[key], value];\n    }\n  });\n\n  return result;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fcGFyc2UtaGVhZGVyc0AyLjAuMUBwYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanM/MmU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL19wYXJzZS1oZWFkZXJzQDIuMC4xQHBhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///139\n");

/***/ }),

/***/ 140:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports = module.exports = trim;\n\nfunction trim(str) {\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function (str) {\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function (str) {\n  return str.replace(/\\s*$/, '');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdHJpbUAwLjAuMUB0cmltL2luZGV4LmpzPzgyYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fdHJpbUAwLjAuMUB0cmltL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///140\n");

/***/ }),

/***/ 141:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isFunction = __webpack_require__(125);\n\nmodule.exports = forEach;\n\nvar toString = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction forEach(list, iterator, context) {\n    if (!isFunction(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    if (arguments.length < 3) {\n        context = this;\n    }\n\n    if (toString.call(list) === '[object Array]') forEachArray(list, iterator, context);else if (typeof list === 'string') forEachString(list, iterator, context);else forEachObject(list, iterator, context);\n}\n\nfunction forEachArray(array, iterator, context) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            iterator.call(context, array[i], i, array);\n        }\n    }\n}\n\nfunction forEachString(string, iterator, context) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        iterator.call(context, string.charAt(i), i, string);\n    }\n}\n\nfunction forEachObject(object, iterator, context) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            iterator.call(context, object[k], k, object);\n        }\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fZm9yLWVhY2hAMC4zLjJAZm9yLWVhY2gvaW5kZXguanM/Yzc1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX2Zvci1lYWNoQDAuMy4yQGZvci1lYWNoL2luZGV4LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///141\n");

/***/ }),

/***/ 142:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = extend;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n\n    return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9feHRlbmRANC4wLjFAeHRlbmQvaW1tdXRhYmxlLmpzPzJiYmUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvX3h0ZW5kQDQuMC4xQHh0ZW5kL2ltbXV0YWJsZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///142\n");

/***/ }),

/***/ 143:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Default exports for Node. Export the extended versions of VTTCue and\n// VTTRegion in Node since we likely want the capability to convert back and\n// forth between JSON. If we don't then it's not that big of a deal since we're\n// off browser.\n\nvar window = __webpack_require__(3);\n\nvar vttjs = module.exports = {\n  WebVTT: __webpack_require__(144),\n  VTTCue: __webpack_require__(145),\n  VTTRegion: __webpack_require__(146)\n};\n\nwindow.vttjs = vttjs;\nwindow.WebVTT = vttjs.WebVTT;\n\nvar cueShim = vttjs.VTTCue;\nvar regionShim = vttjs.VTTRegion;\nvar nativeVTTCue = window.VTTCue;\nvar nativeVTTRegion = window.VTTRegion;\n\nvttjs.shim = function () {\n  window.VTTCue = cueShim;\n  window.VTTRegion = regionShim;\n};\n\nvttjs.restore = function () {\n  window.VTTCue = nativeVTTCue;\n  window.VTTRegion = nativeVTTRegion;\n};\n\nif (!window.VTTCue) {\n  vttjs.shim();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi9icm93c2VyLWluZGV4LmpzP2E5NjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vLyBEZWZhdWx0IGV4cG9ydHMgZm9yIE5vZGUuIEV4cG9ydCB0aGUgZXh0ZW5kZWQgdmVyc2lvbnMgb2YgVlRUQ3VlIGFuZFxuLy8gVlRUUmVnaW9uIGluIE5vZGUgc2luY2Ugd2UgbGlrZWx5IHdhbnQgdGhlIGNhcGFiaWxpdHkgdG8gY29udmVydCBiYWNrIGFuZFxuLy8gZm9ydGggYmV0d2VlbiBKU09OLiBJZiB3ZSBkb24ndCB0aGVuIGl0J3Mgbm90IHRoYXQgYmlnIG9mIGEgZGVhbCBzaW5jZSB3ZSdyZVxuLy8gb2ZmIGJyb3dzZXIuXG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93Jyk7XG5cbnZhciB2dHRqcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJWVFQ6IHJlcXVpcmUoXCIuL3Z0dC5qc1wiKSxcbiAgVlRUQ3VlOiByZXF1aXJlKFwiLi92dHRjdWUuanNcIiksXG4gIFZUVFJlZ2lvbjogcmVxdWlyZShcIi4vdnR0cmVnaW9uLmpzXCIpXG59O1xuXG53aW5kb3cudnR0anMgPSB2dHRqcztcbndpbmRvdy5XZWJWVFQgPSB2dHRqcy5XZWJWVFQ7XG5cbnZhciBjdWVTaGltID0gdnR0anMuVlRUQ3VlO1xudmFyIHJlZ2lvblNoaW0gPSB2dHRqcy5WVFRSZWdpb247XG52YXIgbmF0aXZlVlRUQ3VlID0gd2luZG93LlZUVEN1ZTtcbnZhciBuYXRpdmVWVFRSZWdpb24gPSB3aW5kb3cuVlRUUmVnaW9uO1xuXG52dHRqcy5zaGltID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5WVFRDdWUgPSBjdWVTaGltO1xuICB3aW5kb3cuVlRUUmVnaW9uID0gcmVnaW9uU2hpbTtcbn07XG5cbnZ0dGpzLnJlc3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LlZUVEN1ZSA9IG5hdGl2ZVZUVEN1ZTtcbiAgd2luZG93LlZUVFJlZ2lvbiA9IG5hdGl2ZVZUVFJlZ2lvbjtcbn07XG5cbmlmICghd2luZG93LlZUVEN1ZSkge1xuICB2dHRqcy5zaGltKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL2Jyb3dzZXItaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///143\n");

/***/ }),

/***/ 144:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\nvar _objCreate = Object.create || function () {\n  function F() {}\n  return function (o) {\n    if (arguments.length !== 1) {\n      throw new Error('Object.create shim only accepts one parameter.');\n    }\n    F.prototype = o;\n    return new F();\n  };\n}();\n\n// Creates a new ParserError object from an errorData object. The errorData\n// object should have default code and message properties. The default message\n// property can be overriden by passing in a message parameter.\n// See ParsingError.Errors below for acceptable errors.\nfunction ParsingError(errorData, message) {\n  this.name = \"ParsingError\";\n  this.code = errorData.code;\n  this.message = message || errorData.message;\n}\nParsingError.prototype = _objCreate(Error.prototype);\nParsingError.prototype.constructor = ParsingError;\n\n// ParsingError metadata for acceptable ParsingErrors.\nParsingError.Errors = {\n  BadSignature: {\n    code: 0,\n    message: \"Malformed WebVTT signature.\"\n  },\n  BadTimeStamp: {\n    code: 1,\n    message: \"Malformed time stamp.\"\n  }\n};\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n  }\n\n  var m = input.match(/^(\\d+):(\\d{2})(:\\d{2})?\\.(\\d{3})/);\n  if (!m) {\n    return null;\n  }\n\n  if (m[3]) {\n    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n  } else if (m[1] > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[1], m[2], 0, m[4]);\n  } else {\n    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n    return computeSeconds(0, m[1], m[2], m[4]);\n  }\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nfunction Settings() {\n  this.values = _objCreate(null);\n}\n\nSettings.prototype = {\n  // Only accept the first assignment to any key.\n  set: function set(k, v) {\n    if (!this.get(k) && v !== \"\") {\n      this.values[k] = v;\n    }\n  },\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get: function get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  },\n  // Check whether we have a value for a key.\n  has: function has(k) {\n    return k in this.values;\n  },\n  // Accept a setting if its one of the given alternatives.\n  alt: function alt(k, v, a) {\n    for (var n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  },\n  // Accept a setting if its a valid (signed) integer.\n  integer: function integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  },\n  // Accept a setting if its a valid percentage.\n  percent: function percent(k, v) {\n    var m;\n    if (m = v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n      v = parseFloat(v);\n      if (v >= 0 && v <= 100) {\n        this.set(k, v);\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interprete each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  var groups = groupDelim ? input.split(groupDelim) : [input];\n  for (var i in groups) {\n    if (typeof groups[i] !== \"string\") {\n      continue;\n    }\n    var kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    var k = kv[0];\n    var v = kv[1];\n    callback(k, v);\n  }\n}\n\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  var oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    var ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\n    }\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    var settings = new Settings();\n\n    parseOptions(input, function (k, v) {\n      switch (k) {\n        case \"region\":\n          // Find the last region we parsed with the same region id.\n          for (var i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case \"vertical\":\n          settings.alt(k, v, [\"rl\", \"lr\"]);\n          break;\n        case \"line\":\n          var vals = v.split(\",\"),\n              vals0 = vals[0];\n          settings.integer(k, vals0);\n          settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n          settings.alt(k, vals0, [\"auto\"]);\n          if (vals.length === 2) {\n            settings.alt(\"lineAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n          }\n          break;\n        case \"position\":\n          vals = v.split(\",\");\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt(\"positionAlign\", vals[1], [\"start\", \"middle\", \"end\"]);\n          }\n          break;\n        case \"size\":\n          settings.percent(k, v);\n          break;\n        case \"align\":\n          settings.alt(k, v, [\"start\", \"middle\", \"end\", \"left\", \"right\"]);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get(\"region\", null);\n    cue.vertical = settings.get(\"vertical\", \"\");\n    cue.line = settings.get(\"line\", \"auto\");\n    cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n    cue.snapToLines = settings.get(\"snapToLines\", true);\n    cue.size = settings.get(\"size\", 100);\n    cue.align = settings.get(\"align\", \"middle\");\n    cue.position = settings.get(\"position\", {\n      start: 0,\n      left: 0,\n      middle: 50,\n      end: 100,\n      right: 100\n    }, cue.align);\n    cue.positionAlign = settings.get(\"positionAlign\", {\n      start: \"start\",\n      left: \"start\",\n      middle: \"middle\",\n      end: \"end\",\n      right: \"end\"\n    }, cue.align);\n  }\n\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, \"\");\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.substr(0, 3) !== \"-->\") {\n    // (3) next characters must match \"-->\"\n    throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.substr(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\n\nvar ESCAPE = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\",\n  \"&nbsp;\": \"\\xA0\"\n};\n\nvar TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\"\n};\n\nvar TAG_ANNOTATION = {\n  v: \"title\",\n  lang: \"lang\"\n};\n\nvar NEEDS_PARENT = {\n  rt: \"ruby\"\n};\n\n// Parse content into a document fragment.\nfunction parseContent(window, input) {\n  function nextToken() {\n    // Check for end-of-string.\n    if (!input) {\n      return null;\n    }\n\n    // Consume 'n' characters from the input.\n    function consume(result) {\n      input = input.substr(result.length);\n      return result;\n    }\n\n    var m = input.match(/^([^<]*)(<[^>]+>?)?/);\n    // If there is some text before the next tag, return it, otherwise return\n    // the tag.\n    return consume(m[1] ? m[1] : m[2]);\n  }\n\n  // Unescape a string 's'.\n  function unescape1(e) {\n    return ESCAPE[e];\n  }\n  function unescape(s) {\n    while (m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/)) {\n      s = s.replace(m[0], unescape1);\n    }\n    return s;\n  }\n\n  function shouldAdd(current, element) {\n    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\n  }\n\n  // Create an element for this tag.\n  function createElement(type, annotation) {\n    var tagName = TAG_NAME[type];\n    if (!tagName) {\n      return null;\n    }\n    var element = window.document.createElement(tagName);\n    element.localName = tagName;\n    var name = TAG_ANNOTATION[type];\n    if (name && annotation) {\n      element[name] = annotation.trim();\n    }\n    return element;\n  }\n\n  var rootDiv = window.document.createElement(\"div\"),\n      current = rootDiv,\n      t,\n      tagStack = [];\n\n  while ((t = nextToken()) !== null) {\n    if (t[0] === '<') {\n      if (t[1] === \"/\") {\n        // If the closing tag matches, move back up to the parent node.\n        if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n          tagStack.pop();\n          current = current.parentNode;\n        }\n        // Otherwise just ignore the end tag.\n        continue;\n      }\n      var ts = parseTimeStamp(t.substr(1, t.length - 2));\n      var node;\n      if (ts) {\n        // Timestamps are lead nodes as well.\n        node = window.document.createProcessingInstruction(\"timestamp\", ts);\n        current.appendChild(node);\n        continue;\n      }\n      var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n      // If we can't parse the tag, skip to the next tag.\n      if (!m) {\n        continue;\n      }\n      // Try to construct an element, and ignore the tag if we couldn't.\n      node = createElement(m[1], m[3]);\n      if (!node) {\n        continue;\n      }\n      // Determine if the tag should be added based on the context of where it\n      // is placed in the cuetext.\n      if (!shouldAdd(current, node)) {\n        continue;\n      }\n      // Set the class list (as a list of classes, separated by space).\n      if (m[2]) {\n        node.className = m[2].substr(1).replace('.', ' ');\n      }\n      // Append the node to the current node, and enter the scope of the new\n      // node.\n      tagStack.push(m[1]);\n      current.appendChild(node);\n      current = node;\n      continue;\n    }\n\n    // Text nodes are leaf nodes.\n    current.appendChild(window.document.createTextNode(unescape(t)));\n  }\n\n  return rootDiv;\n}\n\n// This is a list of all the Unicode characters that have a strong\n// right-to-left category. What this means is that these characters are\n// written right-to-left for sure. It was generated by pulling all the strong\n// right-to-left characters out of the Unicode data table. That table can\n// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n\nfunction isStrongRTLChar(charCode) {\n  for (var i = 0; i < strongRTLRanges.length; i++) {\n    var currentRange = strongRTLRanges[i];\n    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction determineBidi(cueDiv) {\n  var nodeStack = [],\n      text = \"\",\n      charCode;\n\n  if (!cueDiv || !cueDiv.childNodes) {\n    return \"ltr\";\n  }\n\n  function pushNodes(nodeStack, node) {\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      nodeStack.push(node.childNodes[i]);\n    }\n  }\n\n  function nextTextNode(nodeStack) {\n    if (!nodeStack || !nodeStack.length) {\n      return null;\n    }\n\n    var node = nodeStack.pop(),\n        text = node.textContent || node.innerText;\n    if (text) {\n      // TODO: This should match all unicode type B characters (paragraph\n      // separator characters). See issue #115.\n      var m = text.match(/^.*(\\n|\\r)/);\n      if (m) {\n        nodeStack.length = 0;\n        return m[0];\n      }\n      return text;\n    }\n    if (node.tagName === \"ruby\") {\n      return nextTextNode(nodeStack);\n    }\n    if (node.childNodes) {\n      pushNodes(nodeStack, node);\n      return nextTextNode(nodeStack);\n    }\n  }\n\n  pushNodes(nodeStack, cueDiv);\n  while (text = nextTextNode(nodeStack)) {\n    for (var i = 0; i < text.length; i++) {\n      charCode = text.charCodeAt(i);\n      if (isStrongRTLChar(charCode)) {\n        return \"rtl\";\n      }\n    }\n  }\n  return \"ltr\";\n}\n\nfunction computeLinePos(cue) {\n  if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\n    return cue.line;\n  }\n  if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\n    return -1;\n  }\n  var track = cue.track,\n      trackList = track.textTrackList,\n      count = 0;\n  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n    if (trackList[i].mode === \"showing\") {\n      count++;\n    }\n  }\n  return ++count * -1;\n}\n\nfunction StyleBox() {}\n\n// Apply styles to a div. If there is no div passed then it defaults to the\n// div on 'this'.\nStyleBox.prototype.applyStyles = function (styles, div) {\n  div = div || this.div;\n  for (var prop in styles) {\n    if (styles.hasOwnProperty(prop)) {\n      div.style[prop] = styles[prop];\n    }\n  }\n};\n\nStyleBox.prototype.formatStyle = function (val, unit) {\n  return val === 0 ? 0 : val + unit;\n};\n\n// Constructs the computed display state of the cue (a div). Places the div\n// into the overlay which should be a block level element (usually a div).\nfunction CueStyleBox(window, cue, styleOptions) {\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n  var color = \"rgba(255, 255, 255, 1)\";\n  var backgroundColor = \"rgba(0, 0, 0, 0.8)\";\n\n  if (isIE8) {\n    color = \"rgb(255, 255, 255)\";\n    backgroundColor = \"rgb(0, 0, 0)\";\n  }\n\n  StyleBox.call(this);\n  this.cue = cue;\n\n  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n  // have inline positioning and will function as the cue background box.\n  this.cueDiv = parseContent(window, cue.text);\n  var styles = {\n    color: color,\n    backgroundColor: backgroundColor,\n    position: \"relative\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    display: \"inline\"\n  };\n\n  if (!isIE8) {\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\";\n    styles.unicodeBidi = \"plaintext\";\n  }\n  this.applyStyles(styles, this.cueDiv);\n\n  // Create an absolutely positioned div that will be used to position the cue\n  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n  // mirrors of them except \"middle\" which is \"center\" in CSS.\n  this.div = window.document.createElement(\"div\");\n  styles = {\n    textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n    font: styleOptions.font,\n    whiteSpace: \"pre-line\",\n    position: \"absolute\"\n  };\n\n  if (!isIE8) {\n    styles.direction = determineBidi(this.cueDiv);\n    styles.writingMode = cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\".stylesunicodeBidi = \"plaintext\";\n  }\n\n  this.applyStyles(styles);\n\n  this.div.appendChild(this.cueDiv);\n\n  // Calculate the distance from the reference edge of the viewport to the text\n  // position of the cue box. The reference edge will be resolved later when\n  // the box orientation styles are applied.\n  var textPos = 0;\n  switch (cue.positionAlign) {\n    case \"start\":\n      textPos = cue.position;\n      break;\n    case \"middle\":\n      textPos = cue.position - cue.size / 2;\n      break;\n    case \"end\":\n      textPos = cue.position - cue.size;\n      break;\n  }\n\n  // Horizontal box orientation; textPos is the distance from the left edge of the\n  // area to the left edge of the box and cue.size is the distance extending to\n  // the right from there.\n  if (cue.vertical === \"\") {\n    this.applyStyles({\n      left: this.formatStyle(textPos, \"%\"),\n      width: this.formatStyle(cue.size, \"%\")\n    });\n    // Vertical box orientation; textPos is the distance from the top edge of the\n    // area to the top edge of the box and cue.size is the height extending\n    // downwards from there.\n  } else {\n    this.applyStyles({\n      top: this.formatStyle(textPos, \"%\"),\n      height: this.formatStyle(cue.size, \"%\")\n    });\n  }\n\n  this.move = function (box) {\n    this.applyStyles({\n      top: this.formatStyle(box.top, \"px\"),\n      bottom: this.formatStyle(box.bottom, \"px\"),\n      left: this.formatStyle(box.left, \"px\"),\n      right: this.formatStyle(box.right, \"px\"),\n      height: this.formatStyle(box.height, \"px\"),\n      width: this.formatStyle(box.width, \"px\")\n    });\n  };\n}\nCueStyleBox.prototype = _objCreate(StyleBox.prototype);\nCueStyleBox.prototype.constructor = CueStyleBox;\n\n// Represents the co-ordinates of an Element in a way that we can easily\n// compute things with such as if it overlaps or intersects with another Element.\n// Can initialize it with either a StyleBox or another BoxPosition.\nfunction BoxPosition(obj) {\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n\n  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n  // was passed in and we need to copy the results of 'getBoundingClientRect'\n  // as the object returned is readonly. All co-ordinate values are in reference\n  // to the viewport origin (top left).\n  var lh, height, width, top;\n  if (obj.div) {\n    height = obj.div.offsetHeight;\n    width = obj.div.offsetWidth;\n    top = obj.div.offsetTop;\n\n    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\n    obj = obj.div.getBoundingClientRect();\n    // In certain cases the outter div will be slightly larger then the sum of\n    // the inner div's lines. This could be due to bold text, etc, on some platforms.\n    // In this case we should get the average line height and use that. This will\n    // result in the desired behaviour.\n    lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\n  }\n  this.left = obj.left;\n  this.right = obj.right;\n  this.top = obj.top || top;\n  this.height = obj.height || height;\n  this.bottom = obj.bottom || top + (obj.height || height);\n  this.width = obj.width || width;\n  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n\n  if (isIE8 && !this.lineHeight) {\n    this.lineHeight = 13;\n  }\n}\n\n// Move the box along a particular axis. Optionally pass in an amount to move\n// the box. If no amount is passed then the default is the line height of the\n// box.\nBoxPosition.prototype.move = function (axis, toMove) {\n  toMove = toMove !== undefined ? toMove : this.lineHeight;\n  switch (axis) {\n    case \"+x\":\n      this.left += toMove;\n      this.right += toMove;\n      break;\n    case \"-x\":\n      this.left -= toMove;\n      this.right -= toMove;\n      break;\n    case \"+y\":\n      this.top += toMove;\n      this.bottom += toMove;\n      break;\n    case \"-y\":\n      this.top -= toMove;\n      this.bottom -= toMove;\n      break;\n  }\n};\n\n// Check if this box overlaps another box, b2.\nBoxPosition.prototype.overlaps = function (b2) {\n  return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\n};\n\n// Check if this box overlaps any other boxes in boxes.\nBoxPosition.prototype.overlapsAny = function (boxes) {\n  for (var i = 0; i < boxes.length; i++) {\n    if (this.overlaps(boxes[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if this box is within another box.\nBoxPosition.prototype.within = function (container) {\n  return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\n};\n\n// Check if this box is entirely within the container or it is overlapping\n// on the edge opposite of the axis direction passed. For example, if \"+x\" is\n// passed and the box is overlapping on the left edge of the container, then\n// return true.\nBoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\n  switch (axis) {\n    case \"+x\":\n      return this.left < container.left;\n    case \"-x\":\n      return this.right > container.right;\n    case \"+y\":\n      return this.top < container.top;\n    case \"-y\":\n      return this.bottom > container.bottom;\n  }\n};\n\n// Find the percentage of the area that this box is overlapping with another\n// box.\nBoxPosition.prototype.intersectPercentage = function (b2) {\n  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n      intersectArea = x * y;\n  return intersectArea / (this.height * this.width);\n};\n\n// Convert the positions from this box to CSS compatible positions using\n// the reference container's positions. This has to be done because this\n// box's positions are in reference to the viewport origin, whereas, CSS\n// values are in referecne to their respective edges.\nBoxPosition.prototype.toCSSCompatValues = function (reference) {\n  return {\n    top: this.top - reference.top,\n    bottom: reference.bottom - this.bottom,\n    left: this.left - reference.left,\n    right: reference.right - this.right,\n    height: this.height,\n    width: this.width\n  };\n};\n\n// Get an object that represents the box's position without anything extra.\n// Can pass a StyleBox, HTMLElement, or another BoxPositon.\nBoxPosition.getSimpleBoxPosition = function (obj) {\n  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n\n  obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\n  var ret = {\n    left: obj.left,\n    right: obj.right,\n    top: obj.top || top,\n    height: obj.height || height,\n    bottom: obj.bottom || top + (obj.height || height),\n    width: obj.width || width\n  };\n  return ret;\n};\n\n// Move a StyleBox to its specified, or next best, position. The containerBox\n// is the box that contains the StyleBox, such as a div. boxPositions are\n// a list of other boxes that the styleBox can't overlap with.\nfunction moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n\n  // Find the best position for a cue box, b, on the video. The axis parameter\n  // is a list of axis, the order of which, it will move the box along. For example:\n  // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n  // direction. If it doesn't find a good position for it there it will then move\n  // it along the x axis in the negative direction.\n  function findBestPosition(b, axis) {\n    var bestPosition,\n        specifiedPosition = new BoxPosition(b),\n        percentage = 1; // Highest possible so the first thing we get is better.\n\n    for (var i = 0; i < axis.length; i++) {\n      while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\n        b.move(axis[i]);\n      }\n      // We found a spot where we aren't overlapping anything. This is our\n      // best position.\n      if (b.within(containerBox)) {\n        return b;\n      }\n      var p = b.intersectPercentage(containerBox);\n      // If we're outside the container box less then we were on our last try\n      // then remember this position as the best position.\n      if (percentage > p) {\n        bestPosition = new BoxPosition(b);\n        percentage = p;\n      }\n      // Reset the box position to the specified position.\n      b = new BoxPosition(specifiedPosition);\n    }\n    return bestPosition || specifiedPosition;\n  }\n\n  var boxPosition = new BoxPosition(styleBox),\n      cue = styleBox.cue,\n      linePos = computeLinePos(cue),\n      axis = [];\n\n  // If we have a line number to align the cue to.\n  if (cue.snapToLines) {\n    var size;\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n\n    var step = boxPosition.lineHeight,\n        position = step * Math.round(linePos),\n        maxPosition = containerBox[size] + step,\n        initialAxis = axis[0];\n\n    // If the specified intial position is greater then the max position then\n    // clamp the box to the amount of steps it would take for the box to\n    // reach the max position.\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n\n    // If computed line position returns negative then line numbers are\n    // relative to the bottom of the video instead of the top. Therefore, we\n    // need to increase our initial position by the length or width of the\n    // video, depending on the writing direction, and reverse our axis directions.\n    if (linePos < 0) {\n      position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n      axis = axis.reverse();\n    }\n\n    // Move the box to the specified position. This may not be its best\n    // position.\n    boxPosition.move(initialAxis, position);\n  } else {\n    // If we have a percentage line value for the cue.\n    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\n\n    switch (cue.lineAlign) {\n      case \"middle\":\n        linePos -= calculatedPercentage / 2;\n        break;\n      case \"end\":\n        linePos -= calculatedPercentage;\n        break;\n    }\n\n    // Apply initial line position to the cue box.\n    switch (cue.vertical) {\n      case \"\":\n        styleBox.applyStyles({\n          top: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"rl\":\n        styleBox.applyStyles({\n          left: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n      case \"lr\":\n        styleBox.applyStyles({\n          right: styleBox.formatStyle(linePos, \"%\")\n        });\n        break;\n    }\n\n    axis = [\"+y\", \"-x\", \"+x\", \"-y\"];\n\n    // Get the box position again after we've applied the specified positioning\n    // to it.\n    boxPosition = new BoxPosition(styleBox);\n  }\n\n  var bestPosition = findBestPosition(boxPosition, axis);\n  styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n}\n\nfunction WebVTT() {}\n// Nothing\n\n\n// Helper to allow strings to be decoded instead of the default binary utf8 data.\nWebVTT.StringDecoder = function () {\n  return {\n    decode: function decode(data) {\n      if (!data) {\n        return \"\";\n      }\n      if (typeof data !== \"string\") {\n        throw new Error(\"Error - expected string data.\");\n      }\n      return decodeURIComponent(encodeURIComponent(data));\n    }\n  };\n};\n\nWebVTT.convertCueToDOMTree = function (window, cuetext) {\n  if (!window || !cuetext) {\n    return null;\n  }\n  return parseContent(window, cuetext);\n};\n\nvar FONT_SIZE_PERCENT = 0.05;\nvar FONT_STYLE = \"sans-serif\";\nvar CUE_BACKGROUND_PADDING = \"1.5%\";\n\n// Runs the processing model over the cues and regions passed to it.\n// @param overlay A block level element (usually a div) that the computed cues\n//                and regions will be placed into.\nWebVTT.processCues = function (window, cues, overlay) {\n  if (!window || !cues || !overlay) {\n    return null;\n  }\n\n  // Remove all previous children.\n  while (overlay.firstChild) {\n    overlay.removeChild(overlay.firstChild);\n  }\n\n  var paddedOverlay = window.document.createElement(\"div\");\n  paddedOverlay.style.position = \"absolute\";\n  paddedOverlay.style.left = \"0\";\n  paddedOverlay.style.right = \"0\";\n  paddedOverlay.style.top = \"0\";\n  paddedOverlay.style.bottom = \"0\";\n  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n  overlay.appendChild(paddedOverlay);\n\n  // Determine if we need to compute the display states of the cues. This could\n  // be the case if a cue's state has been changed since the last computation or\n  // if it has not been computed yet.\n  function shouldCompute(cues) {\n    for (var i = 0; i < cues.length; i++) {\n      if (cues[i].hasBeenReset || !cues[i].displayState) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // We don't need to recompute the cues' display states. Just reuse them.\n  if (!shouldCompute(cues)) {\n    for (var i = 0; i < cues.length; i++) {\n      paddedOverlay.appendChild(cues[i].displayState);\n    }\n    return;\n  }\n\n  var boxPositions = [],\n      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n  var styleOptions = {\n    font: fontSize + \"px \" + FONT_STYLE\n  };\n\n  (function () {\n    var styleBox, cue;\n\n    for (var i = 0; i < cues.length; i++) {\n      cue = cues[i];\n\n      // Compute the intial position and styles of the cue div.\n      styleBox = new CueStyleBox(window, cue, styleOptions);\n      paddedOverlay.appendChild(styleBox.div);\n\n      // Move the cue div to it's correct line position.\n      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n      // Remember the computed div so that we don't have to recompute it later\n      // if we don't have too.\n      cue.displayState = styleBox.div;\n\n      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n    }\n  })();\n};\n\nWebVTT.Parser = function (window, vttjs, decoder) {\n  if (!decoder) {\n    decoder = vttjs;\n    vttjs = {};\n  }\n  if (!vttjs) {\n    vttjs = {};\n  }\n\n  this.window = window;\n  this.vttjs = vttjs;\n  this.state = \"INITIAL\";\n  this.buffer = \"\";\n  this.decoder = decoder || new TextDecoder(\"utf8\");\n  this.regionList = [];\n};\n\nWebVTT.Parser.prototype = {\n  // If the error is a ParsingError then report it to the consumer if\n  // possible. If it's not a ParsingError then throw it like normal.\n  reportOrThrowError: function reportOrThrowError(e) {\n    if (e instanceof ParsingError) {\n      this.onparsingerror && this.onparsingerror(e);\n    } else {\n      throw e;\n    }\n  },\n  parse: function parse(data) {\n    var self = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      self.buffer += self.decoder.decode(data, { stream: true });\n    }\n\n    function collectNextLine() {\n      var buffer = self.buffer;\n      var pos = 0;\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      var line = buffer.substr(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      self.buffer = buffer.substr(pos);\n      return line;\n    }\n\n    // 3.4 WebVTT region and WebVTT region settings syntax\n    function parseRegion(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case \"id\":\n            settings.set(k, v);\n            break;\n          case \"width\":\n            settings.percent(k, v);\n            break;\n          case \"lines\":\n            settings.integer(k, v);\n            break;\n          case \"regionanchor\":\n          case \"viewportanchor\":\n            var xy = v.split(',');\n            if (xy.length !== 2) {\n              break;\n            }\n            // We have to make sure both x and y parse, so use a temporary\n            // settings object here.\n            var anchor = new Settings();\n            anchor.percent(\"x\", xy[0]);\n            anchor.percent(\"y\", xy[1]);\n            if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n              break;\n            }\n            settings.set(k + \"X\", anchor.get(\"x\"));\n            settings.set(k + \"Y\", anchor.get(\"y\"));\n            break;\n          case \"scroll\":\n            settings.alt(k, v, [\"up\"]);\n            break;\n        }\n      }, /=/, /\\s/);\n\n      // Create the region, using default values for any values that were not\n      // specified.\n      if (settings.has(\"id\")) {\n        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n        region.width = settings.get(\"width\", 100);\n        region.lines = settings.get(\"lines\", 3);\n        region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n        region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n        region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n        region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n        region.scroll = settings.get(\"scroll\", \"\");\n        // Register the region.\n        self.onregion && self.onregion(region);\n        // Remember the VTTRegion for later in case we parse any VTTCues that\n        // reference it.\n        self.regionList.push({\n          id: settings.get(\"id\"),\n          region: region\n        });\n      }\n    }\n\n    // draft-pantos-http-live-streaming-20\n    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n    // 3.5 WebVTT\n    function parseTimestampMap(input) {\n      var settings = new Settings();\n\n      parseOptions(input, function (k, v) {\n        switch (k) {\n          case \"MPEGT\":\n            settings.integer(k + 'S', v);\n            break;\n          case \"LOCA\":\n            settings.set(k + 'L', parseTimeStamp(v));\n            break;\n        }\n      }, /[^\\d]:/, /,/);\n\n      self.ontimestampmap && self.ontimestampmap({\n        \"MPEGTS\": settings.get(\"MPEGTS\"),\n        \"LOCAL\": settings.get(\"LOCAL\")\n      });\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      if (input.match(/X-TIMESTAMP-MAP/)) {\n        // This line contains HLS X-TIMESTAMP-MAP metadata\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"X-TIMESTAMP-MAP\":\n              parseTimestampMap(v);\n              break;\n          }\n        }, /=/);\n      } else {\n        parseOptions(input, function (k, v) {\n          switch (k) {\n            case \"Region\":\n              // 3.3 WebVTT region metadata header syntax\n              parseRegion(v);\n              break;\n          }\n        }, /:/);\n      }\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      var line;\n      if (self.state === \"INITIAL\") {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        line = collectNextLine();\n\n        var m = line.match(/^WEBVTT([ \\t].*)?$/);\n        if (!m || !m[0]) {\n          throw new ParsingError(ParsingError.Errors.BadSignature);\n        }\n\n        self.state = \"HEADER\";\n      }\n\n      var alreadyCollectedLine = false;\n      while (self.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(self.buffer)) {\n          return this;\n        }\n\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n\n        switch (self.state) {\n          case \"HEADER\":\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              self.state = \"ID\";\n            }\n            continue;\n          case \"NOTE\":\n            // Ignore NOTE blocks.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n          case \"ID\":\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              self.state = \"NOTE\";\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n            self.state = \"CUE\";\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf(\"-->\") === -1) {\n              self.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /*falls through*/\n          case \"CUE\":\n            // 40 - Collect cue timings and settings.\n            try {\n              parseCue(line, self.cue, self.regionList);\n            } catch (e) {\n              self.reportOrThrowError(e);\n              // In case of an error ignore rest of the cue.\n              self.cue = null;\n              self.state = \"BADCUE\";\n              continue;\n            }\n            self.state = \"CUETEXT\";\n            continue;\n          case \"CUETEXT\":\n            var hasSubstring = line.indexOf(\"-->\") !== -1;\n            // 34 - If we have an empty line then report the cue.\n            // 35 - If we have the special substring '-->' then report the cue,\n            // but do not collect the line as we need to process the current\n            // one as a new cue.\n            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n              // We are done parsing self cue.\n              self.oncue && self.oncue(self.cue);\n              self.cue = null;\n              self.state = \"ID\";\n              continue;\n            }\n            if (self.cue.text) {\n              self.cue.text += \"\\n\";\n            }\n            self.cue.text += line;\n            continue;\n          case \"BADCUE\":\n            // BADCUE\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              self.state = \"ID\";\n            }\n            continue;\n        }\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n\n      // If we are currently parsing a cue, report what we have.\n      if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n        self.oncue(self.cue);\n      }\n      self.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  },\n  flush: function flush() {\n    var self = this;\n    try {\n      // Finish decoding the stream.\n      self.buffer += self.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (self.cue || self.state === \"HEADER\") {\n        self.buffer += \"\\n\\n\";\n        self.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (self.state === \"INITIAL\") {\n        throw new ParsingError(ParsingError.Errors.BadSignature);\n      }\n    } catch (e) {\n      self.reportOrThrowError(e);\n    }\n    self.onflush && self.onflush();\n    return this;\n  }\n};\n\nmodule.exports = WebVTT;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHQuanM/YmM5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotICovXG4vKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovXG52YXIgX29iakNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBGKCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QuY3JlYXRlIHNoaW0gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XG4gICAgfVxuICAgIEYucHJvdG90eXBlID0gbztcbiAgICByZXR1cm4gbmV3IEYoKTtcbiAgfTtcbn0pKCk7XG5cbi8vIENyZWF0ZXMgYSBuZXcgUGFyc2VyRXJyb3Igb2JqZWN0IGZyb20gYW4gZXJyb3JEYXRhIG9iamVjdC4gVGhlIGVycm9yRGF0YVxuLy8gb2JqZWN0IHNob3VsZCBoYXZlIGRlZmF1bHQgY29kZSBhbmQgbWVzc2FnZSBwcm9wZXJ0aWVzLiBUaGUgZGVmYXVsdCBtZXNzYWdlXG4vLyBwcm9wZXJ0eSBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHBhc3NpbmcgaW4gYSBtZXNzYWdlIHBhcmFtZXRlci5cbi8vIFNlZSBQYXJzaW5nRXJyb3IuRXJyb3JzIGJlbG93IGZvciBhY2NlcHRhYmxlIGVycm9ycy5cbmZ1bmN0aW9uIFBhcnNpbmdFcnJvcihlcnJvckRhdGEsIG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJQYXJzaW5nRXJyb3JcIjtcbiAgdGhpcy5jb2RlID0gZXJyb3JEYXRhLmNvZGU7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgZXJyb3JEYXRhLm1lc3NhZ2U7XG59XG5QYXJzaW5nRXJyb3IucHJvdG90eXBlID0gX29iakNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2luZ0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNpbmdFcnJvcjtcblxuLy8gUGFyc2luZ0Vycm9yIG1ldGFkYXRhIGZvciBhY2NlcHRhYmxlIFBhcnNpbmdFcnJvcnMuXG5QYXJzaW5nRXJyb3IuRXJyb3JzID0ge1xuICBCYWRTaWduYXR1cmU6IHtcbiAgICBjb2RlOiAwLFxuICAgIG1lc3NhZ2U6IFwiTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuXCJcbiAgfSxcbiAgQmFkVGltZVN0YW1wOiB7XG4gICAgY29kZTogMSxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wLlwiXG4gIH1cbn07XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWNvbmRzKGgsIG0sIHMsIGYpIHtcbiAgICByZXR1cm4gKGggfCAwKSAqIDM2MDAgKyAobSB8IDApICogNjAgKyAocyB8IDApICsgKGYgfCAwKSAvIDEwMDA7XG4gIH1cblxuICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFxcZCspOihcXGR7Mn0pKDpcXGR7Mn0pP1xcLihcXGR7M30pLyk7XG4gIGlmICghbSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG1bM10pIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZShcIjpcIiwgXCJcIiksIG1bNF0pO1xuICB9IGVsc2UgaWYgKG1bMV0gPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsxXSwgbVsyXSwgMCwgIG1bNF0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKDAsIG1bMV0sIG1bMl0sIG1bNF0pO1xuICB9XG59XG5cbi8vIEEgc2V0dGluZ3Mgb2JqZWN0IGhvbGRzIGtleS92YWx1ZSBwYWlycyBhbmQgd2lsbCBpZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdFxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cbmZ1bmN0aW9uIFNldHRpbmdzKCkge1xuICB0aGlzLnZhbHVlcyA9IF9vYmpDcmVhdGUobnVsbCk7XG59XG5cblNldHRpbmdzLnByb3RvdHlwZSA9IHtcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKCF0aGlzLmdldChrKSAmJiB2ICE9PSBcIlwiKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0OiBmdW5jdGlvbihrLCBkZmx0LCBkZWZhdWx0S2V5KSB7XG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdFtkZWZhdWx0S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xuICB9LFxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhczogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrIGluIHRoaXMudmFsdWVzO1xuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cbiAgYWx0OiBmdW5jdGlvbihrLCB2LCBhKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXI6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHYpKSB7IC8vIGludGVnZXJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfVxuICB9LFxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcbiAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKHYgPj0gMCAmJiB2IDw9IDEwMCkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGlucHV0IGludG8gZ3JvdXBzIHNlcGFyYXRlZCBieSAnZ3JvdXBEZWxpbScsIGFuZFxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwRGVsaW0gPyBpbnB1dC5zcGxpdChncm91cERlbGltKSA6IFtpbnB1dF07XG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cHNbaV0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIga3YgPSBncm91cHNbaV0uc3BsaXQoa2V5VmFsdWVEZWxpbSk7XG4gICAgaWYgKGt2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBrID0ga3ZbMF07XG4gICAgdmFyIHYgPSBrdlsxXTtcbiAgICBjYWxsYmFjayhrLCB2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUN1ZShpbnB1dCwgY3VlLCByZWdpb25MaXN0KSB7XG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxuICB2YXIgb0lucHV0ID0gaW5wdXQ7XG4gIC8vIDQuMSBXZWJWVFQgdGltZXN0YW1wXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XG4gICAgdmFyIHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFRpbWVTdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1hbGZvcm1lZCB0aW1lc3RhbXA6IFwiICsgb0lucHV0KTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL15bXlxcc2EtekEtWi1dKy8sIFwiXCIpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHN3aXRjaCAoaykge1xuICAgICAgY2FzZSBcInJlZ2lvblwiOlxuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXG4gICAgICAgIGZvciAodmFyIGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHJlZ2lvbkxpc3RbaV0uaWQgPT09IHYpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInJsXCIsIFwibHJcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgIHZhciB2YWxzID0gdi5zcGxpdChcIixcIiksXG4gICAgICAgICAgICB2YWxzMCA9IHZhbHNbMF07XG4gICAgICAgIHNldHRpbmdzLmludGVnZXIoaywgdmFsczApO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSA/IHNldHRpbmdzLnNldChcInNuYXBUb0xpbmVzXCIsIGZhbHNlKSA6IG51bGw7XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2YWxzMCwgW1wiYXV0b1wiXSk7XG4gICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNldHRpbmdzLmFsdChcImxpbmVBbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9zaXRpb25cIjpcbiAgICAgICAgdmFscyA9IHYuc3BsaXQoXCIsXCIpO1xuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJwb3NpdGlvbkFsaWduXCIsIHZhbHNbMV0sIFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFsaWduXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uXCIsIG51bGwpO1xuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldChcInZlcnRpY2FsXCIsIFwiXCIpO1xuICAgIGN1ZS5saW5lID0gc2V0dGluZ3MuZ2V0KFwibGluZVwiLCBcImF1dG9cIik7XG4gICAgY3VlLmxpbmVBbGlnbiA9IHNldHRpbmdzLmdldChcImxpbmVBbGlnblwiLCBcInN0YXJ0XCIpO1xuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldChcInNuYXBUb0xpbmVzXCIsIHRydWUpO1xuICAgIGN1ZS5zaXplID0gc2V0dGluZ3MuZ2V0KFwic2l6ZVwiLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldChcImFsaWduXCIsIFwibWlkZGxlXCIpO1xuICAgIGN1ZS5wb3NpdGlvbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uXCIsIHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG1pZGRsZTogNTAsXG4gICAgICBlbmQ6IDEwMCxcbiAgICAgIHJpZ2h0OiAxMDBcbiAgICB9LCBjdWUuYWxpZ24pO1xuICAgIGN1ZS5wb3NpdGlvbkFsaWduID0gc2V0dGluZ3MuZ2V0KFwicG9zaXRpb25BbGlnblwiLCB7XG4gICAgICBzdGFydDogXCJzdGFydFwiLFxuICAgICAgbGVmdDogXCJzdGFydFwiLFxuICAgICAgbWlkZGxlOiBcIm1pZGRsZVwiLFxuICAgICAgZW5kOiBcImVuZFwiLFxuICAgICAgcmlnaHQ6IFwiZW5kXCJcbiAgICB9LCBjdWUuYWxpZ24pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpO1xuICB9XG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgdGltaW5ncy5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLnN0YXJ0VGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAvLyAoMSkgY29sbGVjdCBjdWUgc3RhcnQgdGltZVxuICBza2lwV2hpdGVzcGFjZSgpO1xuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSBcIi0tPlwiKSB7ICAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggXCItLT5cIlxuICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wICh0aW1lIHN0YW1wcyBtdXN0IGJlIHNlcGFyYXRlZCBieSAnLS0+Jyk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMyk7XG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5lbmRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgICAgLy8gKDUpIGNvbGxlY3QgY3VlIGVuZCB0aW1lXG5cbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpO1xufVxuXG52YXIgRVNDQVBFID0ge1xuICBcIiZhbXA7XCI6IFwiJlwiLFxuICBcIiZsdDtcIjogXCI8XCIsXG4gIFwiJmd0O1wiOiBcIj5cIixcbiAgXCImbHJtO1wiOiBcIlxcdTIwMGVcIixcbiAgXCImcmxtO1wiOiBcIlxcdTIwMGZcIixcbiAgXCImbmJzcDtcIjogXCJcXHUwMGEwXCJcbn07XG5cbnZhciBUQUdfTkFNRSA9IHtcbiAgYzogXCJzcGFuXCIsXG4gIGk6IFwiaVwiLFxuICBiOiBcImJcIixcbiAgdTogXCJ1XCIsXG4gIHJ1Ynk6IFwicnVieVwiLFxuICBydDogXCJydFwiLFxuICB2OiBcInNwYW5cIixcbiAgbGFuZzogXCJzcGFuXCJcbn07XG5cbnZhciBUQUdfQU5OT1RBVElPTiA9IHtcbiAgdjogXCJ0aXRsZVwiLFxuICBsYW5nOiBcImxhbmdcIlxufTtcblxudmFyIE5FRURTX1BBUkVOVCA9IHtcbiAgcnQ6IFwicnVieVwiXG59O1xuXG4vLyBQYXJzZSBjb250ZW50IGludG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbmZ1bmN0aW9uIHBhcnNlQ29udGVudCh3aW5kb3csIGlucHV0KSB7XG4gIGZ1bmN0aW9uIG5leHRUb2tlbigpIHtcbiAgICAvLyBDaGVjayBmb3IgZW5kLW9mLXN0cmluZy5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lICduJyBjaGFyYWN0ZXJzIGZyb20gdGhlIGlucHV0LlxuICAgIGZ1bmN0aW9uIGNvbnN1bWUocmVzdWx0KSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cihyZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihbXjxdKikoPFtePl0rPj8pPy8pO1xuICAgIC8vIElmIHRoZXJlIGlzIHNvbWUgdGV4dCBiZWZvcmUgdGhlIG5leHQgdGFnLCByZXR1cm4gaXQsIG90aGVyd2lzZSByZXR1cm5cbiAgICAvLyB0aGUgdGFnLlxuICAgIHJldHVybiBjb25zdW1lKG1bMV0gPyBtWzFdIDogbVsyXSk7XG4gIH1cblxuICAvLyBVbmVzY2FwZSBhIHN0cmluZyAncycuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlMShlKSB7XG4gICAgcmV0dXJuIEVTQ0FQRVtlXTtcbiAgfVxuICBmdW5jdGlvbiB1bmVzY2FwZShzKSB7XG4gICAgd2hpbGUgKChtID0gcy5tYXRjaCgvJihhbXB8bHR8Z3R8bHJtfHJsbXxuYnNwKTsvKSkpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UobVswXSwgdW5lc2NhcGUxKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRBZGQoY3VycmVudCwgZWxlbWVudCkge1xuICAgIHJldHVybiAhTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSB8fFxuICAgICAgICAgICBORUVEU19QQVJFTlRbZWxlbWVudC5sb2NhbE5hbWVdID09PSBjdXJyZW50LmxvY2FsTmFtZTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbiBlbGVtZW50IGZvciB0aGlzIHRhZy5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBhbm5vdGF0aW9uKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBUQUdfTkFNRVt0eXBlXTtcbiAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGVsZW1lbnQubG9jYWxOYW1lID0gdGFnTmFtZTtcbiAgICB2YXIgbmFtZSA9IFRBR19BTk5PVEFUSU9OW3R5cGVdO1xuICAgIGlmIChuYW1lICYmIGFubm90YXRpb24pIHtcbiAgICAgIGVsZW1lbnRbbmFtZV0gPSBhbm5vdGF0aW9uLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgcm9vdERpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgY3VycmVudCA9IHJvb3REaXYsXG4gICAgICB0LFxuICAgICAgdGFnU3RhY2sgPSBbXTtcblxuICB3aGlsZSAoKHQgPSBuZXh0VG9rZW4oKSkgIT09IG51bGwpIHtcbiAgICBpZiAodFswXSA9PT0gJzwnKSB7XG4gICAgICBpZiAodFsxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNsb3NpbmcgdGFnIG1hdGNoZXMsIG1vdmUgYmFjayB1cCB0byB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgIGlmICh0YWdTdGFjay5sZW5ndGggJiZcbiAgICAgICAgICAgIHRhZ1N0YWNrW3RhZ1N0YWNrLmxlbmd0aCAtIDFdID09PSB0LnN1YnN0cigyKS5yZXBsYWNlKFwiPlwiLCBcIlwiKSkge1xuICAgICAgICAgIHRhZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgaWdub3JlIHRoZSBlbmQgdGFnLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKHQuc3Vic3RyKDEsIHQubGVuZ3RoIC0gMikpO1xuICAgICAgdmFyIG5vZGU7XG4gICAgICBpZiAodHMpIHtcbiAgICAgICAgLy8gVGltZXN0YW1wcyBhcmUgbGVhZCBub2RlcyBhcyB3ZWxsLlxuICAgICAgICBub2RlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbihcInRpbWVzdGFtcFwiLCB0cyk7XG4gICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG0gPSB0Lm1hdGNoKC9ePChbXi5cXHMvMC05Pl0rKShcXC5bXlxcc1xcXFw+XSspPyhbXj5cXFxcXSspPyhcXFxcPyk+PyQvKTtcbiAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSB0YWcsIHNraXAgdG8gdGhlIG5leHQgdGFnLlxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBhbiBlbGVtZW50LCBhbmQgaWdub3JlIHRoZSB0YWcgaWYgd2UgY291bGRuJ3QuXG4gICAgICBub2RlID0gY3JlYXRlRWxlbWVudChtWzFdLCBtWzNdKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFnIHNob3VsZCBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgY29udGV4dCBvZiB3aGVyZSBpdFxuICAgICAgLy8gaXMgcGxhY2VkIGluIHRoZSBjdWV0ZXh0LlxuICAgICAgaWYgKCFzaG91bGRBZGQoY3VycmVudCwgbm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBTZXQgdGhlIGNsYXNzIGxpc3QgKGFzIGEgbGlzdCBvZiBjbGFzc2VzLCBzZXBhcmF0ZWQgYnkgc3BhY2UpLlxuICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBtWzJdLnN1YnN0cigxKS5yZXBsYWNlKCcuJywgJyAnKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgY3VycmVudCBub2RlLCBhbmQgZW50ZXIgdGhlIHNjb3BlIG9mIHRoZSBuZXdcbiAgICAgIC8vIG5vZGUuXG4gICAgICB0YWdTdGFjay5wdXNoKG1bMV0pO1xuICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIGN1cnJlbnQgPSBub2RlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGV4dCBub2RlcyBhcmUgbGVhZiBub2Rlcy5cbiAgICBjdXJyZW50LmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1bmVzY2FwZSh0KSkpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3REaXY7XG59XG5cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCB0aGUgVW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjYXRlZ29yeS4gV2hhdCB0aGlzIG1lYW5zIGlzIHRoYXQgdGhlc2UgY2hhcmFjdGVycyBhcmVcbi8vIHdyaXR0ZW4gcmlnaHQtdG8tbGVmdCBmb3Igc3VyZS4gSXQgd2FzIGdlbmVyYXRlZCBieSBwdWxsaW5nIGFsbCB0aGUgc3Ryb25nXG4vLyByaWdodC10by1sZWZ0IGNoYXJhY3RlcnMgb3V0IG9mIHRoZSBVbmljb2RlIGRhdGEgdGFibGUuIFRoYXQgdGFibGUgY2FuXG4vLyBmb3VuZCBhdDogaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVU5JREFUQS9Vbmljb2RlRGF0YS50eHRcbnZhciBzdHJvbmdSVExSYW5nZXMgPSBbWzB4NWJlLCAweDViZV0sIFsweDVjMCwgMHg1YzBdLCBbMHg1YzMsIDB4NWMzXSwgWzB4NWM2LCAweDVjNl0sXG4gWzB4NWQwLCAweDVlYV0sIFsweDVmMCwgMHg1ZjRdLCBbMHg2MDgsIDB4NjA4XSwgWzB4NjBiLCAweDYwYl0sIFsweDYwZCwgMHg2MGRdLFxuIFsweDYxYiwgMHg2MWJdLCBbMHg2MWUsIDB4NjRhXSwgWzB4NjZkLCAweDY2Zl0sIFsweDY3MSwgMHg2ZDVdLCBbMHg2ZTUsIDB4NmU2XSxcbiBbMHg2ZWUsIDB4NmVmXSwgWzB4NmZhLCAweDcwZF0sIFsweDcwZiwgMHg3MTBdLCBbMHg3MTIsIDB4NzJmXSwgWzB4NzRkLCAweDdhNV0sXG4gWzB4N2IxLCAweDdiMV0sIFsweDdjMCwgMHg3ZWFdLCBbMHg3ZjQsIDB4N2Y1XSwgWzB4N2ZhLCAweDdmYV0sIFsweDgwMCwgMHg4MTVdLFxuIFsweDgxYSwgMHg4MWFdLCBbMHg4MjQsIDB4ODI0XSwgWzB4ODI4LCAweDgyOF0sIFsweDgzMCwgMHg4M2VdLCBbMHg4NDAsIDB4ODU4XSxcbiBbMHg4NWUsIDB4ODVlXSwgWzB4OGEwLCAweDhhMF0sIFsweDhhMiwgMHg4YWNdLCBbMHgyMDBmLCAweDIwMGZdLFxuIFsweGZiMWQsIDB4ZmIxZF0sIFsweGZiMWYsIDB4ZmIyOF0sIFsweGZiMmEsIDB4ZmIzNl0sIFsweGZiMzgsIDB4ZmIzY10sXG4gWzB4ZmIzZSwgMHhmYjNlXSwgWzB4ZmI0MCwgMHhmYjQxXSwgWzB4ZmI0MywgMHhmYjQ0XSwgWzB4ZmI0NiwgMHhmYmMxXSxcbiBbMHhmYmQzLCAweGZkM2RdLCBbMHhmZDUwLCAweGZkOGZdLCBbMHhmZDkyLCAweGZkYzddLCBbMHhmZGYwLCAweGZkZmNdLFxuIFsweGZlNzAsIDB4ZmU3NF0sIFsweGZlNzYsIDB4ZmVmY10sIFsweDEwODAwLCAweDEwODA1XSwgWzB4MTA4MDgsIDB4MTA4MDhdLFxuIFsweDEwODBhLCAweDEwODM1XSwgWzB4MTA4MzcsIDB4MTA4MzhdLCBbMHgxMDgzYywgMHgxMDgzY10sIFsweDEwODNmLCAweDEwODU1XSxcbiBbMHgxMDg1NywgMHgxMDg1Zl0sIFsweDEwOTAwLCAweDEwOTFiXSwgWzB4MTA5MjAsIDB4MTA5MzldLCBbMHgxMDkzZiwgMHgxMDkzZl0sXG4gWzB4MTA5ODAsIDB4MTA5YjddLCBbMHgxMDliZSwgMHgxMDliZl0sIFsweDEwYTAwLCAweDEwYTAwXSwgWzB4MTBhMTAsIDB4MTBhMTNdLFxuIFsweDEwYTE1LCAweDEwYTE3XSwgWzB4MTBhMTksIDB4MTBhMzNdLCBbMHgxMGE0MCwgMHgxMGE0N10sIFsweDEwYTUwLCAweDEwYTU4XSxcbiBbMHgxMGE2MCwgMHgxMGE3Zl0sIFsweDEwYjAwLCAweDEwYjM1XSwgWzB4MTBiNDAsIDB4MTBiNTVdLCBbMHgxMGI1OCwgMHgxMGI3Ml0sXG4gWzB4MTBiNzgsIDB4MTBiN2ZdLCBbMHgxMGMwMCwgMHgxMGM0OF0sIFsweDFlZTAwLCAweDFlZTAzXSwgWzB4MWVlMDUsIDB4MWVlMWZdLFxuIFsweDFlZTIxLCAweDFlZTIyXSwgWzB4MWVlMjQsIDB4MWVlMjRdLCBbMHgxZWUyNywgMHgxZWUyN10sIFsweDFlZTI5LCAweDFlZTMyXSxcbiBbMHgxZWUzNCwgMHgxZWUzN10sIFsweDFlZTM5LCAweDFlZTM5XSwgWzB4MWVlM2IsIDB4MWVlM2JdLCBbMHgxZWU0MiwgMHgxZWU0Ml0sXG4gWzB4MWVlNDcsIDB4MWVlNDddLCBbMHgxZWU0OSwgMHgxZWU0OV0sIFsweDFlZTRiLCAweDFlZTRiXSwgWzB4MWVlNGQsIDB4MWVlNGZdLFxuIFsweDFlZTUxLCAweDFlZTUyXSwgWzB4MWVlNTQsIDB4MWVlNTRdLCBbMHgxZWU1NywgMHgxZWU1N10sIFsweDFlZTU5LCAweDFlZTU5XSxcbiBbMHgxZWU1YiwgMHgxZWU1Yl0sIFsweDFlZTVkLCAweDFlZTVkXSwgWzB4MWVlNWYsIDB4MWVlNWZdLCBbMHgxZWU2MSwgMHgxZWU2Ml0sXG4gWzB4MWVlNjQsIDB4MWVlNjRdLCBbMHgxZWU2NywgMHgxZWU2YV0sIFsweDFlZTZjLCAweDFlZTcyXSwgWzB4MWVlNzQsIDB4MWVlNzddLFxuIFsweDFlZTc5LCAweDFlZTdjXSwgWzB4MWVlN2UsIDB4MWVlN2VdLCBbMHgxZWU4MCwgMHgxZWU4OV0sIFsweDFlZThiLCAweDFlZTliXSxcbiBbMHgxZWVhMSwgMHgxZWVhM10sIFsweDFlZWE1LCAweDFlZWE5XSwgWzB4MWVlYWIsIDB4MWVlYmJdLCBbMHgxMGZmZmQsIDB4MTBmZmZkXV07XG5cbmZ1bmN0aW9uIGlzU3Ryb25nUlRMQ2hhcihjaGFyQ29kZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cm9uZ1JUTFJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjdXJyZW50UmFuZ2UgPSBzdHJvbmdSVExSYW5nZXNbaV07XG4gICAgaWYgKGNoYXJDb2RlID49IGN1cnJlbnRSYW5nZVswXSAmJiBjaGFyQ29kZSA8PSBjdXJyZW50UmFuZ2VbMV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lQmlkaShjdWVEaXYpIHtcbiAgdmFyIG5vZGVTdGFjayA9IFtdLFxuICAgICAgdGV4dCA9IFwiXCIsXG4gICAgICBjaGFyQ29kZTtcblxuICBpZiAoIWN1ZURpdiB8fCAhY3VlRGl2LmNoaWxkTm9kZXMpIHtcbiAgICByZXR1cm4gXCJsdHJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpIHtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBub2RlU3RhY2sucHVzaChub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUZXh0Tm9kZShub2RlU3RhY2spIHtcbiAgICBpZiAoIW5vZGVTdGFjayB8fCAhbm9kZVN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBub2RlU3RhY2sucG9wKCksXG4gICAgICAgIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJUZXh0O1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtYXRjaCBhbGwgdW5pY29kZSB0eXBlIEIgY2hhcmFjdGVycyAocGFyYWdyYXBoXG4gICAgICAvLyBzZXBhcmF0b3IgY2hhcmFjdGVycykuIFNlZSBpc3N1ZSAjMTE1LlxuICAgICAgdmFyIG0gPSB0ZXh0Lm1hdGNoKC9eLiooXFxufFxccikvKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIG5vZGVTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWdOYW1lID09PSBcInJ1YnlcIikge1xuICAgICAgcmV0dXJuIG5leHRUZXh0Tm9kZShub2RlU3RhY2spO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKTtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gIH1cblxuICBwdXNoTm9kZXMobm9kZVN0YWNrLCBjdWVEaXYpO1xuICB3aGlsZSAoKHRleHQgPSBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGlzU3Ryb25nUlRMQ2hhcihjaGFyQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIFwicnRsXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBcImx0clwiO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTGluZVBvcyhjdWUpIHtcbiAgaWYgKHR5cGVvZiBjdWUubGluZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgKGN1ZS5zbmFwVG9MaW5lcyB8fCAoY3VlLmxpbmUgPj0gMCAmJiBjdWUubGluZSA8PSAxMDApKSkge1xuICAgIHJldHVybiBjdWUubGluZTtcbiAgfVxuICBpZiAoIWN1ZS50cmFjayB8fCAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QgfHxcbiAgICAgICFjdWUudHJhY2sudGV4dFRyYWNrTGlzdC5tZWRpYUVsZW1lbnQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIHRyYWNrID0gY3VlLnRyYWNrLFxuICAgICAgdHJhY2tMaXN0ID0gdHJhY2sudGV4dFRyYWNrTGlzdCxcbiAgICAgIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xpc3QubGVuZ3RoICYmIHRyYWNrTGlzdFtpXSAhPT0gdHJhY2s7IGkrKykge1xuICAgIGlmICh0cmFja0xpc3RbaV0ubW9kZSA9PT0gXCJzaG93aW5nXCIpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiArK2NvdW50ICogLTE7XG59XG5cbmZ1bmN0aW9uIFN0eWxlQm94KCkge1xufVxuXG4vLyBBcHBseSBzdHlsZXMgdG8gYSBkaXYuIElmIHRoZXJlIGlzIG5vIGRpdiBwYXNzZWQgdGhlbiBpdCBkZWZhdWx0cyB0byB0aGVcbi8vIGRpdiBvbiAndGhpcycuXG5TdHlsZUJveC5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMsIGRpdikge1xuICBkaXYgPSBkaXYgfHwgdGhpcy5kaXY7XG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgZGl2LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdO1xuICAgIH1cbiAgfVxufTtcblxuU3R5bGVCb3gucHJvdG90eXBlLmZvcm1hdFN0eWxlID0gZnVuY3Rpb24odmFsLCB1bml0KSB7XG4gIHJldHVybiB2YWwgPT09IDAgPyAwIDogdmFsICsgdW5pdDtcbn07XG5cbi8vIENvbnN0cnVjdHMgdGhlIGNvbXB1dGVkIGRpc3BsYXkgc3RhdGUgb2YgdGhlIGN1ZSAoYSBkaXYpLiBQbGFjZXMgdGhlIGRpdlxuLy8gaW50byB0aGUgb3ZlcmxheSB3aGljaCBzaG91bGQgYmUgYSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KS5cbmZ1bmN0aW9uIEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpIHtcbiAgdmFyIGlzSUU4ID0gKC9NU0lFXFxzOFxcLjAvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgY29sb3IgPSBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIjtcbiAgdmFyIGJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwLjgpXCI7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgY29sb3IgPSBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xuICAgIGJhY2tncm91bmRDb2xvciA9IFwicmdiKDAsIDAsIDApXCI7XG4gIH1cblxuICBTdHlsZUJveC5jYWxsKHRoaXMpO1xuICB0aGlzLmN1ZSA9IGN1ZTtcblxuICAvLyBQYXJzZSBvdXIgY3VlJ3MgdGV4dCBpbnRvIGEgRE9NIHRyZWUgcm9vdGVkIGF0ICdjdWVEaXYnLiBUaGlzIGRpdiB3aWxsXG4gIC8vIGhhdmUgaW5saW5lIHBvc2l0aW9uaW5nIGFuZCB3aWxsIGZ1bmN0aW9uIGFzIHRoZSBjdWUgYmFja2dyb3VuZCBib3guXG4gIHRoaXMuY3VlRGl2ID0gcGFyc2VDb250ZW50KHdpbmRvdywgY3VlLnRleHQpO1xuICB2YXIgc3R5bGVzID0ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gIH07XG5cbiAgaWYgKCFpc0lFOCkge1xuICAgIHN0eWxlcy53cml0aW5nTW9kZSA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IFwiaG9yaXpvbnRhbC10YlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIjtcbiAgICBzdHlsZXMudW5pY29kZUJpZGkgPSBcInBsYWludGV4dFwiO1xuICB9XG4gIHRoaXMuYXBwbHlTdHlsZXMoc3R5bGVzLCB0aGlzLmN1ZURpdik7XG5cbiAgLy8gQ3JlYXRlIGFuIGFic29sdXRlbHkgcG9zaXRpb25lZCBkaXYgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcG9zaXRpb24gdGhlIGN1ZVxuICAvLyBkaXYuIE5vdGUsIGFsbCBXZWJWVFQgY3VlLXNldHRpbmcgYWxpZ25tZW50cyBhcmUgZXF1aXZhbGVudCB0byB0aGUgQ1NTXG4gIC8vIG1pcnJvcnMgb2YgdGhlbSBleGNlcHQgXCJtaWRkbGVcIiB3aGljaCBpcyBcImNlbnRlclwiIGluIENTUy5cbiAgdGhpcy5kaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgc3R5bGVzID0ge1xuICAgIHRleHRBbGlnbjogY3VlLmFsaWduID09PSBcIm1pZGRsZVwiID8gXCJjZW50ZXJcIiA6IGN1ZS5hbGlnbixcbiAgICBmb250OiBzdHlsZU9wdGlvbnMuZm9udCxcbiAgICB3aGl0ZVNwYWNlOiBcInByZS1saW5lXCIsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xuXG4gIGlmICghaXNJRTgpIHtcbiAgICBzdHlsZXMuZGlyZWN0aW9uID0gZGV0ZXJtaW5lQmlkaSh0aGlzLmN1ZURpdik7XG4gICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VlLnZlcnRpY2FsID09PSBcImxyXCIgPyBcInZlcnRpY2FsLWxyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJ2ZXJ0aWNhbC1ybFwiLlxuICAgIHN0eWxlc3VuaWNvZGVCaWRpID0gIFwicGxhaW50ZXh0XCI7XG4gIH1cblxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XG5cbiAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jdWVEaXYpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcmVmZXJlbmNlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHRvIHRoZSB0ZXh0XG4gIC8vIHBvc2l0aW9uIG9mIHRoZSBjdWUgYm94LiBUaGUgcmVmZXJlbmNlIGVkZ2Ugd2lsbCBiZSByZXNvbHZlZCBsYXRlciB3aGVuXG4gIC8vIHRoZSBib3ggb3JpZW50YXRpb24gc3R5bGVzIGFyZSBhcHBsaWVkLlxuICB2YXIgdGV4dFBvcyA9IDA7XG4gIHN3aXRjaCAoY3VlLnBvc2l0aW9uQWxpZ24pIHtcbiAgY2FzZSBcInN0YXJ0XCI6XG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbjtcbiAgICBicmVhaztcbiAgY2FzZSBcIm1pZGRsZVwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb24gLSAoY3VlLnNpemUgLyAyKTtcbiAgICBicmVhaztcbiAgY2FzZSBcImVuZFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb24gLSBjdWUuc2l6ZTtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIEhvcml6b250YWwgYm94IG9yaWVudGF0aW9uOyB0ZXh0UG9zIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlXG4gIC8vIGFyZWEgdG8gdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgZGlzdGFuY2UgZXh0ZW5kaW5nIHRvXG4gIC8vIHRoZSByaWdodCBmcm9tIHRoZXJlLlxuICBpZiAoY3VlLnZlcnRpY2FsID09PSBcIlwiKSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICBsZWZ0OiAgdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICB3aWR0aDogdGhpcy5mb3JtYXRTdHlsZShjdWUuc2l6ZSwgXCIlXCIpXG4gICAgfSk7XG4gIC8vIFZlcnRpY2FsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGVkZ2Ugb2YgdGhlXG4gIC8vIGFyZWEgdG8gdGhlIHRvcCBlZGdlIG9mIHRoZSBib3ggYW5kIGN1ZS5zaXplIGlzIHRoZSBoZWlnaHQgZXh0ZW5kaW5nXG4gIC8vIGRvd253YXJkcyBmcm9tIHRoZXJlLlxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShjdWUuc2l6ZSwgXCIlXCIpXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLm1vdmUgPSBmdW5jdGlvbihib3gpIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZShib3gudG9wLCBcInB4XCIpLFxuICAgICAgYm90dG9tOiB0aGlzLmZvcm1hdFN0eWxlKGJveC5ib3R0b20sIFwicHhcIiksXG4gICAgICBsZWZ0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5sZWZ0LCBcInB4XCIpLFxuICAgICAgcmlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnJpZ2h0LCBcInB4XCIpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5oZWlnaHQsIFwicHhcIiksXG4gICAgICB3aWR0aDogdGhpcy5mb3JtYXRTdHlsZShib3gud2lkdGgsIFwicHhcIilcbiAgICB9KTtcbiAgfTtcbn1cbkN1ZVN0eWxlQm94LnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoU3R5bGVCb3gucHJvdG90eXBlKTtcbkN1ZVN0eWxlQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1ZVN0eWxlQm94O1xuXG4vLyBSZXByZXNlbnRzIHRoZSBjby1vcmRpbmF0ZXMgb2YgYW4gRWxlbWVudCBpbiBhIHdheSB0aGF0IHdlIGNhbiBlYXNpbHlcbi8vIGNvbXB1dGUgdGhpbmdzIHdpdGggc3VjaCBhcyBpZiBpdCBvdmVybGFwcyBvciBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBFbGVtZW50LlxuLy8gQ2FuIGluaXRpYWxpemUgaXQgd2l0aCBlaXRoZXIgYSBTdHlsZUJveCBvciBhbm90aGVyIEJveFBvc2l0aW9uLlxuZnVuY3Rpb24gQm94UG9zaXRpb24ob2JqKSB7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAvLyBFaXRoZXIgYSBCb3hQb3NpdGlvbiB3YXMgcGFzc2VkIGluIGFuZCB3ZSBuZWVkIHRvIGNvcHkgaXQsIG9yIGEgU3R5bGVCb3hcbiAgLy8gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IHRoZSByZXN1bHRzIG9mICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gIC8vIGFzIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgcmVhZG9ubHkuIEFsbCBjby1vcmRpbmF0ZSB2YWx1ZXMgYXJlIGluIHJlZmVyZW5jZVxuICAvLyB0byB0aGUgdmlld3BvcnQgb3JpZ2luICh0b3AgbGVmdCkuXG4gIHZhciBsaCwgaGVpZ2h0LCB3aWR0aCwgdG9wO1xuICBpZiAob2JqLmRpdikge1xuICAgIGhlaWdodCA9IG9iai5kaXYub2Zmc2V0SGVpZ2h0O1xuICAgIHdpZHRoID0gb2JqLmRpdi5vZmZzZXRXaWR0aDtcbiAgICB0b3AgPSBvYmouZGl2Lm9mZnNldFRvcDtcblxuICAgIHZhciByZWN0cyA9IChyZWN0cyA9IG9iai5kaXYuY2hpbGROb2RlcykgJiYgKHJlY3RzID0gcmVjdHNbMF0pICYmXG4gICAgICAgICAgICAgICAgcmVjdHMuZ2V0Q2xpZW50UmVjdHMgJiYgcmVjdHMuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBvYmogPSBvYmouZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEluIGNlcnRhaW4gY2FzZXMgdGhlIG91dHRlciBkaXYgd2lsbCBiZSBzbGlnaHRseSBsYXJnZXIgdGhlbiB0aGUgc3VtIG9mXG4gICAgLy8gdGhlIGlubmVyIGRpdidzIGxpbmVzLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBib2xkIHRleHQsIGV0Yywgb24gc29tZSBwbGF0Zm9ybXMuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIHNob3VsZCBnZXQgdGhlIGF2ZXJhZ2UgbGluZSBoZWlnaHQgYW5kIHVzZSB0aGF0LiBUaGlzIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGRlc2lyZWQgYmVoYXZpb3VyLlxuICAgIGxoID0gcmVjdHMgPyBNYXRoLm1heCgocmVjdHNbMF0gJiYgcmVjdHNbMF0uaGVpZ2h0KSB8fCAwLCBvYmouaGVpZ2h0IC8gcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgOiAwO1xuXG4gIH1cbiAgdGhpcy5sZWZ0ID0gb2JqLmxlZnQ7XG4gIHRoaXMucmlnaHQgPSBvYmoucmlnaHQ7XG4gIHRoaXMudG9wID0gb2JqLnRvcCB8fCB0b3A7XG4gIHRoaXMuaGVpZ2h0ID0gb2JqLmhlaWdodCB8fCBoZWlnaHQ7XG4gIHRoaXMuYm90dG9tID0gb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSk7XG4gIHRoaXMud2lkdGggPSBvYmoud2lkdGggfHwgd2lkdGg7XG4gIHRoaXMubGluZUhlaWdodCA9IGxoICE9PSB1bmRlZmluZWQgPyBsaCA6IG9iai5saW5lSGVpZ2h0O1xuXG4gIGlmIChpc0lFOCAmJiAhdGhpcy5saW5lSGVpZ2h0KSB7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gMTM7XG4gIH1cbn1cblxuLy8gTW92ZSB0aGUgYm94IGFsb25nIGEgcGFydGljdWxhciBheGlzLiBPcHRpb25hbGx5IHBhc3MgaW4gYW4gYW1vdW50IHRvIG1vdmVcbi8vIHRoZSBib3guIElmIG5vIGFtb3VudCBpcyBwYXNzZWQgdGhlbiB0aGUgZGVmYXVsdCBpcyB0aGUgbGluZSBoZWlnaHQgb2YgdGhlXG4vLyBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGF4aXMsIHRvTW92ZSkge1xuICB0b01vdmUgPSB0b01vdmUgIT09IHVuZGVmaW5lZCA/IHRvTW92ZSA6IHRoaXMubGluZUhlaWdodDtcbiAgc3dpdGNoIChheGlzKSB7XG4gIGNhc2UgXCIreFwiOlxuICAgIHRoaXMubGVmdCArPSB0b01vdmU7XG4gICAgdGhpcy5yaWdodCArPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIteFwiOlxuICAgIHRoaXMubGVmdCAtPSB0b01vdmU7XG4gICAgdGhpcy5yaWdodCAtPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIreVwiOlxuICAgIHRoaXMudG9wICs9IHRvTW92ZTtcbiAgICB0aGlzLmJvdHRvbSArPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCIteVwiOlxuICAgIHRoaXMudG9wIC09IHRvTW92ZTtcbiAgICB0aGlzLmJvdHRvbSAtPSB0b01vdmU7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IG92ZXJsYXBzIGFub3RoZXIgYm94LCBiMi5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwcyA9IGZ1bmN0aW9uKGIyKSB7XG4gIHJldHVybiB0aGlzLmxlZnQgPCBiMi5yaWdodCAmJlxuICAgICAgICAgdGhpcy5yaWdodCA+IGIyLmxlZnQgJiZcbiAgICAgICAgIHRoaXMudG9wIDwgYjIuYm90dG9tICYmXG4gICAgICAgICB0aGlzLmJvdHRvbSA+IGIyLnRvcDtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IG92ZXJsYXBzIGFueSBvdGhlciBib3hlcyBpbiBib3hlcy5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc0FueSA9IGZ1bmN0aW9uKGJveGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5vdmVybGFwcyhib3hlc1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBpcyB3aXRoaW4gYW5vdGhlciBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUud2l0aGluID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gIHJldHVybiB0aGlzLnRvcCA+PSBjb250YWluZXIudG9wICYmXG4gICAgICAgICB0aGlzLmJvdHRvbSA8PSBjb250YWluZXIuYm90dG9tICYmXG4gICAgICAgICB0aGlzLmxlZnQgPj0gY29udGFpbmVyLmxlZnQgJiZcbiAgICAgICAgIHRoaXMucmlnaHQgPD0gY29udGFpbmVyLnJpZ2h0O1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgZW50aXJlbHkgd2l0aGluIHRoZSBjb250YWluZXIgb3IgaXQgaXMgb3ZlcmxhcHBpbmdcbi8vIG9uIHRoZSBlZGdlIG9wcG9zaXRlIG9mIHRoZSBheGlzIGRpcmVjdGlvbiBwYXNzZWQuIEZvciBleGFtcGxlLCBpZiBcIit4XCIgaXNcbi8vIHBhc3NlZCBhbmQgdGhlIGJveCBpcyBvdmVybGFwcGluZyBvbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBjb250YWluZXIsIHRoZW5cbi8vIHJldHVybiB0cnVlLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzT3Bwb3NpdGVBeGlzID0gZnVuY3Rpb24oY29udGFpbmVyLCBheGlzKSB7XG4gIHN3aXRjaCAoYXhpcykge1xuICBjYXNlIFwiK3hcIjpcbiAgICByZXR1cm4gdGhpcy5sZWZ0IDwgY29udGFpbmVyLmxlZnQ7XG4gIGNhc2UgXCIteFwiOlxuICAgIHJldHVybiB0aGlzLnJpZ2h0ID4gY29udGFpbmVyLnJpZ2h0O1xuICBjYXNlIFwiK3lcIjpcbiAgICByZXR1cm4gdGhpcy50b3AgPCBjb250YWluZXIudG9wO1xuICBjYXNlIFwiLXlcIjpcbiAgICByZXR1cm4gdGhpcy5ib3R0b20gPiBjb250YWluZXIuYm90dG9tO1xuICB9XG59O1xuXG4vLyBGaW5kIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBhcmVhIHRoYXQgdGhpcyBib3ggaXMgb3ZlcmxhcHBpbmcgd2l0aCBhbm90aGVyXG4vLyBib3guXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUuaW50ZXJzZWN0UGVyY2VudGFnZSA9IGZ1bmN0aW9uKGIyKSB7XG4gIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5yaWdodCwgYjIucmlnaHQpIC0gTWF0aC5tYXgodGhpcy5sZWZ0LCBiMi5sZWZ0KSksXG4gICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5ib3R0b20sIGIyLmJvdHRvbSkgLSBNYXRoLm1heCh0aGlzLnRvcCwgYjIudG9wKSksXG4gICAgICBpbnRlcnNlY3RBcmVhID0geCAqIHk7XG4gIHJldHVybiBpbnRlcnNlY3RBcmVhIC8gKHRoaXMuaGVpZ2h0ICogdGhpcy53aWR0aCk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBwb3NpdGlvbnMgZnJvbSB0aGlzIGJveCB0byBDU1MgY29tcGF0aWJsZSBwb3NpdGlvbnMgdXNpbmdcbi8vIHRoZSByZWZlcmVuY2UgY29udGFpbmVyJ3MgcG9zaXRpb25zLiBUaGlzIGhhcyB0byBiZSBkb25lIGJlY2F1c2UgdGhpc1xuLy8gYm94J3MgcG9zaXRpb25zIGFyZSBpbiByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiwgd2hlcmVhcywgQ1NTXG4vLyB2YWx1ZXMgYXJlIGluIHJlZmVyZWNuZSB0byB0aGVpciByZXNwZWN0aXZlIGVkZ2VzLlxuQm94UG9zaXRpb24ucHJvdG90eXBlLnRvQ1NTQ29tcGF0VmFsdWVzID0gZnVuY3Rpb24ocmVmZXJlbmNlKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0aGlzLnRvcCAtIHJlZmVyZW5jZS50b3AsXG4gICAgYm90dG9tOiByZWZlcmVuY2UuYm90dG9tIC0gdGhpcy5ib3R0b20sXG4gICAgbGVmdDogdGhpcy5sZWZ0IC0gcmVmZXJlbmNlLmxlZnQsXG4gICAgcmlnaHQ6IHJlZmVyZW5jZS5yaWdodCAtIHRoaXMucmlnaHQsXG4gICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICB3aWR0aDogdGhpcy53aWR0aFxuICB9O1xufTtcblxuLy8gR2V0IGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGJveCdzIHBvc2l0aW9uIHdpdGhvdXQgYW55dGhpbmcgZXh0cmEuXG4vLyBDYW4gcGFzcyBhIFN0eWxlQm94LCBIVE1MRWxlbWVudCwgb3IgYW5vdGhlciBCb3hQb3NpdG9uLlxuQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGhlaWdodCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldEhlaWdodCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldEhlaWdodCA6IDA7XG4gIHZhciB3aWR0aCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFdpZHRoIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0V2lkdGggOiAwO1xuICB2YXIgdG9wID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0VG9wIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0VG9wIDogMDtcblxuICBvYmogPSBvYmouZGl2ID8gb2JqLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6XG4gICAgICAgICAgICAgICAgb2JqLnRhZ05hbWUgPyBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBvYmo7XG4gIHZhciByZXQgPSB7XG4gICAgbGVmdDogb2JqLmxlZnQsXG4gICAgcmlnaHQ6IG9iai5yaWdodCxcbiAgICB0b3A6IG9iai50b3AgfHwgdG9wLFxuICAgIGhlaWdodDogb2JqLmhlaWdodCB8fCBoZWlnaHQsXG4gICAgYm90dG9tOiBvYmouYm90dG9tIHx8ICh0b3AgKyAob2JqLmhlaWdodCB8fCBoZWlnaHQpKSxcbiAgICB3aWR0aDogb2JqLndpZHRoIHx8IHdpZHRoXG4gIH07XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBNb3ZlIGEgU3R5bGVCb3ggdG8gaXRzIHNwZWNpZmllZCwgb3IgbmV4dCBiZXN0LCBwb3NpdGlvbi4gVGhlIGNvbnRhaW5lckJveFxuLy8gaXMgdGhlIGJveCB0aGF0IGNvbnRhaW5zIHRoZSBTdHlsZUJveCwgc3VjaCBhcyBhIGRpdi4gYm94UG9zaXRpb25zIGFyZVxuLy8gYSBsaXN0IG9mIG90aGVyIGJveGVzIHRoYXQgdGhlIHN0eWxlQm94IGNhbid0IG92ZXJsYXAgd2l0aC5cbmZ1bmN0aW9uIG1vdmVCb3hUb0xpbmVQb3NpdGlvbih3aW5kb3csIHN0eWxlQm94LCBjb250YWluZXJCb3gsIGJveFBvc2l0aW9ucykge1xuXG4gIC8vIEZpbmQgdGhlIGJlc3QgcG9zaXRpb24gZm9yIGEgY3VlIGJveCwgYiwgb24gdGhlIHZpZGVvLiBUaGUgYXhpcyBwYXJhbWV0ZXJcbiAgLy8gaXMgYSBsaXN0IG9mIGF4aXMsIHRoZSBvcmRlciBvZiB3aGljaCwgaXQgd2lsbCBtb3ZlIHRoZSBib3ggYWxvbmcuIEZvciBleGFtcGxlOlxuICAvLyBQYXNzaW5nIFtcIit4XCIsIFwiLXhcIl0gd2lsbCBtb3ZlIHRoZSBib3ggZmlyc3QgYWxvbmcgdGhlIHggYXhpcyBpbiB0aGUgcG9zaXRpdmVcbiAgLy8gZGlyZWN0aW9uLiBJZiBpdCBkb2Vzbid0IGZpbmQgYSBnb29kIHBvc2l0aW9uIGZvciBpdCB0aGVyZSBpdCB3aWxsIHRoZW4gbW92ZVxuICAvLyBpdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24uXG4gIGZ1bmN0aW9uIGZpbmRCZXN0UG9zaXRpb24oYiwgYXhpcykge1xuICAgIHZhciBiZXN0UG9zaXRpb24sXG4gICAgICAgIHNwZWNpZmllZFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKGIpLFxuICAgICAgICBwZXJjZW50YWdlID0gMTsgLy8gSGlnaGVzdCBwb3NzaWJsZSBzbyB0aGUgZmlyc3QgdGhpbmcgd2UgZ2V0IGlzIGJldHRlci5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgd2hpbGUgKGIub3ZlcmxhcHNPcHBvc2l0ZUF4aXMoY29udGFpbmVyQm94LCBheGlzW2ldKSB8fFxuICAgICAgICAgICAgIChiLndpdGhpbihjb250YWluZXJCb3gpICYmIGIub3ZlcmxhcHNBbnkoYm94UG9zaXRpb25zKSkpIHtcbiAgICAgICAgYi5tb3ZlKGF4aXNbaV0pO1xuICAgICAgfVxuICAgICAgLy8gV2UgZm91bmQgYSBzcG90IHdoZXJlIHdlIGFyZW4ndCBvdmVybGFwcGluZyBhbnl0aGluZy4gVGhpcyBpcyBvdXJcbiAgICAgIC8vIGJlc3QgcG9zaXRpb24uXG4gICAgICBpZiAoYi53aXRoaW4oY29udGFpbmVyQm94KSkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIHZhciBwID0gYi5pbnRlcnNlY3RQZXJjZW50YWdlKGNvbnRhaW5lckJveCk7XG4gICAgICAvLyBJZiB3ZSdyZSBvdXRzaWRlIHRoZSBjb250YWluZXIgYm94IGxlc3MgdGhlbiB3ZSB3ZXJlIG9uIG91ciBsYXN0IHRyeVxuICAgICAgLy8gdGhlbiByZW1lbWJlciB0aGlzIHBvc2l0aW9uIGFzIHRoZSBiZXN0IHBvc2l0aW9uLlxuICAgICAgaWYgKHBlcmNlbnRhZ2UgPiBwKSB7XG4gICAgICAgIGJlc3RQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihiKTtcbiAgICAgICAgcGVyY2VudGFnZSA9IHA7XG4gICAgICB9XG4gICAgICAvLyBSZXNldCB0aGUgYm94IHBvc2l0aW9uIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICBiID0gbmV3IEJveFBvc2l0aW9uKHNwZWNpZmllZFBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGJlc3RQb3NpdGlvbiB8fCBzcGVjaWZpZWRQb3NpdGlvbjtcbiAgfVxuXG4gIHZhciBib3hQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihzdHlsZUJveCksXG4gICAgICBjdWUgPSBzdHlsZUJveC5jdWUsXG4gICAgICBsaW5lUG9zID0gY29tcHV0ZUxpbmVQb3MoY3VlKSxcbiAgICAgIGF4aXMgPSBbXTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbGluZSBudW1iZXIgdG8gYWxpZ24gdGhlIGN1ZSB0by5cbiAgaWYgKGN1ZS5zbmFwVG9MaW5lcykge1xuICAgIHZhciBzaXplO1xuICAgIHN3aXRjaCAoY3VlLnZlcnRpY2FsKSB7XG4gICAgY2FzZSBcIlwiOlxuICAgICAgYXhpcyA9IFsgXCIreVwiLCBcIi15XCIgXTtcbiAgICAgIHNpemUgPSBcImhlaWdodFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJsXCI6XG4gICAgICBheGlzID0gWyBcIit4XCIsIFwiLXhcIiBdO1xuICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsclwiOlxuICAgICAgYXhpcyA9IFsgXCIteFwiLCBcIit4XCIgXTtcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgc3RlcCA9IGJveFBvc2l0aW9uLmxpbmVIZWlnaHQsXG4gICAgICAgIHBvc2l0aW9uID0gc3RlcCAqIE1hdGgucm91bmQobGluZVBvcyksXG4gICAgICAgIG1heFBvc2l0aW9uID0gY29udGFpbmVyQm94W3NpemVdICsgc3RlcCxcbiAgICAgICAgaW5pdGlhbEF4aXMgPSBheGlzWzBdO1xuXG4gICAgLy8gSWYgdGhlIHNwZWNpZmllZCBpbnRpYWwgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGVuIHRoZSBtYXggcG9zaXRpb24gdGhlblxuICAgIC8vIGNsYW1wIHRoZSBib3ggdG8gdGhlIGFtb3VudCBvZiBzdGVwcyBpdCB3b3VsZCB0YWtlIGZvciB0aGUgYm94IHRvXG4gICAgLy8gcmVhY2ggdGhlIG1heCBwb3NpdGlvbi5cbiAgICBpZiAoTWF0aC5hYnMocG9zaXRpb24pID4gbWF4UG9zaXRpb24pIHtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPCAwID8gLTEgOiAxO1xuICAgICAgcG9zaXRpb24gKj0gTWF0aC5jZWlsKG1heFBvc2l0aW9uIC8gc3RlcCkgKiBzdGVwO1xuICAgIH1cblxuICAgIC8vIElmIGNvbXB1dGVkIGxpbmUgcG9zaXRpb24gcmV0dXJucyBuZWdhdGl2ZSB0aGVuIGxpbmUgbnVtYmVycyBhcmVcbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSB2aWRlbyBpbnN0ZWFkIG9mIHRoZSB0b3AuIFRoZXJlZm9yZSwgd2VcbiAgICAvLyBuZWVkIHRvIGluY3JlYXNlIG91ciBpbml0aWFsIHBvc2l0aW9uIGJ5IHRoZSBsZW5ndGggb3Igd2lkdGggb2YgdGhlXG4gICAgLy8gdmlkZW8sIGRlcGVuZGluZyBvbiB0aGUgd3JpdGluZyBkaXJlY3Rpb24sIGFuZCByZXZlcnNlIG91ciBheGlzIGRpcmVjdGlvbnMuXG4gICAgaWYgKGxpbmVQb3MgPCAwKSB7XG4gICAgICBwb3NpdGlvbiArPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBjb250YWluZXJCb3guaGVpZ2h0IDogY29udGFpbmVyQm94LndpZHRoO1xuICAgICAgYXhpcyA9IGF4aXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIC8vIE1vdmUgdGhlIGJveCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBUaGlzIG1heSBub3QgYmUgaXRzIGJlc3RcbiAgICAvLyBwb3NpdGlvbi5cbiAgICBib3hQb3NpdGlvbi5tb3ZlKGluaXRpYWxBeGlzLCBwb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGVyY2VudGFnZSBsaW5lIHZhbHVlIGZvciB0aGUgY3VlLlxuICAgIHZhciBjYWxjdWxhdGVkUGVyY2VudGFnZSA9IChib3hQb3NpdGlvbi5saW5lSGVpZ2h0IC8gY29udGFpbmVyQm94LmhlaWdodCkgKiAxMDA7XG5cbiAgICBzd2l0Y2ggKGN1ZS5saW5lQWxpZ24pIHtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICBsaW5lUG9zIC09IChjYWxjdWxhdGVkUGVyY2VudGFnZSAvIDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgbGluZVBvcyAtPSBjYWxjdWxhdGVkUGVyY2VudGFnZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGluaXRpYWwgbGluZSBwb3NpdGlvbiB0byB0aGUgY3VlIGJveC5cbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgdG9wOiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJsXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIGxlZnQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJcIjpcbiAgICAgIHN0eWxlQm94LmFwcGx5U3R5bGVzKHtcbiAgICAgICAgcmlnaHQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBheGlzID0gWyBcIit5XCIsIFwiLXhcIiwgXCIreFwiLCBcIi15XCIgXTtcblxuICAgIC8vIEdldCB0aGUgYm94IHBvc2l0aW9uIGFnYWluIGFmdGVyIHdlJ3ZlIGFwcGxpZWQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbmluZ1xuICAgIC8vIHRvIGl0LlxuICAgIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KTtcbiAgfVxuXG4gIHZhciBiZXN0UG9zaXRpb24gPSBmaW5kQmVzdFBvc2l0aW9uKGJveFBvc2l0aW9uLCBheGlzKTtcbiAgc3R5bGVCb3gubW92ZShiZXN0UG9zaXRpb24udG9DU1NDb21wYXRWYWx1ZXMoY29udGFpbmVyQm94KSk7XG59XG5cbmZ1bmN0aW9uIFdlYlZUVCgpIHtcbiAgLy8gTm90aGluZ1xufVxuXG4vLyBIZWxwZXIgdG8gYWxsb3cgc3RyaW5ncyB0byBiZSBkZWNvZGVkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmluYXJ5IHV0ZjggZGF0YS5cbldlYlZUVC5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSk7XG4gICAgfVxuICB9O1xufTtcblxuV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgPSBmdW5jdGlvbih3aW5kb3csIGN1ZXRleHQpIHtcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXRleHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyc2VDb250ZW50KHdpbmRvdywgY3VldGV4dCk7XG59O1xuXG52YXIgRk9OVF9TSVpFX1BFUkNFTlQgPSAwLjA1O1xudmFyIEZPTlRfU1RZTEUgPSBcInNhbnMtc2VyaWZcIjtcbnZhciBDVUVfQkFDS0dST1VORF9QQURESU5HID0gXCIxLjUlXCI7XG5cbi8vIFJ1bnMgdGhlIHByb2Nlc3NpbmcgbW9kZWwgb3ZlciB0aGUgY3VlcyBhbmQgcmVnaW9ucyBwYXNzZWQgdG8gaXQuXG4vLyBAcGFyYW0gb3ZlcmxheSBBIGJsb2NrIGxldmVsIGVsZW1lbnQgKHVzdWFsbHkgYSBkaXYpIHRoYXQgdGhlIGNvbXB1dGVkIGN1ZXNcbi8vICAgICAgICAgICAgICAgIGFuZCByZWdpb25zIHdpbGwgYmUgcGxhY2VkIGludG8uXG5XZWJWVFQucHJvY2Vzc0N1ZXMgPSBmdW5jdGlvbih3aW5kb3csIGN1ZXMsIG92ZXJsYXkpIHtcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXMgfHwgIW92ZXJsYXkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgcHJldmlvdXMgY2hpbGRyZW4uXG4gIHdoaWxlIChvdmVybGF5LmZpcnN0Q2hpbGQpIHtcbiAgICBvdmVybGF5LnJlbW92ZUNoaWxkKG92ZXJsYXkuZmlyc3RDaGlsZCk7XG4gIH1cblxuICB2YXIgcGFkZGVkT3ZlcmxheSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5yaWdodCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLnRvcCA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICBwYWRkZWRPdmVybGF5LnN0eWxlLm1hcmdpbiA9IENVRV9CQUNLR1JPVU5EX1BBRERJTkc7XG4gIG92ZXJsYXkuYXBwZW5kQ2hpbGQocGFkZGVkT3ZlcmxheSk7XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgZGlzcGxheSBzdGF0ZXMgb2YgdGhlIGN1ZXMuIFRoaXMgY291bGRcbiAgLy8gYmUgdGhlIGNhc2UgaWYgYSBjdWUncyBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGNvbXB1dGF0aW9uIG9yXG4gIC8vIGlmIGl0IGhhcyBub3QgYmVlbiBjb21wdXRlZCB5ZXQuXG4gIGZ1bmN0aW9uIHNob3VsZENvbXB1dGUoY3Vlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGN1ZXNbaV0uaGFzQmVlblJlc2V0IHx8ICFjdWVzW2ldLmRpc3BsYXlTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWNvbXB1dGUgdGhlIGN1ZXMnIGRpc3BsYXkgc3RhdGVzLiBKdXN0IHJldXNlIHRoZW0uXG4gIGlmICghc2hvdWxkQ29tcHV0ZShjdWVzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcGFkZGVkT3ZlcmxheS5hcHBlbmRDaGlsZChjdWVzW2ldLmRpc3BsYXlTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBib3hQb3NpdGlvbnMgPSBbXSxcbiAgICAgIGNvbnRhaW5lckJveCA9IEJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uKHBhZGRlZE92ZXJsYXkpLFxuICAgICAgZm9udFNpemUgPSBNYXRoLnJvdW5kKGNvbnRhaW5lckJveC5oZWlnaHQgKiBGT05UX1NJWkVfUEVSQ0VOVCAqIDEwMCkgLyAxMDA7XG4gIHZhciBzdHlsZU9wdGlvbnMgPSB7XG4gICAgZm9udDogZm9udFNpemUgKyBcInB4IFwiICsgRk9OVF9TVFlMRVxuICB9O1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3R5bGVCb3gsIGN1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VlID0gY3Vlc1tpXTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50aWFsIHBvc2l0aW9uIGFuZCBzdHlsZXMgb2YgdGhlIGN1ZSBkaXYuXG4gICAgICBzdHlsZUJveCA9IG5ldyBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKTtcbiAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoc3R5bGVCb3guZGl2KTtcblxuICAgICAgLy8gTW92ZSB0aGUgY3VlIGRpdiB0byBpdCdzIGNvcnJlY3QgbGluZSBwb3NpdGlvbi5cbiAgICAgIG1vdmVCb3hUb0xpbmVQb3NpdGlvbih3aW5kb3csIHN0eWxlQm94LCBjb250YWluZXJCb3gsIGJveFBvc2l0aW9ucyk7XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBjb21wdXRlZCBkaXYgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBpdCBsYXRlclxuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0b28uXG4gICAgICBjdWUuZGlzcGxheVN0YXRlID0gc3R5bGVCb3guZGl2O1xuXG4gICAgICBib3hQb3NpdGlvbnMucHVzaChCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihzdHlsZUJveCkpO1xuICAgIH1cbiAgfSkoKTtcbn07XG5cbldlYlZUVC5QYXJzZXIgPSBmdW5jdGlvbih3aW5kb3csIHZ0dGpzLCBkZWNvZGVyKSB7XG4gIGlmICghZGVjb2Rlcikge1xuICAgIGRlY29kZXIgPSB2dHRqcztcbiAgICB2dHRqcyA9IHt9O1xuICB9XG4gIGlmICghdnR0anMpIHtcbiAgICB2dHRqcyA9IHt9O1xuICB9XG5cbiAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gIHRoaXMudnR0anMgPSB2dHRqcztcbiAgdGhpcy5zdGF0ZSA9IFwiSU5JVElBTFwiO1xuICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gIHRoaXMuZGVjb2RlciA9IGRlY29kZXIgfHwgbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTtcbiAgdGhpcy5yZWdpb25MaXN0ID0gW107XG59O1xuXG5XZWJWVFQuUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgLy8gSWYgdGhlIGVycm9yIGlzIGEgUGFyc2luZ0Vycm9yIHRoZW4gcmVwb3J0IGl0IHRvIHRoZSBjb25zdW1lciBpZlxuICAvLyBwb3NzaWJsZS4gSWYgaXQncyBub3QgYSBQYXJzaW5nRXJyb3IgdGhlbiB0aHJvdyBpdCBsaWtlIG5vcm1hbC5cbiAgcmVwb3J0T3JUaHJvd0Vycm9yOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMub25wYXJzaW5nZXJyb3IgJiYgdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXG4gICAgLy8gd2hhdGV2ZXIgaXMgaW4gYnVmZmVyIGFscmVhZHkuIFRoaXMgbWF5IG9jY3VyIGluIGNpcmN1bXN0YW5jZXMsIGZvclxuICAgIC8vIGV4YW1wbGUgd2hlbiBmbHVzaCgpIGlzIGNhbGxlZC5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgZGF0YSB0aGF0IHdlIHJlY2VpdmVkLlxuICAgICAgc2VsZi5idWZmZXIgKz0gc2VsZi5kZWNvZGVyLmRlY29kZShkYXRhLCB7c3RyZWFtOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdE5leHRMaW5lKCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB3aGlsZSAocG9zIDwgYnVmZmVyLmxlbmd0aCAmJiBidWZmZXJbcG9zXSAhPT0gJ1xccicgJiYgYnVmZmVyW3Bvc10gIT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmUgPSBidWZmZXIuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBzZWxmLmJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHIocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuNCBXZWJWVFQgcmVnaW9uIGFuZCBXZWJWVFQgcmVnaW9uIHNldHRpbmdzIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlUmVnaW9uKGlucHV0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZXNcIjpcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVnaW9uYW5jaG9yXCI6XG4gICAgICAgIGNhc2UgXCJ2aWV3cG9ydGFuY2hvclwiOlxuICAgICAgICAgIHZhciB4eSA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBpZiAoeHkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYWtlIHN1cmUgYm90aCB4IGFuZCB5IHBhcnNlLCBzbyB1c2UgYSB0ZW1wb3JhcnlcbiAgICAgICAgICAvLyBzZXR0aW5ncyBvYmplY3QgaGVyZS5cbiAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IFNldHRpbmdzKCk7XG4gICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ4XCIsIHh5WzBdKTtcbiAgICAgICAgICBhbmNob3IucGVyY2VudChcInlcIiwgeHlbMV0pO1xuICAgICAgICAgIGlmICghYW5jaG9yLmhhcyhcInhcIikgfHwgIWFuY2hvci5oYXMoXCJ5XCIpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyBcIlhcIiwgYW5jaG9yLmdldChcInhcIikpO1xuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJZXCIsIGFuY2hvci5nZXQoXCJ5XCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJ1cFwiXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sIC89LywgL1xccy8pO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlZ2lvbiwgdXNpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSB2YWx1ZXMgdGhhdCB3ZXJlIG5vdFxuICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgaWYgKHNldHRpbmdzLmhhcyhcImlkXCIpKSB7XG4gICAgICAgIHZhciByZWdpb24gPSBuZXcgKHNlbGYudnR0anMuVlRUUmVnaW9uIHx8IHNlbGYud2luZG93LlZUVFJlZ2lvbikoKTtcbiAgICAgICAgcmVnaW9uLndpZHRoID0gc2V0dGluZ3MuZ2V0KFwid2lkdGhcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLmxpbmVzID0gc2V0dGluZ3MuZ2V0KFwibGluZXNcIiwgMyk7XG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JYID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWFwiLCAwKTtcbiAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclkgPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JZXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvclhcIiwgMCk7XG4gICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclkgPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvcllcIiwgMTAwKTtcbiAgICAgICAgcmVnaW9uLnNjcm9sbCA9IHNldHRpbmdzLmdldChcInNjcm9sbFwiLCBcIlwiKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHJlZ2lvbi5cbiAgICAgICAgc2VsZi5vbnJlZ2lvbiAmJiBzZWxmLm9ucmVnaW9uKHJlZ2lvbik7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBWVFRSZWdpb24gZm9yIGxhdGVyIGluIGNhc2Ugd2UgcGFyc2UgYW55IFZUVEN1ZXMgdGhhdFxuICAgICAgICAvLyByZWZlcmVuY2UgaXQuXG4gICAgICAgIHNlbGYucmVnaW9uTGlzdC5wdXNoKHtcbiAgICAgICAgICBpZDogc2V0dGluZ3MuZ2V0KFwiaWRcIiksXG4gICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMjBcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMjAjc2VjdGlvbi0zLjVcbiAgICAvLyAzLjUgV2ViVlRUXG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXBNYXAoaW5wdXQpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuXG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgc3dpdGNoKGspIHtcbiAgICAgICAgY2FzZSBcIk1QRUdUXCI6XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrICsgJ1MnLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxPQ0FcIjpcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArICdMJywgcGFyc2VUaW1lU3RhbXAodikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvW15cXGRdOi8sIC8sLyk7XG5cbiAgICAgIHNlbGYub250aW1lc3RhbXBtYXAgJiYgc2VsZi5vbnRpbWVzdGFtcG1hcCh7XG4gICAgICAgIFwiTVBFR1RTXCI6IHNldHRpbmdzLmdldChcIk1QRUdUU1wiKSxcbiAgICAgICAgXCJMT0NBTFwiOiBzZXR0aW5ncy5nZXQoXCJMT0NBTFwiKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gMy4yIFdlYlZUVCBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5tYXRjaCgvWC1USU1FU1RBTVAtTUFQLykpIHtcbiAgICAgICAgLy8gVGhpcyBsaW5lIGNvbnRhaW5zIEhMUyBYLVRJTUVTVEFNUC1NQVAgbWV0YWRhdGFcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoKGspIHtcbiAgICAgICAgICBjYXNlIFwiWC1USU1FU1RBTVAtTUFQXCI6XG4gICAgICAgICAgICBwYXJzZVRpbWVzdGFtcE1hcCh2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLz0vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlIFwiUmVnaW9uXCI6XG4gICAgICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgICAgICBwYXJzZVJlZ2lvbih2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgLzovKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZTtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIikge1xuICAgICAgICAvLyBXZSBjYW4ndCBzdGFydCBwYXJzaW5nIHVudGlsIHdlIGhhdmUgdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG5cbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghbSB8fCAhbVswXSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRTaWduYXR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSEVBREVSXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHBhcnNlIGEgbGluZSB1bnRpbCB3ZSBoYXZlIHRoZSBmdWxsIGxpbmUuXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcIkhFQURFUlwiOlxuICAgICAgICAgIC8vIDEzLTE4IC0gQWxsb3cgYSBoZWFkZXIgKG1ldGFkYXRhKSB1bmRlciB0aGUgV0VCVlRUIGxpbmUuXG4gICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBwYXJzZUhlYWRlcihsaW5lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiTk9URVwiOlxuICAgICAgICAgIC8vIElnbm9yZSBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiSURcIjpcbiAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIHN0YXJ0IG9mIE5PVEUgYmxvY2tzLlxuICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJOT1RFXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMTktMjkgLSBBbGxvdyBhbnkgbnVtYmVyIG9mIGxpbmUgdGVybWluYXRvcnMsIHRoZW4gaW5pdGlhbGl6ZSBuZXcgY3VlIHZhbHVlcy5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmN1ZSA9IG5ldyAoc2VsZi52dHRqcy5WVFRDdWUgfHwgc2VsZi53aW5kb3cuVlRUQ3VlKSgwLCAwLCBcIlwiKTtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVcIjtcbiAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoXCItLT5cIikgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxuICAgICAgICAgIC8qZmFsbHMgdGhyb3VnaCovXG4gICAgICAgIGNhc2UgXCJDVUVcIjpcbiAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZUN1ZShsaW5lLCBzZWxmLmN1ZSwgc2VsZi5yZWdpb25MaXN0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkJBRENVRVwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIkNVRVRFWFRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIkNVRVRFWFRcIjpcbiAgICAgICAgICB2YXIgaGFzU3Vic3RyaW5nID0gbGluZS5pbmRleE9mKFwiLS0+XCIpICE9PSAtMTtcbiAgICAgICAgICAvLyAzNCAtIElmIHdlIGhhdmUgYW4gZW1wdHkgbGluZSB0aGVuIHJlcG9ydCB0aGUgY3VlLlxuICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcbiAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gb25lIGFzIGEgbmV3IGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgc2VsZi5vbmN1ZSAmJiBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuY3VlLnRleHQpIHtcbiAgICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIFwiQkFEQ1VFXCI6IC8vIEJBRENVRVxuICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG5cbiAgICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgcGFyc2luZyBhIGN1ZSwgcmVwb3J0IHdoYXQgd2UgaGF2ZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIkNVRVRFWFRcIiAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XG4gICAgICAgIHNlbGYub25jdWUoc2VsZi5jdWUpO1xuICAgICAgfVxuICAgICAgc2VsZi5jdWUgPSBudWxsO1xuICAgICAgLy8gRW50ZXIgQkFEV0VCVlRUIHN0YXRlIGlmIGhlYWRlciB3YXMgbm90IHBhcnNlZCBjb3JyZWN0bHkgb3RoZXJ3aXNlXG4gICAgICAvLyBhbm90aGVyIGV4Y2VwdGlvbiBvY2N1cnJlZCBzbyBlbnRlciBCQURDVUUgc3RhdGUuXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIgPyBcIkJBRFdFQlZUVFwiIDogXCJCQURDVUVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAvLyBGaW5pc2ggZGVjb2RpbmcgdGhlIHN0cmVhbS5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKHNlbGYuY3VlIHx8IHNlbGYuc3RhdGUgPT09IFwiSEVBREVSXCIpIHtcbiAgICAgICAgc2VsZi5idWZmZXIgKz0gXCJcXG5cXG5cIjtcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIklOSVRJQUxcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuICAgIH1cbiAgICBzZWxmLm9uZmx1c2ggJiYgc2VsZi5vbmZsdXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViVlRUO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHQuanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoREE7QUFDQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFDQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBZkE7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0JBO0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkVBO0FBeUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL1JBO0FBQ0E7QUFpU0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///144\n");

/***/ }),

/***/ 145:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar autoKeyword = \"auto\";\nvar directionSetting = {\n  \"\": true,\n  \"lr\": true,\n  \"rl\": true\n};\nvar alignSetting = {\n  \"start\": true,\n  \"middle\": true,\n  \"end\": true,\n  \"left\": true,\n  \"right\": true\n};\n\nfunction findDirectionSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var dir = directionSetting[value.toLowerCase()];\n  return dir ? value.toLowerCase() : false;\n}\n\nfunction findAlignSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var align = alignSetting[value.toLowerCase()];\n  return align ? value.toLowerCase() : false;\n}\n\nfunction extend(obj) {\n  var i = 1;\n  for (; i < arguments.length; i++) {\n    var cobj = arguments[i];\n    for (var p in cobj) {\n      obj[p] = cobj[p];\n    }\n  }\n\n  return obj;\n}\n\nfunction VTTCue(startTime, endTime, text) {\n  var cue = this;\n  var isIE8 = /MSIE\\s8\\.0/.test(navigator.userAgent);\n  var baseObj = {};\n\n  if (isIE8) {\n    cue = document.createElement('custom');\n  } else {\n    baseObj.enumerable = true;\n  }\n\n  /**\n   * Shim implementation specific properties. These properties are not in\n   * the spec.\n   */\n\n  // Lets us know when the VTTCue's data has changed in such a way that we need\n  // to recompute its display state. This lets us compute its display state\n  // lazily.\n  cue.hasBeenReset = false;\n\n  /**\n   * VTTCue and TextTrackCue properties\n   * http://dev.w3.org/html5/webvtt/#vttcue-interface\n   */\n\n  var _id = \"\";\n  var _pauseOnExit = false;\n  var _startTime = startTime;\n  var _endTime = endTime;\n  var _text = text;\n  var _region = null;\n  var _vertical = \"\";\n  var _snapToLines = true;\n  var _line = \"auto\";\n  var _lineAlign = \"start\";\n  var _position = 50;\n  var _positionAlign = \"middle\";\n  var _size = 50;\n  var _align = \"middle\";\n\n  Object.defineProperty(cue, \"id\", extend({}, baseObj, {\n    get: function get() {\n      return _id;\n    },\n    set: function set(value) {\n      _id = \"\" + value;\n    }\n  }));\n\n  Object.defineProperty(cue, \"pauseOnExit\", extend({}, baseObj, {\n    get: function get() {\n      return _pauseOnExit;\n    },\n    set: function set(value) {\n      _pauseOnExit = !!value;\n    }\n  }));\n\n  Object.defineProperty(cue, \"startTime\", extend({}, baseObj, {\n    get: function get() {\n      return _startTime;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\") {\n        throw new TypeError(\"Start time must be set to a number.\");\n      }\n      _startTime = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"endTime\", extend({}, baseObj, {\n    get: function get() {\n      return _endTime;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\") {\n        throw new TypeError(\"End time must be set to a number.\");\n      }\n      _endTime = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"text\", extend({}, baseObj, {\n    get: function get() {\n      return _text;\n    },\n    set: function set(value) {\n      _text = \"\" + value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"region\", extend({}, baseObj, {\n    get: function get() {\n      return _region;\n    },\n    set: function set(value) {\n      _region = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"vertical\", extend({}, baseObj, {\n    get: function get() {\n      return _vertical;\n    },\n    set: function set(value) {\n      var setting = findDirectionSetting(value);\n      // Have to check for false because the setting an be an empty string.\n      if (setting === false) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _vertical = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"snapToLines\", extend({}, baseObj, {\n    get: function get() {\n      return _snapToLines;\n    },\n    set: function set(value) {\n      _snapToLines = !!value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"line\", extend({}, baseObj, {\n    get: function get() {\n      return _line;\n    },\n    set: function set(value) {\n      if (typeof value !== \"number\" && value !== autoKeyword) {\n        throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n      }\n      _line = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"lineAlign\", extend({}, baseObj, {\n    get: function get() {\n      return _lineAlign;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _lineAlign = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"position\", extend({}, baseObj, {\n    get: function get() {\n      return _position;\n    },\n    set: function set(value) {\n      if (value < 0 || value > 100) {\n        throw new Error(\"Position must be between 0 and 100.\");\n      }\n      _position = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"positionAlign\", extend({}, baseObj, {\n    get: function get() {\n      return _positionAlign;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _positionAlign = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"size\", extend({}, baseObj, {\n    get: function get() {\n      return _size;\n    },\n    set: function set(value) {\n      if (value < 0 || value > 100) {\n        throw new Error(\"Size must be between 0 and 100.\");\n      }\n      _size = value;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  Object.defineProperty(cue, \"align\", extend({}, baseObj, {\n    get: function get() {\n      return _align;\n    },\n    set: function set(value) {\n      var setting = findAlignSetting(value);\n      if (!setting) {\n        throw new SyntaxError(\"An invalid or illegal string was specified.\");\n      }\n      _align = setting;\n      this.hasBeenReset = true;\n    }\n  }));\n\n  /**\n   * Other <track> spec defined properties\n   */\n\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n  cue.displayState = undefined;\n\n  if (isIE8) {\n    return cue;\n  }\n}\n\n/**\n * VTTCue methods\n */\n\nVTTCue.prototype.getCueAsHTML = function () {\n  // Assume WebVTT.convertCueToDOMTree is on the global.\n  return WebVTT.convertCueToDOMTree(window, this.text);\n};\n\nmodule.exports = VTTCue;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHRjdWUuanM/YjhmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBhdXRvS2V5d29yZCA9IFwiYXV0b1wiO1xudmFyIGRpcmVjdGlvblNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwibHJcIjogdHJ1ZSxcbiAgXCJybFwiOiB0cnVlXG59O1xudmFyIGFsaWduU2V0dGluZyA9IHtcbiAgXCJzdGFydFwiOiB0cnVlLFxuICBcIm1pZGRsZVwiOiB0cnVlLFxuICBcImVuZFwiOiB0cnVlLFxuICBcImxlZnRcIjogdHJ1ZSxcbiAgXCJyaWdodFwiOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBkaXIgPSBkaXJlY3Rpb25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gZGlyID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYWxpZ24gPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgdmFyIGkgPSAxO1xuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAodmFyIHAgaW4gY29iaikge1xuICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gIHZhciBjdWUgPSB0aGlzO1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBiYXNlT2JqID0ge307XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgY3VlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZU9iai5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGltIGltcGxlbWVudGF0aW9uIHNwZWNpZmljIHByb3BlcnRpZXMuIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBpblxuICAgKiB0aGUgc3BlYy5cbiAgICovXG5cbiAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcbiAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAvLyBsYXppbHkuXG4gIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xuICAgKiBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dGN1ZS1pbnRlcmZhY2VcbiAgICovXG5cbiAgdmFyIF9pZCA9IFwiXCI7XG4gIHZhciBfcGF1c2VPbkV4aXQgPSBmYWxzZTtcbiAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIHZhciBfZW5kVGltZSA9IGVuZFRpbWU7XG4gIHZhciBfdGV4dCA9IHRleHQ7XG4gIHZhciBfcmVnaW9uID0gbnVsbDtcbiAgdmFyIF92ZXJ0aWNhbCA9IFwiXCI7XG4gIHZhciBfc25hcFRvTGluZXMgPSB0cnVlO1xuICB2YXIgX2xpbmUgPSBcImF1dG9cIjtcbiAgdmFyIF9saW5lQWxpZ24gPSBcInN0YXJ0XCI7XG4gIHZhciBfcG9zaXRpb24gPSA1MDtcbiAgdmFyIF9wb3NpdGlvbkFsaWduID0gXCJtaWRkbGVcIjtcbiAgdmFyIF9zaXplID0gNTA7XG4gIHZhciBfYWxpZ24gPSBcIm1pZGRsZVwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJpZFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfaWQgPSBcIlwiICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwYXVzZU9uRXhpdFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfcGF1c2VPbkV4aXQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwic3RhcnRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN0YXJ0IHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwiZW5kVGltZVwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInRleHRcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3RleHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGV4dCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicmVnaW9uXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInZlcnRpY2FsXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBiZWNhdXNlIHRoZSBzZXR0aW5nIGFuIGJlIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgaWYgKHNldHRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzbmFwVG9MaW5lc1wiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfc25hcFRvTGluZXMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJsaW5lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gYXV0b0tleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJsaW5lQWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVBbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBvc2l0aW9uXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25BbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzaXplXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwiYWxpZ25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2FsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIC8qKlxuICAgKiBPdGhlciA8dHJhY2s+IHNwZWMgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAqL1xuXG4gIC8vIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS12aWRlby1lbGVtZW50Lmh0bWwjdGV4dC10cmFjay1jdWUtZGlzcGxheS1zdGF0ZVxuICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0lFOCkge1xuICAgIHJldHVybiBjdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBWVFRDdWUgbWV0aG9kc1xuICovXG5cblZUVEN1ZS5wcm90b3R5cGUuZ2V0Q3VlQXNIVE1MID0gZnVuY3Rpb24oKSB7XG4gIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxuICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUod2luZG93LCB0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWVFRDdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dGN1ZS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFhQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///145\n");

/***/ }),

/***/ 146:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar scrollSetting = {\n  \"\": true,\n  \"up\": true\n};\n\nfunction findScrollSetting(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  var scroll = scrollSetting[value.toLowerCase()];\n  return scroll ? value.toLowerCase() : false;\n}\n\nfunction isValidPercentValue(value) {\n  return typeof value === \"number\" && value >= 0 && value <= 100;\n}\n\n// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\nfunction VTTRegion() {\n  var _width = 100;\n  var _lines = 3;\n  var _regionAnchorX = 0;\n  var _regionAnchorY = 100;\n  var _viewportAnchorX = 0;\n  var _viewportAnchorY = 100;\n  var _scroll = \"\";\n\n  Object.defineProperties(this, {\n    \"width\": {\n      enumerable: true,\n      get: function get() {\n        return _width;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"Width must be between 0 and 100.\");\n        }\n        _width = value;\n      }\n    },\n    \"lines\": {\n      enumerable: true,\n      get: function get() {\n        return _lines;\n      },\n      set: function set(value) {\n        if (typeof value !== \"number\") {\n          throw new TypeError(\"Lines must be set to a number.\");\n        }\n        _lines = value;\n      }\n    },\n    \"regionAnchorY\": {\n      enumerable: true,\n      get: function get() {\n        return _regionAnchorY;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n        }\n        _regionAnchorY = value;\n      }\n    },\n    \"regionAnchorX\": {\n      enumerable: true,\n      get: function get() {\n        return _regionAnchorX;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n        }\n        _regionAnchorX = value;\n      }\n    },\n    \"viewportAnchorY\": {\n      enumerable: true,\n      get: function get() {\n        return _viewportAnchorY;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n        }\n        _viewportAnchorY = value;\n      }\n    },\n    \"viewportAnchorX\": {\n      enumerable: true,\n      get: function get() {\n        return _viewportAnchorX;\n      },\n      set: function set(value) {\n        if (!isValidPercentValue(value)) {\n          throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n        }\n        _viewportAnchorX = value;\n      }\n    },\n    \"scroll\": {\n      enumerable: true,\n      get: function get() {\n        return _scroll;\n      },\n      set: function set(value) {\n        var setting = findScrollSetting(value);\n        // Have to check for false as an empty string is a legal value.\n        if (setting === false) {\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        }\n        _scroll = setting;\n      }\n    }\n  });\n}\n\nmodule.exports = VTTRegion;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHRyZWdpb24uanM/ZmJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBzY3JvbGxTZXR0aW5nID0ge1xuICBcIlwiOiB0cnVlLFxuICBcInVwXCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNjcm9sbCA9IHNjcm9sbFNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBzY3JvbGwgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxMDApO1xufVxuXG4vLyBWVFRSZWdpb24gc2hpbSBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJ2dHQvI3Z0dHJlZ2lvbi1pbnRlcmZhY2VcbmZ1bmN0aW9uIFZUVFJlZ2lvbigpIHtcbiAgdmFyIF93aWR0aCA9IDEwMDtcbiAgdmFyIF9saW5lcyA9IDM7XG4gIHZhciBfcmVnaW9uQW5jaG9yWCA9IDA7XG4gIHZhciBfcmVnaW9uQW5jaG9yWSA9IDEwMDtcbiAgdmFyIF92aWV3cG9ydEFuY2hvclggPSAwO1xuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWSA9IDEwMDtcbiAgdmFyIF9zY3JvbGwgPSBcIlwiO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBcIndpZHRoXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3dpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF93aWR0aCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJsaW5lc1wiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9saW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGluZXMgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lcyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZWdpb25BbmNob3JZXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbkFuY2hvclk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uQW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVnaW9uQW5jaG9yWSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZWdpb25BbmNob3JYXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbkFuY2hvclg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZighaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JZIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9yZWdpb25BbmNob3JYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInZpZXdwb3J0QW5jaG9yWVwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF92aWV3cG9ydEFuY2hvclk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld3BvcnRBbmNob3JZIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92aWV3cG9ydEFuY2hvclkgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmlld3BvcnRBbmNob3JYXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJzY3JvbGxcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2Nyb2xsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kU2Nyb2xsU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGFzIGFuIGVtcHR5IHN0cmluZyBpcyBhIGxlZ2FsIHZhbHVlLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9zY3JvbGwgPSBzZXR0aW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVlRUUmVnaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHRyZWdpb24uanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBekVBO0FBd0ZBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///146\n");

/***/ }),

/***/ 147:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjYuMEB2aWRlby5qcy9kaXN0L3ZpZGVvLWpzLmNzcz80ZTk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvX3ZpZGVvLmpzQDYuNi4wQHZpZGVvLmpzL2Rpc3QvdmlkZW8tanMuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///147\n");

/***/ }),

/***/ 148:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3NzL2luZGV4LnNjc3M/ODcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Fzc2V0cy9zY3NzL2luZGV4LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///148\n");

/***/ }),

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\") {\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvd2luZG93LmpzP2M5NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL19nbG9iYWxANC4zLjJAZ2xvYmFsL3dpbmRvdy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ })

},[130]);